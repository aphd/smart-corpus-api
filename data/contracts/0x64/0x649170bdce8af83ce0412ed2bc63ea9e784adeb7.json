{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/database/Database.sol\r\n\r\n// @title A shared storage contract for platform contracts to store and retrieve data\r\n// @notice This contract holds all long-term data for smart-contract systems\r\n// @dev The bytes32 hashes are derived from keccak256(variableName, uniqueID) => value\r\n// @dec Can enable upgradeable contracts by setting a contract manager\r\ncontract Database{\r\n\r\n    // Storage Variables\r\n    mapping(bytes32 => uint) public uintStorage;\r\n    mapping(bytes32 => string) public stringStorage;\r\n    mapping(bytes32 => address) public addressStorage;\r\n    mapping(bytes32 => bytes) public bytesStorage;\r\n    mapping(bytes32 => bytes32) public bytes32Storage;\r\n    mapping(bytes32 => bool) public boolStorage;\r\n    mapping(bytes32 => int) public intStorage;\r\n\r\n\r\n\r\n    // @notice Constructor: Sets the owners of the platform\r\n    // @dev Owners must set the contract manager to add more contracts\r\n    constructor(address[] _owners, bool _upgradeable)\r\n    public {\r\n      for(uint i=0; i<_owners.length; i++){\r\n        require(_owners[i] != address(0), \"Empty address\");\r\n        boolStorage[keccak256(abi.encodePacked(\"owner\", _owners[i]))] = true;\r\n        emit LogInitialized(_owners[i], _upgradeable);\r\n      }\r\n      if (_upgradeable){\r\n        boolStorage[keccak256(\"upgradeable\")] = true;\r\n      }\r\n    }\r\n\r\n    // @notice ContractManager will be the only contract that can add/remove contracts on the platform.\r\n    // @param (address) _contractManager is the contract which can upgrade/remove contracts to platform\r\n    function enableContractManagement(address _contractManager)\r\n    external\r\n    returns (bool){\r\n        require(_contractManager != address(0), \"Empty address\");\r\n        require(boolStorage[keccak256(abi.encodePacked(\"owner\", msg.sender))], \"Not owner\");\r\n        require(addressStorage[keccak256(abi.encodePacked(\"contract\", \"ContractManager\"))] == address(0), \"There is already a contract manager\");\r\n        addressStorage[keccak256(abi.encodePacked(\"contract\", \"ContractManager\"))] = _contractManager;\r\n        boolStorage[keccak256(abi.encodePacked(\"contract\", _contractManager))] = true;\r\n        return true;\r\n    }\r\n\r\n    // @notice Storage functions\r\n    function setAddress(bytes32 _key, address _value)\r\n    onlyApprovedContract\r\n    external {\r\n        addressStorage[_key] = _value;\r\n    }\r\n\r\n    function setUint(bytes32 _key, uint _value)\r\n    onlyApprovedContract\r\n    external {\r\n        uintStorage[_key] = _value;\r\n    }\r\n\r\n    function setString(bytes32 _key, string _value)\r\n    onlyApprovedContract\r\n    external {\r\n        stringStorage[_key] = _value;\r\n    }\r\n\r\n    function setBytes(bytes32 _key, bytes _value)\r\n    onlyApprovedContract\r\n    external {\r\n        bytesStorage[_key] = _value;\r\n    }\r\n\r\n    function setBytes32(bytes32 _key, bytes32 _value)\r\n    onlyApprovedContract\r\n    external {\r\n        bytes32Storage[_key] = _value;\r\n    }\r\n\r\n    function setBool(bytes32 _key, bool _value)\r\n    onlyApprovedContract\r\n    external {\r\n        boolStorage[_key] = _value;\r\n    }\r\n\r\n    function setInt(bytes32 _key, int _value)\r\n    onlyApprovedContract\r\n    external {\r\n        intStorage[_key] = _value;\r\n    }\r\n\r\n\r\n    // Deletion functions: Can alternatively use setter functions and set to null value (ie. uint = 0)\r\n    function deleteAddress(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete addressStorage[_key];\r\n    }\r\n\r\n    function deleteUint(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete uintStorage[_key];\r\n    }\r\n\r\n    function deleteString(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete stringStorage[_key];\r\n    }\r\n\r\n    function deleteBytes(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete bytesStorage[_key];\r\n    }\r\n\r\n    function deleteBytes32(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete bytes32Storage[_key];\r\n    }\r\n\r\n    function deleteBool(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete boolStorage[_key];\r\n    }\r\n\r\n    function deleteInt(bytes32 _key)\r\n    onlyApprovedContract\r\n    external {\r\n        delete intStorage[_key];\r\n    }\r\n\r\n\r\n    // --------------------------------------------------------------------------------------\r\n    //                                     Modifiers\r\n    // --------------------------------------------------------------------------------------\r\n\r\n    // Caller must be registered as a contract through ContractManager.sol\r\n    modifier onlyApprovedContract() {\r\n        require(boolStorage[keccak256(abi.encodePacked(\"contract\", msg.sender))]);\r\n        _;\r\n    }\r\n\r\n    // --------------------------------------------------------------------------------------\r\n    //                                     Events\r\n    // --------------------------------------------------------------------------------------\r\n    event LogInitialized(address _owner, bool _upgradeable);\r\n}\r\n\r\n// File: contracts/interfaces/DBInterface.sol\r\n\r\n// Database interface\r\ninterface DBInterface {\r\n\r\n  function setContractManager(address _contractManager)\r\n  external;\r\n\r\n    // --------------------Set Functions------------------------\r\n\r\n    function setAddress(bytes32 _key, address _value)\r\n    external;\r\n\r\n    function setUint(bytes32 _key, uint _value)\r\n    external;\r\n\r\n    function setString(bytes32 _key, string _value)\r\n    external;\r\n\r\n    function setBytes(bytes32 _key, bytes _value)\r\n    external;\r\n\r\n    function setBytes32(bytes32 _key, bytes32 _value)\r\n    external;\r\n\r\n    function setBool(bytes32 _key, bool _value)\r\n    external;\r\n\r\n    function setInt(bytes32 _key, int _value)\r\n    external;\r\n\r\n\r\n     // -------------- Deletion Functions ------------------\r\n\r\n    function deleteAddress(bytes32 _key)\r\n    external;\r\n\r\n    function deleteUint(bytes32 _key)\r\n    external;\r\n\r\n    function deleteString(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBytes(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBytes32(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBool(bytes32 _key)\r\n    external;\r\n\r\n    function deleteInt(bytes32 _key)\r\n    external;\r\n\r\n    // ----------------Variable Getters---------------------\r\n\r\n    function uintStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (uint);\r\n\r\n    function stringStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (string);\r\n\r\n    function addressStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n    function bytesStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bytes);\r\n\r\n    function bytes32Storage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bytes32);\r\n\r\n    function boolStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n    function intStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n// File: contracts/database/Events.sol\r\n\r\ncontract Events {\r\n  DBInterface public database;\r\n\r\n  constructor(address _database) public{\r\n    database = DBInterface(_database);\r\n  }\r\n\r\n  function message(string _message)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogEvent(_message, keccak256(abi.encodePacked(_message)), tx.origin);\r\n  }\r\n\r\n  function transaction(string _message, address _from, address _to, uint _amount, address _token)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogTransaction(_message, keccak256(abi.encodePacked(_message)), _from, _to, _amount, _token, tx.origin);\r\n  }\r\n\r\n  function registration(string _message, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogAddress(_message, keccak256(abi.encodePacked(_message)), _account, tx.origin);\r\n  }\r\n\r\n  function contractChange(string _message, address _account, string _name)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogContractChange(_message, keccak256(abi.encodePacked(_message)), _account, _name, tx.origin);\r\n  }\r\n\r\n  function asset(string _message, string _uri, address _assetAddress, address _manager)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogAsset(_message, keccak256(abi.encodePacked(_message)), _uri, keccak256(abi.encodePacked(_uri)), _assetAddress, _manager, tx.origin);\r\n  }\r\n\r\n  function escrow(string _message, address _assetAddress, bytes32 _escrowID, address _manager, uint _amount)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogEscrow(_message, keccak256(abi.encodePacked(_message)), _assetAddress, _escrowID, _manager, _amount, tx.origin);\r\n  }\r\n\r\n  function order(string _message, bytes32 _orderID, uint _amount, uint _price)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogOrder(_message, keccak256(abi.encodePacked(_message)), _orderID, _amount, _price, tx.origin);\r\n  }\r\n\r\n  function exchange(string _message, bytes32 _orderID, address _assetAddress, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogExchange(_message, keccak256(abi.encodePacked(_message)), _orderID, _assetAddress, _account, tx.origin);\r\n  }\r\n\r\n  function operator(string _message, bytes32 _id, string _name, string _ipfs, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogOperator(_message, keccak256(abi.encodePacked(_message)), _id, _name, _ipfs, _account, tx.origin);\r\n  }\r\n\r\n  function consensus(string _message, bytes32 _executionID, bytes32 _votesID, uint _votes, uint _tokens, uint _quorum)\r\n  external\r\n  onlyApprovedContract {\r\n    emit LogConsensus(_message, keccak256(abi.encodePacked(_message)), _executionID, _votesID, _votes, _tokens, _quorum, tx.origin);\r\n  }\r\n\r\n  //Generalized events\r\n  event LogEvent(string message, bytes32 indexed messageID, address indexed origin);\r\n  event LogTransaction(string message, bytes32 indexed messageID, address indexed from, address indexed to, uint amount, address token, address origin); //amount and token will be empty on some events\r\n  event LogAddress(string message, bytes32 indexed messageID, address indexed account, address indexed origin);\r\n  event LogContractChange(string message, bytes32 indexed messageID, address indexed account, string name, address indexed origin);\r\n  event LogAsset(string message, bytes32 indexed messageID, string uri, bytes32 indexed assetID, address asset, address manager, address indexed origin);\r\n  event LogEscrow(string message, bytes32 indexed messageID, address asset, bytes32  escrowID, address indexed manager, uint amount, address indexed origin);\r\n  event LogOrder(string message, bytes32 indexed messageID, bytes32 indexed orderID, uint amount, uint price, address indexed origin);\r\n  event LogExchange(string message, bytes32 indexed messageID, bytes32 orderID, address indexed asset, address account, address indexed origin);\r\n  event LogOperator(string message, bytes32 indexed messageID, bytes32 id, string name, string ipfs, address indexed account, address indexed origin);\r\n  event LogConsensus(string message, bytes32 indexed messageID, bytes32 executionID, bytes32 votesID, uint votes, uint tokens, uint quorum, address indexed origin);\r\n\r\n\r\n  // --------------------------------------------------------------------------------------\r\n  // Caller must be registered as a contract through ContractManager.sol\r\n  // --------------------------------------------------------------------------------------\r\n  modifier onlyApprovedContract() {\r\n      require(database.boolStorage(keccak256(abi.encodePacked(\"contract\", msg.sender))));\r\n      _;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/roles/Operators.sol\r\n\r\ncontract Operators {\r\n\r\n  Database public database;\r\n  Events public events;\r\n\r\n  constructor(address _database, address _events) public {\r\n    database = Database(_database);\r\n    events = Events(_events);\r\n  }\r\n\r\n  // @notice allows the platform owners to onboard a new operator.\r\n  // @notice operators will receive crowdfunding payments and are liable for producing/installing assets.\r\n  function registerOperator(address _operatorAddress, string _operatorURI, string _ipfs, address _referrerAddress)\r\n  external\r\n  onlyOwner {\r\n    require(_operatorAddress != address(0));\r\n    bytes32 operatorID = keccak256(abi.encodePacked(\"operator.uri\", _operatorURI));\r\n    require(database.addressStorage(keccak256(abi.encodePacked(\"operator\", operatorID))) == address(0));\r\n    database.setBytes32(keccak256(abi.encodePacked(\"operator\", _operatorAddress)), operatorID);\r\n    database.setAddress(keccak256(abi.encodePacked(\"operator\", operatorID)), _operatorAddress);\r\n    database.setString(keccak256(abi.encodePacked(\"operator.ipfs\", operatorID)), _ipfs);\r\n    if(_referrerAddress == address(0)){\r\n      database.setAddress(keccak256(abi.encodePacked(\"referrer\", operatorID)), database.addressStorage(keccak256(abi.encodePacked(\"platform.wallet.assets\"))));\r\n    } else {\r\n      database.setAddress(keccak256(abi.encodePacked(\"referrer\", operatorID)), _referrerAddress);\r\n    }\r\n\r\n    events.operator('Operator registered', operatorID, _operatorURI, _ipfs, _operatorAddress);\r\n  }\r\n\r\n  // @notice owners can remove operators from the platform here\r\n  function removeOperator(bytes32 _operatorID)\r\n  external {\r\n    address operatorAddress = database.addressStorage(keccak256(abi.encodePacked(\"operator\", _operatorID)));\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\"owner\", msg.sender))) || msg.sender == operatorAddress);\r\n    database.deleteBytes32(keccak256(abi.encodePacked(\"operator\", operatorAddress)));\r\n    database.deleteAddress(keccak256(abi.encodePacked(\"operator\", _operatorID)));\r\n    database.deleteAddress(keccak256(abi.encodePacked(\"referrer\", _operatorID)));\r\n    events.operator('Operator removed', _operatorID, '', '', msg.sender);\r\n  }\r\n\r\n\r\n  // @notice operator or owner can change the withdraw address of a registered operator\r\n  function changeOperatorAddress(bytes32 _operatorID, address _newAddress)\r\n  external {\r\n    address oldAddress = database.addressStorage(keccak256(abi.encodePacked(\"operator\", _operatorID)));\r\n    require(oldAddress != address(0));\r\n    require(msg.sender == oldAddress || database.boolStorage(keccak256(abi.encodePacked(\"owner\", msg.sender))));\r\n    database.setAddress(keccak256(abi.encodePacked(\"operator\", _operatorID)), _newAddress);\r\n    database.deleteBytes32(keccak256(abi.encodePacked(\"operator\", oldAddress)));\r\n    database.setBytes32(keccak256(abi.encodePacked(\"operator\", _newAddress)), _operatorID);\r\n    events.operator('Operator address changed', _operatorID, '', '', _newAddress);\r\n  }\r\n\r\n  function changeReferrerAddress(bytes32 _operatorID, address _newAddress)\r\n  external {\r\n    address oldAddress = database.addressStorage(keccak256(abi.encodePacked(\"referrer\", _operatorID)));\r\n    require(oldAddress != address(0));\r\n    require(msg.sender == oldAddress || database.boolStorage(keccak256(abi.encodePacked(\"owner\", msg.sender))));\r\n    database.setAddress(keccak256(abi.encodePacked(\"referrer\", _operatorID)), _newAddress);\r\n    events.operator('Referrer address changed', _operatorID, '', '', _newAddress);\r\n  }\r\n\r\n  function updateIPFS(bytes32 _operatorID, string _ipfs)\r\n  external\r\n  onlyOperator(_operatorID)\r\n  returns(bool){\r\n    database.setString(keccak256(abi.encodePacked(\"operator.ipfs\", _operatorID)), _ipfs);\r\n    events.operator('Operator ipfs', _operatorID, '', _ipfs, msg.sender);\r\n  }\r\n\r\n  function addAsset(bytes32 _operatorID, string _name, string _ipfs, bool _acceptCrypto, bool _payoutCrypto, address _token)\r\n  external\r\n  onlyOperator(_operatorID)\r\n  returns (bool) {\r\n    bytes32 modelID = keccak256(abi.encodePacked('model.id', _operatorID, _name));\r\n    require(database.addressStorage(keccak256(abi.encodePacked(\"model.operator\", modelID))) == address(0));\r\n    database.setAddress(keccak256(abi.encodePacked(\"model.operator\", modelID)), msg.sender);\r\n    database.setString(keccak256(abi.encodePacked('model.ipfs', modelID)), _ipfs);\r\n    acceptToken(modelID, _token, _acceptCrypto);\r\n    payoutToken(modelID, _token, _payoutCrypto);\r\n    events.operator('Asset added', modelID, _name, _ipfs, msg.sender);\r\n    return true;\r\n  }\r\n\r\n  function removeAsset(bytes32 _modelID)\r\n  external\r\n  onlyOperator(_modelID)\r\n  returns (bool) {\r\n    database.deleteAddress(keccak256(abi.encodePacked(\"model.operator\", _modelID)));\r\n    database.deleteString(keccak256(abi.encodePacked('model.ipfs', _modelID)));\r\n    events.operator('Asset added', _modelID, '', '', msg.sender);\r\n  }\r\n\r\n  // @notice operator can choose which ERC20 tokens he's willing to accept as payment\r\n  function acceptToken(bytes32 _modelID, address _tokenAddress, bool _accept)\r\n  public\r\n  onlyOperator(_modelID)\r\n  returns (bool) {\r\n    if(_tokenAddress == address(0)){\r\n      database.setBool(keccak256(abi.encodePacked(\"model.acceptsEther\", _modelID)), _accept);\r\n    }\r\n    database.setBool(keccak256(abi.encodePacked(\"model.acceptsToken\", _modelID, _tokenAddress)), _accept);\r\n    return true;\r\n  }\r\n\r\n\r\n  // @notice operator can choose which ERC20 tokens it pays out with\r\n  function payoutToken(bytes32 _modelID, address _tokenAddress, bool _payout)\r\n  public\r\n  onlyOperator(_modelID)\r\n  returns (bool) {\r\n    if(_tokenAddress == address(0)){\r\n      database.setBool(keccak256(abi.encodePacked(\"model.payoutEther\", _modelID)), _payout);\r\n    }\r\n    database.setBool(keccak256(abi.encodePacked(\"model.payoutToken\", _modelID, _tokenAddress)), _payout);\r\n    return true;\r\n  }\r\n\r\n  // @notice platform owners can destroy contract here\r\n  function destroy()\r\n  onlyOwner\r\n  external {\r\n    events.transaction('Operators destroyed', address(this), msg.sender, address(this).balance, address(0));\r\n    selfdestruct(msg.sender);\r\n  }\r\n\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  //                                                Modifiers                                                                     //\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n  // @notice Sender must be a registered owner\r\n  modifier onlyOwner {\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\"owner\", msg.sender))));\r\n    _;\r\n  }\r\n\r\n  // @notice Sender must be the operator address for this operatorID or modelID\r\n  modifier onlyOperator(bytes32 _id) {\r\n    require(database.addressStorage(keccak256(abi.encodePacked(\"operator\", _id))) == msg.sender || database.addressStorage(keccak256(abi.encodePacked(\"model.operator\", _id))) == msg.sender);\r\n    _;\r\n  }\r\n\r\n\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  //                                                Events                                                                        //\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  /*\r\n  event LogOperatorRegistered(bytes32 indexed _operatorID, string _operatorURI);\r\n  event LogOperatorRemoved(bytes32 indexed _operatorID, address _owner);\r\n  event LogOperatorAddressChanged(bytes32 indexed _operatorID, address _oldAddress, address _newAddress);\r\n  event LogOperatorAcceptsToken(bytes32 indexed _operatorID, address _tokenAddress);\r\n  */\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_operatorID\",\"type\":\"bytes32\"},{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeOperatorAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operatorID\",\"type\":\"bytes32\"},{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeReferrerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operatorID\",\"type\":\"bytes32\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operatorAddress\",\"type\":\"address\"},{\"name\":\"_operatorURI\",\"type\":\"string\"},{\"name\":\"_ipfs\",\"type\":\"string\"},{\"name\":\"_referrerAddress\",\"type\":\"address\"}],\"name\":\"registerOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operatorID\",\"type\":\"bytes32\"},{\"name\":\"_ipfs\",\"type\":\"string\"}],\"name\":\"updateIPFS\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"database\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operatorID\",\"type\":\"bytes32\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_ipfs\",\"type\":\"string\"},{\"name\":\"_acceptCrypto\",\"type\":\"bool\"},{\"name\":\"_payoutCrypto\",\"type\":\"bool\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"addAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_modelID\",\"type\":\"bytes32\"}],\"name\":\"removeAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_modelID\",\"type\":\"bytes32\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_accept\",\"type\":\"bool\"}],\"name\":\"acceptToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_modelID\",\"type\":\"bytes32\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_payout\",\"type\":\"bool\"}],\"name\":\"payoutToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"events\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_database\",\"type\":\"address\"},{\"name\":\"_events\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Operators","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005fcebeb70b88e86dd880352684e775b0f4d57c71000000000000000000000000eb6533f29a54c2c18bb2ce2a100de717692a518f","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://a79a6c2407a24adfa6ccc5e8650087c96f685509e396a11fa09245b6f4044a98"}]}