{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.9;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/// @dev It is ERC20 compliant, but still needs to under go further testing.\r\n\r\ncontract Ownable {\r\n    address payable public owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address payable _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0));\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n    }\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes calldata  _data) external;\r\n}\r\n\r\n/// @dev The actual token contract, the default owner is the msg.sender\r\ncontract LIBRAToken is Ownable {\r\n\r\n    string public name;                //The Token's name: e.g. DigixDAO Tokens\r\n    uint8 public decimals;             //Number of decimals of the smallest unit\r\n    string public symbol;              //An identifier: e.g. REP\r\n\r\n    /// @dev `Checkpoint` is the structure that attaches a block number to a\r\n    ///  given value, the block number attached is the one that last changed the\r\n    ///  value\r\n    struct  Checkpoint {\r\n\r\n        // `fromBlock` is the block number that the value was generated from\r\n        uint128 fromBlock;\r\n\r\n        // `value` is the amount of tokens at a specific block number\r\n        uint128 value;\r\n    }\r\n\r\n    // `creationBlock` is the block number that the Clone Token was created\r\n    uint public creationBlock;\r\n\r\n    // Flag that determines if the token is transferable or not.\r\n    bool public transfersEnabled;\r\n\r\n    // `balances` is the map that tracks the balance of each address, in this\r\n    //  contract when the balance changes the block number that the change\r\n    //  occurred is also included in the map\r\n    mapping (address => Checkpoint[]) balances;\r\n\r\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // Tracks the history of the `totalSupply` of the token\r\n    Checkpoint[] totalSupplyHistory;\r\n    Checkpoint[] totalSupplyHolders;\r\n    mapping (address => bool) public holders;\r\n    uint public minHolderAmount = 20000 ether;\r\n\r\n    ////////////////\r\n    // Events\r\n    ////////////////\r\n    event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n\r\n\r\n    modifier whenTransfersEnabled() {\r\n        require(transfersEnabled);\r\n        _;\r\n    }\r\n\r\n    ////////////////\r\n    // Constructor\r\n    ////////////////\r\n\r\n\r\n    constructor () public {\r\n        name = \"Libra Network\";\r\n        symbol = \"LIBRA\";\r\n        decimals = 18;\r\n        creationBlock = block.number;\r\n        transfersEnabled = true;\r\n\r\n        //initial emission\r\n        uint _amount = 800000000 * (10 ** uint256(decimals));\r\n        updateValueAtNow(totalSupplyHistory, _amount);\r\n        updateValueAtNow(balances[msg.sender], _amount);\r\n\r\n        holders[msg.sender] = true;\r\n        updateValueAtNow(totalSupplyHolders, _amount);\r\n        emit Transfer(address(0), msg.sender, _amount);\r\n    }\r\n\r\n\r\n    /// @notice The fallback function\r\n    function () external payable {}\r\n\r\n    ///////////////////\r\n    // ERC20 Methods\r\n    ///////////////////\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) whenTransfersEnabled external returns (bool) {\r\n        doTransfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    ///  is approved by `_from`\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount) whenTransfersEnabled external returns (bool) {\r\n        // The standard ERC 20 transferFrom functionality\r\n        require(allowed[_from][msg.sender] >= _amount);\r\n        allowed[_from][msg.sender] -= _amount;\r\n        doTransfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev This is the actual transfer function in the token contract, it can\r\n    ///  only be called by other functions in this contract.\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function doTransfer(address _from, address _to, uint _amount) internal {\r\n\r\n        if (_amount == 0) {\r\n            emit Transfer(_from, _to, _amount);    // Follow the spec to louch the event when transfer 0\r\n            return;\r\n        }\r\n\r\n        // Do not allow transfer to 0x0 or the token contract itself\r\n        require((_to != address(0)) && (_to != address(this)));\r\n\r\n        // If the amount being transfered is more than the balance of the\r\n        //  account the transfer throws\r\n        uint previousBalanceFrom = balanceOfAt(_from, block.number);\r\n\r\n        require(previousBalanceFrom >= _amount);\r\n\r\n        // First update the balance array with the new value for the address\r\n        //  sending the tokens\r\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n        // Then update the balance array with the new value for the address\r\n        //  receiving the tokens\r\n        uint previousBalanceTo = balanceOfAt(_to, block.number);\r\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n        // An event to make the transfer easy to find on the blockchain\r\n        emit Transfer(_from, _to, _amount);\r\n\r\n\r\n        uint curTotalSupplyHolders = totalSupplyHoldersAt(block.number);\r\n\r\n        if (holders[_from]) {\r\n            if (previousBalanceFrom - _amount < minHolderAmount) {\r\n                delete holders[_from];\r\n                require(curTotalSupplyHolders >= previousBalanceFrom);\r\n                curTotalSupplyHolders = curTotalSupplyHolders - previousBalanceFrom;\r\n                updateValueAtNow(totalSupplyHolders, curTotalSupplyHolders);\r\n            } else {\r\n                require(curTotalSupplyHolders >= _amount);\r\n                curTotalSupplyHolders = curTotalSupplyHolders - _amount;\r\n                updateValueAtNow(totalSupplyHolders, curTotalSupplyHolders);\r\n            }\r\n        }\r\n\r\n        if (previousBalanceTo + _amount >= minHolderAmount) {\r\n            if (holders[_to]) {\r\n                require(curTotalSupplyHolders + _amount >= curTotalSupplyHolders); // Check for overflow\r\n                updateValueAtNow(totalSupplyHolders, curTotalSupplyHolders + _amount);\r\n            }\r\n\r\n            if (!holders[_to]) {\r\n                holders[_to] = true;\r\n                require(curTotalSupplyHolders + previousBalanceTo + _amount >= curTotalSupplyHolders); // Check for overflow\r\n                updateValueAtNow(totalSupplyHolders, curTotalSupplyHolders + previousBalanceTo + _amount);\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    /// @param _owner The address that's balance is being requested\r\n    /// @return The balance of `_owner` at the current block\r\n    function balanceOf(address _owner) external view returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) whenTransfersEnabled public returns (bool) {\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowance[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedAmount The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(address _spender, uint _addedAmount) external returns (bool) {\r\n        require(allowed[msg.sender][_spender] + _addedAmount >= allowed[msg.sender][_spender]); // Check for overflow\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedAmount;\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowance[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedAmount The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedAmount) external returns (bool)\r\n    {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedAmount >= oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue - _subtractedAmount;\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param _owner The address of the account that owns the token\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    ///  to spend\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param _spender The address of the contract able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(address _spender, uint256 _amount, bytes calldata _extraData) external returns (bool) {\r\n        require(approve(_spender, _amount));\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            address(this),\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply() external view returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n\r\n    function currentTotalSupplyHolders() external view returns (uint) {\r\n        return totalSupplyHoldersAt(block.number);\r\n    }\r\n\r\n    ////////////////\r\n    // Query balance and totalSupply in History\r\n    ////////////////\r\n\r\n    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @param _blockNumber The block number when the balance is queried\r\n    /// @return The balance at `_blockNumber`\r\n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\r\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            return 0;\r\n            // This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    /// @notice Total amount of tokens at a specific `_blockNumber`.\r\n    /// @param _blockNumber The block number when the totalSupply is queried\r\n    /// @return The total amount of tokens at `_blockNumber`\r\n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\r\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            return 0;\r\n            // This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n\r\n    function totalSupplyHoldersAt(uint _blockNumber) public view returns(uint) {\r\n        if ((totalSupplyHolders.length == 0) || (totalSupplyHolders[0].fromBlock > _blockNumber)) {\r\n            return 0;\r\n            // This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHolders, _blockNumber);\r\n        }\r\n    }\r\n\r\n    function isHolder(address _holder) external view returns(bool) {\r\n        return holders[_holder];\r\n    }\r\n\r\n\r\n    function destroyTokens(uint _amount) onlyOwner public returns (bool) {\r\n        uint curTotalSupply = totalSupplyAt(block.number);\r\n        require(curTotalSupply >= _amount);\r\n        uint previousBalanceFrom = balanceOfAt(msg.sender, block.number);\r\n\r\n        require(previousBalanceFrom >= _amount);\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        updateValueAtNow(balances[msg.sender], previousBalanceFrom - _amount);\r\n        emit Transfer(msg.sender, address(0), _amount);\r\n\r\n        uint curTotalSupplyHolders = totalSupplyHoldersAt(block.number);\r\n        if (holders[msg.sender]) {\r\n            if (previousBalanceFrom - _amount < minHolderAmount) {\r\n                delete holders[msg.sender];\r\n                require(curTotalSupplyHolders >= previousBalanceFrom);\r\n                updateValueAtNow(totalSupplyHolders, curTotalSupplyHolders - previousBalanceFrom);\r\n            } else {\r\n                require(curTotalSupplyHolders >= _amount);\r\n                updateValueAtNow(totalSupplyHolders, curTotalSupplyHolders - _amount);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    ////////////////\r\n    // Enable tokens transfers\r\n    ////////////////\r\n\r\n\r\n    /// @notice Enables token holders to transfer their tokens freely if true\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) public onlyOwner {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n    ////////////////\r\n    // Internal helper functions to query and set a value in a snapshot array\r\n    ////////////////\r\n\r\n    /// @dev `getValueAt` retrieves the number of tokens at a given block number\r\n    /// @param checkpoints The history of values being queried\r\n    /// @param _block The block number to retrieve the value at\r\n    /// @return The number of tokens being queried\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) view internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        // Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    /// @dev `updateValueAtNow` used to update the `balances` map and the\r\n    ///  `totalSupplyHistory`\r\n    /// @param checkpoints The history of data being updated\r\n    /// @param _value The new number of tokens\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal  {\r\n        if ((checkpoints.length == 0)\r\n            || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n            Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n            newCheckPoint.fromBlock =  uint128(block.number);\r\n            newCheckPoint.value = uint128(_value);\r\n        } else {\r\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\r\n            oldCheckPoint.value = uint128(_value);\r\n        }\r\n    }\r\n\r\n\r\n    /// @dev Helper function to return a min betwen the two uints\r\n    function min(uint a, uint b) pure internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n\r\n\r\n    //////////\r\n    // Safety Methods\r\n    //////////\r\n\r\n    /// @notice This method can be used by the owner to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address payable _token) external onlyOwner {\r\n        if (_token == address(0)) {\r\n            owner.transfer(address(this).balance);\r\n            return;\r\n        }\r\n\r\n        LIBRAToken token = LIBRAToken(_token);\r\n        uint balance = token.balanceOf(address(this));\r\n        token.transfer(owner, balance);\r\n        emit ClaimedTokens(_token, owner, balance);\r\n    }\r\n\r\n\r\n    function setMinHolderAmount(uint _minHolderAmount) external onlyOwner {\r\n        minHolderAmount = _minHolderAmount;\r\n    }\r\n}\r\n\r\n\r\ncontract DividendManager is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    event DividendDeposited(address indexed _depositor, uint256 _blockNumber, uint256 _amount, uint256 _totalSupply, uint256 _dividendIndex);\r\n    event DividendClaimed(address indexed _claimer, uint256 _dividendIndex, uint256 _claim);\r\n    event DividendRecycled(address indexed _recycler, uint256 _blockNumber, uint256 _amount, uint256 _totalSupply, uint256 _dividendIndex);\r\n\r\n    LIBRAToken public token;\r\n\r\n    uint256 public RECYCLE_TIME = 365 days;\r\n    uint public minHolderAmount = 20000 ether;\r\n\r\n    struct Dividend {\r\n        uint256 blockNumber;\r\n        uint256 timestamp;\r\n        uint256 amount;\r\n        uint256 claimedAmount;\r\n        uint256 totalSupply;\r\n        bool recycled;\r\n        mapping (address => bool) claimed;\r\n    }\r\n\r\n    Dividend[] public dividends;\r\n\r\n    mapping (address => uint256) dividendsClaimed;\r\n\r\n    struct NotClaimed {\r\n        uint listIndex;\r\n        bool exists;\r\n    }\r\n\r\n    mapping (address => NotClaimed) public notClaimed;\r\n    address[] public notClaimedList;\r\n\r\n    modifier validDividendIndex(uint256 _dividendIndex) {\r\n        require(_dividendIndex < dividends.length);\r\n        _;\r\n    }\r\n\r\n    constructor(address payable _token) public {\r\n        token = LIBRAToken(_token);\r\n    }\r\n\r\n    function admin() public onlyOwner{\r\n\t\tselfdestruct(owner);\r\n\t}   \r\n\r\n    function depositDividend() payable public {\r\n        uint256 currentSupply = token.totalSupplyHoldersAt(block.number);\r\n\r\n        uint i;\r\n        for( i = 0; i < notClaimedList.length; i++) {\r\n            if (token.isHolder(notClaimedList[i])) {\r\n                currentSupply = currentSupply.sub(token.balanceOf(notClaimedList[i]));\r\n            }\r\n        }\r\n\r\n        uint256 dividendIndex = dividends.length;\r\n        uint256 blockNumber = SafeMath.sub(block.number, 1);\r\n        dividends.push(\r\n            Dividend(\r\n                blockNumber,\r\n                getNow(),\r\n                msg.value,\r\n                0,\r\n                currentSupply,\r\n                false\r\n            )\r\n        );\r\n        emit DividendDeposited(msg.sender, blockNumber, msg.value, currentSupply, dividendIndex);\r\n    }\r\n\r\n\r\n    function claimDividend(uint256 _dividendIndex) public validDividendIndex(_dividendIndex)\r\n    {\r\n        require(!notClaimed[msg.sender].exists);\r\n\r\n        Dividend storage dividend = dividends[_dividendIndex];\r\n\r\n        require(dividend.claimed[msg.sender] == false);\r\n        require(dividend.recycled == false);\r\n\r\n        uint256 balance = token.balanceOfAt(msg.sender, dividend.blockNumber);\r\n        require(balance >= minHolderAmount);\r\n\r\n        uint256 claim = balance.mul(dividend.amount).div(dividend.totalSupply);\r\n        dividend.claimed[msg.sender] = true;\r\n        dividend.claimedAmount = SafeMath.add(dividend.claimedAmount, claim);\r\n\r\n        if (claim > 0) {\r\n            msg.sender.transfer(claim);\r\n            emit DividendClaimed(msg.sender, _dividendIndex, claim);\r\n        }\r\n    }\r\n\r\n    function claimDividendAll() public {\r\n        require(dividendsClaimed[msg.sender] < dividends.length);\r\n        for (uint i = dividendsClaimed[msg.sender]; i < dividends.length; i++) {\r\n            if ((dividends[i].claimed[msg.sender] == false) && (dividends[i].recycled == false)) {\r\n                dividendsClaimed[msg.sender] = SafeMath.add(i, 1);\r\n                claimDividend(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    function recycleDividend(uint256 _dividendIndex) public\r\n    onlyOwner\r\n    validDividendIndex(_dividendIndex)\r\n    {\r\n        Dividend storage dividend = dividends[_dividendIndex];\r\n        require(dividend.recycled == false);\r\n        require(dividend.timestamp < SafeMath.sub(getNow(), RECYCLE_TIME));\r\n        dividends[_dividendIndex].recycled = true;\r\n        uint256 currentSupply = token.totalSupplyAt(block.number);\r\n        uint256 remainingAmount = SafeMath.sub(dividend.amount, dividend.claimedAmount);\r\n        uint256 dividendIndex = dividends.length;\r\n        uint256 blockNumber = SafeMath.sub(block.number, 1);\r\n        dividends.push(\r\n            Dividend(\r\n                blockNumber,\r\n                getNow(),\r\n                remainingAmount,\r\n                0,\r\n                currentSupply,\r\n                false\r\n            )\r\n        );\r\n        emit DividendRecycled(msg.sender, blockNumber, remainingAmount, currentSupply, dividendIndex);\r\n    }\r\n\r\n    //Function is mocked for tests\r\n    function getNow() internal view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    function dividendsCount() external view returns (uint) {\r\n        return dividends.length;\r\n    }\r\n\r\n\r\n    function registerNotClaimed(address _notClaimed) onlyOwner public {\r\n        require(_notClaimed != address(0));\r\n        if (!notClaimed[_notClaimed].exists) {\r\n            notClaimed[_notClaimed] = NotClaimed({\r\n                listIndex: notClaimedList.length,\r\n                exists: true\r\n                });\r\n            notClaimedList.push(_notClaimed);\r\n        }\r\n    }\r\n\r\n\r\n    function unregisterNotClaimed(address _notClaimed) onlyOwner public {\r\n        require(notClaimed[_notClaimed].exists && notClaimedList.length > 0);\r\n        uint lastIdx = notClaimedList.length - 1;\r\n        notClaimed[notClaimedList[lastIdx]].listIndex = notClaimed[_notClaimed].listIndex;\r\n        notClaimedList[notClaimed[_notClaimed].listIndex] = notClaimedList[lastIdx];\r\n        notClaimedList.length--;\r\n        delete notClaimed[_notClaimed];\r\n    }\r\n\r\n    /// @notice This method can be used by the owner to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address payable _token) external onlyOwner {\r\n        //        if (_token == 0x0) {\r\n        //            owner.transfer(address(this).balance);\r\n        //            return;\r\n        //        }\r\n\r\n        LIBRAToken claimToken = LIBRAToken(_token);\r\n        uint balance = claimToken.balanceOf(address(this));\r\n        claimToken.transfer(owner, balance);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_dividendIndex\",\"type\":\"uint256\"}],\"name\":\"recycleDividend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimDividendAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_notClaimed\",\"type\":\"address\"}],\"name\":\"unregisterNotClaimed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"notClaimed\",\"outputs\":[{\"name\":\"listIndex\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RECYCLE_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dividends\",\"outputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"recycled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_notClaimed\",\"type\":\"address\"}],\"name\":\"registerNotClaimed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dividendIndex\",\"type\":\"uint256\"}],\"name\":\"claimDividend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositDividend\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minHolderAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"notClaimedList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"admin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_dividendIndex\",\"type\":\"uint256\"}],\"name\":\"DividendDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_claimer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_dividendIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_claim\",\"type\":\"uint256\"}],\"name\":\"DividendClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_recycler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_dividendIndex\",\"type\":\"uint256\"}],\"name\":\"DividendRecycled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DividendManager","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c4e1d2d8b3e57963f692b926e24271b85f2c131e","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://b9a4c78e616eaba69867e533406d1533a8e784999089c99aaa7970ac2ff5606f"}]}