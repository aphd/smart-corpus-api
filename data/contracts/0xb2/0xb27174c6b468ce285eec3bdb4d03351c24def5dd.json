{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Token {\r\n  /// @return total amount of tokens\r\n  function totalSupply() public view returns (uint256 supply) {}\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) public returns (bool success) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) public  returns (bool success) {}\r\n\r\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of wei to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) public returns (bool success) {}\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  uint public decimals;\r\n  string public name;\r\n}\r\n\r\n\r\ncontract DaiSwap is SafeMath {\r\n    mapping (address => uint) public daiposit;\r\n    uint public totaldai = 0;\r\n    uint public baseMultiplier = 20;\r\n    uint fee = 997; // 0.3%\r\n    uint constant decOffset = 1e12;\r\n    Token   daiContract = Token(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);\r\n    Token  usdcContract = Token(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    //Kovan Testnet\r\n    //Token   daiContract = Token(0xE888757Fbf1f29B520a80f977DBE52F9AD20d6C9);\r\n    //Token  usdcContract = Token(0x3502B803f2a516cD6e9d6E8938b700d78ABF1373);\r\n    \r\n    function usdcAmountFromDai(uint dai) public view returns (uint) {\r\n        if (totaldai == 0) return dai / decOffset; // Initialisation\r\n        uint base = safeMul(baseMultiplier, totaldai);\r\n        uint amt_dai  =  daiContract.balanceOf(address(this));\r\n        uint amt_usdc = safeMul(usdcContract.balanceOf(address(this)), decOffset);\r\n        return safeMul(dai, safeAdd(amt_usdc, base)) / safeAdd(amt_dai, base) / decOffset;\r\n    }\r\n    \r\n    function deposit(uint dai) public {\r\n        uint usdc = usdcAmountFromDai(dai);\r\n        daiposit[msg.sender] = safeAdd(daiposit[msg.sender], dai);\r\n        totaldai             = safeAdd(totaldai, dai);\r\n        if ( !daiContract.transferFrom(msg.sender, address(this), dai)) revert();\r\n        if (!usdcContract.transferFrom(msg.sender, address(this), usdc)) revert();\r\n    }\r\n    \r\n    function withdraw() public {\r\n        uint dai  = safeMul(daiposit[msg.sender],  daiContract.balanceOf(address(this))) / totaldai;\r\n        uint usdc = safeMul(daiposit[msg.sender], usdcContract.balanceOf(address(this))) / totaldai;\r\n        totaldai  = safeSub(totaldai, daiposit[msg.sender]);\r\n        daiposit[msg.sender] = 0;\r\n        if ( !daiContract.transfer(msg.sender, dai)) revert();\r\n        if (!usdcContract.transfer(msg.sender, usdc)) revert();\r\n    }\r\n    \r\n    function calcSwapForUSDC(uint dai) public view returns (uint) {\r\n        uint base     = safeMul(baseMultiplier, totaldai);\r\n        uint amt_dai  =          daiContract.balanceOf(address(this));\r\n        uint amt_usdc = safeMul(usdcContract.balanceOf(address(this)), decOffset);\r\n        uint usdc     = safeSub(safeAdd(amt_usdc, base), ( safeMul(safeAdd(base, amt_usdc), safeAdd(base, amt_dai)) / safeAdd(safeAdd(base, amt_dai), dai)));\r\n        usdc = usdc / decOffset;\r\n        return safeMul(usdc, fee) / 1000;\r\n    }\r\n    \r\n    function swapForUSDC(uint dai) public {\r\n        uint usdc = calcSwapForUSDC(dai);\r\n        require(usdc < usdcContract.balanceOf(address(this)));\r\n        if ( !daiContract.transferFrom(msg.sender, address(this), dai)) revert();\r\n        if (!usdcContract.transfer(msg.sender, usdc)) revert();\r\n    }\r\n    \r\n    function calcSwapForDai(uint usdc) public view returns (uint) {\r\n        uint base     = safeMul(baseMultiplier, totaldai);\r\n        uint amt_dai  =          daiContract.balanceOf(address(this));\r\n        uint amt_usdc = safeMul(usdcContract.balanceOf(address(this)), decOffset);\r\n        uint dai      = safeSub(safeAdd(amt_dai, base), ( safeMul(safeAdd(base, amt_usdc), safeAdd(base, amt_dai)) / safeAdd(safeAdd(base, amt_usdc), safeMul(usdc, decOffset))));\r\n        return safeMul(dai, fee) / 1000;\r\n    }\r\n    \r\n    function swapForDai(uint usdc) public {\r\n        uint dai = calcSwapForDai(usdc);\r\n        require(dai < daiContract.balanceOf(address(this)));\r\n        if (!usdcContract.transferFrom(msg.sender, address(this), usdc)) revert();\r\n        if ( !daiContract.transfer(msg.sender, dai)) revert();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"daiposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dai\",\"type\":\"uint256\"}],\"name\":\"swapForUSDC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"dai\",\"type\":\"uint256\"}],\"name\":\"calcSwapForUSDC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dai\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totaldai\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"usdc\",\"type\":\"uint256\"}],\"name\":\"calcSwapForDai\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"dai\",\"type\":\"uint256\"}],\"name\":\"usdcAmountFromDai\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdc\",\"type\":\"uint256\"}],\"name\":\"swapForDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DaiSwap","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://fe71acd67da11539af612286c492b990a285753028a875f454a89c2b7afc31d7"}]}