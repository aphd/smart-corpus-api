{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title   EllipticCurve\r\n *\r\n * @author  Tilman Drerup;\r\n *\r\n * @notice  Implements elliptic curve math; Parametrized for SECP256R1.\r\n *\r\n *          Includes components of code by Andreas Olofsson, Alexander Vlasov\r\n *          (https://github.com/BANKEX/CurveArithmetics), and Avi Asayag\r\n *          (https://github.com/orbs-network/elliptic-curve-solidity)\r\n *\r\n * @dev     NOTE: To disambiguate public keys when verifying signatures, activate\r\n *          condition 'rs[1] > lowSmax' in validateSignature().\r\n */\r\ncontract EllipticCurve {\r\n\r\n    // Set parameters for curve.\r\n    uint constant a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\r\n    uint constant b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\r\n    uint constant gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\r\n    uint constant gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\r\n    uint constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\r\n    uint constant n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\r\n\r\n    uint constant lowSmax = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\r\n\r\n    /**\r\n     * @dev Inverse of u in the field of modulo m.\r\n     */\r\n    function inverseMod(uint u, uint m) internal pure\r\n        returns (uint)\r\n    {\r\n        if (u == 0 || u == m || m == 0)\r\n            return 0;\r\n        if (u > m)\r\n            u = u % m;\r\n\r\n        int t1;\r\n        int t2 = 1;\r\n        uint r1 = m;\r\n        uint r2 = u;\r\n        uint q;\r\n\r\n        while (r2 != 0) {\r\n            q = r1 / r2;\r\n            (t1, t2, r1, r2) = (t2, t1 - int(q) * t2, r2, r1 - q * r2);\r\n        }\r\n\r\n        if (t1 < 0)\r\n            return (m - uint(-t1));\r\n\r\n        return uint(t1);\r\n    }\r\n\r\n    /**\r\n     * @dev Transform affine coordinates into projective coordinates.\r\n     */\r\n    function toProjectivePoint(uint x0, uint y0) public pure\r\n        returns (uint[3] memory P)\r\n    {\r\n        P[2] = addmod(0, 1, p);\r\n        P[0] = mulmod(x0, P[2], p);\r\n        P[1] = mulmod(y0, P[2], p);\r\n    }\r\n\r\n    /**\r\n     * @dev Add two points in affine coordinates and return projective point.\r\n     */\r\n    function addAndReturnProjectivePoint(uint x1, uint y1, uint x2, uint y2) public pure\r\n        returns (uint[3] memory P)\r\n    {\r\n        uint x;\r\n        uint y;\r\n        (x, y) = add(x1, y1, x2, y2);\r\n        P = toProjectivePoint(x, y);\r\n    }\r\n\r\n    /**\r\n     * @dev Transform from projective to affine coordinates.\r\n     */\r\n    function toAffinePoint(uint x0, uint y0, uint z0) public pure\r\n        returns (uint x1, uint y1)\r\n    {\r\n        uint z0Inv;\r\n        z0Inv = inverseMod(z0, p);\r\n        x1 = mulmod(x0, z0Inv, p);\r\n        y1 = mulmod(y0, z0Inv, p);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the zero curve in projective coordinates.\r\n     */\r\n    function zeroProj() public pure\r\n        returns (uint x, uint y, uint z)\r\n    {\r\n        return (0, 1, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the zero curve in affine coordinates.\r\n     */\r\n    function zeroAffine() public pure\r\n        returns (uint x, uint y)\r\n    {\r\n        return (0, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if the curve is the zero curve.\r\n     */\r\n    function isZeroCurve(uint x0, uint y0) public pure\r\n        returns (bool isZero)\r\n    {\r\n        if(x0 == 0 && y0 == 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a point in affine coordinates is on the curve.\r\n     */\r\n    function isOnCurve(uint x, uint y) public pure\r\n        returns (bool)\r\n    {\r\n        if (0 == x || x == p || 0 == y || y == p) {\r\n            return false;\r\n        }\r\n\r\n        uint LHS = mulmod(y, y, p); // y^2\r\n        uint RHS = mulmod(mulmod(x, x, p), x, p); // x^3\r\n\r\n        if (a != 0) {\r\n            RHS = addmod(RHS, mulmod(x, a, p), p); // x^3 + a*x\r\n        }\r\n        if (b != 0) {\r\n            RHS = addmod(RHS, b, p); // x^3 + a*x + b\r\n        }\r\n\r\n        return LHS == RHS;\r\n    }\r\n\r\n    /**\r\n     * @dev Double an elliptic curve point in projective coordinates. See\r\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\r\n     */\r\n    function twiceProj(uint x0, uint y0, uint z0) public pure\r\n        returns (uint x1, uint y1, uint z1)\r\n    {\r\n        uint t;\r\n        uint u;\r\n        uint v;\r\n        uint w;\r\n\r\n        if(isZeroCurve(x0, y0)) {\r\n            return zeroProj();\r\n        }\r\n\r\n        u = mulmod(y0, z0, p);\r\n        u = mulmod(u, 2, p);\r\n\r\n        v = mulmod(u, x0, p);\r\n        v = mulmod(v, y0, p);\r\n        v = mulmod(v, 2, p);\r\n\r\n        x0 = mulmod(x0, x0, p);\r\n        t = mulmod(x0, 3, p);\r\n\r\n        z0 = mulmod(z0, z0, p);\r\n        z0 = mulmod(z0, a, p);\r\n        t = addmod(t, z0, p);\r\n\r\n        w = mulmod(t, t, p);\r\n        x0 = mulmod(2, v, p);\r\n        w = addmod(w, p-x0, p);\r\n\r\n        x0 = addmod(v, p-w, p);\r\n        x0 = mulmod(t, x0, p);\r\n        y0 = mulmod(y0, u, p);\r\n        y0 = mulmod(y0, y0, p);\r\n        y0 = mulmod(2, y0, p);\r\n        y1 = addmod(x0, p-y0, p);\r\n\r\n        x1 = mulmod(u, w, p);\r\n\r\n        z1 = mulmod(u, u, p);\r\n        z1 = mulmod(z1, u, p);\r\n    }\r\n\r\n    /**\r\n     * @dev Add two elliptic curve points in projective coordinates. See\r\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\r\n     */\r\n    function addProj(uint x0, uint y0, uint z0, uint x1, uint y1, uint z1) public pure\r\n        returns (uint x2, uint y2, uint z2)\r\n    {\r\n        uint t0;\r\n        uint t1;\r\n        uint u0;\r\n        uint u1;\r\n\r\n        if (isZeroCurve(x0, y0)) {\r\n            return (x1, y1, z1);\r\n        }\r\n        else if (isZeroCurve(x1, y1)) {\r\n            return (x0, y0, z0);\r\n        }\r\n\r\n        t0 = mulmod(y0, z1, p);\r\n        t1 = mulmod(y1, z0, p);\r\n\r\n        u0 = mulmod(x0, z1, p);\r\n        u1 = mulmod(x1, z0, p);\r\n\r\n        if (u0 == u1) {\r\n            if (t0 == t1) {\r\n                return twiceProj(x0, y0, z0);\r\n            }\r\n            else {\r\n                return zeroProj();\r\n            }\r\n        }\r\n\r\n        (x2, y2, z2) = addProj2(mulmod(z0, z1, p), u0, u1, t1, t0);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function that splits addProj to avoid too many local variables.\r\n     */\r\n    function addProj2(uint v, uint u0, uint u1, uint t1, uint t0) private pure\r\n        returns (uint x2, uint y2, uint z2)\r\n    {\r\n        uint u;\r\n        uint u2;\r\n        uint u3;\r\n        uint w;\r\n        uint t;\r\n\r\n        t = addmod(t0, p-t1, p);\r\n        u = addmod(u0, p-u1, p);\r\n        u2 = mulmod(u, u, p);\r\n\r\n        w = mulmod(t, t, p);\r\n        w = mulmod(w, v, p);\r\n        u1 = addmod(u1, u0, p);\r\n        u1 = mulmod(u1, u2, p);\r\n        w = addmod(w, p-u1, p);\r\n\r\n        x2 = mulmod(u, w, p);\r\n\r\n        u3 = mulmod(u2, u, p);\r\n        u0 = mulmod(u0, u2, p);\r\n        u0 = addmod(u0, p-w, p);\r\n        t = mulmod(t, u0, p);\r\n        t0 = mulmod(t0, u3, p);\r\n\r\n        y2 = addmod(t, p-t0, p);\r\n\r\n        z2 = mulmod(u3, v, p);\r\n    }\r\n\r\n    /**\r\n     * @dev Add two elliptic curve points in affine coordinates.\r\n     */\r\n    function add(uint x0, uint y0, uint x1, uint y1) public pure\r\n        returns (uint, uint)\r\n    {\r\n        uint z0;\r\n\r\n        (x0, y0, z0) = addProj(x0, y0, 1, x1, y1, 1);\r\n\r\n        return toAffinePoint(x0, y0, z0);\r\n    }\r\n\r\n    /**\r\n     * @dev Double an elliptic curve point in affine coordinates.\r\n     */\r\n    function twice(uint x0, uint y0) public pure\r\n        returns (uint, uint)\r\n    {\r\n        uint z0;\r\n\r\n        (x0, y0, z0) = twiceProj(x0, y0, 1);\r\n\r\n        return toAffinePoint(x0, y0, z0);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an elliptic curve point by a 2 power base (i.e., (2^exp)*P)).\r\n     */\r\n    function multiplyPowerBase2(uint x0, uint y0, uint exp) public pure\r\n        returns (uint, uint)\r\n    {\r\n        uint base2X = x0;\r\n        uint base2Y = y0;\r\n        uint base2Z = 1;\r\n\r\n        for(uint i = 0; i < exp; i++) {\r\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\r\n        }\r\n\r\n        return toAffinePoint(base2X, base2Y, base2Z);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an elliptic curve point by a scalar.\r\n     */\r\n    function multiplyScalar(uint x0, uint y0, uint scalar) public pure\r\n        returns (uint x1, uint y1)\r\n    {\r\n        if(scalar == 0) {\r\n            return zeroAffine();\r\n        }\r\n        else if (scalar == 1) {\r\n            return (x0, y0);\r\n        }\r\n        else if (scalar == 2) {\r\n            return twice(x0, y0);\r\n        }\r\n\r\n        uint base2X = x0;\r\n        uint base2Y = y0;\r\n        uint base2Z = 1;\r\n        uint z1 = 1;\r\n        x1 = x0;\r\n        y1 = y0;\r\n\r\n        if(scalar%2 == 0) {\r\n            x1 = y1 = 0;\r\n        }\r\n\r\n        scalar = scalar >> 1;\r\n\r\n        while(scalar > 0) {\r\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\r\n\r\n            if(scalar%2 == 1) {\r\n                (x1, y1, z1) = addProj(base2X, base2Y, base2Z, x1, y1, z1);\r\n            }\r\n\r\n            scalar = scalar >> 1;\r\n        }\r\n\r\n        return toAffinePoint(x1, y1, z1);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply the curve's generator point by a scalar.\r\n     */\r\n    function multipleGeneratorByScalar(uint scalar) public pure\r\n        returns (uint, uint)\r\n    {\r\n        return multiplyScalar(gx, gy, scalar);\r\n    }\r\n\r\n    /**\r\n     * @dev Validate combination of message, signature, and public key.\r\n     */\r\n    function validateSignature(bytes32 message, uint[2] memory rs, uint[2] memory Q) public pure\r\n        returns (bool)\r\n    {\r\n\r\n        // To disambiguate between public key solutions, include comment below.\r\n        if(rs[0] == 0 || rs[0] >= n || rs[1] == 0) {// || rs[1] > lowSmax)\r\n            return false;\r\n        }\r\n        if (!isOnCurve(Q[0], Q[1])) {\r\n            return false;\r\n        }\r\n\r\n        uint x1;\r\n        uint x2;\r\n        uint y1;\r\n        uint y2;\r\n\r\n        uint sInv = inverseMod(rs[1], n);\r\n        (x1, y1) = multiplyScalar(gx, gy, mulmod(uint(message), sInv, n));\r\n        (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, n));\r\n        uint[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);\r\n\r\n        if (P[2] == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint Px = inverseMod(P[2], p);\r\n        Px = mulmod(P[0], mulmod(Px, Px, p), p);\r\n\r\n        return Px % n == rs[0];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"message\",\"type\":\"bytes32\"},{\"name\":\"rs\",\"type\":\"uint256[2]\"},{\"name\":\"Q\",\"type\":\"uint256[2]\"}],\"name\":\"validateSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x0\",\"type\":\"uint256\"},{\"name\":\"y0\",\"type\":\"uint256\"}],\"name\":\"twice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"scalar\",\"type\":\"uint256\"}],\"name\":\"multipleGeneratorByScalar\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"isOnCurve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zeroProj\",\"outputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"z\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x0\",\"type\":\"uint256\"},{\"name\":\"y0\",\"type\":\"uint256\"},{\"name\":\"exp\",\"type\":\"uint256\"}],\"name\":\"multiplyPowerBase2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x0\",\"type\":\"uint256\"},{\"name\":\"y0\",\"type\":\"uint256\"},{\"name\":\"z0\",\"type\":\"uint256\"}],\"name\":\"toAffinePoint\",\"outputs\":[{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"},{\"name\":\"x2\",\"type\":\"uint256\"},{\"name\":\"y2\",\"type\":\"uint256\"}],\"name\":\"addAndReturnProjectivePoint\",\"outputs\":[{\"name\":\"P\",\"type\":\"uint256[3]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x0\",\"type\":\"uint256\"},{\"name\":\"y0\",\"type\":\"uint256\"},{\"name\":\"scalar\",\"type\":\"uint256\"}],\"name\":\"multiplyScalar\",\"outputs\":[{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x0\",\"type\":\"uint256\"},{\"name\":\"y0\",\"type\":\"uint256\"}],\"name\":\"toProjectivePoint\",\"outputs\":[{\"name\":\"P\",\"type\":\"uint256[3]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zeroAffine\",\"outputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x0\",\"type\":\"uint256\"},{\"name\":\"y0\",\"type\":\"uint256\"}],\"name\":\"isZeroCurve\",\"outputs\":[{\"name\":\"isZero\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x0\",\"type\":\"uint256\"},{\"name\":\"y0\",\"type\":\"uint256\"},{\"name\":\"z0\",\"type\":\"uint256\"}],\"name\":\"twiceProj\",\"outputs\":[{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"},{\"name\":\"z1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x0\",\"type\":\"uint256\"},{\"name\":\"y0\",\"type\":\"uint256\"},{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x0\",\"type\":\"uint256\"},{\"name\":\"y0\",\"type\":\"uint256\"},{\"name\":\"z0\",\"type\":\"uint256\"},{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"},{\"name\":\"z1\",\"type\":\"uint256\"}],\"name\":\"addProj\",\"outputs\":[{\"name\":\"x2\",\"type\":\"uint256\"},{\"name\":\"y2\",\"type\":\"uint256\"},{\"name\":\"z2\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"EllipticCurve","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://7e0d356d30248d320dc91fd5a6f8222bcd6d29681432b071c03ae0469a00fdad"}]}