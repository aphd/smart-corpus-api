{"status":"1","message":"OK","result":[{"SourceCode":"// File: installed_contracts/openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: installed_contracts/openzeppelin-solidity/contracts/ownership/Secondary.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Secondary\r\n * @dev A Secondary contract can only be used by its primary account (the one that created it)\r\n */\r\ncontract Secondary {\r\n    address private _primary;\r\n\r\n    event PrimaryTransferred(\r\n        address recipient\r\n    );\r\n\r\n    /**\r\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\r\n     */\r\n    constructor () internal {\r\n        _primary = msg.sender;\r\n        emit PrimaryTransferred(_primary);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if called from any account other than the primary.\r\n     */\r\n    modifier onlyPrimary() {\r\n        require(msg.sender == _primary);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return the address of the primary.\r\n     */\r\n    function primary() public view returns (address) {\r\n        return _primary;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers contract to a new primary.\r\n     * @param recipient The address of new primary.\r\n     */\r\n    function transferPrimary(address recipient) public onlyPrimary {\r\n        require(recipient != address(0));\r\n        _primary = recipient;\r\n        emit PrimaryTransferred(_primary);\r\n    }\r\n}\r\n\r\n// File: installed_contracts/openzeppelin-solidity/contracts/payment/escrow/Escrow.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n /**\r\n  * @title Escrow\r\n  * @dev Base escrow contract, holds funds designated for a payee until they\r\n  * withdraw them.\r\n  * @dev Intended usage: This contract (and derived escrow contracts) should be a\r\n  * standalone contract, that only interacts with the contract that instantiated\r\n  * it. That way, it is guaranteed that all Ether will be handled according to\r\n  * the Escrow rules, and there is no need to check for payable functions or\r\n  * transfers in the inheritance tree. The contract that uses the escrow as its\r\n  * payment method should be its primary, and provide public methods redirecting\r\n  * to the escrow's deposit and withdraw.\r\n  */\r\ncontract Escrow is Secondary {\r\n    using SafeMath for uint256;\r\n\r\n    event Deposited(address indexed payee, uint256 weiAmount);\r\n    event Withdrawn(address indexed payee, uint256 weiAmount);\r\n\r\n    mapping(address => uint256) private _deposits;\r\n\r\n    function depositsOf(address payee) public view returns (uint256) {\r\n        return _deposits[payee];\r\n    }\r\n\r\n    /**\r\n     * @dev Stores the sent amount as credit to be withdrawn.\r\n     * @param payee The destination address of the funds.\r\n     */\r\n    function deposit(address payee) public onlyPrimary payable {\r\n        uint256 amount = msg.value;\r\n        _deposits[payee] = _deposits[payee].add(amount);\r\n\r\n        emit Deposited(payee, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw accumulated balance for a payee.\r\n     * @param payee The address whose funds will be withdrawn and transferred to.\r\n     */\r\n    function withdraw(address payable payee) public onlyPrimary {\r\n        uint256 payment = _deposits[payee];\r\n\r\n        _deposits[payee] = 0;\r\n\r\n        payee.transfer(payment);\r\n\r\n        emit Withdrawn(payee, payment);\r\n    }\r\n}\r\n\r\n// File: installed_contracts/openzeppelin-solidity/contracts/payment/escrow/ConditionalEscrow.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ConditionalEscrow\r\n * @dev Base abstract escrow to only allow withdrawal if a condition is met.\r\n * @dev Intended usage: See Escrow.sol. Same usage guidelines apply here.\r\n */\r\ncontract ConditionalEscrow is Escrow {\r\n    /**\r\n     * @dev Returns whether an address is allowed to withdraw their funds. To be\r\n     * implemented by derived contracts.\r\n     * @param payee The destination address of the funds.\r\n     */\r\n    function withdrawalAllowed(address payee) public view returns (bool);\r\n\r\n    function withdraw(address payable payee) public {\r\n        require(withdrawalAllowed(payee));\r\n        super.withdraw(payee);\r\n    }\r\n}\r\n\r\n// File: installed_contracts/openzeppelin-solidity/contracts/payment/escrow/RefundEscrow.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title RefundEscrow\r\n * @dev Escrow that holds funds for a beneficiary, deposited from multiple\r\n * parties.\r\n * @dev Intended usage: See Escrow.sol. Same usage guidelines apply here.\r\n * @dev The primary account (that is, the contract that instantiates this\r\n * contract) may deposit, close the deposit period, and allow for either\r\n * withdrawal by the beneficiary, or refunds to the depositors. All interactions\r\n * with RefundEscrow will be made through the primary contract. See the\r\n * RefundableCrowdsale contract for an example of RefundEscrowâ€™s use.\r\n */\r\ncontract RefundEscrow is ConditionalEscrow {\r\n    enum State { Active, Refunding, Closed }\r\n\r\n    event RefundsClosed();\r\n    event RefundsEnabled();\r\n\r\n    State private _state;\r\n    address payable private _beneficiary;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param beneficiary The beneficiary of the deposits.\r\n     */\r\n    constructor (address payable beneficiary) public {\r\n        require(beneficiary != address(0));\r\n        _beneficiary = beneficiary;\r\n        _state = State.Active;\r\n    }\r\n\r\n    /**\r\n     * @return the current state of the escrow.\r\n     */\r\n    function state() public view returns (State) {\r\n        return _state;\r\n    }\r\n\r\n    /**\r\n     * @return the beneficiary of the escrow.\r\n     */\r\n    function beneficiary() public view returns (address) {\r\n        return _beneficiary;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores funds that may later be refunded.\r\n     * @param refundee The address funds will be sent to if a refund occurs.\r\n     */\r\n    function deposit(address refundee) public payable {\r\n        require(_state == State.Active);\r\n        super.deposit(refundee);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows for the beneficiary to withdraw their funds, rejecting\r\n     * further deposits.\r\n     */\r\n    function close() public onlyPrimary {\r\n        require(_state == State.Active);\r\n        _state = State.Closed;\r\n        emit RefundsClosed();\r\n    }\r\n\r\n    /**\r\n     * @dev Allows for refunds to take place, rejecting further deposits.\r\n     */\r\n    function enableRefunds() public onlyPrimary {\r\n        require(_state == State.Active);\r\n        _state = State.Refunding;\r\n        emit RefundsEnabled();\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws the beneficiary's funds.\r\n     */\r\n    function beneficiaryWithdraw() public {\r\n        require(_state == State.Closed);\r\n        _beneficiary.transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether refundees can withdraw their deposits (be refunded). The overridden function receives a\r\n     * 'payee' argument, but we ignore it here since the condition is global, not per-payee.\r\n     */\r\n    function withdrawalAllowed(address) public view returns (bool) {\r\n        return _state == State.Refunding;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"transferPrimary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawalAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableRefunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"beneficiaryWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"primary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"depositsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"refundee\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RefundsClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RefundsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"PrimaryTransferred\",\"type\":\"event\"}]","ContractName":"RefundEscrow","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008038aca215a031a673f4e7d9d7c20e623e006c8f","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://615e768d905ff0924bec1356ff152de492ea39e28c4f3800cdea644f03feb69f"}]}