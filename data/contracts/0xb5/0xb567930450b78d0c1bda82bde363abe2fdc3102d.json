{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n/**\r\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\r\n *\r\n * This source code is licensed under the Mozilla Public License, version 2,\r\n * found in the LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n/**\r\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\r\n *\r\n * This source code is licensed under the Mozilla Public License, version 2,\r\n * found in the LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool wasInitializing = initializing;\r\n    initializing = true;\r\n    initialized = true;\r\n\r\n    _;\r\n\r\n    initializing = wasInitializing;\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n/**\r\n * @title Adminable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Adminable is Initializable {\r\n\r\n  /**\r\n   * @dev Storage slot with the admin of the contract.\r\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.admin\", and is\r\n   * validated in the constructor.\r\n   */\r\n  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\r\n\r\n  /**\r\n   * @dev Modifier to check whether the `msg.sender` is the admin.\r\n   * If it is, it will run the function. Otherwise, fails.\r\n   */\r\n  modifier ifAdmin() {\r\n    require(msg.sender == _admin());\r\n    _;\r\n  }\r\n\r\n  function admin() external view returns (address) {\r\n    return _admin();\r\n  }\r\n\r\n  function implementation() external view returns (address impl) {\r\n    bytes32 slot = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\r\n    assembly {\r\n      impl := sload(slot)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return The admin slot.\r\n   */\r\n  function _admin() internal view returns (address adm) {\r\n    bytes32 slot = ADMIN_SLOT;\r\n    assembly {\r\n      adm := sload(slot)\r\n    }\r\n  }\r\n}\r\n\r\ncontract Bridge is Adminable {\r\n  using SafeMath for uint256;\r\n\r\n  modifier onlyOperator() {\r\n    require(msg.sender == operator, \"Tried to call a only-operator function from non-operator\");\r\n    _;\r\n  }\r\n\r\n  event NewHeight(uint256 height, bytes32 indexed root);\r\n  event NewOperator(address operator);\r\n\r\n  struct Period {\r\n    uint32 height;            // the height of last block in period\r\n    uint32 timestamp;         // the block.timestamp at submission of period\r\n    uint32 parentBlockNumber; // the block.number at submission of period\r\n    bytes32 parentBlockHash;  // the blockhash(block.number -1) at submission of period\r\n  }\r\n\r\n  bytes32 constant GENESIS = 0x4920616d207665727920616e6772792c20627574206974207761732066756e21;\r\n\r\n  bytes32 public tipHash; // hash of first period that has extended chain to some height\r\n  uint256 public genesisBlockNumber;\r\n  uint256 parentBlockInterval; // how often epochs can be submitted max\r\n  uint256 public lastParentBlock; // last ethereum block when epoch was submitted\r\n  address public operator; // the operator contract\r\n\r\n  mapping(bytes32 => Period) public periods;\r\n\r\n  function initialize(uint256 _parentBlockInterval) public initializer {\r\n    // init genesis preiod\r\n    Period memory genesisPeriod = Period({\r\n      height: 1,\r\n      timestamp: uint32(block.timestamp),\r\n      parentBlockNumber: uint32(block.number),\r\n      parentBlockHash: blockhash(block.number-1)\r\n    });\r\n    tipHash = GENESIS;\r\n    periods[GENESIS] = genesisPeriod;\r\n    genesisBlockNumber = block.number;\r\n    parentBlockInterval = _parentBlockInterval;\r\n    operator = msg.sender;\r\n  }\r\n\r\n  function setOperator(address _operator) public ifAdmin {\r\n    operator = _operator;\r\n    emit NewOperator(_operator);\r\n  }\r\n\r\n  function getParentBlockInterval() public view returns (uint256) {\r\n    return parentBlockInterval;\r\n  }\r\n\r\n  function setParentBlockInterval(uint256 _parentBlockInterval) public ifAdmin {\r\n    parentBlockInterval = _parentBlockInterval;\r\n  }\r\n\r\n  function submitPeriod(\r\n    bytes32 _prevHash,\r\n    bytes32 _root)\r\n  public onlyOperator returns (uint256 newHeight) {\r\n\r\n    require(periods[_prevHash].timestamp > 0, \"Parent node should exist\");\r\n    require(periods[_root].timestamp == 0, \"Trying to submit the same root twice\");\r\n\r\n    // calculate height\r\n    newHeight = periods[_prevHash].height + 1;\r\n    // do some magic if chain extended\r\n    if (newHeight > periods[tipHash].height) {\r\n      // new periods can only be submitted every x Ethereum blocks\r\n      require(\r\n        block.number >= lastParentBlock + parentBlockInterval,\r\n        \"Tried to submit new period too soon\"\r\n      );\r\n      tipHash = _root;\r\n      lastParentBlock = block.number;\r\n    }\r\n    // strictly speaking this event should be called \"New Period\"\r\n    // but we don't want to break interfaces for now.\r\n    emit NewHeight(newHeight, _root);\r\n    // store the period\r\n    Period memory newPeriod = Period({\r\n      height: uint32(newHeight),\r\n      timestamp: uint32(block.timestamp),\r\n      parentBlockNumber: uint32(block.number),\r\n      parentBlockHash: blockhash(block.number-1)\r\n    });\r\n    periods[_root] = newPeriod;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"genesisBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastParentBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_prevHash\",\"type\":\"bytes32\"},{\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"submitPeriod\",\"outputs\":[{\"name\":\"newHeight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"impl\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_parentBlockInterval\",\"type\":\"uint256\"}],\"name\":\"setParentBlockInterval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParentBlockInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"periods\",\"outputs\":[{\"name\":\"height\",\"type\":\"uint32\"},{\"name\":\"timestamp\",\"type\":\"uint32\"},{\"name\":\"parentBlockNumber\",\"type\":\"uint32\"},{\"name\":\"parentBlockHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tipHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_parentBlockInterval\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"height\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"NewHeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"NewOperator\",\"type\":\"event\"}]","ContractName":"Bridge","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MPL-2.0","SwarmSource":"bzzr://cdd70ef5c58c479a0a2da3d6d859f69b21ddc11e0ca5b9a0bb91479d82ea017d"}]}