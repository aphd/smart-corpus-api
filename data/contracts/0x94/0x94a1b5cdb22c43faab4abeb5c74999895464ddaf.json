{"status":"1","message":"OK","result":[{"SourceCode":"// https://tornado.cash\r\n/*\r\n* d888888P                                           dP              a88888b.                   dP\r\n*    88                                              88             d8'   `88                   88\r\n*    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\r\n*    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\r\n*    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\r\n*    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\r\n* ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\r\n*/\r\n\r\n// File: contracts/MerkleTreeWithHistory.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\nlibrary MiMC {\r\n  function MiMCSponge(uint256 in_xL, uint256 in_xR, uint256 in_k) public pure returns (uint256 xL, uint256 xR);\r\n}\r\n\r\ncontract MerkleTreeWithHistory {\r\n  uint256 public levels;\r\n\r\n  uint8 constant ROOT_HISTORY_SIZE = 100;\r\n  uint256[] private _roots;\r\n  uint256 public current_root = 0;\r\n\r\n  uint256[] private _filled_subtrees;\r\n  uint256[] private _zeros;\r\n\r\n  uint32 public next_index = 0;\r\n\r\n  constructor(uint256 tree_levels, uint256 zero_value) public {\r\n    levels = tree_levels;\r\n\r\n    _zeros.push(zero_value);\r\n    _filled_subtrees.push(_zeros[0]);\r\n\r\n    for (uint8 i = 1; i < levels; i++) {\r\n      _zeros.push(hashLeftRight(_zeros[i-1], _zeros[i-1]));\r\n      _filled_subtrees.push(_zeros[i]);\r\n    }\r\n\r\n    _roots = new uint256[](ROOT_HISTORY_SIZE);\r\n    _roots[0] = hashLeftRight(_zeros[levels - 1], _zeros[levels - 1]);\r\n  }\r\n\r\n  function hashLeftRight(uint256 left, uint256 right) public pure returns (uint256 mimc_hash) {\r\n    uint256 k = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    uint256 R = 0;\r\n    uint256 C = 0;\r\n\r\n    R = addmod(R, left, k);\r\n    (R, C) = MiMC.MiMCSponge(R, C, 0);\r\n\r\n    R = addmod(R, right, k);\r\n    (R, C) = MiMC.MiMCSponge(R, C, 0);\r\n\r\n    mimc_hash = R;\r\n  }\r\n\r\n  function _insert(uint256 leaf) internal {\r\n    uint32 current_index = next_index;\r\n    require(current_index != 2**(levels - 1), \"Merkle tree is full\");\r\n    next_index += 1;\r\n    uint256 current_level_hash = leaf;\r\n    uint256 left;\r\n    uint256 right;\r\n\r\n    for (uint256 i = 0; i < levels; i++) {\r\n      if (current_index % 2 == 0) {\r\n        left = current_level_hash;\r\n        right = _zeros[i];\r\n\r\n        _filled_subtrees[i] = current_level_hash;\r\n      } else {\r\n        left = _filled_subtrees[i];\r\n        right = current_level_hash;\r\n      }\r\n\r\n      current_level_hash = hashLeftRight(left, right);\r\n\r\n      current_index /= 2;\r\n    }\r\n\r\n    current_root = (current_root + 1) % ROOT_HISTORY_SIZE;\r\n    _roots[current_root] = current_level_hash;\r\n  }\r\n\r\n  function isKnownRoot(uint256 root) public view returns(bool) {\r\n    if (root == 0) {\r\n      return false;\r\n    }\r\n    // search most recent first\r\n    uint256 i;\r\n    for(i = current_root; i < 2**256 - 1; i--) {\r\n      if (root == _roots[i]) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // process the rest of roots\r\n    for(i = ROOT_HISTORY_SIZE - 1; i > current_root; i--) {\r\n      if (root == _roots[i]) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n\r\n    // or we can do that in other way\r\n    //   uint256 i = _current_root;\r\n    //   do {\r\n    //       if (root == _roots[i]) {\r\n    //           return true;\r\n    //       }\r\n    //       if (i == 0) {\r\n    //           i = ROOT_HISTORY_SIZE;\r\n    //       }\r\n    //       i--;\r\n    //   } while (i != _current_root);\r\n  }\r\n\r\n  function getLastRoot() public view returns(uint256) {\r\n    return _roots[current_root];\r\n  }\r\n\r\n  function roots() public view returns(uint256[] memory) {\r\n    return _roots;\r\n  }\r\n\r\n  function filled_subtrees() public view returns(uint256[] memory) {\r\n    return _filled_subtrees;\r\n  }\r\n\r\n  function zeros() public view returns(uint256[] memory) {\r\n    return _zeros;\r\n  }\r\n}\r\n\r\n// File: contracts/Mixer.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ncontract IVerifier {\r\n  function verifyProof(uint256[2] memory a, uint256[2][2] memory b, uint256[2] memory c, uint256[4] memory input) public returns(bool);\r\n}\r\n\r\ncontract Mixer is MerkleTreeWithHistory {\r\n  uint256 public transferValue;\r\n  bool public isDepositsEnabled = true;\r\n  // operator can disable new deposits in case of emergency\r\n  // it also receives a relayer fee\r\n  address payable public operator;\r\n  mapping(uint256 => bool) public nullifierHashes;\r\n  // we store all commitments just to prevent accidental deposits with the same commitment\r\n  mapping(uint256 => bool) public commitments;\r\n  IVerifier verifier;\r\n\r\n  event Deposit(uint256 indexed commitment, uint256 leafIndex, uint256 timestamp);\r\n  event Withdraw(address to, uint256 nullifierHash, uint256 fee);\r\n\r\n  /**\r\n    @dev The constructor\r\n    @param _verifier the address of SNARK verifier for this contract\r\n    @param _transferValue the value for all deposits in this contract in wei\r\n  */\r\n  constructor(\r\n    address _verifier,\r\n    uint256 _transferValue,\r\n    uint8 _merkleTreeHeight,\r\n    uint256 _emptyElement,\r\n    address payable _operator\r\n  ) MerkleTreeWithHistory(_merkleTreeHeight, _emptyElement) public {\r\n    verifier = IVerifier(_verifier);\r\n    transferValue = _transferValue;\r\n    operator = _operator;\r\n  }\r\n\r\n  /**\r\n    @dev Deposit funds into mixer. The caller must send value equal to `transferValue` of this mixer.\r\n    @param commitment the note commitment, which is PedersenHash(nullifier + secret)\r\n  */\r\n  function deposit(uint256 commitment) public payable {\r\n    require(isDepositsEnabled, \"deposits disabled\");\r\n    require(msg.value == transferValue, \"Please send `transferValue` ETH along with transaction\");\r\n    require(!commitments[commitment], \"The commitment has been submitted\");\r\n    _insert(commitment);\r\n    commitments[commitment] = true;\r\n    emit Deposit(commitment, next_index - 1, block.timestamp);\r\n  }\r\n\r\n  /**\r\n    @dev Withdraw deposit from the mixer. `a`, `b`, and `c` are zkSNARK proof data, and input is an array of circuit public inputs\r\n    `input` array consists of:\r\n      - merkle root of all deposits in the mixer\r\n      - hash of unique deposit nullifier to prevent double spends\r\n      - the receiver of funds\r\n      - optional fee that goes to the transaction sender (usually a relay)\r\n  */\r\n  function withdraw(uint256[2] memory a, uint256[2][2] memory b, uint256[2] memory c, uint256[4] memory input) public {\r\n    uint256 root = input[0];\r\n    uint256 nullifierHash = input[1];\r\n    address payable receiver = address(input[2]);\r\n    uint256 fee = input[3];\r\n\r\n    require(!nullifierHashes[nullifierHash], \"The note has been already spent\");\r\n    require(fee < transferValue, \"Fee exceeds transfer value\");\r\n    require(isKnownRoot(root), \"Cannot find your merkle root\"); // Make sure to use a recent one\r\n    require(verifier.verifyProof(a, b, c, input), \"Invalid withdraw proof\");\r\n\r\n    nullifierHashes[nullifierHash] = true;\r\n    receiver.transfer(transferValue - fee);\r\n    if (fee > 0) {\r\n      operator.transfer(fee);\r\n    }\r\n    emit Withdraw(receiver, nullifierHash, fee);\r\n  }\r\n\r\n  function toggleDeposits() external {\r\n    require(msg.sender == operator, \"unauthorized\");\r\n    isDepositsEnabled = !isDepositsEnabled;\r\n  }\r\n\r\n  function changeOperator(address payable _newAccount) external {\r\n    require(msg.sender == operator, \"unauthorized\");\r\n    operator = _newAccount;\r\n  }\r\n\r\n  function isSpent(uint256 nullifier) public view returns(bool) {\r\n    return nullifierHashes[nullifier];\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAccount\",\"type\":\"address\"}],\"name\":\"changeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"filled_subtrees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nullifierHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commitments\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zeros\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levels\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256[2]\"},{\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"name\":\"c\",\"type\":\"uint256[2]\"},{\"name\":\"input\",\"type\":\"uint256[4]\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDepositsEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nullifier\",\"type\":\"uint256\"}],\"name\":\"isSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"left\",\"type\":\"uint256\"},{\"name\":\"right\",\"type\":\"uint256\"}],\"name\":\"hashLeftRight\",\"outputs\":[{\"name\":\"mimc_hash\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"next_index\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"current_root\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"root\",\"type\":\"uint256\"}],\"name\":\"isKnownRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commitment\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleDeposits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_verifier\",\"type\":\"address\"},{\"name\":\"_transferValue\",\"type\":\"uint256\"},{\"name\":\"_merkleTreeHeight\",\"type\":\"uint8\"},{\"name\":\"_emptyElement\",\"type\":\"uint256\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"commitment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"leafIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nullifierHash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"Mixer","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002c031def2175f4f5aabda87b169bac91a44a2048000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000010000000000000000000000008589427373d6d84e98730d7795d8f6f8731fda16","Library":"MiMC:100341623d0e9e3cd5be19e8db7c53709812a873","LicenseType":"MIT","SwarmSource":"bzzr://305dc7e1aa034e649ccab81c9e67331ad48ac3b809cc078de5f3c060d281b509"}]}