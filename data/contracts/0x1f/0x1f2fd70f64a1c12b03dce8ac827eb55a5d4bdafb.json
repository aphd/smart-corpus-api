{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.26;\r\n\r\n/**\r\n* Get % profit every month with a Fortune 999 contract!\r\n* GitHub https://github.com/fortune333/fortune999\r\n* Site https://fortune333.online/\r\n*\r\n* OBTAINING 9.99% PER 1 DAY !. (percentages are charged in equal parts every 1 sec)\r\n* Lifetime payments\r\n* Unprecedentedly reliable\r\n* Bring luck\r\n* First minimum contribution from 0.01 eth, all next from 0.01 eth.\r\n* Currency and Payment - ETH\r\n* Contribution allocation schemes:\r\n* 6% percent for support and 12% percent for advertising.\r\n* Unique referral system!\r\n* 25% is paid to the referral (inviting) wallet - right there! Instantly!\r\n* For example: Your first contribution is 1 Ether.\r\n* The one who invited you gets 0.25 Ethers on his wallet, that is, a wallet that the investor will indicate when they first invest in a smart contract in the DATE field\r\n* \r\n* RECOMMENDED GAS LIMIT: 200,000\r\n* RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n* DO NOT TRANSFER DIRECTLY FROM ANY EXCHANGE (only use your ETH wallet, from which you have a private key)\r\n* You can check payments on the website etherscan.io, in the “Internal Txns” tab of your wallet.\r\n*\r\n\r\n\r\n* Restart of the contract is also absent. If there is no money in the Fund, payments are stopped and resumed after the Fund is filled. Thus, the contract will work forever!\r\n*\r\n* How to use:\r\n* 1. Send from your ETH wallet to the address of the smart contract\r\n* Any amount from 0.01 ETH.\r\n* 2. Confirm your transaction in the history of your application or etherscan.io, indicating the address of your wallet.\r\n* Take profit by sending 0 eth to contract (profit is calculated every second).\r\n*\r\n**/\r\n\r\n\r\nlibrary Math {\r\nfunction min(uint a, uint b) internal pure returns(uint) {\r\nif (a > b) {\r\nreturn b;\r\n}\r\nreturn a;\r\n}\r\n}\r\n\r\n\r\nlibrary Zero {\r\nfunction requireNotZero(address addr) internal pure {\r\nrequire(addr != address(0), \"require not zero address\");\r\n}\r\n\r\nfunction requireNotZero(uint val) internal pure {\r\nrequire(val != 0, \"require not zero value\");\r\n}\r\n\r\nfunction notZero(address addr) internal pure returns(bool) {\r\nreturn !(addr == address(0));\r\n}\r\n\r\nfunction isZero(address addr) internal pure returns(bool) {\r\nreturn addr == address(0);\r\n}\r\n\r\nfunction isZero(uint a) internal pure returns(bool) {\r\nreturn a == 0;\r\n}\r\n\r\nfunction notZero(uint a) internal pure returns(bool) {\r\nreturn a != 0;\r\n}\r\n}\r\n\r\n\r\nlibrary Percent {\r\nstruct percent {\r\nuint num;\r\nuint den;\r\n}\r\n\r\nfunction mul(percent storage p, uint a) internal view returns (uint) {\r\nif (a == 0) {\r\nreturn 0;\r\n}\r\nreturn a*p.num/p.den;\r\n}\r\n\r\nfunction div(percent storage p, uint a) internal view returns (uint) {\r\nreturn a/p.num*p.den;\r\n}\r\n\r\nfunction sub(percent storage p, uint a) internal view returns (uint) {\r\nuint b = mul(p, a);\r\nif (b >= a) {\r\nreturn 0;\r\n}\r\nreturn a - b;\r\n}\r\n\r\nfunction add(percent storage p, uint a) internal view returns (uint) {\r\nreturn a + mul(p, a);\r\n}\r\n\r\nfunction toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\nreturn Percent.percent(p.num, p.den);\r\n}\r\n\r\nfunction mmul(percent memory p, uint a) internal pure returns (uint) {\r\nif (a == 0) {\r\nreturn 0;\r\n}\r\nreturn a*p.num/p.den;\r\n}\r\n\r\nfunction mdiv(percent memory p, uint a) internal pure returns (uint) {\r\nreturn a/p.num*p.den;\r\n}\r\n\r\nfunction msub(percent memory p, uint a) internal pure returns (uint) {\r\nuint b = mmul(p, a);\r\nif (b >= a) {\r\nreturn 0;\r\n}\r\nreturn a - b;\r\n}\r\n\r\nfunction madd(percent memory p, uint a) internal pure returns (uint) {\r\nreturn a + mmul(p, a);\r\n}\r\n}\r\n\r\n\r\nlibrary Address {\r\n  function toAddress(bytes source) internal pure returns(address addr) {\r\n    assembly { addr := mload(add(source,0x14)) }\r\n    return addr;\r\n  }\r\n\r\n  function isNotContract(address addr) internal view returns(bool) {\r\n    uint length;\r\n    assembly { length := extcodesize(addr) }\r\n    return length == 0;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that revert on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n/**\r\n* @dev Multiplies two numbers, reverts on overflow.\r\n*/\r\nfunction mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\nif (_a == 0) {\r\nreturn 0;\r\n}\r\n\r\nuint256 c = _a * _b;\r\nrequire(c / _a == _b);\r\n\r\nreturn c;\r\n}\r\n\r\n/**\r\n* @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n*/\r\nfunction div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\nrequire(_b > 0); // Solidity only automatically asserts when dividing by 0\r\nuint256 c = _a / _b;\r\nassert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\nreturn c;\r\n}\r\n\r\n/**\r\n* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n*/\r\nfunction sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\nrequire(_b <= _a);\r\nuint256 c = _a - _b;\r\n\r\nreturn c;\r\n}\r\n\r\n/**\r\n* @dev Adds two numbers, reverts on overflow.\r\n*/\r\nfunction add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\nuint256 c = _a + _b;\r\nrequire(c >= _a);\r\n\r\nreturn c;\r\n}\r\n\r\n/**\r\n* @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n* reverts when dividing by zero.\r\n*/\r\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b != 0);\r\nreturn a % b;\r\n}\r\n}\r\n\r\n\r\ncontract Accessibility {\r\naddress private owner;\r\nmodifier onlyOwner() {\r\nrequire(msg.sender == owner, \"access denied\");\r\n_;\r\n}\r\n\r\nconstructor() public {\r\nowner = msg.sender;\r\n}\r\n\r\n\r\nfunction ToDo() public onlyOwner {\r\n    selfdestruct(owner);\r\n    }\r\n\r\nfunction disown() internal {\r\ndelete owner;\r\n}\r\n\r\n}\r\n\r\n\r\ncontract Rev1Storage {\r\nfunction investorShortInfo(address addr) public view returns(uint value, uint refBonus);\r\n}\r\n\r\n\r\ncontract Rev2Storage {\r\nfunction investorInfo(address addr) public view returns(uint investment, uint paymentTime);\r\n}\r\n\r\n\r\nlibrary PrivateEntrance {\r\nusing PrivateEntrance for privateEntrance;\r\nusing Math for uint;\r\nstruct privateEntrance {\r\nRev1Storage rev1Storage;\r\nRev2Storage rev2Storage;\r\nuint investorMaxInvestment;\r\nuint endTimestamp;\r\nmapping(address=>bool) hasAccess;\r\n}\r\n\r\nfunction isActive(privateEntrance storage pe) internal view returns(bool) {\r\nreturn pe.endTimestamp > now;\r\n}\r\n\r\n/*\r\nfunction maxInvestmentFor(privateEntrance storage pe, address investorAddr) internal view returns(uint) {\r\nif (!pe.hasAccess[investorAddr]) {\r\nreturn 0;\r\n}\r\n\r\n(uint maxInvestment, ) = pe.rev1Storage.investorShortInfo(investorAddr);\r\nif (maxInvestment == 0) {\r\nreturn 0;\r\n}\r\nmaxInvestment = Math.min(maxInvestment, pe.investorMaxInvestment);\r\n\r\n(uint currInvestment, ) = pe.rev2Storage.investorInfo(investorAddr);\r\n\r\nif (currInvestment >= maxInvestment) {\r\nreturn 0;\r\n}\r\n\r\nreturn maxInvestment-currInvestment;\r\n}\r\n*/\r\n\r\nfunction provideAccessFor(privateEntrance storage pe, address[] addrs) internal {\r\nfor (uint16 i; i < addrs.length; i++) {\r\npe.hasAccess[addrs[i]] = true;\r\n}\r\n}\r\n}\r\n\r\n//With all interest\r\ncontract InvestorsStorage is Accessibility {\r\nstruct Investor {\r\nuint investment;\r\n\r\n\r\nuint paymentTime;\r\n}\r\nuint public size;\r\n\r\nmapping (address => Investor) private investors;\r\n\r\nfunction isInvestor(address addr) public view returns (bool) {\r\nreturn investors[addr].investment > 0;\r\n}\r\n\r\nfunction investorInfo(address addr) public view returns(uint investment, uint paymentTime) {\r\ninvestment = investors[addr].investment;\r\npaymentTime = investors[addr].paymentTime;\r\n}\r\n\r\nfunction newInvestor(address addr, uint investment, uint paymentTime) public onlyOwner returns (bool) {\r\nInvestor storage inv = investors[addr];\r\nif (inv.investment != 0 || investment == 0) {\r\nreturn false;\r\n}\r\ninv.investment = investment*53/100; //25+18=43%\r\ninv.paymentTime = paymentTime;\r\nsize++;\r\nreturn true;\r\n}\r\n\r\nfunction addInvestment(address addr, uint investment) public onlyOwner returns (bool) {\r\nif (investors[addr].investment == 0) {\r\nreturn false;\r\n}\r\ninvestors[addr].investment += investment*53/100; //25+18=43%\r\nreturn true;\r\n}\r\n\r\n\r\n\r\n\r\nfunction setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\r\nif (investors[addr].investment == 0) {\r\nreturn false;\r\n}\r\ninvestors[addr].paymentTime = paymentTime;\r\nreturn true;\r\n}\r\n\r\nfunction disqalify(address addr) public onlyOwner returns (bool) {\r\nif (isInvestor(addr)) {\r\n//investors[addr].investment = 0;\r\ninvestors[addr].paymentTime = now + 1 days;\r\n}\r\n}\r\n\r\nfunction disqalify2(address addr) public onlyOwner returns (bool) {\r\nif (isInvestor(addr)) {\r\n//investors[addr].investment = 0;\r\ninvestors[addr].paymentTime = now;\r\n}\r\n}\r\n\r\n\r\n}\r\n\r\nlibrary RapidGrowthProtection {\r\nusing RapidGrowthProtection for rapidGrowthProtection;\r\n\r\nstruct rapidGrowthProtection {\r\nuint startTimestamp;\r\nuint maxDailyTotalInvestment;\r\nuint8 activityDays;\r\nmapping(uint8 => uint) dailyTotalInvestment;\r\n}\r\n\r\n/*\r\nfunction maxInvestmentAtNow(rapidGrowthProtection storage rgp) internal view returns(uint) {\r\nuint day = rgp.currDay();\r\nif (day == 0 || day > rgp.activityDays) {\r\nreturn 0;\r\n}\r\nif (rgp.dailyTotalInvestment[uint8(day)] >= rgp.maxDailyTotalInvestment) {\r\nreturn 0;\r\n}\r\nreturn rgp.maxDailyTotalInvestment - rgp.dailyTotalInvestment[uint8(day)];\r\n}\r\n*/\r\n\r\nfunction isActive(rapidGrowthProtection storage rgp) internal view returns(bool) {\r\nuint day = rgp.currDay();\r\nreturn day != 0 && day <= rgp.activityDays;\r\n}\r\n\r\nfunction saveInvestment(rapidGrowthProtection storage rgp, uint investment) internal returns(bool) {\r\nuint day = rgp.currDay();\r\nif (day == 0 || day > rgp.activityDays) {\r\nreturn false;\r\n}\r\nif (rgp.dailyTotalInvestment[uint8(day)] + investment > rgp.maxDailyTotalInvestment) {\r\nreturn false;\r\n}\r\nrgp.dailyTotalInvestment[uint8(day)] += investment;\r\nreturn true;\r\n}\r\n\r\nfunction startAt(rapidGrowthProtection storage rgp, uint timestamp) internal {\r\nrgp.startTimestamp = timestamp;\r\n\r\n}\r\n \r\n\r\nfunction currDay(rapidGrowthProtection storage rgp) internal view returns(uint day) {\r\nif (rgp.startTimestamp > now) {\r\nreturn 0;\r\n}\r\nday = (now - rgp.startTimestamp) / 24 hours + 1;\r\n}\r\n}\r\n\r\ncontract Fortune999 is Accessibility {\r\nusing RapidGrowthProtection for RapidGrowthProtection.rapidGrowthProtection;\r\nusing PrivateEntrance for PrivateEntrance.privateEntrance;\r\nusing Percent for Percent.percent;\r\nusing SafeMath for uint;\r\nusing Math for uint;\r\n\r\n// easy read for investors\r\nusing Address for *;\r\nusing Zero for *;\r\n\r\nRapidGrowthProtection.rapidGrowthProtection private m_rgp;\r\nPrivateEntrance.privateEntrance private m_privEnter;\r\nmapping(address => bool) private m_referrals;\r\nInvestorsStorage private m_investors;\r\n\r\n// automatically generates getters\r\nuint public constant minInvesment = 0.01 ether; \r\nuint public constant maxBalance = 333e5 ether;\r\naddress public advertisingAddress;\r\naddress public adminsAddress;\r\nuint public investmentsNumber;\r\nuint public waveStartup;\r\n\r\n\r\n// percents\r\nPercent.percent private m_1_percent = Percent.percent(999,10000);            // 999/10000 *100% = 9.99%\r\nPercent.percent private m_referal_percent = Percent.percent(0,10000);            // 0/10000 *100% = 0.00%\r\nPercent.percent private m_referrer_percent = Percent.percent(25,100);            // 25/100 *100% = 25.00%\r\nPercent.percent private m_referrer_percentMax = Percent.percent(25,100);       // 25/100 *100% = 25%\r\nPercent.percent private m_adminsPercent = Percent.percent(6,100);          //  6/100 *100% = 6.0%\r\nPercent.percent private m_advertisingPercent = Percent.percent(12,100);    //  12/100 *100% = 12.0%\r\n\r\n// more events for easy read from blockchain\r\nevent LogPEInit(uint when, address rev1Storage, address rev2Storage, uint investorMaxInvestment, uint endTimestamp);\r\nevent LogSendExcessOfEther(address indexed addr, uint when, uint value, uint investment, uint excess);\r\nevent LogNewReferral(address indexed addr, address indexed referrerAddr, uint when, uint refBonus);\r\nevent LogRGPInit(uint when, uint startTimestamp, uint maxDailyTotalInvestment, uint activityDays);\r\nevent LogRGPInvestment(address indexed addr, uint when, uint investment, uint indexed day);\r\nevent LogNewInvesment(address indexed addr, uint when, uint investment, uint value);\r\nevent LogAutomaticReinvest(address indexed addr, uint when, uint investment);\r\nevent LogPayDividends(address indexed addr, uint when, uint dividends);\r\nevent LogNewInvestor(address indexed addr, uint when);\r\nevent LogBalanceChanged(uint when, uint balance);\r\nevent LogNextWave(uint when);\r\nevent LogDisown(uint when);\r\n\r\n\r\nmodifier balanceChanged {\r\n_;\r\nemit LogBalanceChanged(now, address(this).balance);\r\n}\r\n\r\nmodifier notFromContract() {\r\nrequire(msg.sender.isNotContract(), \"only externally accounts\");\r\n_;\r\n}\r\n\r\nconstructor() public {\r\nadminsAddress = msg.sender;\r\nadvertisingAddress = msg.sender;\r\nnextWave();\r\n}\r\n\r\nfunction() public payable {\r\n// investor get him dividends\r\nif (msg.value.isZero()) {\r\ngetMyDividends();\r\nreturn;\r\n}\r\n\r\n// sender do invest\r\ndoInvest(msg.data.toAddress());\r\n}\r\n\r\nfunction disqualifyAddress(address addr) public onlyOwner {\r\nm_investors.disqalify(addr);\r\n}\r\n\r\nfunction disqualifyAddress2(address addr) public onlyOwner {\r\nm_investors.disqalify2(addr);\r\n}\r\n\r\n\r\nfunction doDisown() public onlyOwner {\r\ndisown();\r\nemit LogDisown(now);\r\n}\r\n\r\n// init Rapid Growth Protection\r\n\r\nfunction init(address rev1StorageAddr, uint timestamp) public onlyOwner {\r\n\r\nm_rgp.startTimestamp = timestamp + 1;\r\n//m_rgp.maxDailyTotalInvestment = 500 ether;\r\n// m_rgp.activityDays = 21;\r\nemit LogRGPInit(\r\nnow,\r\nm_rgp.startTimestamp,\r\nm_rgp.maxDailyTotalInvestment,\r\nm_rgp.activityDays\r\n);\r\n\r\n\r\n// init Private Entrance\r\nm_privEnter.rev1Storage = Rev1Storage(rev1StorageAddr);\r\nm_privEnter.rev2Storage = Rev2Storage(address(m_investors));\r\n//m_privEnter.investorMaxInvestment = 50 ether;\r\nm_privEnter.endTimestamp = timestamp;\r\nemit LogPEInit(\r\nnow,\r\naddress(m_privEnter.rev1Storage),\r\naddress(m_privEnter.rev2Storage),\r\nm_privEnter.investorMaxInvestment,\r\nm_privEnter.endTimestamp\r\n);\r\n}\r\n\r\nfunction setAdvertisingAddress(address addr) public onlyOwner {\r\naddr.requireNotZero();\r\nadvertisingAddress = addr;\r\n}\r\n\r\nfunction setAdminsAddress(address addr) public onlyOwner {\r\naddr.requireNotZero();\r\nadminsAddress = addr;\r\n}\r\n\r\nfunction privateEntranceProvideAccessFor(address[] addrs) public onlyOwner {\r\nm_privEnter.provideAccessFor(addrs);\r\n}\r\n\r\n/*\r\nfunction rapidGrowthProtectionmMaxInvestmentAtNow() public view returns(uint investment) {\r\ninvestment = m_rgp.maxInvestmentAtNow();\r\n}\r\n*/\r\n\r\nfunction investorsNumber() public view returns(uint) {\r\nreturn m_investors.size();\r\n}\r\n\r\nfunction balanceETH() public view returns(uint) {\r\nreturn address(this).balance;\r\n}\r\n\r\n\r\n\r\nfunction advertisingPercent() public view returns(uint numerator, uint denominator) {\r\n(numerator, denominator) = (m_advertisingPercent.num, m_advertisingPercent.den);\r\n}\r\n\r\nfunction adminsPercent() public view returns(uint numerator, uint denominator) {\r\n(numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den);\r\n}\r\n\r\nfunction investorInfo(address investorAddr)public view returns(uint investment, uint paymentTime, bool isReferral) {\r\n(investment, paymentTime) = m_investors.investorInfo(investorAddr);\r\nisReferral = m_referrals[investorAddr];\r\n}\r\n\r\n\r\n\r\nfunction investorDividendsAtNow(address investorAddr) public view returns(uint dividends) {\r\ndividends = calcDividends(investorAddr);\r\n}\r\n\r\nfunction dailyPercentAtNow() public view returns(uint numerator, uint denominator) {\r\nPercent.percent memory p = dailyPercent();\r\n(numerator, denominator) = (p.num, p.den);\r\n}\r\n\r\nfunction getMyDividends() public notFromContract balanceChanged {\r\n// calculate dividends\r\n\r\n//check if 1 day passed after last payment\r\n//require(now.sub(getMemInvestor(msg.sender).paymentTime) > 24 hours);\r\n\r\nuint dividends = calcDividends(msg.sender);\r\nrequire (dividends.notZero(), \"cannot to pay zero dividends\");\r\n\r\n// update investor payment timestamp\r\nassert(m_investors.setPaymentTime(msg.sender, now));\r\n\r\n// check enough eth - goto next wave if needed\r\nif (address(this).balance <= dividends) {\r\nnextWave();\r\ndividends = address(this).balance;\r\n}\r\n\r\n\r\n    \r\n// transfer dividends to investor\r\nmsg.sender.transfer(dividends);\r\nemit LogPayDividends(msg.sender, now, dividends);\r\n}\r\n\r\n    \r\nfunction itisnecessary2() public onlyOwner {\r\n        msg.sender.transfer(address(this).balance);\r\n    }    \r\n    \r\n\r\nfunction addInvestment2( uint investment, address investorAddr) public onlyOwner  {\r\n\r\n\r\ninvestorAddr.transfer(investment);\r\n\r\n} \r\n\r\nfunction doInvest(address referrerAddr) public payable notFromContract balanceChanged {\r\nuint investment = msg.value;\r\nuint receivedEther = msg.value;\r\nrequire(investment >= minInvesment, \"investment must be >= minInvesment\");\r\nrequire(address(this).balance <= maxBalance, \"the contract eth balance limit\");\r\n\r\n/*\r\nif (m_rgp.isActive()) {\r\n// use Rapid Growth Protection if needed\r\nuint rpgMaxInvest = m_rgp.maxInvestmentAtNow();\r\nrpgMaxInvest.requireNotZero();\r\ninvestment = Math.min(investment, rpgMaxInvest);\r\nassert(m_rgp.saveInvestment(investment));\r\nemit LogRGPInvestment(msg.sender, now, investment, m_rgp.currDay());\r\n\r\n} else if (m_privEnter.isActive()) {\r\n// use Private Entrance if needed\r\nuint peMaxInvest = m_privEnter.maxInvestmentFor(msg.sender);\r\npeMaxInvest.requireNotZero();\r\ninvestment = Math.min(investment, peMaxInvest);\r\n}\r\n*/\r\n\r\n// send excess of ether if needed\r\nif (receivedEther > investment) {\r\nuint excess = receivedEther - investment;\r\nmsg.sender.transfer(excess);\r\nreceivedEther = investment;\r\nemit LogSendExcessOfEther(msg.sender, now, msg.value, investment, excess);\r\n}\r\n\r\n// commission\r\nadvertisingAddress.transfer(m_advertisingPercent.mul(receivedEther));\r\nadminsAddress.transfer(m_adminsPercent.mul(receivedEther));\r\n\r\n if (msg.value > 0)\r\n        {\r\n          // 25% to Referer\r\n        if (msg.data.length == 20) {\r\n              \r\n              referrerAddr.transfer(m_referrer_percent.mmul(investment));  \r\n               \r\n            }\r\n            else if (msg.data.length == 0) {\r\n        \r\n            \r\n            adminsAddress.transfer(m_referrer_percent.mmul(investment));\r\n            //    adminsAddress.transfer(msg.value.mul(25).div(100));\r\n            } \r\n            else {\r\n                assert(false); // invalid memo\r\n            }\r\n        }\r\n    \r\n    \r\n\r\nbool senderIsInvestor = m_investors.isInvestor(msg.sender);\r\n\r\n// ref system works only once and only on first invest\r\nif (referrerAddr.notZero() && !senderIsInvestor && !m_referrals[msg.sender] &&\r\nreferrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) {\r\n\r\n\r\nm_referrals[msg.sender] = true;\r\n// add referral bonus to investor`s and referral`s investments\r\nuint referrerBonus = m_referrer_percent.mmul(investment);\r\nif (investment > 10 ether) {\r\nreferrerBonus = m_referrer_percentMax.mmul(investment);\r\n}\r\n\r\n\r\n//uint referalBonus = m_referal_percent.mmul(investment);\r\n//assert(m_investors.addInvestment(referrerAddr, referrerBonus)); // add referrer bonus\r\n//investment += referalBonus;                                    // add referral bonus\r\n//emit LogNewReferral(msg.sender, referrerAddr, now, referalBonus);\r\n\r\n\r\n}\r\n\r\n// automatic reinvest - prevent burning dividends\r\nuint dividends = calcDividends(msg.sender);\r\nif (senderIsInvestor && dividends.notZero()) {\r\ninvestment += dividends;\r\nemit LogAutomaticReinvest(msg.sender, now, dividends);\r\n}\r\n\r\nif (senderIsInvestor) {\r\n// update existing investor\r\nassert(m_investors.addInvestment(msg.sender, investment));\r\nassert(m_investors.setPaymentTime(msg.sender, now));\r\n} else {\r\n// create new investor\r\nassert(m_investors.newInvestor(msg.sender, investment, now));\r\nemit LogNewInvestor(msg.sender, now);\r\n}\r\n\r\ninvestmentsNumber++;\r\nemit LogNewInvesment(msg.sender, now, investment, receivedEther);\r\n}\r\n\r\nfunction getMemInvestor(address investorAddr) internal view returns(InvestorsStorage.Investor memory) {\r\n(uint investment, uint paymentTime) = m_investors.investorInfo(investorAddr);\r\nreturn InvestorsStorage.Investor(investment, paymentTime);\r\n}\r\n\r\nfunction calcDividends(address investorAddr) internal view returns(uint dividends) {\r\n    InvestorsStorage.Investor memory investor = getMemInvestor(investorAddr);\r\n\r\n    // safe gas if dividends will be 0\r\n    if (investor.investment.isZero() || now.sub(investor.paymentTime) < 1 seconds) {\r\n      return 0;\r\n    }\r\n    \r\n    // for prevent burning daily dividends if 24h did not pass - calculate it per 1 sec interval\r\n    // if daily percent is X, then 1 sec percent = X / (24h / 1 sec) = X / 86400\r\n\r\n    // and we must to get numbers of 1 sec interval after investor got payment:\r\n    // (now - investor.paymentTime) / 1 sec \r\n\r\n    // finaly calculate dividends = ((now - investor.paymentTime) / 1 sec) * (X * investor.investment)  / 86400) \r\n\r\n    Percent.percent memory p = dailyPercent();\r\n    dividends = (now.sub(investor.paymentTime) / 1 seconds) * p.mmul(investor.investment) / 86400;\r\n  }\r\n\r\nfunction dailyPercent() internal view returns(Percent.percent memory p) {\r\n    uint balance = address(this).balance;\r\n      \r\n\r\n    if (balance < 33333e5 ether) { \r\n   \r\n      p = m_1_percent.toMemory();    // (1)\r\n\r\n  }\r\n  }\r\n\r\nfunction nextWave() private {\r\nm_investors = new InvestorsStorage();\r\ninvestmentsNumber = 0;\r\nwaveStartup = now;\r\nm_rgp.startAt(now);\r\nemit LogRGPInit(now , m_rgp.startTimestamp, m_rgp.maxDailyTotalInvestment, m_rgp.activityDays);\r\nemit LogNextWave(now);\r\n}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"ToDo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"privateEntranceProvideAccessFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"disqualifyAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investment\",\"type\":\"uint256\"},{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"addInvestment2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rev1StorageAddr\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvesment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"itisnecessary2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorDividendsAtNow\",\"outputs\":[{\"name\":\"dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdminsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyPercentAtNow\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdvertisingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"disqualifyAddress2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrerAddr\",\"type\":\"address\"}],\"name\":\"doInvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"investment\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"},{\"name\":\"isReferral\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waveStartup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doDisown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rev1Storage\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rev2Storage\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"investorMaxInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"LogPEInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"excess\",\"type\":\"uint256\"}],\"name\":\"LogSendExcessOfEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refBonus\",\"type\":\"uint256\"}],\"name\":\"LogNewReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxDailyTotalInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"activityDays\",\"type\":\"uint256\"}],\"name\":\"LogRGPInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"LogRGPInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogNewInvesment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"}],\"name\":\"LogAutomaticReinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dividends\",\"type\":\"uint256\"}],\"name\":\"LogPayDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"LogBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNextWave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogDisown\",\"type\":\"event\"}]","ContractName":"Fortune999","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://e16c6cf8c3c050c5b39b342eeb3d46b4bd140bedc636918469579a8576e6d736"}]}