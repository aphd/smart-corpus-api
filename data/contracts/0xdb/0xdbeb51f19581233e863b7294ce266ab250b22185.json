{"status":"1","message":"OK","result":[{"SourceCode":"// File: @digix/cacp-contracts-dao/contracts/ACOwned.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n/// @title Owner based access control\r\n/// @author DigixGlobal\r\n\r\ncontract ACOwned {\r\n\r\n  address public owner;\r\n  address public new_owner;\r\n  bool is_ac_owned_init;\r\n\r\n  /// @dev Modifier to check if msg.sender is the contract owner\r\n  modifier if_owner() {\r\n    require(is_owner());\r\n    _;\r\n  }\r\n\r\n  function init_ac_owned()\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (is_ac_owned_init == false) {\r\n      owner = msg.sender;\r\n      is_ac_owned_init = true;\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function is_owner()\r\n           private\r\n           constant\r\n           returns (bool _is_owner)\r\n  {\r\n    _is_owner = (msg.sender == owner);\r\n  }\r\n\r\n  function change_owner(address _new_owner)\r\n           if_owner()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    new_owner = _new_owner;\r\n    _success = true;\r\n  }\r\n\r\n  function claim_ownership()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(msg.sender == new_owner);\r\n    owner = new_owner;\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/Constants.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n/// @title Some useful constants\r\n/// @author DigixGlobal\r\n\r\ncontract Constants {\r\n  address constant NULL_ADDRESS = address(0x0);\r\n  uint256 constant ZERO = uint256(0);\r\n  bytes32 constant EMPTY = bytes32(0x0);\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/ContractResolver.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n/// @title Contract Name Registry\r\n/// @author DigixGlobal\r\n\r\ncontract ContractResolver is ACOwned, Constants {\r\n\r\n  mapping (bytes32 => address) contracts;\r\n  bool public locked_forever;\r\n\r\n  modifier unless_registered(bytes32 _key) {\r\n    require(contracts[_key] == NULL_ADDRESS);\r\n    _;\r\n  }\r\n\r\n  modifier if_owner_origin() {\r\n    require(tx.origin == owner);\r\n    _;\r\n  }\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(msg.sender == get_contract(_contract));\r\n    _;\r\n  }\r\n\r\n  modifier if_not_locked() {\r\n    require(locked_forever == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev ContractResolver constructor will perform the following: 1. Set msg.sender as the contract owner.\r\n  constructor() public\r\n  {\r\n    require(init_ac_owned());\r\n    locked_forever = false;\r\n  }\r\n\r\n  /// @dev Called at contract initialization\r\n  /// @param _key bytestring for CACP name\r\n  /// @param _contract_address The address of the contract to be registered\r\n  /// @return _success if the operation is successful\r\n  function init_register_contract(bytes32 _key, address _contract_address)\r\n           if_owner_origin()\r\n           if_not_locked()\r\n           unless_registered(_key)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(_contract_address != NULL_ADDRESS);\r\n    contracts[_key] = _contract_address;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Lock the resolver from any further modifications.  This can only be called from the owner\r\n  /// @return _success if the operation is successful\r\n  function lock_resolver_forever()\r\n           if_owner\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    locked_forever = true;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Get address of a contract\r\n  /// @param _key the bytestring name of the contract to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           view\r\n           returns (address _contract)\r\n  {\r\n    require(contracts[_key] != NULL_ADDRESS);\r\n    _contract = contracts[_key];\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/ResolverClient.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n/// @title Contract Resolver Interface\r\n/// @author DigixGlobal\r\n\r\ncontract ResolverClient {\r\n\r\n  /// The address of the resolver contract for this project\r\n  address public resolver;\r\n  bytes32 public key;\r\n\r\n  /// Make our own address available to us as a constant\r\n  address public CONTRACT_ADDRESS;\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(sender_is(_contract));\r\n    _;\r\n  }\r\n\r\n  function sender_is(bytes32 _contract) internal view returns (bool _isFrom) {\r\n    _isFrom = msg.sender == ContractResolver(resolver).get_contract(_contract);\r\n  }\r\n\r\n  modifier if_sender_is_from(bytes32[3] _contracts) {\r\n    require(sender_is_from(_contracts));\r\n    _;\r\n  }\r\n\r\n  function sender_is_from(bytes32[3] _contracts) internal view returns (bool _isFrom) {\r\n    uint256 _n = _contracts.length;\r\n    for (uint256 i = 0; i < _n; i++) {\r\n      if (_contracts[i] == bytes32(0x0)) continue;\r\n      if (msg.sender == ContractResolver(resolver).get_contract(_contracts[i])) {\r\n        _isFrom = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// Function modifier to check resolver's locking status.\r\n  modifier unless_resolver_is_locked() {\r\n    require(is_locked() == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev Initialize new contract\r\n  /// @param _key the resolver key for this contract\r\n  /// @return _success if the initialization is successful\r\n  function init(bytes32 _key, address _resolver)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    bool _is_locked = ContractResolver(_resolver).locked_forever();\r\n    if (_is_locked == false) {\r\n      CONTRACT_ADDRESS = address(this);\r\n      resolver = _resolver;\r\n      key = _key;\r\n      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\r\n      _success = true;\r\n    }  else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Check if resolver is locked\r\n  /// @return _locked if the resolver is currently locked\r\n  function is_locked()\r\n           private\r\n           view\r\n           returns (bool _locked)\r\n  {\r\n    _locked = ContractResolver(resolver).locked_forever();\r\n  }\r\n\r\n  /// @dev Get the address of a contract\r\n  /// @param _key the resolver key to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           view\r\n           returns (address _contract)\r\n  {\r\n    _contract = ContractResolver(resolver).get_contract(_key);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/common/DaoConstants.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ncontract DaoConstants {\r\n    using SafeMath for uint256;\r\n    bytes32 EMPTY_BYTES = bytes32(0x0);\r\n    address EMPTY_ADDRESS = address(0x0);\r\n\r\n\r\n    bytes32 PROPOSAL_STATE_PREPROPOSAL = \"proposal_state_preproposal\";\r\n    bytes32 PROPOSAL_STATE_DRAFT = \"proposal_state_draft\";\r\n    bytes32 PROPOSAL_STATE_MODERATED = \"proposal_state_moderated\";\r\n    bytes32 PROPOSAL_STATE_ONGOING = \"proposal_state_ongoing\";\r\n    bytes32 PROPOSAL_STATE_CLOSED = \"proposal_state_closed\";\r\n    bytes32 PROPOSAL_STATE_ARCHIVED = \"proposal_state_archived\";\r\n\r\n    uint256 PRL_ACTION_STOP = 1;\r\n    uint256 PRL_ACTION_PAUSE = 2;\r\n    uint256 PRL_ACTION_UNPAUSE = 3;\r\n\r\n    uint256 COLLATERAL_STATUS_UNLOCKED = 1;\r\n    uint256 COLLATERAL_STATUS_LOCKED = 2;\r\n    uint256 COLLATERAL_STATUS_CLAIMED = 3;\r\n\r\n    bytes32 INTERMEDIATE_DGD_IDENTIFIER = \"inter_dgd_id\";\r\n    bytes32 INTERMEDIATE_MODERATOR_DGD_IDENTIFIER = \"inter_mod_dgd_id\";\r\n    bytes32 INTERMEDIATE_BONUS_CALCULATION_IDENTIFIER = \"inter_bonus_calculation_id\";\r\n\r\n    // interactive contracts\r\n    bytes32 CONTRACT_DAO = \"dao\";\r\n    bytes32 CONTRACT_DAO_SPECIAL_PROPOSAL = \"dao:special:proposal\";\r\n    bytes32 CONTRACT_DAO_STAKE_LOCKING = \"dao:stake-locking\";\r\n    bytes32 CONTRACT_DAO_VOTING = \"dao:voting\";\r\n    bytes32 CONTRACT_DAO_VOTING_CLAIMS = \"dao:voting:claims\";\r\n    bytes32 CONTRACT_DAO_SPECIAL_VOTING_CLAIMS = \"dao:svoting:claims\";\r\n    bytes32 CONTRACT_DAO_IDENTITY = \"dao:identity\";\r\n    bytes32 CONTRACT_DAO_REWARDS_MANAGER = \"dao:rewards-manager\";\r\n    bytes32 CONTRACT_DAO_REWARDS_MANAGER_EXTRAS = \"dao:rewards-extras\";\r\n    bytes32 CONTRACT_DAO_ROLES = \"dao:roles\";\r\n    bytes32 CONTRACT_DAO_FUNDING_MANAGER = \"dao:funding-manager\";\r\n    bytes32 CONTRACT_DAO_WHITELISTING = \"dao:whitelisting\";\r\n    bytes32 CONTRACT_DAO_INFORMATION = \"dao:information\";\r\n\r\n    // service contracts\r\n    bytes32 CONTRACT_SERVICE_ROLE = \"service:role\";\r\n    bytes32 CONTRACT_SERVICE_DAO_INFO = \"service:dao:info\";\r\n    bytes32 CONTRACT_SERVICE_DAO_LISTING = \"service:dao:listing\";\r\n    bytes32 CONTRACT_SERVICE_DAO_CALCULATOR = \"service:dao:calculator\";\r\n\r\n    // storage contracts\r\n    bytes32 CONTRACT_STORAGE_DAO = \"storage:dao\";\r\n    bytes32 CONTRACT_STORAGE_DAO_COUNTER = \"storage:dao:counter\";\r\n    bytes32 CONTRACT_STORAGE_DAO_UPGRADE = \"storage:dao:upgrade\";\r\n    bytes32 CONTRACT_STORAGE_DAO_IDENTITY = \"storage:dao:identity\";\r\n    bytes32 CONTRACT_STORAGE_DAO_POINTS = \"storage:dao:points\";\r\n    bytes32 CONTRACT_STORAGE_DAO_SPECIAL = \"storage:dao:special\";\r\n    bytes32 CONTRACT_STORAGE_DAO_CONFIG = \"storage:dao:config\";\r\n    bytes32 CONTRACT_STORAGE_DAO_STAKE = \"storage:dao:stake\";\r\n    bytes32 CONTRACT_STORAGE_DAO_REWARDS = \"storage:dao:rewards\";\r\n    bytes32 CONTRACT_STORAGE_DAO_WHITELISTING = \"storage:dao:whitelisting\";\r\n    bytes32 CONTRACT_STORAGE_INTERMEDIATE_RESULTS = \"storage:intermediate:results\";\r\n\r\n    bytes32 CONTRACT_DGD_TOKEN = \"t:dgd\";\r\n    bytes32 CONTRACT_DGX_TOKEN = \"t:dgx\";\r\n    bytes32 CONTRACT_BADGE_TOKEN = \"t:badge\";\r\n\r\n    uint8 ROLES_ROOT = 1;\r\n    uint8 ROLES_FOUNDERS = 2;\r\n    uint8 ROLES_PRLS = 3;\r\n    uint8 ROLES_KYC_ADMINS = 4;\r\n\r\n    uint256 QUARTER_DURATION = 90 days;\r\n\r\n    bytes32 CONFIG_MINIMUM_LOCKED_DGD = \"min_dgd_participant\";\r\n    bytes32 CONFIG_MINIMUM_DGD_FOR_MODERATOR = \"min_dgd_moderator\";\r\n    bytes32 CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR = \"min_reputation_moderator\";\r\n\r\n    bytes32 CONFIG_LOCKING_PHASE_DURATION = \"locking_phase_duration\";\r\n    bytes32 CONFIG_QUARTER_DURATION = \"quarter_duration\";\r\n    bytes32 CONFIG_VOTING_COMMIT_PHASE = \"voting_commit_phase\";\r\n    bytes32 CONFIG_VOTING_PHASE_TOTAL = \"voting_phase_total\";\r\n    bytes32 CONFIG_INTERIM_COMMIT_PHASE = \"interim_voting_commit_phase\";\r\n    bytes32 CONFIG_INTERIM_PHASE_TOTAL = \"interim_voting_phase_total\";\r\n\r\n    bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR = \"draft_quorum_fixed_numerator\";\r\n    bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR = \"draft_quorum_fixed_denominator\";\r\n    bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR = \"draft_quorum_sfactor_numerator\";\r\n    bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR = \"draft_quorum_sfactor_denominator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR = \"vote_quorum_fixed_numerator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR = \"vote_quorum_fixed_denominator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR = \"vote_quorum_sfactor_numerator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR = \"vote_quorum_sfactor_denominator\";\r\n    bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR = \"final_reward_sfactor_numerator\";\r\n    bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR = \"final_reward_sfactor_denominator\";\r\n\r\n    bytes32 CONFIG_DRAFT_QUOTA_NUMERATOR = \"draft_quota_numerator\";\r\n    bytes32 CONFIG_DRAFT_QUOTA_DENOMINATOR = \"draft_quota_denominator\";\r\n    bytes32 CONFIG_VOTING_QUOTA_NUMERATOR = \"voting_quota_numerator\";\r\n    bytes32 CONFIG_VOTING_QUOTA_DENOMINATOR = \"voting_quota_denominator\";\r\n\r\n    bytes32 CONFIG_MINIMAL_QUARTER_POINT = \"minimal_qp\";\r\n    bytes32 CONFIG_QUARTER_POINT_SCALING_FACTOR = \"quarter_point_scaling_factor\";\r\n    bytes32 CONFIG_REPUTATION_POINT_SCALING_FACTOR = \"rep_point_scaling_factor\";\r\n\r\n    bytes32 CONFIG_MODERATOR_MINIMAL_QUARTER_POINT = \"minimal_mod_qp\";\r\n    bytes32 CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR = \"mod_qp_scaling_factor\";\r\n    bytes32 CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR = \"mod_rep_point_scaling_factor\";\r\n\r\n    bytes32 CONFIG_QUARTER_POINT_DRAFT_VOTE = \"quarter_point_draft_vote\";\r\n    bytes32 CONFIG_QUARTER_POINT_VOTE = \"quarter_point_vote\";\r\n    bytes32 CONFIG_QUARTER_POINT_INTERIM_VOTE = \"quarter_point_interim_vote\";\r\n\r\n    /// this is per 10000 ETHs\r\n    bytes32 CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH = \"q_p_milestone_completion\";\r\n\r\n    bytes32 CONFIG_BONUS_REPUTATION_NUMERATOR = \"bonus_reputation_numerator\";\r\n    bytes32 CONFIG_BONUS_REPUTATION_DENOMINATOR = \"bonus_reputation_denominator\";\r\n\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE = \"special_proposal_commit_phase\";\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL = \"special_proposal_phase_total\";\r\n\r\n    bytes32 CONFIG_SPECIAL_QUOTA_NUMERATOR = \"config_special_quota_numerator\";\r\n    bytes32 CONFIG_SPECIAL_QUOTA_DENOMINATOR = \"config_special_quota_denominator\";\r\n\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR = \"special_quorum_numerator\";\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR = \"special_quorum_denominator\";\r\n\r\n    bytes32 CONFIG_MAXIMUM_REPUTATION_DEDUCTION = \"config_max_reputation_deduction\";\r\n    bytes32 CONFIG_PUNISHMENT_FOR_NOT_LOCKING = \"config_punishment_not_locking\";\r\n\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_NUM = \"config_rep_per_extra_qp_num\";\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_DEN = \"config_rep_per_extra_qp_den\";\r\n\r\n    bytes32 CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION = \"config_max_m_rp_deduction\";\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM = \"config_rep_per_extra_m_qp_num\";\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN = \"config_rep_per_extra_m_qp_den\";\r\n\r\n    bytes32 CONFIG_PORTION_TO_MODERATORS_NUM = \"config_mod_portion_num\";\r\n    bytes32 CONFIG_PORTION_TO_MODERATORS_DEN = \"config_mod_portion_den\";\r\n\r\n    bytes32 CONFIG_DRAFT_VOTING_PHASE = \"config_draft_voting_phase\";\r\n\r\n    bytes32 CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE = \"config_rp_boost_per_badge\";\r\n\r\n    bytes32 CONFIG_VOTE_CLAIMING_DEADLINE = \"config_claiming_deadline\";\r\n\r\n    bytes32 CONFIG_PREPROPOSAL_COLLATERAL = \"config_preproposal_collateral\";\r\n\r\n    bytes32 CONFIG_MAX_FUNDING_FOR_NON_DIGIX = \"config_max_funding_nonDigix\";\r\n    bytes32 CONFIG_MAX_MILESTONES_FOR_NON_DIGIX = \"config_max_milestones_nonDigix\";\r\n    bytes32 CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER = \"config_nonDigix_proposal_cap\";\r\n\r\n    bytes32 CONFIG_PROPOSAL_DEAD_DURATION = \"config_dead_duration\";\r\n    bytes32 CONFIG_CARBON_VOTE_REPUTATION_BONUS = \"config_cv_reputation\";\r\n}\r\n\r\n// File: contracts/storage/DaoPointsStorage.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\ncontract DaoPointsStorage is ResolverClient, DaoConstants {\r\n\r\n    // struct for a non-transferrable token\r\n    struct Token {\r\n        uint256 totalSupply;\r\n        mapping (address => uint256) balance;\r\n    }\r\n\r\n    // the reputation point token\r\n    // since reputation is cumulative, we only need to store one value\r\n    Token reputationPoint;\r\n\r\n    // since quarter points are specific to quarters, we need a mapping from\r\n    // quarter number to the quarter point token for that quarter\r\n    mapping (uint256 => Token) quarterPoint;\r\n\r\n    // the same is the case with quarter moderator points\r\n    // these are specific to quarters\r\n    mapping (uint256 => Token) quarterModeratorPoint;\r\n\r\n    constructor(address _resolver)\r\n        public\r\n    {\r\n        require(init(CONTRACT_STORAGE_DAO_POINTS, _resolver));\r\n    }\r\n\r\n    /// @notice add quarter points for a _participant for a _quarterNumber\r\n    function addQuarterPoint(address _participant, uint256 _point, uint256 _quarterNumber)\r\n        public\r\n        returns (uint256 _newPoint, uint256 _newTotalPoint)\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_VOTING, CONTRACT_DAO_VOTING_CLAIMS, EMPTY_BYTES]));\r\n        quarterPoint[_quarterNumber].totalSupply = quarterPoint[_quarterNumber].totalSupply.add(_point);\r\n        quarterPoint[_quarterNumber].balance[_participant] = quarterPoint[_quarterNumber].balance[_participant].add(_point);\r\n\r\n        _newPoint = quarterPoint[_quarterNumber].balance[_participant];\r\n        _newTotalPoint = quarterPoint[_quarterNumber].totalSupply;\r\n    }\r\n\r\n    function addModeratorQuarterPoint(address _participant, uint256 _point, uint256 _quarterNumber)\r\n        public\r\n        returns (uint256 _newPoint, uint256 _newTotalPoint)\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_VOTING, CONTRACT_DAO_VOTING_CLAIMS, EMPTY_BYTES]));\r\n        quarterModeratorPoint[_quarterNumber].totalSupply = quarterModeratorPoint[_quarterNumber].totalSupply.add(_point);\r\n        quarterModeratorPoint[_quarterNumber].balance[_participant] = quarterModeratorPoint[_quarterNumber].balance[_participant].add(_point);\r\n\r\n        _newPoint = quarterModeratorPoint[_quarterNumber].balance[_participant];\r\n        _newTotalPoint = quarterModeratorPoint[_quarterNumber].totalSupply;\r\n    }\r\n\r\n    /// @notice get quarter points for a _participant in a _quarterNumber\r\n    function getQuarterPoint(address _participant, uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _point)\r\n    {\r\n        _point = quarterPoint[_quarterNumber].balance[_participant];\r\n    }\r\n\r\n    function getQuarterModeratorPoint(address _participant, uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _point)\r\n    {\r\n        _point = quarterModeratorPoint[_quarterNumber].balance[_participant];\r\n    }\r\n\r\n    /// @notice get total quarter points for a particular _quarterNumber\r\n    function getTotalQuarterPoint(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _totalPoint)\r\n    {\r\n        _totalPoint = quarterPoint[_quarterNumber].totalSupply;\r\n    }\r\n\r\n    function getTotalQuarterModeratorPoint(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _totalPoint)\r\n    {\r\n        _totalPoint = quarterModeratorPoint[_quarterNumber].totalSupply;\r\n    }\r\n\r\n    /// @notice add reputation points for a _participant\r\n    function increaseReputation(address _participant, uint256 _point)\r\n        public\r\n        returns (uint256 _newPoint, uint256 _totalPoint)\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_VOTING_CLAIMS, CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_STAKE_LOCKING]));\r\n        reputationPoint.totalSupply = reputationPoint.totalSupply.add(_point);\r\n        reputationPoint.balance[_participant] = reputationPoint.balance[_participant].add(_point);\r\n\r\n        _newPoint = reputationPoint.balance[_participant];\r\n        _totalPoint = reputationPoint.totalSupply;\r\n    }\r\n\r\n    /// @notice subtract reputation points for a _participant\r\n    function reduceReputation(address _participant, uint256 _point)\r\n        public\r\n        returns (uint256 _newPoint, uint256 _totalPoint)\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_VOTING_CLAIMS, CONTRACT_DAO_REWARDS_MANAGER, EMPTY_BYTES]));\r\n        uint256 _toDeduct = _point;\r\n        if (reputationPoint.balance[_participant] > _point) {\r\n            reputationPoint.balance[_participant] = reputationPoint.balance[_participant].sub(_point);\r\n        } else {\r\n            _toDeduct = reputationPoint.balance[_participant];\r\n            reputationPoint.balance[_participant] = 0;\r\n        }\r\n\r\n        reputationPoint.totalSupply = reputationPoint.totalSupply.sub(_toDeduct);\r\n\r\n        _newPoint = reputationPoint.balance[_participant];\r\n        _totalPoint = reputationPoint.totalSupply;\r\n    }\r\n\r\n  /// @notice get reputation points for a _participant\r\n  function getReputation(address _participant)\r\n      public\r\n      view\r\n      returns (uint256 _point)\r\n  {\r\n      _point = reputationPoint.balance[_participant];\r\n  }\r\n\r\n  /// @notice get total reputation points distributed in the dao\r\n  function getTotalReputation()\r\n      public\r\n      view\r\n      returns (uint256 _totalPoint)\r\n  {\r\n      _totalPoint = reputationPoint.totalSupply;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalReputation\",\"outputs\":[{\"name\":\"_totalPoint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_point\",\"type\":\"uint256\"},{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"addQuarterPoint\",\"outputs\":[{\"name\":\"_newPoint\",\"type\":\"uint256\"},{\"name\":\"_newTotalPoint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"getTotalQuarterModeratorPoint\",\"outputs\":[{\"name\":\"_totalPoint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"key\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"get_contract\",\"outputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_point\",\"type\":\"uint256\"}],\"name\":\"reduceReputation\",\"outputs\":[{\"name\":\"_newPoint\",\"type\":\"uint256\"},{\"name\":\"_totalPoint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"getTotalQuarterPoint\",\"outputs\":[{\"name\":\"_totalPoint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"getQuarterPoint\",\"outputs\":[{\"name\":\"_point\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"getReputation\",\"outputs\":[{\"name\":\"_point\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"getQuarterModeratorPoint\",\"outputs\":[{\"name\":\"_point\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_point\",\"type\":\"uint256\"}],\"name\":\"increaseReputation\",\"outputs\":[{\"name\":\"_newPoint\",\"type\":\"uint256\"},{\"name\":\"_totalPoint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_point\",\"type\":\"uint256\"},{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"addModeratorQuarterPoint\",\"outputs\":[{\"name\":\"_newPoint\",\"type\":\"uint256\"},{\"name\":\"_newTotalPoint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DaoPointsStorage","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000005f60ef7e1443f82ca7de947711f0966ca6e3b5","Library":"","LicenseType":"BSD-3-Clause","SwarmSource":"bzzr://ea8c956299ed5883ec123d2297dd6f62b2676a9008861da564410a27f19571aa"}]}