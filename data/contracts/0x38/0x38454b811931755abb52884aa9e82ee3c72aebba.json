{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\r\n// From: https://github.com/mixbytes/solidity/blob/master/contracts/ownership/multiowned.sol\r\n// Copyright (C) 2017  MixBytes, LLC\r\n\r\n// Licensed under the Apache License, Version 2.0 (the \"License\").\r\n// You may not use this file except in compliance with the License.\r\n\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\r\n\r\n// Code taken from https://github.com/ethereum/dapp-bin/blob/master/wallet/wallet.sol\r\n// Audit, refactoring and improvements by github.com/Eenae\r\n\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyOwner (just own owned) or onlyManyOwners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\n\r\n\r\n/// note: during any ownership changes all pending operations (waiting for more signatures) are cancelled\r\n// TODO acceptOwnership\r\ncontract multiowned {\r\n\r\n\t// TYPES\r\n\r\n\t// struct for the status of a pending operation.\r\n\tstruct MultiOwnedOperationPendingState {\r\n\t\t// count of confirmations needed\r\n\t\tuint256 yetNeeded;\r\n\r\n\t\t// bitmap of confirmations where owner #ownerIndex's decision corresponds to 2**ownerIndex bit\r\n\t\tuint256 ownersDone;\r\n\r\n\t\t// position of this operation key in m_multiOwnedPendingIndex\r\n\t\tuint256 index;\r\n\t}\r\n\r\n\t// EVENTS\r\n\r\n\tevent Confirmation(address owner, bytes32 operation);\r\n\tevent Revoke(address owner, bytes32 operation);\r\n\tevent FinalConfirmation(address owner, bytes32 operation);\r\n\r\n\t// some others are in the case of an owner changing.\r\n\tevent OwnerChanged(address oldOwner, address newOwner);\r\n\tevent OwnerAdded(address newOwner);\r\n\tevent OwnerRemoved(address oldOwner);\r\n\r\n\t// the last one is emitted if the required signatures change\r\n\tevent RequirementChanged(uint256 newRequirement);\r\n\r\n\t// MODIFIERS\r\n\r\n\t// simple single-sig function modifier.\r\n\tmodifier onlyOwner {\r\n\t\trequire(isOwner(msg.sender), \"Auth\");\r\n\t\t_;\r\n\t}\r\n\t// multi-sig function modifier: the operation must have an intrinsic hash in order\r\n\t// that later attempts can be realised as the same underlying operation and\r\n\t// thus count as confirmations.\r\n\tmodifier onlyManyOwners(bytes32 _operation) {\r\n\t\tif (confirmAndCheck(_operation)) {\r\n\t\t\t_;\r\n\t\t}\r\n\t\t// Even if required number of confirmations has't been collected yet,\r\n\t\t// we can't throw here - because changes to the state have to be preserved.\r\n\t\t// But, confirmAndCheck itself will throw in case sender is not an owner.\r\n\t}\r\n\r\n\tmodifier validNumOwners(uint256 _numOwners) {\r\n\t\trequire(_numOwners > 0 && _numOwners <= c_maxOwners, \"NumOwners OOR\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier multiOwnedValidRequirement(uint256 _required, uint256 _numOwners) {\r\n\t\trequire(_required > 0 && _required <= _numOwners, \"Req OOR\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier ownerExists(address _address) {\r\n\t\trequire(isOwner(_address), \"Auth\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier ownerDoesNotExist(address _address) {\r\n\t\trequire(!isOwner(_address), \"Is owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier multiOwnedOperationIsActive(bytes32 _operation) {\r\n\t\trequire(isOperationActive(_operation), \"NoOp\");\r\n\t\t_;\r\n\t}\r\n\r\n\t// METHODS\r\n\r\n\t// constructor is given number of sigs required to do protected \"onlyManyOwners\" transactions\r\n\t// as well as the selection of addresses capable of confirming them (msg.sender is not added to the owners!).\r\n\tconstructor (address[] memory _owners, uint256 _required)\r\n\t\tpublic\r\n\t\tvalidNumOwners(_owners.length)\r\n\t\tmultiOwnedValidRequirement(_required, _owners.length)\r\n\t{\r\n\t\tassert(c_maxOwners <= 255);\r\n\r\n\t\tm_numOwners = _owners.length;\r\n\t\tm_multiOwnedRequired = _required;\r\n\r\n\t\tfor (uint256 i = 0; i < _owners.length; ++i)\r\n\t\t{\r\n\t\t\taddress owner = _owners[i];\r\n\t\t\t// invalid and duplicate addresses are not allowed\r\n\t\t\trequire(address(0) != owner && !isOwner(owner), \"Exists\");  /* not isOwner yet! */\r\n\r\n\t\t\tuint256 currentOwnerIndex = checkOwnerIndex(i + 1);  /* first slot is unused */\r\n\t\t\tm_owners[currentOwnerIndex] = owner;\r\n\t\t\tm_ownerIndex[owner] = currentOwnerIndex;\r\n\t\t}\r\n\r\n\t\tassertOwnersAreConsistent();\r\n\t}\r\n\r\n\t/// @notice replaces an owner `_from` with another `_to`.\r\n\t/// @param _from address of owner to replace\r\n\t/// @param _to address of new owner\r\n\t// All pending operations will be canceled!\r\n\tfunction changeOwner(address _from, address _to)\r\n\t\texternal\r\n\t\townerExists(_from)\r\n\t\townerDoesNotExist(_to)\r\n\t\tonlyManyOwners(keccak256(msg.data))\r\n\t{\r\n\t\tassertOwnersAreConsistent();\r\n\r\n\t\tclearPending();\r\n\t\tuint256 ownerIndex = checkOwnerIndex(m_ownerIndex[_from]);\r\n\t\tm_owners[ownerIndex] = _to;\r\n\t\tm_ownerIndex[_from] = 0;\r\n\t\tm_ownerIndex[_to] = ownerIndex;\r\n\r\n\t\tassertOwnersAreConsistent();\r\n\t\temit OwnerChanged(_from, _to);\r\n\t}\r\n\r\n\t/// @notice adds an owner\r\n\t/// @param _owner address of new owner\r\n\t// All pending operations will be canceled!\r\n\tfunction addOwner(address _owner)\r\n\t\texternal\r\n\t\townerDoesNotExist(_owner)\r\n\t\tvalidNumOwners(m_numOwners + 1)\r\n\t\tonlyManyOwners(keccak256(msg.data))\r\n\t{\r\n\t\tassertOwnersAreConsistent();\r\n\r\n\t\tclearPending();\r\n\t\tm_numOwners++;\r\n\t\tm_owners[m_numOwners] = _owner;\r\n\t\tm_ownerIndex[_owner] = checkOwnerIndex(m_numOwners);\r\n\r\n\t\tassertOwnersAreConsistent();\r\n\t\temit OwnerAdded(_owner);\r\n\t}\r\n\r\n\t/// @notice removes an owner\r\n\t/// @param _owner address of owner to remove\r\n\t// All pending operations will be canceled!\r\n\tfunction removeOwner(address _owner)\r\n\t\texternal\r\n\t\townerExists(_owner)\r\n\t\tvalidNumOwners(m_numOwners - 1)\r\n\t\tmultiOwnedValidRequirement(m_multiOwnedRequired, m_numOwners - 1)\r\n\t\tonlyManyOwners(keccak256(msg.data))\r\n\t{\r\n\t\tassertOwnersAreConsistent();\r\n\r\n\t\tclearPending();\r\n\t\tuint256 ownerIndex = checkOwnerIndex(m_ownerIndex[_owner]);\r\n\t\tm_owners[ownerIndex] = address(0);\r\n\t\tm_ownerIndex[_owner] = 0;\r\n\t\t//make sure m_numOwners is equal to the number of owners and always points to the last owner\r\n\t\treorganizeOwners();\r\n\r\n\t\tassertOwnersAreConsistent();\r\n\t\temit OwnerRemoved(_owner);\r\n\t}\r\n\r\n\t/// @notice changes the required number of owner signatures\r\n\t/// @param _newRequired new number of signatures required\r\n\t// All pending operations will be canceled!\r\n\tfunction changeRequirement(uint256 _newRequired)\r\n\t\texternal\r\n\t\tmultiOwnedValidRequirement(_newRequired, m_numOwners)\r\n\t\tonlyManyOwners(keccak256(msg.data))\r\n\t{\r\n\t\tm_multiOwnedRequired = _newRequired;\r\n\t\tclearPending();\r\n\t\temit RequirementChanged(_newRequired);\r\n\t}\r\n\r\n\t/// @notice Gets an owner by 0-indexed position\r\n\t/// @param ownerIndex 0-indexed owner position\r\n\tfunction getOwner(uint256 ownerIndex) public view returns (address) {\r\n\t\treturn m_owners[ownerIndex + 1];\r\n\t}\r\n\r\n\t/// @notice Gets owners\r\n\t/// @return memory array of owners\r\n\tfunction getOwners() public view returns (address[] memory) {\r\n\t\taddress[] memory result = new address[](m_numOwners);\r\n\t\tfor (uint256 i = 0; i < m_numOwners; i++)\r\n\t\t\tresult[i] = getOwner(i);\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/// @notice checks if provided address is an owner address\r\n\t/// @param _addr address to check\r\n\t/// @return true if it's an owner\r\n\tfunction isOwner(address _addr) public view returns (bool) {\r\n\t\treturn m_ownerIndex[_addr] > 0;\r\n\t}\r\n\r\n\t/// @notice Tests ownership of the current caller.\r\n\t/// @return true if it's an owner\r\n\t// It's advisable to call it by new owner to make sure that the same erroneous address is not copy-pasted to\r\n\t// addOwner/changeOwner and to isOwner.\r\n\tfunction amIOwner() external view onlyOwner returns (bool) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/// @notice Revokes a prior confirmation of the given operation\r\n\t/// @param _operation operation value, typically keccak256(msg.data)\r\n\tfunction revoke(bytes32 _operation)\r\n\t\texternal\r\n\t\tmultiOwnedOperationIsActive(_operation)\r\n\t\tonlyOwner\r\n\t{\r\n\t\tuint256 ownerIndexBit = makeOwnerBitmapBit(msg.sender);\r\n\t\tMultiOwnedOperationPendingState storage pending = m_multiOwnedPending[_operation];\r\n\t\trequire(pending.ownersDone & ownerIndexBit > 0, \"Auth\");\r\n\r\n\t\tassertOperationIsConsistent(_operation);\r\n\r\n\t\tpending.yetNeeded++;\r\n\t\tpending.ownersDone -= ownerIndexBit;\r\n\r\n\t\tassertOperationIsConsistent(_operation);\r\n\t\temit Revoke(msg.sender, _operation);\r\n\t}\r\n\r\n\t/// @notice Checks if owner confirmed given operation\r\n\t/// @param _operation operation value, typically keccak256(msg.data)\r\n\t/// @param _owner an owner address\r\n\tfunction hasConfirmed(bytes32 _operation, address _owner)\r\n\t\texternal\r\n\t\tview\r\n\t\tmultiOwnedOperationIsActive(_operation)\r\n\t\townerExists(_owner)\r\n\t\treturns (bool)\r\n\t{\r\n\t\treturn !(m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner) == 0);\r\n\t}\r\n\r\n\t// INTERNAL METHODS\r\n\r\n\tfunction confirmAndCheck(bytes32 _operation)\r\n\t\tinternal\r\n\t\tonlyOwner\r\n\t\treturns (bool)\r\n\t{\r\n\t\tif (512 == m_multiOwnedPendingIndex.length)\r\n\t\t\t// In case m_multiOwnedPendingIndex grows too much we have to shrink it: otherwise at some point\r\n\t\t\t// we won't be able to do it because of block gas limit.\r\n\t\t\t// Yes, pending confirmations will be lost. Dont see any security or stability implications.\r\n\t\t\t// TODO use more graceful approach like compact or removal of clearPending completely\r\n\t\t\tclearPending();\r\n\r\n\t\tMultiOwnedOperationPendingState storage pending = m_multiOwnedPending[_operation];\r\n\r\n\t\t// if we're not yet working on this operation, switch over and reset the confirmation status.\r\n\t\tif (! isOperationActive(_operation)) {\r\n\t\t\t// reset count of confirmations needed.\r\n\t\t\tpending.yetNeeded = m_multiOwnedRequired;\r\n\t\t\t// reset which owners have confirmed (none) - set our bitmap to 0.\r\n\t\t\tpending.ownersDone = 0;\r\n\t\t\tpending.index = m_multiOwnedPendingIndex.length++;\r\n\t\t\tm_multiOwnedPendingIndex[pending.index] = _operation;\r\n\t\t\tassertOperationIsConsistent(_operation);\r\n\t\t}\r\n\r\n\t\t// determine the bit to set for this owner.\r\n\t\tuint256 ownerIndexBit = makeOwnerBitmapBit(msg.sender);\r\n\t\t// make sure we (the message sender) haven't confirmed this operation previously.\r\n\t\tif (pending.ownersDone & ownerIndexBit == 0) {\r\n\t\t\t// ok - check if count is enough to go ahead.\r\n\t\t\tassert(pending.yetNeeded > 0);\r\n\t\t\tif (pending.yetNeeded == 1) {\r\n\t\t\t\t// enough confirmations: reset and run interior.\r\n\t\t\t\tdelete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index];\r\n\t\t\t\tdelete m_multiOwnedPending[_operation];\r\n\t\t\t\temit FinalConfirmation(msg.sender, _operation);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// not enough: record that this owner in particular confirmed.\r\n\t\t\t\tpending.yetNeeded--;\r\n\t\t\t\tpending.ownersDone |= ownerIndexBit;\r\n\t\t\t\tassertOperationIsConsistent(_operation);\r\n\t\t\t\temit Confirmation(msg.sender, _operation);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Reclaims free slots between valid owners in m_owners.\r\n\t// TODO given that its called after each removal, it could be simplified.\r\n\tfunction reorganizeOwners() private {\r\n\t\tuint256 free = 1;\r\n\t\twhile (free < m_numOwners)\r\n\t\t{\r\n\t\t\t// iterating to the first free slot from the beginning\r\n\t\t\twhile (free < m_numOwners && m_owners[free] != address(0)) free++;\r\n\r\n\t\t\t// iterating to the first occupied slot from the end\r\n\t\t\twhile (m_numOwners > 1 && m_owners[m_numOwners] == address(0)) m_numOwners--;\r\n\r\n\t\t\t// swap, if possible, so free slot is located at the end after the swap\r\n\t\t\tif (free < m_numOwners && m_owners[m_numOwners] != address(0) && m_owners[free] == address(0))\r\n\t\t\t{\r\n\t\t\t\t// owners between swapped slots should't be renumbered - that saves a lot of gas\r\n\t\t\t\tm_owners[free] = m_owners[m_numOwners];\r\n\t\t\t\tm_ownerIndex[m_owners[free]] = free;\r\n\t\t\t\tm_owners[m_numOwners] = address(0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction clearPending() private onlyOwner {\r\n\t\tuint256 length = m_multiOwnedPendingIndex.length;\r\n\t\t// TODO block gas limit\r\n\t\tfor (uint256 i = 0; i < length; ++i) {\r\n\t\t\tif (m_multiOwnedPendingIndex[i] != 0)\r\n\t\t\t\tdelete m_multiOwnedPending[m_multiOwnedPendingIndex[i]];\r\n\t\t}\r\n\t\tdelete m_multiOwnedPendingIndex;\r\n\t}\r\n\r\n\tfunction checkOwnerIndex(uint256 ownerIndex) internal pure returns (uint256) {\r\n\t\tassert(0 != ownerIndex && ownerIndex <= c_maxOwners);\r\n\t\treturn ownerIndex;\r\n\t}\r\n\r\n\tfunction makeOwnerBitmapBit(address owner) private view returns (uint256) {\r\n\t\tuint256 ownerIndex = checkOwnerIndex(m_ownerIndex[owner]);\r\n\t\treturn 2 ** ownerIndex;\r\n\t}\r\n\r\n\tfunction isOperationActive(bytes32 _operation) private view returns (bool) {\r\n\t\treturn 0 != m_multiOwnedPending[_operation].yetNeeded;\r\n\t}\r\n\r\n\r\n\tfunction assertOwnersAreConsistent() private view {\r\n\t\tassert(m_numOwners > 0);\r\n\t\tassert(m_numOwners <= c_maxOwners);\r\n\t\tassert(m_owners[0] == address(0));\r\n\t\tassert(0 != m_multiOwnedRequired && m_multiOwnedRequired <= m_numOwners);\r\n\t}\r\n\r\n\tfunction assertOperationIsConsistent(bytes32 _operation) private view {\r\n\t\tMultiOwnedOperationPendingState storage pending = m_multiOwnedPending[_operation];\r\n\t\tassert(0 != pending.yetNeeded);\r\n\t\tassert(m_multiOwnedPendingIndex[pending.index] == _operation);\r\n\t\tassert(pending.yetNeeded <= m_multiOwnedRequired);\r\n\t}\r\n\r\n\r\n\t// FIELDS\r\n\r\n\tuint256 constant c_maxOwners = 250;\r\n\r\n\t// the number of owners that must confirm the same operation before it is run.\r\n\tuint256 public m_multiOwnedRequired;\r\n\r\n\r\n\t// pointer used to find a free slot in m_owners\r\n\tuint256 public m_numOwners;\r\n\r\n\t// list of owners (addresses),\r\n\t// slot 0 is unused so there are no owner which index is 0.\r\n\t// TODO could we save space at the end of the array for the common case of <10 owners? and should we?\r\n\taddress[256] internal m_owners;\r\n\r\n\t// index on the list of owners to allow reverse lookup: owner address => index in m_owners\r\n\tmapping(address => uint256) internal m_ownerIndex;\r\n\r\n\r\n\t// the ongoing operations.\r\n\tmapping(bytes32 => MultiOwnedOperationPendingState) internal m_multiOwnedPending;\r\n\tbytes32[] internal m_multiOwnedPendingIndex;\r\n}\r\n\r\n\r\n/**\r\n* @title ERC20Basic\r\n* @dev Simpler version of ERC20 interface\r\n* See https://github.com/ethereum/EIPs/issues/179\r\n*/\r\ncontract ERC20Basic {\r\n\tfunction totalSupply() public view returns (uint256);\r\n\tfunction balanceOf(address who) public view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) public returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n\t/**\r\n\t* @dev Multiplies two numbers, throws on overflow.\r\n\t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\t// Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tc = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Integer division of two numbers, truncating the quotient.\r\n\t*/\r\n\t/*\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\t// uint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn a / b;\r\n\t}\r\n\t*/\r\n\r\n\t/**\r\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Adds two numbers, throws on overflow.\r\n\t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n* @title Basic token\r\n* @dev Basic version of StandardToken, with no allowances.\r\n*/\r\ncontract BasicToken is ERC20Basic {\r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping(address => uint256) balances;\r\n\r\n\tuint256 totalSupply_;\r\n\r\n\t/**\r\n\t* @dev Total number of tokens in existence\r\n\t*/\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn totalSupply_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfer token for a specified address\r\n\t* @param _to The address to transfer to.\r\n\t* @param _value The amount to be transferred.\r\n\t*/\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(_to != address(0), \"Self\");\r\n\t\trequire(_value <= balances[msg.sender], \"NSF\");\r\n\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Gets the balance of the specified address.\r\n\t* @param _owner The address to query the the balance of.\r\n\t* @return An uint256 representing the amount owned by the passed address.\r\n\t*/\r\n\tfunction balanceOf(address _owner) public view returns (uint256) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n* @title ERC20 interface\r\n* @dev see https://github.com/ethereum/EIPs/issues/20\r\n*/\r\ncontract ERC20 is ERC20Basic {\r\n\tfunction allowance(address owner, address spender) public view returns (uint256);\r\n\r\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n\tfunction approve(address spender, uint256 value) public returns (bool);\r\n\tevent Approval(\r\n\t\taddress indexed owner,\r\n\t\taddress indexed spender,\r\n\t\tuint256 value\r\n\t);\r\n}\r\n\r\n\r\n/**\r\n* @title Standard ERC20 token\r\n*\r\n* @dev Implementation of the basic standard token.\r\n* https://github.com/ethereum/EIPs/issues/20\r\n* Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n*/\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n\tmapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n\t/**\r\n\t* @dev Transfer tokens from one address to another\r\n\t* @param _from address The address which you want to send tokens from\r\n\t* @param _to address The address which you want to transfer to\r\n\t* @param _value uint256 the amount of tokens to be transferred\r\n\t*/\r\n\tfunction transferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _value\r\n\t)\r\n\tpublic\r\n\treturns (bool)\r\n\t{\r\n\t\trequire(_to != address(0), \"Invl\");\r\n\t\trequire(_value <= balances[_from], \"NSF\");\r\n\t\trequire(_value <= allowed[_from][msg.sender], \"NFAllowance\");\r\n\r\n\t\tbalances[_from] = balances[_from].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n\t* Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n\t* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n\t* race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n\t* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t* @param _spender The address which will spend the funds.\r\n\t* @param _value The amount of tokens to be spent.\r\n\t*/\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n\t* @param _owner address The address which owns the funds.\r\n\t* @param _spender address The address which will spend the funds.\r\n\t* @return A uint256 specifying the amount of tokens still available for the spender.\r\n\t*/\r\n\tfunction allowance(\r\n\t\taddress _owner,\r\n\t\taddress _spender\r\n\t)\r\n\tpublic\r\n\tview\r\n\treturns (uint256)\r\n\t{\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Increase the amount of tokens that an owner allowed to a spender.\r\n\t* approve should be called when allowed[_spender] == 0. To increment\r\n\t* allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t* the first transaction is mined)\r\n\t* From MonolithDAO Token.sol\r\n\t* @param _spender The address which will spend the funds.\r\n\t* @param _addedValue The amount of tokens to increase the allowance by.\r\n\t*/\r\n\tfunction increaseApproval(\r\n\t\taddress _spender,\r\n\t\tuint256 _addedValue\r\n\t)\r\n\tpublic\r\n\treturns (bool)\r\n\t{\r\n\t\tallowed[msg.sender][_spender] = (\r\n\t\tallowed[msg.sender][_spender].add(_addedValue));\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n\t* approve should be called when allowed[_spender] == 0. To decrement\r\n\t* allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t* the first transaction is mined)\r\n\t* From MonolithDAO Token.sol\r\n\t* @param _spender The address which will spend the funds.\r\n\t* @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n\t*/\r\n\tfunction decreaseApproval(\r\n\t\taddress _spender,\r\n\t\tuint256 _subtractedValue\r\n\t)\r\n\tpublic\r\n\treturns (bool)\r\n\t{\r\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\r\n\t\tif (_subtractedValue > oldValue) {\r\n\t\t\tallowed[msg.sender][_spender] = 0;\r\n\t\t} else {\r\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\t\t}\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\ncontract SparksterTokenSwap is StandardToken, multiowned {\r\n\tusing SafeMath for uint256;\r\n\tstruct Member {\r\n\t\tmapping(uint256 => uint256) weiBalance; // How much wei has this member contributed for this group?\r\n\t\tuint256[] groups; // A list of groups this member belongs to.\r\n\t\t// Used to see how many locked tokens this user has so we don't have to iterate over all groups;\r\n\t\t// we can just iterate over the groups this user belongs to.\r\n\t}\r\n\r\n\tenum GroupStates {\r\n\t\tnone,\r\n\t\tdistributing,\r\n\t\tdistributed,\r\n\t\tunlocked // This value is only set for groups that don't define an unlock time.\r\n\t\t// For groups that define an unlock time, the group is unlocked if Group.state == GroupStates.distributed and the unlock time has elapsed; the GroupStates.unlocked state will be ignored.\r\n\t}\r\n\r\n\tstruct Group {\r\n\t\tGroupStates state; // Indicates whether the group is distributed or unlocked.\r\n\t\tmapping(address => bool) exists; // If exists[address] is true, this address has made a purchase on this group before.\r\n\t\tstring name;\r\n\t\tuint256 ratio; // 1 eth:ratio tokens. This amount represents the decimal amount. ratio*10**decimal = ratio sparks.\r\n\t\tuint256 unlockTime; // The timestamp after which tokens in this group are unlocked.\r\n\t\t// If set to a truthy value, the group will be considered unlocked after this time elapses and the group is distributed.\r\n\t\tuint256 startTime; // Epoch of crowdsale start time.\r\n\t\tuint256 phase1endTime; // Epoch of phase1 end time.\r\n\t\tuint256 phase2endTime; // Epoch of phase2 end time.\r\n\t\tuint256 deadline; // No contributions allowed after this epoch.\r\n\t\tuint256 max2; // cap of phase2\r\n\t\tuint256 max3; // Total ether this group can collect in phase 3.\r\n\t\tuint256 weiTotal; // How much ether has this group collected?\r\n\t\tuint256 cap; // The hard ether cap.\r\n\t\tuint256 nextDistributionIndex; // The next index to start distributing at.\r\n\t\taddress[] addresses; // List of addresses that have made a purchase on this group.\r\n\t}\r\n\r\n\taddress[] internal initialSigners = [0xCdF06E2F49F7445098CFA54F52C7f43eE40fa016, 0x8a26B989880CB06d18411C0Cd9C3fa960FDACA51, 0x65580BB13A6edF674B5a25A3c3c223471f5f3706];\r\n\taddress public oracleAddress;\r\n\taddress constant public oldSprkAddress = 0x971d048E737619884f2df75e31c7Eb6412392328;\r\n\taddress public owner; // We call this the owner simply because so many ERC-20 contracts have an owner variable,\r\n\t// so if an API implements getting the balance of the original token holder by querying balanceOf(owner()), this contract won't break the API.\r\n\t// But in our implementation, the contract is multiowned so this owner field has no owning significance besides being the token generator.\r\n\tbool public transferLock = true; // A Global transfer lock. Set to lock down all tokens from all groups.\r\n\tbool public allowedToBuyBack = false;\r\n\tbool public allowedToPurchase = false;\r\n\tstring public name;\t\t\t\t\t\t\t\t\t // name for display\r\n\tstring public symbol;\t\t\t\t\t\t\t\t //An identifier\r\n\tuint8 public decimals;\t\t\t\t\t\t\t//How many decimals to show.\r\n\tuint8 constant internal maxGroups = 100; // Total number of groups we are allowed to create.\r\n\tuint256 public penalty;\r\n\tuint256 public maxGasPrice; // The maximum allowed gas for the purchase function.\r\n\tuint256 internal nextGroupNumber;\r\n\tuint256 public sellPrice; // sellPrice wei:1 spark token; we won't allow to sell back parts of a token.\r\n\tuint256 public minimumRequiredBalance; // How much wei is required for the contract to hold that will cover all refunds.\r\n\t// Owners must leave this much in the contract.\r\n\tuint256 public openGroupNumber;\r\n\tmapping(address => Member) internal members; // For reverse member lookup.\r\n\tmapping(uint256 => Group) internal groups; // For reverse group lookup.\r\n\tmapping(address => uint256) internal withdrawableBalances; // How much wei is this address allowed to withdraw?\r\n\tERC20 oldSprk; // The old Sparkster token contract\r\n\tevent WantsToPurchase(address walletAddress, uint256 weiAmount, uint256 groupNumber, bool inPhase1);\r\n\tevent PurchasedCallbackOnAccept(uint256 groupNumber, address[] addresses);\r\n\tevent WantsToDistribute(uint256 groupNumber);\r\n\tevent NearingHardCap(uint256 groupNumber, uint256 remainder);\r\n\tevent ReachedHardCap(uint256 groupNumber);\r\n\tevent DistributeDone(uint256 groupNumber);\r\n\tevent DistributedBatch(uint256 groupNumber, uint256 howMany);\r\n\tevent ShouldCallDoneDistributing();\r\n\tevent AirdroppedBatch(address[] addresses);\r\n\tevent RefundedBatch(address[] addresses);\r\n\tevent AddToGroup(address walletAddress, uint256 groupNumber);\r\n\tevent ChangedTransferLock(bool transferLock);\r\n\tevent ChangedAllowedToPurchase(bool allowedToPurchase);\r\n\tevent ChangedAllowedToBuyBack(bool allowedToBuyBack);\r\n\tevent SetSellPrice(uint256 sellPrice);\r\n\r\n\tmodifier onlyOwnerOrOracle() {\r\n\t\trequire(isOwner(msg.sender) || msg.sender == oracleAddress, \"Auth\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyManyOwnersOrOracle(bytes32 _operation) {\r\n\t\tif (confirmAndCheck(_operation) || msg.sender == oracleAddress)\r\n\t\t\t_;\r\n\t\t// Don't throw here since confirmAndCheck needs to preserve state.\r\n\t}\r\n\r\n\tmodifier canTransfer() {\r\n\t\tif (!isOwner(msg.sender)) { // Owners are immuned from the transfer lock.\r\n\t\t\trequire(!transferLock, \"Locked\");\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier canPurchase() {\r\n\t\trequire(allowedToPurchase, \"Disallowed\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier canSell() {\r\n\t\trequire(allowedToBuyBack, \"Denied\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction() external payable {\r\n\t\tpurchase();\r\n\t}\r\n\r\n\tconstructor()\r\n\tmultiowned( initialSigners, 2) public {\r\n\t\trequire(isOwner(msg.sender), \"NaO\");\r\n\t\toldSprk = ERC20(oldSprkAddress);\r\n\t\towner = msg.sender;\r\n\t\tname = \"Sparkster\";\t\t\t\t\t\t\t\t\t// Set the name for display purposes\r\n\t\tdecimals = 18;\t\t\t\t\t // Amount of decimals for display purposes\r\n\t\tsymbol = \"SPRK\";\t\t\t\t\t\t\t// Set the symbol for display purposes\r\n\t\tmaxGasPrice = 40 * 10**9; // Set max gas to 40 Gwei to start with.\r\n\t\tuint256 amount = 435000000;\r\n\t\tuint256 decimalAmount = amount.mul(uint(10)**decimals);\r\n\t\ttotalSupply_ = decimalAmount;\r\n\t\tbalances[msg.sender] = decimalAmount;\r\n\t\temit Transfer(address(0), msg.sender, decimalAmount); // Per erc20 standards-compliance.\r\n\t}\r\n\r\n\tfunction swapTokens() public canTransfer returns(bool) {\r\n\t\trequire(msg.sender != address(this), \"Self\"); // Don't let this contract swap tokens with itself.\r\n\t\t// First, find out how much the sender has allowed us to spend. This is the amount of Sprk we're allowed to move.\r\n\t\t// Sender can set this value by calling increaseApproval on the old contract.\r\n\t\tuint256 amountToTransfer = oldSprk.allowance(msg.sender, address(this));\r\n\t\trequire(amountToTransfer > 0, \"Amount==0\");\r\n\t\t// However many tokens we took away from the user in the old contract, give that amount in our new contract.\r\n\t\tbalances[msg.sender] = balances[msg.sender].add(amountToTransfer);\r\n\t\tbalances[owner] = balances[owner].sub(amountToTransfer);\r\n\t\t// Finally, transfer the old tokens away from the sender and to our address. This will effectively freeze the tokens because no one can transact on this contract's behalf except the contract.\r\n\t\trequire(oldSprk.transferFrom(msg.sender, address(this), amountToTransfer), \"Transfer\");\r\n\t\temit Transfer(owner, msg.sender, amountToTransfer);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction setOwnerAddress(address newAddress) public onlyManyOwners(keccak256(msg.data)) returns(bool) {\r\n\t\trequire(newAddress != address(0), \"Invl\");\r\n\t\trequire(newAddress != owner, \"Self\");\r\n\t\tuint256 oldOwnerBalance = balances[owner];\r\n\t\tbalances[newAddress] = balances[newAddress].add(oldOwnerBalance);\r\n\t\tbalances[owner] = 0;\r\n\t\temit Transfer(owner, newAddress, oldOwnerBalance);\r\n\t\towner = newAddress;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction setOracleAddress(address newAddress) public onlyManyOwners(keccak256(msg.data)) returns(bool) {\r\n\t\toracleAddress = newAddress;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction removeOracleAddress() public onlyOwner returns(bool) {\r\n\t\toracleAddress = address(0);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction setMaximumGasPrice(uint256 gweiPrice) public onlyManyOwners(keccak256(msg.data)) returns(bool) {\r\n\t\tmaxGasPrice = gweiPrice.mul(10**9); // Convert the gwei value to wei.\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction purchase() public canPurchase payable returns(bool) {\r\n\t\tMember storage memberRecord = members[msg.sender];\r\n\t\tGroup storage openGroup = groups[openGroupNumber];\r\n\t\trequire(openGroup.ratio > 0, \"Not initialized\"); // Group must be initialized.\r\n\t\tuint256 currentTimestamp = block.timestamp;\r\n\t\trequire(currentTimestamp >= openGroup.startTime && currentTimestamp <= openGroup.deadline, \"OOR\");\r\n\t\t// The timestamp must be greater than or equal to the start time and less than or equal to the deadline time\r\n\t\trequire(openGroup.state == GroupStates.none, \"State\");\r\n\t\t// Don't allow to purchase if we're in the middle of distributing, have already distributed, or have unlocked.\r\n\t\trequire(tx.gasprice <= maxGasPrice, \"Gas price\"); // Restrict maximum gas this transaction is allowed to consume.\r\n\t\tuint256 weiAmount = msg.value;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The amount purchased by the current member\r\n\t\t// Updated in purchaseCallbackOnAccept.\r\n\t\trequire(weiAmount >= 0.1 ether, \"Amount<0.1 ether\");\r\n\t\tuint256 weiTotal = openGroup.weiTotal.add(weiAmount); // Calculate total contribution of all members in this group.\r\n\t\t// WeiTotals are updated in purchaseCallbackOnAccept\r\n\t\trequire(weiTotal <= openGroup.cap, \"Cap exceeded\");\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check to see if accepting these funds will put us above the hard ether cap.\r\n\t\tuint256 userWeiTotal = memberRecord.weiBalance[openGroupNumber].add(weiAmount); // Calculate the total amount purchased by the current member\r\n\t\tif (!openGroup.exists[msg.sender]) { // Has this person not purchased on this group before?\r\n\t\t\topenGroup.addresses.push(msg.sender);\r\n\t\t\topenGroup.exists[msg.sender] = true;\r\n\t\t\tmemberRecord.groups.push(openGroupNumber);\r\n\t\t}\r\n\t\tif(currentTimestamp <= openGroup.phase1endTime){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t // whether the current timestamp is in the first phase\r\n\t\t\temit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, true);\r\n\t\t\treturn true;\r\n\t\t} else if (currentTimestamp <= openGroup.phase2endTime) { // Are we in phase 2?\r\n\t\t\trequire(userWeiTotal <= openGroup.max2, \"Phase2 cap exceeded\"); // Allow to contribute no more than max2 in phase 2.\r\n\t\t\temit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, false);\r\n\t\t\treturn true;\r\n\t\t} else { // We've passed both phases 1 and 2.\r\n\t\t\trequire(userWeiTotal <= openGroup.max3, \"Phase3 cap exceeded\"); // Don't allow to contribute more than max3 in phase 3.\r\n\t\t\temit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, false);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction purchaseCallbackOnAccept(\r\n\t\tuint256 groupNumber, address[] memory addresses, uint256[] memory weiAmounts)\r\n\tpublic onlyManyOwnersOrOracle(keccak256(msg.data)) returns(bool success) {\r\n\t\treturn accept(groupNumber, addresses, weiAmounts);\r\n\t}\r\n\r\n\t// Base function for accepts.\r\n\t// Calling functions should be multisig.\r\n\tfunction accept(\r\n\t\tuint256 groupNumber, address[] memory addresses, uint256[] memory weiAmounts)\r\n\tprivate onlyOwnerOrOracle returns(bool) {\r\n\t\tuint256 n = addresses.length;\r\n\t\trequire(n == weiAmounts.length, \"Length\");\r\n\t\tGroup storage theGroup = groups[groupNumber];\r\n\t\tuint256 weiTotal = theGroup.weiTotal;\r\n\t\tfor (uint256 i = 0; i < n; i++) {\r\n\t\t\tMember storage memberRecord = members[addresses[i]];\r\n\t\t\tuint256 weiAmount = weiAmounts[i];\r\n\t\t\tweiTotal = weiTotal.add(weiAmount);\t\t\t\t\t\t\t\t // Calculate the total amount purchased by all members in this group.\r\n\t\t\tmemberRecord.weiBalance[groupNumber] = memberRecord.weiBalance[groupNumber].add(weiAmount);\r\n\t\t\t// Record the total amount purchased by the current member\r\n\t\t}\r\n\t\ttheGroup.weiTotal = weiTotal;\r\n\t\tif (getHowMuchUntilHardCap_(groupNumber) <= 100 ether) {\r\n\t\t\temit NearingHardCap(groupNumber, getHowMuchUntilHardCap_(groupNumber));\r\n\t\t\tif (weiTotal >= theGroup.cap) {\r\n\t\t\t\temit ReachedHardCap(groupNumber);\r\n\t\t\t}\r\n\t\t}\r\n\t\temit PurchasedCallbackOnAccept(groupNumber, addresses);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction insertAndApprove(uint256 groupNumber, address[] memory addresses, uint256[] memory weiAmounts)\r\n\tpublic onlyManyOwnersOrOracle(keccak256(msg.data)) returns(bool) {\r\n\t\tuint256 n = addresses.length;\r\n\t\trequire(n == weiAmounts.length, \"Length\");\r\n\t\tGroup storage theGroup = groups[groupNumber];\r\n\t\tfor (uint256 i = 0; i < n; i++) {\r\n\t\t\taddress theAddress = addresses[i];\r\n\t\t\tif (!theGroup.exists[theAddress]) {\r\n\t\t\t\ttheGroup.addresses.push(theAddress);\r\n\t\t\t\ttheGroup.exists[theAddress] = true;\r\n\t\t\t\tmembers[theAddress].groups.push(groupNumber);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn accept(groupNumber, addresses, weiAmounts);\r\n\t}\r\n\r\n\tfunction callbackInsertApproveAndDistribute(\r\n\t\tuint256 groupNumber, address[] memory addresses, uint256[] memory weiAmounts)\r\n\tpublic onlyManyOwnersOrOracle(keccak256(msg.data)) returns(bool) {\r\n\t\tuint256 n = addresses.length;\r\n\t\trequire(n == weiAmounts.length, \"Length\");\r\n\t\trequire(getGroupState(groupNumber) != GroupStates.unlocked, \"Unlocked\");\r\n\t\tGroup storage theGroup = groups[groupNumber];\r\n\t\tuint256 newOwnerSupply = balances[owner];\r\n\t\tfor (uint256 i = 0; i < n; i++) {\r\n\t\t\taddress theAddress = addresses[i];\r\n\t\t\tMember storage memberRecord = members[theAddress];\r\n\t\t\tuint256 weiAmount = weiAmounts[i];\r\n\t\t\tmemberRecord.weiBalance[groupNumber] = memberRecord.weiBalance[groupNumber].add(weiAmount);\r\n\t\t\t// Record the total amount purchased by the current member\r\n\t\t\tif (!theGroup.exists[theAddress]) {\r\n\t\t\t\ttheGroup.addresses.push(theAddress);\r\n\t\t\t\ttheGroup.exists[theAddress] = true;\r\n\t\t\t\tmemberRecord.groups.push(groupNumber);\r\n\t\t\t}\r\n\t\t\tuint256 additionalBalance = weiAmount.mul(theGroup.ratio); // Don't give cumulative tokens; one address can be distributed multiple times.\r\n\t\t\tif (additionalBalance > 0) {\r\n\t\t\t\tbalances[theAddress] = balances[theAddress].add(additionalBalance);\r\n\t\t\t\tnewOwnerSupply = newOwnerSupply.sub(additionalBalance); // Update the available number of tokens.\r\n\t\t\t\temit Transfer(owner, theAddress, additionalBalance); // Notify exchanges of the distribution.\r\n\t\t\t}\r\n\t\t}\r\n\t\tbalances[owner] = newOwnerSupply;\r\n\t\temit PurchasedCallbackOnAccept(groupNumber, addresses);\r\n\t\tif (getGroupState(groupNumber) != GroupStates.distributed)\r\n\t\t\ttheGroup.state = GroupStates.distributed;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getWithdrawableAmount() public view returns(uint256) {\r\n\t\treturn withdrawableBalances[msg.sender];\r\n\t}\r\n\r\n\tfunction withdraw() public returns (bool) {\r\n\t\tuint256 amount = withdrawableBalances[msg.sender];\r\n\t\trequire(amount > 0, \"NSF\");\r\n\t\twithdrawableBalances[msg.sender] = 0;\r\n\t\tminimumRequiredBalance = minimumRequiredBalance.sub(amount);\r\n\t\tmsg.sender.transfer(amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction refund(address[] memory addresses, uint256[] memory weiAmounts) public onlyManyOwners(keccak256(msg.data)) returns(bool success) {\r\n\t\tuint256 n = addresses.length;\r\n\t\trequire (n == weiAmounts.length, \"Length\");\r\n\t\tuint256 thePenalty = penalty;\r\n\t\tuint256 totalRefund = 0;\r\n\t\tfor(uint256 i = 0; i < n; i++) {\r\n\t\t\tuint256 weiAmount = weiAmounts[i];\r\n\t\t\taddress payable theAddress = address(uint160(address(addresses[i])));\r\n\t\t\tif (thePenalty < weiAmount) {\r\n\t\t\t\tweiAmount = weiAmount.sub(thePenalty);\r\n\t\t\t\ttotalRefund = totalRefund.add(weiAmount);\r\n\t\t\t\twithdrawableBalances[theAddress] = withdrawableBalances[theAddress].add(weiAmount);\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(address(this).balance >= minimumRequiredBalance + totalRefund, \"NSF\"); // The contract must have enough to refund these addresses.\r\n\t\tminimumRequiredBalance = minimumRequiredBalance.add(totalRefund);\r\n\t\temit RefundedBatch(addresses);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction signalDoneDistributing(uint256 groupNumber) public onlyManyOwnersOrOracle(keccak256(msg.data)) {\r\n\t\tGroup storage theGroup = groups[groupNumber];\r\n\t\ttheGroup.state = GroupStates.distributed;\r\n\t\temit DistributeDone(groupNumber);\r\n\t}\r\n\r\n\tfunction drain(address payable to) public onlyManyOwners(keccak256(msg.data)) returns(bool) {\r\n\t\tuint256 amountAllowedToDrain = address(this).balance.sub(minimumRequiredBalance);\r\n\t\trequire(amountAllowedToDrain > 0, \"NSF\");\r\n\t\tto.transfer(amountAllowedToDrain);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction setPenalty(uint256 newPenalty) public onlyManyOwners(keccak256(msg.data)) returns(bool) {\r\n\t\tpenalty = newPenalty;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction buyback(uint256 amount) public canSell {\r\n\t\trequire(sellPrice>0, \"sellPrice==0\");\r\n\t\tuint256 decimalAmount = amount.mul(uint(10)**decimals); // convert the full token value to the smallest unit possible.\r\n\t\trequire(balances[msg.sender].sub(decimalAmount) >= getLockedTokens_(msg.sender), \"NSF\"); // Don't allow to sell locked tokens.\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(decimalAmount);\r\n\t\t// Amount is considered to be how many full tokens the user wants to sell.\r\n\t\tuint256 totalCost = amount.mul(sellPrice); // sellPrice is the per-full-token value.\r\n\t\tminimumRequiredBalance = minimumRequiredBalance.add(totalCost);\r\n\t\trequire(address(this).balance >= minimumRequiredBalance, \"NSF\"); // The contract must have enough funds to cover the selling.\r\n\t\tbalances[owner] = balances[owner].add(decimalAmount); // Put these tokens back into the available pile.\r\n\t\twithdrawableBalances[msg.sender] = withdrawableBalances[msg.sender].add(totalCost); // Pay the seller for their tokens.\r\n\t\temit Transfer(msg.sender, owner, decimalAmount); // Notify exchanges of the sell.\r\n\t}\r\n\r\n\tfunction fundContract() public onlyOwnerOrOracle payable { // For the owner to put funds into the contract.\r\n\t}\r\n\r\n\tfunction setSellPrice(uint256 thePrice) public onlyManyOwners(keccak256(msg.data)) returns (bool) {\r\n\t\tsellPrice = thePrice;\r\n\t\temit SetSellPrice(thePrice);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction setAllowedToBuyBack(bool value) public onlyManyOwners(keccak256(msg.data)) {\r\n\t\tallowedToBuyBack = value;\r\n\t\temit ChangedAllowedToBuyBack(value);\r\n\t}\r\n\r\n\tfunction setAllowedToPurchase(bool value) public onlyManyOwners(keccak256(msg.data)) returns(bool) {\r\n\t\tallowedToPurchase = value;\r\n\t\temit ChangedAllowedToPurchase(value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction createGroup(\r\n\t\tstring memory groupName, uint256 startEpoch, uint256 phase1endEpoch, uint256 phase2endEpoch, uint256 deadlineEpoch,\r\n\t\tuint256 unlockAfterEpoch, uint256 phase2weiCap, uint256 phase3weiCap, uint256 hardWeiCap, uint256 ratio) public\r\n\tonlyManyOwners(keccak256(msg.data)) returns (bool success, uint256 createdGroupNumber) {\r\n\t\trequire(nextGroupNumber < maxGroups, \"Too many groups\");\r\n\t\tcreatedGroupNumber = nextGroupNumber;\r\n\t\tGroup storage theGroup = groups[createdGroupNumber];\r\n\t\ttheGroup.name = groupName;\r\n\t\ttheGroup.startTime = startEpoch;\r\n\t\ttheGroup.phase1endTime = phase1endEpoch;\r\n\t\ttheGroup.phase2endTime = phase2endEpoch;\r\n\t\ttheGroup.deadline = deadlineEpoch;\r\n\t\ttheGroup.unlockTime = unlockAfterEpoch;\r\n\t\ttheGroup.max2 = phase2weiCap;\r\n\t\ttheGroup.max3 = phase3weiCap;\r\n\t\ttheGroup.cap = hardWeiCap;\r\n\t\ttheGroup.ratio = ratio;\r\n\t\tnextGroupNumber++;\r\n\t\tsuccess = true;\r\n\t}\r\n\r\n\tfunction getGroup(uint256 groupNumber) public view returns(string memory groupName, string memory status, uint256 phase2cap,\r\n\tuint256 phase3cap, uint256 cap, uint256 ratio, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline,\r\n\tuint256 weiTotal) {\r\n\t\trequire(groupNumber < nextGroupNumber, \"OOR\");\r\n\t\tGroup storage theGroup = groups[groupNumber];\r\n\t\tgroupName = theGroup.name;\r\n\t\tGroupStates state = getGroupState(groupNumber);\r\n\t\tstatus = (state == GroupStates.none)? \"none\"\r\n\t\t:(state == GroupStates.distributing)? \"distributing\"\r\n\t\t:(state == GroupStates.distributed)? \"distributed\":\"unlocked\";\r\n\t\tphase2cap = theGroup.max2;\r\n\t\tphase3cap = theGroup.max3;\r\n\t\tcap = theGroup.cap;\r\n\t\tratio = theGroup.ratio;\r\n\t\tstartTime = theGroup.startTime;\r\n\t\tphase1endTime = theGroup.phase1endTime;\r\n\t\tphase2endTime = theGroup.phase2endTime;\r\n\t\tdeadline = theGroup.deadline;\r\n\t\tweiTotal = theGroup.weiTotal;\r\n\t}\r\n\r\n\tfunction getGroupUnlockTime(uint256 groupNumber) public view returns(uint256) {\r\n\t\trequire(groupNumber < nextGroupNumber, \"OOR\");\r\n\t\tGroup storage theGroup = groups[groupNumber];\r\n\t\treturn theGroup.unlockTime;\r\n\t}\r\n\r\n\tfunction getHowMuchUntilHardCap_(uint256 groupNumber) internal view returns(uint256) {\r\n\t\tGroup storage theGroup = groups[groupNumber];\r\n\t\tif (theGroup.weiTotal > theGroup.cap) { // calling .sub in this situation will throw.\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn theGroup.cap.sub(theGroup.weiTotal);\r\n\t}\r\n\r\n\tfunction getHowMuchUntilHardCap() public view returns(uint256) {\r\n\t\treturn getHowMuchUntilHardCap_(openGroupNumber);\r\n\t}\r\n\r\n\tfunction addMemberToGroup(address walletAddress, uint256 groupNumber) public onlyOwner returns(bool) {\r\n\t\temit AddToGroup(walletAddress, groupNumber);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction instructOracleToDistribute(uint256 groupNumber) public onlyOwnerOrOracle returns(bool) {\r\n\t\trequire(groupNumber < nextGroupNumber && getGroupState(groupNumber) < GroupStates.distributed, \"Dist\");\r\n\t\temit WantsToDistribute(groupNumber);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction distributeCallback(uint256 groupNumber, uint256 howMany) public onlyManyOwnersOrOracle(keccak256(msg.data)) returns (bool success) {\r\n\t\tGroup storage theGroup = groups[groupNumber];\r\n\t\tGroupStates state = getGroupState(groupNumber);\r\n\t\trequire(state < GroupStates.distributed, \"Dist\");\r\n\t\tif (state != GroupStates.distributing) {\r\n\t\t\ttheGroup.state = GroupStates.distributing;\r\n\t\t}\r\n\t\tuint256 n = theGroup.addresses.length;\r\n\t\tuint256 nextDistributionIndex = theGroup.nextDistributionIndex;\r\n\t\tuint256 exclusiveEndIndex = nextDistributionIndex + howMany;\r\n\t\tif (exclusiveEndIndex > n) {\r\n\t\t\texclusiveEndIndex = n;\r\n\t\t}\r\n\t\tuint256 newOwnerSupply = balances[owner];\r\n\t\tfor (uint256 i = nextDistributionIndex; i < exclusiveEndIndex; i++) {\r\n\t\t\taddress theAddress = theGroup.addresses[i];\r\n\t\t\tuint256 balance = getUndistributedBalanceOf_(theAddress, groupNumber);\r\n\t\t\tif (balance > 0) { // No need to waste ticks if they have no tokens to distribute\r\n\t\t\t\tbalances[theAddress] = balances[theAddress].add(balance);\r\n\t\t\t\tnewOwnerSupply = newOwnerSupply.sub(balance); // Update the available number of tokens.\r\n\t\t\t\temit Transfer(owner, theAddress, balance); // Notify exchanges of the distribution.\r\n\t\t\t}\r\n\t\t}\r\n\t\tbalances[owner] = newOwnerSupply;\r\n\t\tif (exclusiveEndIndex < n) {\r\n\t\t\temit DistributedBatch(groupNumber, howMany);\r\n\t\t} else { // We've finished distributing people\r\n\t\t\t// However, signalDoneDistributing needs to be manually called since it's multisig. So if we're calling this function from multiple owners then calling signalDoneDistributing from here won't work.\r\n\t\t\temit ShouldCallDoneDistributing();\r\n\t\t}\r\n\t\ttheGroup.nextDistributionIndex = exclusiveEndIndex; // Usually not necessary if we've finished distribution,\r\n\t\t// but if we don't update this, getHowManyLeftToDistribute will never show 0.\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getHowManyLeftToDistribute(uint256 groupNumber) public view returns(uint256 remainder) {\r\n\t\tGroup storage theGroup = groups[groupNumber];\r\n\t\treturn theGroup.addresses.length - theGroup.nextDistributionIndex;\r\n\t}\r\n\r\n\tfunction unlock(uint256 groupNumber) public onlyManyOwners(keccak256(msg.data)) returns (bool success) {\r\n\t\tGroup storage theGroup = groups[groupNumber];\r\n\t\trequire(getGroupState(groupNumber) == GroupStates.distributed, \"Undist\"); // Distribution must have occurred first.\r\n\t\trequire(theGroup.unlockTime == 0, \"Unlocktime\");\r\n\t\t// If the group has set an explicit unlock time, the admins cannot force an unlock and the unlock will happen automatically.\r\n\t\ttheGroup.state = GroupStates.unlocked;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction liftGlobalLock() public onlyManyOwners(keccak256(msg.data)) returns(bool) {\r\n\t\ttransferLock = false;\r\n\t\temit ChangedTransferLock(transferLock);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction airdrop( address[] memory addresses, uint256[] memory tokenDecimalAmounts) public onlyManyOwnersOrOracle(keccak256(msg.data))\r\n\treturns (bool) {\r\n\t\tuint256 n = addresses.length;\r\n\t\trequire(n == tokenDecimalAmounts.length, \"Length\");\r\n\t\tuint256 newOwnerBalance = balances[owner];\r\n\t\tfor (uint256 i = 0; i < n; i++) {\r\n\t\t\taddress theAddress = addresses[i];\r\n\t\t\tuint256 airdropAmount = tokenDecimalAmounts[i];\r\n\t\t\tif (airdropAmount > 0) {\r\n\t\t\t\tuint256 currentBalance = balances[theAddress];\r\n\t\t\t\tbalances[theAddress] = currentBalance.add(airdropAmount);\r\n\t\t\t\tnewOwnerBalance = newOwnerBalance.sub(airdropAmount);\r\n\t\t\t\temit Transfer(owner, theAddress, airdropAmount);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbalances[owner] = newOwnerBalance;\r\n\t\temit AirdroppedBatch(addresses);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint256 _value) public canTransfer returns (bool success) {\r\n\t\t// If the transferrer has purchased tokens, they must be unlocked before they can be used.\r\n\t\trequire(balances[msg.sender].sub(_value) >= getLockedTokens_(msg.sender), \"Not enough tokens\");\r\n\t\treturn super.transfer(_to, _value);\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public canTransfer returns (bool success) {\r\n\t\t// If the transferrer has purchased tokens, they must be unlocked before they can be used.\r\n\t\trequire(balances[_from].sub(_value) >= getLockedTokens_(_from), \"Not enough tokens\");\r\n\t\treturn super.transferFrom(_from, _to, _value);\r\n\t}\r\n\r\n\tfunction setOpenGroup(uint256 groupNumber) public onlyManyOwners(keccak256(msg.data)) returns (bool) {\r\n\t\trequire(groupNumber < nextGroupNumber, \"OOR\");\r\n\t\topenGroupNumber = groupNumber;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getGroupState(uint256 groupNumber) public view returns(GroupStates) {\r\n\t\trequire(groupNumber < nextGroupNumber, \"out of range\"); // Must have created at least one group.\r\n\t\tGroup storage theGroup = groups[groupNumber];\r\n\t\tif (theGroup.state < GroupStates.distributed)\r\n\t\t\treturn theGroup.state;\r\n\t\t// Here, we have two cases.\r\n\t\t// If this is a time-based group, tokens will only unlock after a certain time. Otherwise, we depend on the group's state being set to unlock.\r\n\t\tif (block.timestamp < theGroup.unlockTime)\r\n\t\t\treturn GroupStates.distributed;\r\n\t\telse if (theGroup.unlockTime > 0) // Here, blocktime exceeds the group unlock time, and we've set an unlock time explicitly\r\n\t\t\treturn GroupStates.unlocked;\r\n\t\treturn theGroup.state;\r\n\t}\r\n\r\n\tfunction getLockedTokensInGroup_(address walletAddress, uint256 groupNumber) internal view returns (uint256 balance) {\r\n\t\tMember storage theMember = members[walletAddress];\r\n\t\tif (getGroupState(groupNumber) == GroupStates.unlocked) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn theMember.weiBalance[groupNumber].mul(groups[groupNumber].ratio);\r\n\t}\r\n\r\n\tfunction getLockedTokens_(address walletAddress) internal view returns(uint256 balance) {\r\n\t\tuint256[] storage memberGroups = members[walletAddress].groups;\r\n\t\tuint256 n = memberGroups.length;\r\n\t\tfor (uint256 i = 0; i < n; i++) {\r\n\t\t\tbalance = balance.add(getLockedTokensInGroup_(walletAddress, memberGroups[i]));\r\n\t\t}\r\n\t\treturn balance;\r\n\t}\r\n\r\n\tfunction getLockedTokens(address walletAddress) public view returns(uint256 balance) {\r\n\t\treturn getLockedTokens_(walletAddress);\r\n\t}\r\n\r\n\tfunction getUndistributedBalanceOf_(address walletAddress, uint256 groupNumber) internal view returns (uint256 balance) {\r\n\t\tMember storage theMember = members[walletAddress];\r\n\t\tGroup storage theGroup = groups[groupNumber];\r\n\t\tif (getGroupState(groupNumber) > GroupStates.distributing) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn theMember.weiBalance[groupNumber].mul(theGroup.ratio);\r\n\t}\r\n\r\n\tfunction getUndistributedBalanceOf(address walletAddress, uint256 groupNumber) public view returns (uint256 balance) {\r\n\t\treturn getUndistributedBalanceOf_(walletAddress, groupNumber);\r\n\t}\r\n\r\n\tfunction checkMyUndistributedBalance(uint256 groupNumber) public view returns (uint256 balance) {\r\n\t\treturn getUndistributedBalanceOf_(msg.sender, groupNumber);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"signalDoneDistributing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"penalty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"},{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"weiAmounts\",\"type\":\"uint256[]\"}],\"name\":\"purchaseCallbackOnAccept\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"checkMyUndistributedBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"setOpenGroup\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setOwnerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"getGroupUnlockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxGasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"instructOracleToDistribute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowedToPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPenalty\",\"type\":\"uint256\"}],\"name\":\"setPenalty\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amIOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"walletAddress\",\"type\":\"address\"},{\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"getUndistributedBalanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"walletAddress\",\"type\":\"address\"},{\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"addMemberToGroup\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"unlock\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHowMuchUntilHardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"tokenDecimalAmounts\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"getLockedTokens\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openGroupNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"liftGlobalLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"swapTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_multiOwnedRequired\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gweiPrice\",\"type\":\"uint256\"}],\"name\":\"setMaximumGasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumRequiredBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"},{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"weiAmounts\",\"type\":\"uint256[]\"}],\"name\":\"insertAndApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowedToBuyBack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAllowedToBuyBack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWithdrawableAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"getGroupState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"getHowManyLeftToDistribute\",\"outputs\":[{\"name\":\"remainder\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fundContract\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"weiAmounts\",\"type\":\"uint256[]\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ownerIndex\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"getGroup\",\"outputs\":[{\"name\":\"groupName\",\"type\":\"string\"},{\"name\":\"status\",\"type\":\"string\"},{\"name\":\"phase2cap\",\"type\":\"uint256\"},{\"name\":\"phase3cap\",\"type\":\"uint256\"},{\"name\":\"cap\",\"type\":\"uint256\"},{\"name\":\"ratio\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"phase1endTime\",\"type\":\"uint256\"},{\"name\":\"phase2endTime\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"},{\"name\":\"weiTotal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldSprkAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"},{\"name\":\"howMany\",\"type\":\"uint256\"}],\"name\":\"distributeCallback\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"drain\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAllowedToPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"groupName\",\"type\":\"string\"},{\"name\":\"startEpoch\",\"type\":\"uint256\"},{\"name\":\"phase1endEpoch\",\"type\":\"uint256\"},{\"name\":\"phase2endEpoch\",\"type\":\"uint256\"},{\"name\":\"deadlineEpoch\",\"type\":\"uint256\"},{\"name\":\"unlockAfterEpoch\",\"type\":\"uint256\"},{\"name\":\"phase2weiCap\",\"type\":\"uint256\"},{\"name\":\"phase3weiCap\",\"type\":\"uint256\"},{\"name\":\"hardWeiCap\",\"type\":\"uint256\"},{\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"createGroup\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"createdGroupNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"thePrice\",\"type\":\"uint256\"}],\"name\":\"setSellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"groupNumber\",\"type\":\"uint256\"},{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"weiAmounts\",\"type\":\"uint256[]\"}],\"name\":\"callbackInsertApproveAndDistribute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"groupNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"inPhase1\",\"type\":\"bool\"}],\"name\":\"WantsToPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"groupNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"PurchasedCallbackOnAccept\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"WantsToDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"groupNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remainder\",\"type\":\"uint256\"}],\"name\":\"NearingHardCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"ReachedHardCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"DistributeDone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"groupNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"howMany\",\"type\":\"uint256\"}],\"name\":\"DistributedBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ShouldCallDoneDistributing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"AirdroppedBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"RefundedBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"groupNumber\",\"type\":\"uint256\"}],\"name\":\"AddToGroup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"transferLock\",\"type\":\"bool\"}],\"name\":\"ChangedTransferLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"allowedToPurchase\",\"type\":\"bool\"}],\"name\":\"ChangedAllowedToPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"allowedToBuyBack\",\"type\":\"bool\"}],\"name\":\"ChangedAllowedToBuyBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sellPrice\",\"type\":\"uint256\"}],\"name\":\"SetSellPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"FinalConfirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"SparksterTokenSwap","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://51c675acba13b99ff36c7e833152245fe6ec52822c43d15a3713c6014ed7abbf"}]}