{"status":"1","message":"OK","result":[{"SourceCode":"MIN_DEPOSIT_AMOUNT: constant(uint256) = 1000000000  # Gwei\r\nDEPOSIT_CONTRACT_TREE_DEPTH: constant(uint256) = 32\r\nMAX_DEPOSIT_COUNT: constant(uint256) = 4294967295 # 2**DEPOSIT_CONTRACT_TREE_DEPTH - 1\r\nPUBKEY_LENGTH: constant(uint256) = 48  # bytes\r\nWITHDRAWAL_CREDENTIALS_LENGTH: constant(uint256) = 32  # bytes\r\nAMOUNT_LENGTH: constant(uint256) = 8  # bytes\r\nSIGNATURE_LENGTH: constant(uint256) = 96  # bytes\r\n\r\nDepositEvent: event({\r\n    pubkey: bytes[48],\r\n    withdrawal_credentials: bytes[32],\r\n    amount: bytes[8],\r\n    signature: bytes[96],\r\n    index: bytes[8],\r\n})\r\n\r\nbranch: bytes32[DEPOSIT_CONTRACT_TREE_DEPTH]\r\ndeposit_count: uint256\r\n\r\n# Compute hashes in empty sparse Merkle tree\r\nzero_hashes: bytes32[DEPOSIT_CONTRACT_TREE_DEPTH]\r\n@public\r\ndef __init__():\r\n    for i in range(DEPOSIT_CONTRACT_TREE_DEPTH - 1):\r\n        self.zero_hashes[i + 1] = sha256(concat(self.zero_hashes[i], self.zero_hashes[i]))\r\n\r\n\r\n@private\r\n@constant\r\ndef to_little_endian_64(value: uint256) -> bytes[8]:\r\n    # Reversing bytes using bitwise uint256 manipulations\r\n    # Note: array accesses of bytes[] are not currently supported in Vyper\r\n    # Note: this function is only called when `value < 2**64`\r\n    y: uint256 = 0\r\n    x: uint256 = value\r\n    for _ in range(8):\r\n        y = shift(y, 8)\r\n        y = y + bitwise_and(x, 255)\r\n        x = shift(x, -8)\r\n    return slice(convert(y, bytes32), start=24, len=8)\r\n\r\n\r\n@public\r\n@constant\r\ndef get_hash_tree_root() -> bytes32:\r\n    zero_bytes32: bytes32 = 0x0000000000000000000000000000000000000000000000000000000000000000\r\n    node: bytes32 = zero_bytes32\r\n    size: uint256 = self.deposit_count\r\n    for height in range(DEPOSIT_CONTRACT_TREE_DEPTH):\r\n        if bitwise_and(size, 1) == 1:  # More gas efficient than `size % 2 == 1`\r\n            node = sha256(concat(self.branch[height], node))\r\n        else:\r\n            node = sha256(concat(node, self.zero_hashes[height]))\r\n        size /= 2\r\n    return sha256(concat(node, self.to_little_endian_64(self.deposit_count), slice(zero_bytes32, start=0, len=24)))\r\n\r\n\r\n@public\r\n@constant\r\ndef get_deposit_count() -> bytes[8]:\r\n    return self.to_little_endian_64(self.deposit_count)\r\n\r\n\r\n@payable\r\n@public\r\ndef deposit(pubkey: bytes[PUBKEY_LENGTH],\r\n            withdrawal_credentials: bytes[WITHDRAWAL_CREDENTIALS_LENGTH],\r\n            signature: bytes[SIGNATURE_LENGTH]):\r\n    # Avoid overflowing the Merkle tree (and prevent edge case in computing `self.branch`)\r\n    assert self.deposit_count < MAX_DEPOSIT_COUNT\r\n\r\n    # Validate deposit data\r\n    deposit_amount: uint256 = msg.value / as_wei_value(1, \"gwei\")\r\n    assert deposit_amount >= MIN_DEPOSIT_AMOUNT\r\n    assert len(pubkey) == PUBKEY_LENGTH\r\n    assert len(withdrawal_credentials) == WITHDRAWAL_CREDENTIALS_LENGTH\r\n    assert len(signature) == SIGNATURE_LENGTH\r\n\r\n    # Emit `DepositEvent` log\r\n    amount: bytes[8] = self.to_little_endian_64(deposit_amount)\r\n    log.DepositEvent(pubkey, withdrawal_credentials, amount, signature, self.to_little_endian_64(self.deposit_count))\r\n\r\n    # Compute `DepositData` hash tree root\r\n    zero_bytes32: bytes32 = 0x0000000000000000000000000000000000000000000000000000000000000000\r\n    pubkey_root: bytes32 = sha256(concat(pubkey, slice(zero_bytes32, start=0, len=64 - PUBKEY_LENGTH)))\r\n    signature_root: bytes32 = sha256(concat(\r\n        sha256(slice(signature, start=0, len=64)),\r\n        sha256(concat(slice(signature, start=64, len=SIGNATURE_LENGTH - 64), zero_bytes32)),\r\n    ))\r\n    node: bytes32 = sha256(concat(\r\n        sha256(concat(pubkey_root, withdrawal_credentials)),\r\n        sha256(concat(amount, slice(zero_bytes32, start=0, len=32 - AMOUNT_LENGTH), signature_root)),\r\n    ))\r\n\r\n    # Add `DepositData` hash tree root to Merkle tree (update a single `branch` node)\r\n    self.deposit_count += 1\r\n    size: uint256 = self.deposit_count\r\n    for height in range(DEPOSIT_CONTRACT_TREE_DEPTH):\r\n        if bitwise_and(size, 1) == 1:  # More gas efficient than `size % 2 == 1`\r\n            self.branch[height] = node\r\n            break\r\n        node = sha256(concat(self.branch[height], node))\r\n        size /= 2","ABI":"[{\"name\":\"DepositEvent\",\"inputs\":[{\"type\":\"bytes\",\"name\":\"pubkey\",\"indexed\":false},{\"type\":\"bytes\",\"name\":\"withdrawal_credentials\",\"indexed\":false},{\"type\":\"bytes\",\"name\":\"amount\",\"indexed\":false},{\"type\":\"bytes\",\"name\":\"signature\",\"indexed\":false},{\"type\":\"bytes\",\"name\":\"index\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"constructor\"},{\"name\":\"get_hash_tree_root\",\"outputs\":[{\"type\":\"bytes32\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":91674},{\"name\":\"get_deposit_count\",\"outputs\":[{\"type\":\"bytes\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":10433},{\"name\":\"deposit\",\"outputs\":[],\"inputs\":[{\"type\":\"bytes\",\"name\":\"pubkey\"},{\"type\":\"bytes\",\"name\":\"withdrawal_credentials\"},{\"type\":\"bytes\",\"name\":\"signature\"}],\"constant\":false,\"payable\":true,\"type\":\"function\",\"gas\":1334417}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.1.0b9","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":""}]}