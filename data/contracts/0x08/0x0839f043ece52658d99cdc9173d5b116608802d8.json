{"status":"1","message":"OK","result":[{"SourceCode":"// File: SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: ERC20.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n/// @title ERC20 interface is a subset of the ERC20 specification.\r\n/// @notice see https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function balanceOf(address _who) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\n// File: Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: SafeERC20.sol\r\n\r\n/**\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2016-2019 zOS Global Limited\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(ERC20 token, bytes memory data) internal {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: ownable.sol\r\n\r\n/**\r\n *  Ownable - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n/// @title Ownable has an owner address and provides basic authorization control functions.\r\n/// This contract is modified version of the MIT OpenZepplin Ownable contract\r\n/// This contract allows for the transferOwnership operation to be made impossible\r\n/// https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\ncontract Ownable {\r\n    event TransferredOwnership(address _from, address _to);\r\n    event LockedOwnership(address _locked);\r\n\r\n    address payable private _owner;\r\n    bool private _isTransferable;\r\n\r\n    /// @notice Constructor sets the original owner of the contract and whether or not it is one time transferable.\r\n    constructor(address payable _account_, bool _transferable_) internal {\r\n        _owner = _account_;\r\n        _isTransferable = _transferable_;\r\n        // Emit the LockedOwnership event if no longer transferable.\r\n        if (!_isTransferable) {\r\n            emit LockedOwnership(_account_);\r\n        }\r\n        emit TransferredOwnership(address(0), _account_);\r\n    }\r\n\r\n    /// @notice Reverts if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(_isOwner(msg.sender), \"sender is not an owner\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a new address.\r\n    /// @param _account address to transfer ownership to.\r\n    /// @param _transferable indicates whether to keep the ownership transferable.\r\n    function transferOwnership(address payable _account, bool _transferable) external onlyOwner {\r\n        // Require that the ownership is transferable.\r\n        require(_isTransferable, \"ownership is not transferable\");\r\n        // Require that the new owner is not the zero address.\r\n        require(_account != address(0), \"owner cannot be set to zero address\");\r\n        // Set the transferable flag to the value _transferable passed in.\r\n        _isTransferable = _transferable;\r\n        // Emit the LockedOwnership event if no longer transferable.\r\n        if (!_transferable) {\r\n            emit LockedOwnership(_account);\r\n        }\r\n        // Emit the ownership transfer event.\r\n        emit TransferredOwnership(_owner, _account);\r\n        // Set the owner to the provided address.\r\n        _owner = _account;\r\n    }\r\n\r\n    /// @notice check if the ownership is transferable.\r\n    /// @return true if the ownership is transferable.\r\n    function isTransferable() external view returns (bool) {\r\n        return _isTransferable;\r\n    }\r\n\r\n    /// @notice Allows the current owner to relinquish control of the contract.\r\n    /// @dev Renouncing to ownership will leave the contract without an owner and unusable.\r\n    /// @dev It will not be possible to call the functions with the `onlyOwner` modifier anymore.\r\n    function renounceOwnership() external onlyOwner {\r\n        // Require that the ownership is transferable.\r\n        require(_isTransferable, \"ownership is not transferable\");\r\n        // note that this could be terminal\r\n        _owner = address(0);\r\n\r\n        emit TransferredOwnership(_owner, address(0));\r\n    }\r\n\r\n    /// @notice Find out owner address\r\n    /// @return address of the owner.\r\n    function owner() public view returns (address payable) {\r\n        return _owner;\r\n    }\r\n\r\n    /// @notice Check if owner address\r\n    /// @return true if sender is the owner of the contract.\r\n    function _isOwner(address _address) internal view returns (bool) {\r\n        return _address == _owner;\r\n    }\r\n}\r\n\r\n// File: transferrable.sol\r\n\r\n/**\r\n *  Transferrable - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n/// @title SafeTransfer, allowing contract to withdraw tokens accidentally sent to itself\r\ncontract Transferrable {\r\n\r\n    using SafeERC20 for ERC20;\r\n\r\n\r\n    /// @dev This function is used to move tokens sent accidentally to this contract method.\r\n    /// @dev The owner can chose the new destination address\r\n    /// @param _to is the recipient's address.\r\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\r\n    /// @param _amount is the amount to be transferred in base units.\r\n    function _safeTransfer(address payable _to, address _asset, uint _amount) internal {\r\n        // address(0) is used to denote ETH\r\n        if (_asset == address(0)) {\r\n            _to.transfer(_amount);\r\n        } else {\r\n            ERC20(_asset).safeTransfer(_to, _amount);\r\n        }\r\n    }\r\n}\r\n\r\n// File: controller.sol\r\n\r\n/**\r\n *  Controller - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n/// @title The IController interface provides access to the isController and isAdmin checks.\r\ninterface IController {\r\n    function isController(address) external view returns (bool);\r\n    function isAdmin(address) external view returns (bool);\r\n}\r\n\r\n\r\n/// @title Controller stores a list of controller addresses that can be used for authentication in other contracts.\r\n/// @notice The Controller implements a hierarchy of concepts, Owner, Admin, and the Controllers.\r\n/// @dev Owner can change the Admins\r\n/// @dev Admins and can the Controllers\r\n/// @dev Controllers are used by the application.\r\ncontract Controller is IController, Ownable, Transferrable {\r\n\r\n    event AddedController(address _sender, address _controller);\r\n    event RemovedController(address _sender, address _controller);\r\n\r\n    event AddedAdmin(address _sender, address _admin);\r\n    event RemovedAdmin(address _sender, address _admin);\r\n\r\n    event Claimed(address _to, address _asset, uint _amount);\r\n\r\n    event Stopped(address _sender);\r\n    event Started(address _sender);\r\n\r\n    mapping (address => bool) private _isAdmin;\r\n    uint private _adminCount;\r\n\r\n    mapping (address => bool) private _isController;\r\n    uint private _controllerCount;\r\n\r\n    bool private _stopped;\r\n\r\n    /// @notice Constructor initializes the owner with the provided address.\r\n    /// @param _ownerAddress_ address of the owner.\r\n    constructor(address payable _ownerAddress_) Ownable(_ownerAddress_, false) public {}\r\n\r\n    /// @notice Checks if message sender is an admin.\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(msg.sender), \"sender is not an admin\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Check if Owner or Admin\r\n    modifier onlyAdminOrOwner() {\r\n        require(_isOwner(msg.sender) || isAdmin(msg.sender), \"sender is not an admin\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Check if controller is stopped\r\n    modifier notStopped() {\r\n        require(!isStopped(), \"controller is stopped\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Add a new admin to the list of admins.\r\n    /// @param _account address to add to the list of admins.\r\n    function addAdmin(address _account) external onlyOwner notStopped {\r\n        _addAdmin(_account);\r\n    }\r\n\r\n    /// @notice Remove a admin from the list of admins.\r\n    /// @param _account address to remove from the list of admins.\r\n    function removeAdmin(address _account) external onlyOwner {\r\n        _removeAdmin(_account);\r\n    }\r\n\r\n    /// @return the current number of admins.\r\n    function adminCount() external view returns (uint) {\r\n        return _adminCount;\r\n    }\r\n\r\n    /// @notice Add a new controller to the list of controllers.\r\n    /// @param _account address to add to the list of controllers.\r\n    function addController(address _account) external onlyAdminOrOwner notStopped {\r\n        _addController(_account);\r\n    }\r\n\r\n    /// @notice Remove a controller from the list of controllers.\r\n    /// @param _account address to remove from the list of controllers.\r\n    function removeController(address _account) external onlyAdminOrOwner {\r\n        _removeController(_account);\r\n    }\r\n\r\n    /// @notice count the Controllers\r\n    /// @return the current number of controllers.\r\n    function controllerCount() external view returns (uint) {\r\n        return _controllerCount;\r\n    }\r\n\r\n    /// @notice is an address an Admin?\r\n    /// @return true if the provided account is an admin.\r\n    function isAdmin(address _account) public view notStopped returns (bool) {\r\n        return _isAdmin[_account];\r\n    }\r\n\r\n    /// @notice is an address a Controller?\r\n    /// @return true if the provided account is a controller.\r\n    function isController(address _account) public view notStopped returns (bool) {\r\n        return _isController[_account];\r\n    }\r\n\r\n    /// @notice this function can be used to see if the controller has been stopped\r\n    /// @return true is the Controller has been stopped\r\n    function isStopped() public view returns (bool) {\r\n        return _stopped;\r\n    }\r\n\r\n    /// @notice Internal-only function that adds a new admin.\r\n    function _addAdmin(address _account) private {\r\n        require(!_isAdmin[_account], \"provided account is already an admin\");\r\n        require(!_isController[_account], \"provided account is already a controller\");\r\n        require(!_isOwner(_account), \"provided account is already the owner\");\r\n        require(_account != address(0), \"provided account is the zero address\");\r\n        _isAdmin[_account] = true;\r\n        _adminCount++;\r\n        emit AddedAdmin(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice Internal-only function that removes an existing admin.\r\n    function _removeAdmin(address _account) private {\r\n        require(_isAdmin[_account], \"provided account is not an admin\");\r\n        _isAdmin[_account] = false;\r\n        _adminCount--;\r\n        emit RemovedAdmin(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice Internal-only function that adds a new controller.\r\n    function _addController(address _account) private {\r\n        require(!_isAdmin[_account], \"provided account is already an admin\");\r\n        require(!_isController[_account], \"provided account is already a controller\");\r\n        require(!_isOwner(_account), \"provided account is already the owner\");\r\n        require(_account != address(0), \"provided account is the zero address\");\r\n        _isController[_account] = true;\r\n        _controllerCount++;\r\n        emit AddedController(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice Internal-only function that removes an existing controller.\r\n    function _removeController(address _account) private {\r\n        require(_isController[_account], \"provided account is not a controller\");\r\n        _isController[_account] = false;\r\n        _controllerCount--;\r\n        emit RemovedController(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice stop our controllers and admins from being useable\r\n    function stop() external onlyAdminOrOwner {\r\n        _stopped = true;\r\n        emit Stopped(msg.sender);\r\n    }\r\n\r\n    /// @notice start our controller again\r\n    function start() external onlyOwner {\r\n        _stopped = false;\r\n        emit Started(msg.sender);\r\n    }\r\n\r\n    //// @notice Withdraw tokens from the smart contract to the specified account.\r\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin notStopped {\r\n        _safeTransfer(_to, _asset, _amount);\r\n        emit Claimed(_to, _asset, _amount);\r\n    }\r\n}\r\n\r\n// File: ENS.sol\r\n\r\n/**\r\n * BSD 2-Clause License\r\n *\r\n * Copyright (c) 2018, True Names Limited\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n *\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\npragma solidity ^0.5.0;\r\n\r\ninterface ENS {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n\r\n}\r\n\r\n// File: ResolverBase.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract ResolverBase {\r\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == INTERFACE_META_ID;\r\n    }\r\n\r\n    function isAuthorised(bytes32 node) internal view returns(bool);\r\n\r\n    modifier authorised(bytes32 node) {\r\n        require(isAuthorised(node));\r\n        _;\r\n    }\r\n}\r\n\r\n// File: ABIResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract ABIResolver is ResolverBase {\r\n    bytes4 constant private ABI_INTERFACE_ID = 0x2203ab56;\r\n\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n\r\n    mapping(bytes32=>mapping(uint256=>bytes)) abis;\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external authorised(node) {\r\n        // Content types must be powers of 2\r\n        require(((contentType - 1) & contentType) == 0);\r\n\r\n        abis[node][contentType] = data;\r\n        emit ABIChanged(node, contentType);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory) {\r\n        mapping(uint256=>bytes) storage abiset = abis[node];\r\n\r\n        for (uint256 contentType = 1; contentType <= contentTypes; contentType <<= 1) {\r\n            if ((contentType & contentTypes) != 0 && abiset[contentType].length > 0) {\r\n                return (contentType, abiset[contentType]);\r\n            }\r\n        }\r\n\r\n        return (0, bytes(\"\"));\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == ABI_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: AddrResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract AddrResolver is ResolverBase {\r\n    bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n\r\n    mapping(bytes32=>address) addresses;\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) external authorised(node) {\r\n        addresses[node] = addr;\r\n        emit AddrChanged(node, addr);\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public view returns (address) {\r\n        return addresses[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: ContentHashResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract ContentHashResolver is ResolverBase {\r\n    bytes4 constant private CONTENT_HASH_INTERFACE_ID = 0xbc1c58d1;\r\n\r\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n\r\n    mapping(bytes32=>bytes) hashes;\r\n\r\n    /**\r\n     * Sets the contenthash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param hash The contenthash to set\r\n     */\r\n    function setContenthash(bytes32 node, bytes calldata hash) external authorised(node) {\r\n        hashes[node] = hash;\r\n        emit ContenthashChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Returns the contenthash associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function contenthash(bytes32 node) external view returns (bytes memory) {\r\n        return hashes[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == CONTENT_HASH_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: InterfaceResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract InterfaceResolver is ResolverBase, AddrResolver {\r\n    bytes4 constant private INTERFACE_INTERFACE_ID = bytes4(keccak256(\"interfaceImplementer(bytes32,bytes4)\"));\r\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\r\n\r\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\r\n\r\n    mapping(bytes32=>mapping(bytes4=>address)) interfaces;\r\n\r\n    /**\r\n     * Sets an interface associated with a name.\r\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\r\n     * @param node The node to update.\r\n     * @param interfaceID The EIP 168 interface ID.\r\n     * @param implementer The address of a contract that implements this interface for this node.\r\n     */\r\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external authorised(node) {\r\n        interfaces[node][interfaceID] = implementer;\r\n        emit InterfaceChanged(node, interfaceID, implementer);\r\n    }\r\n\r\n    /**\r\n     * Returns the address of a contract that implements the specified interface for this name.\r\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\r\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\r\n     * contract implements EIP168 and returns `true` for the specified interfaceID, its address\r\n     * will be returned.\r\n     * @param node The ENS node to query.\r\n     * @param interfaceID The EIP 168 interface ID to check for.\r\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\r\n     */\r\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address) {\r\n        address implementer = interfaces[node][interfaceID];\r\n        if(implementer != address(0)) {\r\n            return implementer;\r\n        }\r\n\r\n        address a = addr(node);\r\n        if(a == address(0)) {\r\n            return address(0);\r\n        }\r\n\r\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\", INTERFACE_META_ID));\r\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\r\n            // EIP 168 not supported by target\r\n            return address(0);\r\n        }\r\n\r\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\", interfaceID));\r\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\r\n            // Specified interface not supported by target\r\n            return address(0);\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == INTERFACE_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: NameResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract NameResolver is ResolverBase {\r\n    bytes4 constant private NAME_INTERFACE_ID = 0x691f3431;\r\n\r\n    event NameChanged(bytes32 indexed node, string name);\r\n\r\n    mapping(bytes32=>string) names;\r\n\r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param name The name to set.\r\n     */\r\n    function setName(bytes32 node, string calldata name) external authorised(node) {\r\n        names[node] = name;\r\n        emit NameChanged(node, name);\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) external view returns (string memory) {\r\n        return names[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == NAME_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: PubkeyResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract PubkeyResolver is ResolverBase {\r\n    bytes4 constant private PUBKEY_INTERFACE_ID = 0xc8690233;\r\n\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    mapping(bytes32=>PublicKey) pubkeys;\r\n\r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external authorised(node) {\r\n        pubkeys[node] = PublicKey(x, y);\r\n        emit PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x, y the X and Y coordinates of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y) {\r\n        return (pubkeys[node].x, pubkeys[node].y);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == PUBKEY_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: TextResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract TextResolver is ResolverBase {\r\n    bytes4 constant private TEXT_INTERFACE_ID = 0x59d1d43c;\r\n\r\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\r\n\r\n    mapping(bytes32=>mapping(string=>string)) texts;\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(bytes32 node, string calldata key, string calldata value) external authorised(node) {\r\n        texts[node][key] = value;\r\n        emit TextChanged(node, key, key);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string calldata key) external view returns (string memory) {\r\n        return texts[node][key];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == TEXT_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: PublicResolver.sol\r\n\r\n/**\r\n * BSD 2-Clause License\r\n *\r\n * Copyright (c) 2018, True Names Limited\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n *\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * A simple resolver anyone can use; only allows the owner of a node to set its\r\n * address.\r\n */\r\ncontract PublicResolver is ABIResolver, AddrResolver, ContentHashResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\r\n    ENS ens;\r\n\r\n    /**\r\n     * A mapping of authorisations. An address that is authorised for a name\r\n     * may make any changes to the name that the owner could, but may not update\r\n     * the set of authorisations.\r\n     * (node, owner, caller) => isAuthorised\r\n     */\r\n    mapping(bytes32=>mapping(address=>mapping(address=>bool))) public authorisations;\r\n\r\n    event AuthorisationChanged(bytes32 indexed node, address indexed owner, address indexed target, bool isAuthorised);\r\n\r\n    constructor(ENS _ens) public {\r\n        ens = _ens;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or clears an authorisation.\r\n     * Authorisations are specific to the caller. Any account can set an authorisation\r\n     * for any name, but the authorisation that is checked will be that of the\r\n     * current owner of a name. Thus, transferring a name effectively clears any\r\n     * existing authorisations, and new authorisations can be set in advance of\r\n     * an ownership transfer if desired.\r\n     *\r\n     * @param node The name to change the authorisation on.\r\n     * @param target The address that is to be authorised or deauthorised.\r\n     * @param isAuthorised True if the address should be authorised, or false if it should be deauthorised.\r\n     */\r\n    function setAuthorisation(bytes32 node, address target, bool isAuthorised) external {\r\n        authorisations[node][msg.sender][target] = isAuthorised;\r\n        emit AuthorisationChanged(node, msg.sender, target, isAuthorised);\r\n    }\r\n\r\n    function isAuthorised(bytes32 node) internal view returns(bool) {\r\n        address owner = ens.owner(node);\r\n        return owner == msg.sender || authorisations[node][owner][msg.sender];\r\n    }\r\n}\r\n\r\n// File: ensResolvable.sol\r\n\r\n/**\r\n *  ENSResolvable - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n///@title ENSResolvable - Ethereum Name Service Resolver\r\n///@notice contract should be used to get an address for an ENS node\r\ncontract ENSResolvable {\r\n    /// @notice _ens is an instance of ENS\r\n    ENS private _ens;\r\n\r\n    /// @notice _ensRegistry points to the ENS registry smart contract.\r\n    address private _ensRegistry;\r\n\r\n    /// @param _ensReg_ is the ENS registry used\r\n    constructor(address _ensReg_) internal {\r\n        _ensRegistry = _ensReg_;\r\n        _ens = ENS(_ensRegistry);\r\n    }\r\n\r\n    /// @notice this is used to that one can observe which ENS registry is being used\r\n    function ensRegistry() external view returns (address) {\r\n        return _ensRegistry;\r\n    }\r\n\r\n    /// @notice helper function used to get the address of a node\r\n    /// @param _node of the ENS entry that needs resolving\r\n    /// @return the address of the said node\r\n    function _ensResolve(bytes32 _node) internal view returns (address) {\r\n        return PublicResolver(_ens.resolver(_node)).addr(_node);\r\n    }\r\n\r\n}\r\n\r\n// File: controllable.sol\r\n\r\n/**\r\n *  Controllable - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n/// @title Controllable implements access control functionality of the Controller found via ENS.\r\ncontract Controllable is ENSResolvable {\r\n    /// @dev Is the registered ENS node identifying the controller contract.\r\n    bytes32 private _controllerNode;\r\n\r\n    /// @notice Constructor initializes the controller contract object.\r\n    /// @param _controllerNode_ is the ENS node of the Controller.\r\n    constructor(bytes32 _controllerNode_) internal {\r\n        _controllerNode = _controllerNode_;\r\n    }\r\n\r\n    /// @notice Checks if message sender is a controller.\r\n    modifier onlyController() {\r\n        require(_isController(msg.sender), \"sender is not a controller\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Checks if message sender is an admin.\r\n    modifier onlyAdmin() {\r\n        require(_isAdmin(msg.sender), \"sender is not an admin\");\r\n        _;\r\n    }\r\n\r\n    /// @return the controller node registered in ENS.\r\n    function controllerNode() external view returns (bytes32) {\r\n        return _controllerNode;\r\n    }\r\n\r\n    /// @return true if the provided account is a controller.\r\n    function _isController(address _account) internal view returns (bool) {\r\n        return IController(_ensResolve(_controllerNode)).isController(_account);\r\n    }\r\n\r\n    /// @return true if the provided account is an admin.\r\n    function _isAdmin(address _account) internal view returns (bool) {\r\n        return IController(_ensResolve(_controllerNode)).isAdmin(_account);\r\n    }\r\n\r\n}\r\n\r\n// File: licence.sol\r\n\r\n/**\r\n *  Licence - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ILicence interface describes methods for loading a TokenCard and updating licence amount.\r\ninterface ILicence {\r\n    function load(address, uint) external payable;\r\n    function updateLicenceAmount(uint) external;\r\n}\r\n\r\n\r\n/// @title Licence loads the TokenCard and transfers the licence amout to the TKN Holder Contract.\r\n/// @notice the rest of the amount gets sent to the CryptoFloat\r\ncontract Licence is Transferrable, ENSResolvable, Controllable {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n\r\n    /*******************/\r\n    /*     Events     */\r\n    /*****************/\r\n\r\n    event UpdatedLicenceDAO(address _newDAO);\r\n    event UpdatedCryptoFloat(address _newFloat);\r\n    event UpdatedTokenHolder(address _newHolder);\r\n    event UpdatedTKNContractAddress(address _newTKN);\r\n    event UpdatedLicenceAmount(uint _newAmount);\r\n\r\n    event TransferredToTokenHolder(address _from, address _to, address _asset, uint _amount);\r\n    event TransferredToCryptoFloat(address _from, address _to, address _asset, uint _amount);\r\n\r\n    event Claimed(address _to, address _asset, uint _amount);\r\n\r\n    /// @notice This is 100% scaled up by a factor of 10 to give us an extra 1 decimal place of precision\r\n    uint constant public MAX_AMOUNT_SCALE = 1000;\r\n    uint constant public MIN_AMOUNT_SCALE = 1;\r\n\r\n    address private _tknContractAddress = 0xaAAf91D9b90dF800Df4F55c205fd6989c977E73a; // solium-disable-line uppercase\r\n\r\n    address payable private _cryptoFloat;\r\n    address payable private _tokenHolder;\r\n    address private _licenceDAO;\r\n\r\n    bool private _lockedCryptoFloat;\r\n    bool private _lockedTokenHolder;\r\n    bool private _lockedLicenceDAO;\r\n    bool private _lockedTKNContractAddress;\r\n\r\n    /// @notice This is the _licenceAmountScaled by a factor of 10\r\n    /// @dev i.e. 1% is 10 _licenceAmountScaled, 0.1% is 1 _licenceAmountScaled\r\n    uint private _licenceAmountScaled;\r\n\r\n    /// @notice Reverts if called by any address other than the DAO contract.\r\n    modifier onlyDAO() {\r\n        require(msg.sender == _licenceDAO, \"the sender isn't the DAO\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Constructor initializes the card licence contract.\r\n    /// @param _licence_ is the initial card licence amount. this number is scaled 10 = 1%, 9 = 0.9%\r\n    /// @param _float_ is the address of the multi-sig cryptocurrency float contract.\r\n    /// @param _holder_ is the address of the token holder contract\r\n    /// @param _tknAddress_ is the address of the TKN ERC20 contract\r\n    /// @param _ens_ is the address of the ENS Registry\r\n    /// @param _controllerNode_ is the ENS node corresponding to the controller\r\n    constructor(uint _licence_, address payable _float_, address payable _holder_, address _tknAddress_, address _ens_, bytes32 _controllerNode_) ENSResolvable(_ens_) Controllable(_controllerNode_) public {\r\n        require(MIN_AMOUNT_SCALE <= _licence_ && _licence_ <= MAX_AMOUNT_SCALE, \"licence amount out of range\");\r\n        _licenceAmountScaled = _licence_;\r\n        _cryptoFloat = _float_;\r\n        _tokenHolder = _holder_;\r\n        if (_tknAddress_ != address(0)) {\r\n            _tknContractAddress = _tknAddress_;\r\n        }\r\n    }\r\n\r\n    /// @notice Ether can be deposited from any source, so this contract should be payable by anyone.\r\n    function() external payable {}\r\n\r\n    /// @notice this allows for people to see the scaled licence amount\r\n    /// @return the scaled licence amount, used to calculate the split when loading.\r\n    function licenceAmountScaled() external view returns (uint) {\r\n        return _licenceAmountScaled;\r\n    }\r\n\r\n    /// @notice allows one to see the address of the CryptoFloat\r\n    /// @return the address of the multi-sig cryptocurrency float contract.\r\n    function cryptoFloat() external view returns (address) {\r\n        return _cryptoFloat;\r\n    }\r\n\r\n    /// @notice allows one to see the address TKN holder contract\r\n    /// @return the address of the token holder contract.\r\n    function tokenHolder() external view returns (address) {\r\n        return _tokenHolder;\r\n    }\r\n\r\n    /// @notice allows one to see the address of the DAO\r\n    /// @return the address of the DAO contract.\r\n    function licenceDAO() external view returns (address) {\r\n        return _licenceDAO;\r\n    }\r\n\r\n    /// @notice The address of the TKN token\r\n    /// @return the address of the TKN contract.\r\n    function tknContractAddress() external view returns (address) {\r\n        return _tknContractAddress;\r\n    }\r\n\r\n    /// @notice This locks the cryptoFloat address\r\n    /// @dev so that it can no longer be updated\r\n    function lockFloat() external onlyAdmin {\r\n        _lockedCryptoFloat = true;\r\n    }\r\n\r\n    /// @notice This locks the TokenHolder address\r\n    /// @dev so that it can no longer be updated\r\n    function lockHolder() external onlyAdmin {\r\n        _lockedTokenHolder = true;\r\n    }\r\n\r\n    /// @notice This locks the DAO address\r\n    /// @dev so that it can no longer be updated\r\n    function lockLicenceDAO() external onlyAdmin {\r\n        _lockedLicenceDAO = true;\r\n    }\r\n\r\n    /// @notice This locks the TKN address\r\n    /// @dev so that it can no longer be updated\r\n    function lockTKNContractAddress() external onlyAdmin {\r\n        _lockedTKNContractAddress = true;\r\n    }\r\n\r\n    /// @notice Updates the address of the cyptoFloat.\r\n    /// @param _newFloat This is the new address for the CryptoFloat\r\n    function updateFloat(address payable _newFloat) external onlyAdmin {\r\n        require(!floatLocked(), \"float is locked\");\r\n        _cryptoFloat = _newFloat;\r\n        emit UpdatedCryptoFloat(_newFloat);\r\n    }\r\n\r\n    /// @notice Updates the address of the Holder contract.\r\n    /// @param _newHolder This is the new address for the TokenHolder\r\n    function updateHolder(address payable _newHolder) external onlyAdmin {\r\n        require(!holderLocked(), \"holder contract is locked\");\r\n        _tokenHolder = _newHolder;\r\n        emit UpdatedTokenHolder(_newHolder);\r\n    }\r\n\r\n    /// @notice Updates the address of the DAO contract.\r\n    /// @param _newDAO This is the new address for the Licence DAO\r\n    function updateLicenceDAO(address _newDAO) external onlyAdmin {\r\n        require(!licenceDAOLocked(), \"DAO is locked\");\r\n        _licenceDAO = _newDAO;\r\n        emit UpdatedLicenceDAO(_newDAO);\r\n    }\r\n\r\n    /// @notice Updates the address of the TKN contract.\r\n    /// @param _newTKN This is the new address for the TKN contract\r\n    function updateTKNContractAddress(address _newTKN) external onlyAdmin {\r\n        require(!tknContractAddressLocked(), \"TKN is locked\");\r\n        _tknContractAddress = _newTKN;\r\n        emit UpdatedTKNContractAddress(_newTKN);\r\n    }\r\n\r\n    /// @notice Updates the TKN licence amount\r\n    /// @param _newAmount is a number between MIN_AMOUNT_SCALE (1) and MAX_AMOUNT_SCALE\r\n    function updateLicenceAmount(uint _newAmount) external onlyDAO {\r\n        require(MIN_AMOUNT_SCALE <= _newAmount && _newAmount <= MAX_AMOUNT_SCALE, \"licence amount out of range\");\r\n        _licenceAmountScaled = _newAmount;\r\n        emit UpdatedLicenceAmount(_newAmount);\r\n    }\r\n\r\n    /// @notice Load the holder and float contracts based on the licence amount and asset amount.\r\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\r\n    /// @param _amount is the amount of assets to be transferred including the licence amount.\r\n    function load(address _asset, uint _amount) external payable {\r\n        uint loadAmount = _amount;\r\n        // If TKN then no licence to be paid\r\n        if (_asset == _tknContractAddress) {\r\n            ERC20(_asset).safeTransferFrom(msg.sender, _cryptoFloat, loadAmount);\r\n        } else {\r\n            loadAmount = _amount.mul(MAX_AMOUNT_SCALE).div(_licenceAmountScaled + MAX_AMOUNT_SCALE);\r\n            uint licenceAmount = _amount.sub(loadAmount);\r\n\r\n            if (_asset != address(0)) {\r\n                ERC20(_asset).safeTransferFrom(msg.sender, _tokenHolder, licenceAmount);\r\n                ERC20(_asset).safeTransferFrom(msg.sender, _cryptoFloat, loadAmount);\r\n            } else {\r\n                require(msg.value == _amount, \"ETH sent is not equal to amount\");\r\n                _tokenHolder.transfer(licenceAmount);\r\n                _cryptoFloat.transfer(loadAmount);\r\n            }\r\n\r\n            emit TransferredToTokenHolder(msg.sender, _tokenHolder, _asset, licenceAmount);\r\n        }\r\n\r\n        emit TransferredToCryptoFloat(msg.sender, _cryptoFloat, _asset, loadAmount);\r\n    }\r\n\r\n    //// @notice Withdraw tokens from the smart contract to the specified account.\r\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin {\r\n        _safeTransfer(_to, _asset, _amount);\r\n        emit Claimed(_to, _asset, _amount);\r\n    }\r\n\r\n    /// @notice returns whether or not the CryptoFloat address is locked\r\n    function floatLocked() public view returns (bool) {\r\n        return _lockedCryptoFloat;\r\n    }\r\n\r\n    /// @notice returns whether or not the TokenHolder address is locked\r\n    function holderLocked() public view returns (bool) {\r\n        return _lockedTokenHolder;\r\n    }\r\n\r\n    /// @notice returns whether or not the Licence DAO address is locked\r\n    function licenceDAOLocked() public view returns (bool) {\r\n        return _lockedLicenceDAO;\r\n    }\r\n\r\n    /// @notice returns whether or not the TKN address is locked\r\n    function tknContractAddressLocked() public view returns (bool) {\r\n        return _lockedTKNContractAddress;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"lockTKNContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTKN\",\"type\":\"address\"}],\"name\":\"updateTKNContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_asset\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"load\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"licenceDAO\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_AMOUNT_SCALE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newHolder\",\"type\":\"address\"}],\"name\":\"updateHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockLicenceDAO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAmount\",\"type\":\"uint256\"}],\"name\":\"updateLicenceAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ensRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tknContractAddressLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"floatLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_asset\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tknContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cryptoFloat\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"licenceAmountScaled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_AMOUNT_SCALE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockFloat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFloat\",\"type\":\"address\"}],\"name\":\"updateFloat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllerNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"licenceDAOLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDAO\",\"type\":\"address\"}],\"name\":\"updateLicenceDAO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holderLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_licence_\",\"type\":\"uint256\"},{\"name\":\"_float_\",\"type\":\"address\"},{\"name\":\"_holder_\",\"type\":\"address\"},{\"name\":\"_tknAddress_\",\"type\":\"address\"},{\"name\":\"_ens_\",\"type\":\"address\"},{\"name\":\"_controllerNode_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newDAO\",\"type\":\"address\"}],\"name\":\"UpdatedLicenceDAO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newFloat\",\"type\":\"address\"}],\"name\":\"UpdatedCryptoFloat\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newHolder\",\"type\":\"address\"}],\"name\":\"UpdatedTokenHolder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newTKN\",\"type\":\"address\"}],\"name\":\"UpdatedTKNContractAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedLicenceAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferredToTokenHolder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferredToCryptoFloat\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"}]","ContractName":"Licence","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000ab613544d53173e65e75a2390f7512f6fe94125700000000000000000000000024f0bb6c9b2c3db66603fa0ec07ab0cf55cdd387000000000000000000000000aaaf91d9b90df800df4f55c205fd6989c977e73a000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b7f2ce995617d2816b426c5c8698c5ec2952f7a34bb10f38326f74933d5893697","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://fcb2619e3b6b1d323cf6d8f408ae9fef5fc6965792a11e4b00d62d50183b4d2e"}]}