{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n\r\n// @title SafeMath: overflow/underflow checks\r\n// @notice Math operations with safety checks that throw on error\r\nlibrary SafeMath {\r\n\r\n  // @notice Multiplies two numbers, throws on overflow.\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  // @notice Integer division of two numbers, truncating the quotient.\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  // @notice Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  // @notice Adds two numbers, throws on overflow.\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  // @notice Returns fractional amount\r\n  function getFractionalAmount(uint256 _amount, uint256 _percentage)\r\n  internal\r\n  pure\r\n  returns (uint256) {\r\n    return div(mul(_amount, _percentage), 100);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface ERC20 {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address _who) external view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/MinterInterface.sol\r\n\r\ninterface MinterInterface {\r\n  function cloneToken(string _uri, address _erc20Address) external returns (address asset);\r\n\r\n  function mintAssetTokens(address _assetAddress, address _receiver, uint256 _amount) external returns (bool);\r\n\r\n  function changeTokenController(address _assetAddress, address _newController) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/CrowdsaleReserveInterface.sol\r\n\r\ninterface CrowdsaleReserveInterface {\r\n  function issueETH(address _receiver, uint256 _amount) external returns (bool);\r\n  function receiveETH(address _payer) external payable returns (bool);\r\n  function refundETHAsset(address _asset, uint256 _amount) external returns (bool);\r\n  function issueERC20(address _receiver, uint256 _amount, address _tokenAddress) external returns (bool);\r\n  function requestERC20(address _payer, uint256 _amount, address _tokenAddress) external returns (bool);\r\n  function approveERC20(address _receiver, uint256 _amount, address _tokenAddress) external returns (bool);\r\n  function refundERC20Asset(address _asset, uint256 _amount, address _tokenAddress) external returns (bool);\r\n}\r\n\r\n// File: contracts/crowdsale/CrowdsaleETH.sol\r\n\r\ninterface Events {\r\n  function transaction(string _message, address _from, address _to, uint _amount, address _token)  external;\r\n  function asset(string _message, string _uri, address _assetAddress, address _manager);\r\n}\r\ninterface DB {\r\n  function addressStorage(bytes32 _key) external view returns (address);\r\n  function uintStorage(bytes32 _key) external view returns (uint);\r\n  function setUint(bytes32 _key, uint _value) external;\r\n  function deleteUint(bytes32 _key) external;\r\n  function setBool(bytes32 _key, bool _value) external;\r\n  function boolStorage(bytes32 _key) external view returns (bool);\r\n}\r\n\r\n// @title An asset crowdsale contract, which accepts Ether for funding.\r\n// @author Kyle Dewhurst & Peter Phillips, MyBit Foundation\r\n// @notice Starts a new crowdsale and returns asset dividend tokens for Wei received.\r\n// @dev The AssetManager\r\ncontract CrowdsaleETH {\r\n    using SafeMath for uint256;\r\n\r\n    DB private database;\r\n    Events private events;\r\n    MinterInterface private minter;\r\n    CrowdsaleReserveInterface private reserve;\r\n\r\n    // @notice Constructor: Initiates the database\r\n    // @param: The address for the database contract\r\n    constructor(address _database, address _events)\r\n    public {\r\n      database = DB(_database);\r\n      events = Events(_events);\r\n      minter = MinterInterface(database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"Minter\"))));\r\n      reserve = CrowdsaleReserveInterface(database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"CrowdsaleReserve\"))));\r\n    }\r\n\r\n\r\n    // @notice Investors can send Ether here to fund asset, receiving an equivalent number of asset-tokens.\r\n    // @param (bytes32) _assetAddress = The address of the asset which completed the crowdsale\r\n    function buyAssetOrderETH(address _assetAddress)\r\n    external\r\n    payable\r\n    requiresEther\r\n    validAsset(_assetAddress)\r\n    beforeDeadline(_assetAddress)\r\n    notFinalized(_assetAddress)\r\n    returns (bool) {\r\n      uint fundingRemaining = database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.remaining\", _assetAddress)));\r\n      uint amount; //The number of tokens that will be minted\r\n      if (msg.value < fundingRemaining) {\r\n        amount = msg.value.mul(100).div(uint(100).add(database.uintStorage(keccak256(abi.encodePacked(\"platform.fee\")))));\r\n        database.setUint(keccak256(abi.encodePacked(\"crowdsale.remaining\", _assetAddress)), fundingRemaining.sub(msg.value));\r\n        //Mint tokens equal to the msg.value\r\n        require(minter.mintAssetTokens(_assetAddress, msg.sender, amount), \"Investor minting failed\");\r\n        reserve.receiveETH.value(msg.value)(msg.sender);\r\n      } else {\r\n        amount = fundingRemaining.mul(100).div(uint(100).add(database.uintStorage(keccak256(abi.encodePacked(\"platform.fee\")))));\r\n        //Funding complete, finalize crowdsale\r\n        database.setBool(keccak256(abi.encodePacked(\"crowdsale.finalized\", _assetAddress)), true);\r\n        database.deleteUint(keccak256(abi.encodePacked(\"crowdsale.remaining\", _assetAddress)));\r\n        //Since investor paid equal to or over the funding remaining, just mint for tokensRemaining\r\n        require(minter.mintAssetTokens(_assetAddress, msg.sender, amount), \"Investor minting failed\");\r\n        reserve.receiveETH.value(fundingRemaining)(msg.sender);\r\n        //Return leftover WEI after cost of tokens calculated and subtracted from msg.value to msg.sender\r\n        msg.sender.transfer(msg.value.sub(fundingRemaining));\r\n        events.asset('Crowdsale finalized', '', _assetAddress, msg.sender);\r\n      }\r\n      events.transaction('Asset purchased', address(this), msg.sender, amount, _assetAddress);\r\n\r\n      return true;\r\n    }\r\n\r\n    // @notice This is called once funding has succeeded. Sends Ether to a distribution contract where receiver & assetManager can withdraw\r\n    // @dev The contract manager needs to know  the address PlatformDistribution contract\r\n    // @param (bytes32) _assetAddress = The address of the asset which completed the crowdsale\r\n    function payoutETH(address _assetAddress)\r\n    external\r\n    whenNotPaused\r\n    finalized(_assetAddress)\r\n    notPaid(_assetAddress)\r\n    returns (bool) {\r\n      //Set paid to true\r\n      database.setBool(keccak256(abi.encodePacked(\"crowdsale.paid\", _assetAddress)), true);\r\n      //Setup token\r\n      //Mint tokens for the asset manager and platform + finish minting\r\n      address platformAssetsWallet = database.addressStorage(keccak256(abi.encodePacked(\"platform.wallet.assets\")));\r\n      require(platformAssetsWallet != address(0), \"Platform assets wallet not set\");\r\n      require(minter.mintAssetTokens(_assetAddress, database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"AssetManagerFunds\"))), database.uintStorage(keccak256(abi.encodePacked(\"asset.managerTokens\", _assetAddress)))), \"Manager minting failed\");\r\n      require(minter.mintAssetTokens(_assetAddress, platformAssetsWallet, database.uintStorage(keccak256(abi.encodePacked(\"asset.platformTokens\", _assetAddress)))), \"Platform minting failed\");\r\n      //Get the addresses for the receiver and platform\r\n      address receiver = database.addressStorage(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress)));\r\n      address platformFundsWallet = database.addressStorage(keccak256(abi.encodePacked(\"platform.wallet.funds\")));\r\n      require(receiver != address(0) && platformFundsWallet != address(0), \"Receiver or platform wallet not set\");\r\n      //Calculate amounts for platform and receiver\r\n      uint amount = database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.goal\", _assetAddress)));\r\n      uint platformFee = amount.getFractionalAmount(database.uintStorage(keccak256(abi.encodePacked(\"platform.fee\"))));\r\n      //Transfer funds to receiver and platform\r\n      require(reserve.issueETH(platformFundsWallet, platformFee), 'Platform funds not paid');\r\n      require(reserve.issueETH(receiver, amount), 'Operator funds not paid');\r\n      //Delete crowdsale start time\r\n      database.deleteUint(keccak256(abi.encodePacked(\"crowdsale.start\", _assetAddress)));\r\n      //Increase asset count for manager\r\n      address manager = database.addressStorage(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress)));\r\n      database.setUint(keccak256(abi.encodePacked(\"manager.assets\", manager)), database.uintStorage(keccak256(abi.encodePacked(\"manager.assets\", manager))).add(1));\r\n      //Emit event\r\n      events.transaction('Asset payout', _assetAddress, receiver, amount, address(0));\r\n      return true;\r\n    }\r\n\r\n    function cancel(address _assetAddress)\r\n    external\r\n    whenNotPaused\r\n    validAsset(_assetAddress)\r\n    beforeDeadline(_assetAddress)\r\n    notFinalized(_assetAddress)\r\n    returns (bool){\r\n      require(msg.sender == database.addressStorage(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress))));\r\n      database.setUint(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress)), 1);\r\n      refund(_assetAddress);\r\n    }\r\n\r\n    // @notice Contributors can retrieve their funds here if crowdsale has paased deadline and not reached its goal\r\n    // @param (bytes32) _assetAddress = The address of the asset which completed the crowdsale\r\n    function refund(address _assetAddress)\r\n    public\r\n    whenNotPaused\r\n    validAsset(_assetAddress)\r\n    afterDeadline(_assetAddress)\r\n    notFinalized(_assetAddress)\r\n    returns (bool) {\r\n      require(database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress))) != 0);\r\n      database.deleteUint(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress)));\r\n      ERC20 assetToken = ERC20(_assetAddress);\r\n      uint refundValue = assetToken.totalSupply().mul(uint(100).add(database.uintStorage(keccak256(abi.encodePacked(\"platform.fee\"))))).div(100); //total supply plus platform fees\r\n      reserve.refundETHAsset(_assetAddress, refundValue);\r\n      return true;\r\n    }\r\n\r\n    // @notice platform owners can recover tokens here\r\n    function recoverTokens(address _erc20Token)\r\n    onlyOwner\r\n    external {\r\n      ERC20 thisToken = ERC20(_erc20Token);\r\n      uint contractBalance = thisToken.balanceOf(address(this));\r\n      thisToken.transfer(msg.sender, contractBalance);\r\n    }\r\n\r\n    // @notice platform owners can destroy contract here\r\n    function destroy()\r\n    onlyOwner\r\n    external {\r\n      events.transaction('CrowdsaleETH destroyed', address(this), msg.sender, address(this).balance, address(0));\r\n      selfdestruct(msg.sender);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------------------------------------------\r\n    //                                            Modifiers\r\n    //------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n    // @notice Requires that Ether is sent with the transaction\r\n    modifier requiresEther() {\r\n      require(msg.value > 0);\r\n      _;\r\n    }\r\n\r\n    // @notice Sender must be a registered owner\r\n    modifier onlyOwner {\r\n      require(database.boolStorage(keccak256(abi.encodePacked(\"owner\", msg.sender))), \"Not owner\");\r\n      _;\r\n    }\r\n\r\n    // @notice function won't run if owners have paused this contract\r\n    modifier whenNotPaused {\r\n      require(!database.boolStorage(keccak256(abi.encodePacked(\"paused\", address(this)))), \"Contract paused\");\r\n      _;\r\n    }\r\n\r\n    // @notice reverts if the asset does not have a token address set in the database\r\n    modifier validAsset(address _assetAddress) {\r\n      require(database.addressStorage(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress))) != address(0), \"Invalid asset\");\r\n      _;\r\n    }\r\n\r\n    // @notice reverts if the funding deadline has not passed\r\n    modifier beforeDeadline(address _assetAddress) {\r\n      require(now < database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress))), \"Before deadline\");\r\n      _;\r\n    }\r\n\r\n    // @notice reverts if the funding deadline has already past or crowsale has not started\r\n    modifier betweenDeadlines(address _assetAddress) {\r\n      require(now <= database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress))), \"Past deadline\");\r\n      require(now >= database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.start\", _assetAddress))), \"Before start time\");\r\n      _;\r\n    }\r\n\r\n    // @notice reverts if the funding deadline has already past\r\n    modifier afterDeadline(address _assetAddress) {\r\n      require(now > database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress))), \"Before deadline\");\r\n      _;\r\n    }\r\n\r\n    // @notice returns true if crowdsale is finshed\r\n    modifier finalized(address _assetAddress) {\r\n      require( database.boolStorage(keccak256(abi.encodePacked(\"crowdsale.finalized\", _assetAddress))), \"Crowdsale not finalized\");\r\n      _;\r\n    }\r\n\r\n    // @notice returns true if crowdsale is not finshed\r\n    modifier notFinalized(address _assetAddress) {\r\n      require( !database.boolStorage(keccak256(abi.encodePacked(\"crowdsale.finalized\", _assetAddress))), \"Crowdsale finalized\");\r\n      _;\r\n    }\r\n\r\n    // @notice returns true if crowdsale has not paid out\r\n    modifier notPaid(address _assetAddress) {\r\n      require( !database.boolStorage(keccak256(abi.encodePacked(\"crowdsale.paid\", _assetAddress))), \"Crowdsale had paid out\");\r\n      _;\r\n    }\r\n\r\n  }","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_erc20Token\",\"type\":\"address\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"cancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"buyAssetOrderETH\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"payoutETH\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_database\",\"type\":\"address\"},{\"name\":\"_events\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"CrowdsaleETH","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005fcebeb70b88e86dd880352684e775b0f4d57c71000000000000000000000000eb6533f29a54c2c18bb2ce2a100de717692a518f","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://788ee6f791f90161e48b07819763ecc45b8525aa15c8aefbd516e5e66c1da6f7"}]}