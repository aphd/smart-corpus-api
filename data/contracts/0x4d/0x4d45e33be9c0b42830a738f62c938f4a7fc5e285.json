{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\r\n\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the average of two numbers. Since these are integers,\r\n     * averages of an even and odd number cannot be represented, and will be\r\n     * rounded down.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        require(token.transfer(to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        require(token.transferFrom(from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(msg.sender, spender) == 0));\r\n        require(token.approve(spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title TokenSale\r\n */\r\ncontract TokenSale is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // token for sale\r\n    IERC20 public saleToken;\r\n\r\n    // address where funds are collected\r\n    address public fundCollector;\r\n\r\n    // address where has tokens to sell\r\n    address public tokenWallet;\r\n\r\n    // use whitelist[user] to get whether the user was allowed to buy\r\n    mapping(address => bool) public whitelist;\r\n\r\n    // exchangeable token\r\n    struct ExToken {\r\n        bool accepted;\r\n        uint256 rate;\r\n    }\r\n\r\n    // exchangeable tokens\r\n    mapping(address => ExToken) private _exTokens;\r\n\r\n    // bonus threshold\r\n    uint256 public bonusThreshold;\r\n\r\n    // tier-1 bonus\r\n    uint256 public tierOneBonusTime;\r\n    uint256 public tierOneBonusRate;\r\n\r\n    // tier-2 bonus\r\n    uint256 public tierTwoBonusTime;\r\n    uint256 public tierTwoBonusRate;\r\n\r\n    /**\r\n     * @param setter who set fund collector\r\n     * @param fundCollector address of fund collector\r\n     */\r\n    event FundCollectorSet(\r\n        address indexed setter,\r\n        address indexed fundCollector\r\n    );\r\n\r\n    /**\r\n     * @param setter who set sale token\r\n     * @param saleToken address of sale token\r\n     */\r\n    event SaleTokenSet(\r\n        address indexed setter,\r\n        address indexed saleToken\r\n    );\r\n\r\n    /**\r\n     * @param setter who set token wallet\r\n     * @param tokenWallet address of token wallet\r\n     */\r\n    event TokenWalletSet(\r\n        address indexed setter,\r\n        address indexed tokenWallet\r\n    );\r\n\r\n    /**\r\n     * @param setter who set bonus threshold\r\n     * @param bonusThreshold exceed the threshold will get bonus\r\n     * @param tierOneBonusTime tier one bonus timestamp\r\n     * @param tierOneBonusRate tier one bonus rate\r\n     * @param tierTwoBonusTime tier two bonus timestamp\r\n     * @param tierTwoBonusRate tier two bonus rate\r\n     */\r\n    event BonusConditionsSet(\r\n        address indexed setter,\r\n        uint256 bonusThreshold,\r\n        uint256 tierOneBonusTime,\r\n        uint256 tierOneBonusRate,\r\n        uint256 tierTwoBonusTime,\r\n        uint256 tierTwoBonusRate\r\n    );\r\n\r\n    /**\r\n     * @param setter who set the whitelist\r\n     * @param user address of the user\r\n     * @param allowed whether the user allowed to buy\r\n     */\r\n    event WhitelistSet(\r\n        address indexed setter,\r\n        address indexed user,\r\n        bool allowed\r\n    );\r\n\r\n    /**\r\n     * event for logging exchangeable token updates\r\n     * @param setter who set the exchangeable token\r\n     * @param exToken the exchangeable token\r\n     * @param accepted whether the exchangeable token was accepted\r\n     * @param rate exchange rate of the exchangeable token\r\n     */\r\n    event ExTokenSet(\r\n        address indexed setter,\r\n        address indexed exToken,\r\n        bool accepted,\r\n        uint256 rate\r\n    );\r\n\r\n    /**\r\n     * event for token purchase logging\r\n     * @param buyer address of token buyer\r\n     * @param exToken address of the exchangeable token\r\n     * @param exTokenAmount amount of the exchangeable tokens\r\n     * @param amount amount of tokens purchased\r\n     */\r\n    event TokensPurchased(\r\n        address indexed buyer,\r\n        address indexed exToken,\r\n        uint256 exTokenAmount,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @param fundCollector address where collected funds will be forwarded to\r\n     * @param saleToken address of the token being sold\r\n     * @param tokenWallet address of wallet has tokens to sell\r\n     */\r\n    constructor (\r\n        address fundCollector,\r\n        address saleToken,\r\n        address tokenWallet,\r\n        uint256 bonusThreshold,\r\n        uint256 tierOneBonusTime,\r\n        uint256 tierOneBonusRate,\r\n        uint256 tierTwoBonusTime,\r\n        uint256 tierTwoBonusRate\r\n    )\r\n        public\r\n    {\r\n        _setFundCollector(fundCollector);\r\n        _setSaleToken(saleToken);\r\n        _setTokenWallet(tokenWallet);\r\n        _setBonusConditions(\r\n            bonusThreshold,\r\n            tierOneBonusTime,\r\n            tierOneBonusRate,\r\n            tierTwoBonusTime,\r\n            tierTwoBonusRate\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n     * @param fundCollector address of the fund collector\r\n     */\r\n    function setFundCollector(address fundCollector) external onlyOwner {\r\n        _setFundCollector(fundCollector);\r\n    }\r\n\r\n    /**\r\n     * @param collector address of the fund collector\r\n     */\r\n    function _setFundCollector(address collector) private {\r\n        require(collector != address(0), \"fund collector cannot be 0x0\");\r\n        fundCollector = collector;\r\n        emit FundCollectorSet(msg.sender, collector);\r\n    }\r\n\r\n    /**\r\n     * @param saleToken address of the sale token\r\n     */\r\n    function setSaleToken(address saleToken) external onlyOwner {\r\n        _setSaleToken(saleToken);\r\n    }\r\n\r\n    /**\r\n     * @param token address of the sale token\r\n     */\r\n    function _setSaleToken(address token) private {\r\n        require(token != address(0), \"sale token cannot be 0x0\");\r\n        saleToken = IERC20(token);\r\n        emit SaleTokenSet(msg.sender, token);\r\n    }\r\n\r\n    /**\r\n     * @param tokenWallet address of the token wallet\r\n     */\r\n    function setTokenWallet(address tokenWallet) external onlyOwner {\r\n        _setTokenWallet(tokenWallet);\r\n    }\r\n\r\n    /**\r\n     * @param wallet address of the token wallet\r\n     */\r\n    function _setTokenWallet(address wallet) private {\r\n        require(wallet != address(0), \"token wallet cannot be 0x0\");\r\n        tokenWallet = wallet;\r\n        emit TokenWalletSet(msg.sender, wallet);\r\n    }\r\n\r\n    /**\r\n     * @param threshold exceed the threshold will get bonus\r\n     * @param t1BonusTime before t1 bonus timestamp will use t1 bonus rate\r\n     * @param t1BonusRate tier-1 bonus rate\r\n     * @param t2BonusTime before t2 bonus timestamp will use t2 bonus rate\r\n     * @param t2BonusRate tier-2 bonus rate\r\n     */\r\n    function setBonusConditions(\r\n        uint256 threshold,\r\n        uint256 t1BonusTime,\r\n        uint256 t1BonusRate,\r\n        uint256 t2BonusTime,\r\n        uint256 t2BonusRate\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        _setBonusConditions(\r\n            threshold,\r\n            t1BonusTime,\r\n            t1BonusRate,\r\n            t2BonusTime,\r\n            t2BonusRate\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @param threshold exceed the threshold will get bonus\r\n     */\r\n    function _setBonusConditions(\r\n        uint256 threshold,\r\n        uint256 t1BonusTime,\r\n        uint256 t1BonusRate,\r\n        uint256 t2BonusTime,\r\n        uint256 t2BonusRate\r\n    )\r\n        private\r\n        onlyOwner\r\n    {\r\n        require(threshold > 0,\" threshold cannot be zero.\");\r\n        require(t1BonusTime < t2BonusTime, \"invalid bonus time\");\r\n        require(t1BonusRate >= t2BonusRate, \"invalid bonus rate\");\r\n\r\n        bonusThreshold = threshold;\r\n        tierOneBonusTime = t1BonusTime;\r\n        tierOneBonusRate = t1BonusRate;\r\n        tierTwoBonusTime = t2BonusTime;\r\n        tierTwoBonusRate = t2BonusRate;\r\n\r\n        emit BonusConditionsSet(\r\n            msg.sender,\r\n            threshold,\r\n            t1BonusTime,\r\n            t1BonusRate,\r\n            t2BonusTime,\r\n            t2BonusRate\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice set allowed to ture to add the user into the whitelist\r\n     * @notice set allowed to false to remove the user from the whitelist\r\n     * @param user address of user\r\n     * @param allowed whether allow the user to deposit/withdraw or not\r\n     */\r\n    function setWhitelist(address user, bool allowed) external onlyOwner {\r\n        whitelist[user] = allowed;\r\n        emit WhitelistSet(msg.sender, user, allowed);\r\n    }\r\n\r\n    /**\r\n     * @dev checks the amount of tokens left in the allowance.\r\n     * @return amount of tokens left in the allowance\r\n     */\r\n    function remainingTokens() external view returns (uint256) {\r\n        return Math.min(\r\n            saleToken.balanceOf(tokenWallet),\r\n            saleToken.allowance(tokenWallet, address(this))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @param exToken address of the exchangeable token\r\n     * @param accepted true: accepted; false: rejected\r\n     * @param rate exchange rate\r\n     */\r\n    function setExToken(\r\n        address exToken,\r\n        bool accepted,\r\n        uint256 rate\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        _exTokens[exToken].accepted = accepted;\r\n        _exTokens[exToken].rate = rate;\r\n        emit ExTokenSet(msg.sender, exToken, accepted, rate);\r\n    }\r\n\r\n    /**\r\n     * @param exToken address of the exchangeable token\r\n     * @return whether the exchangeable token is accepted or not\r\n     */\r\n    function accepted(address exToken) public view returns (bool) {\r\n        return _exTokens[exToken].accepted;\r\n    }\r\n\r\n    /**\r\n     * @param exToken address of the exchangeale token\r\n     * @return amount of sale token a buyer gets per exchangeable token\r\n     */\r\n    function rate(address exToken) external view returns (uint256) {\r\n        return _exTokens[exToken].rate;\r\n    }\r\n\r\n    /**\r\n     * @dev get exchangeable sale token amount\r\n     * @param exToken address of the exchangeable token\r\n     * @param amount amount of the exchangeable token (how much to pay)\r\n     * @return purchased sale token amount\r\n     */\r\n    function exchangeableAmounts(\r\n        address exToken,\r\n        uint256 amount\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _getTokenAmount(exToken, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev buy tokens\r\n     * @dev buyer must be in whitelist\r\n     * @param exToken address of the exchangeable token\r\n     * @param amount amount of the exchangeable token\r\n     */\r\n    function buyTokens(\r\n        address exToken,\r\n        uint256 amount\r\n    )\r\n        external\r\n    {\r\n        require(_exTokens[exToken].accepted, \"token was not accepted\");\r\n        require(amount != 0, \"amount cannot 0\");\r\n        require(whitelist[msg.sender], \"buyer must be in whitelist\");\r\n        // calculate token amount to sell\r\n        uint256 tokens = _getTokenAmount(exToken, amount);\r\n        require(tokens >= 10**19, \"at least buy 10 tokens per purchase\");\r\n        _forwardFunds(exToken, amount);\r\n        _processPurchase(msg.sender, tokens);\r\n        emit TokensPurchased(msg.sender, exToken, amount, tokens);\r\n    }\r\n\r\n    /**\r\n     * @dev buyer transfers amount of the exchangeable token to fund collector\r\n     * @param exToken address of the exchangeable token\r\n     * @param amount amount of the exchangeable token will send to fund collector\r\n     */\r\n    function _forwardFunds(address exToken, uint256 amount) private {\r\n        IERC20(exToken).safeTransferFrom(msg.sender, fundCollector, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev calculated purchased sale token amount\r\n     * @param exToken address of the exchangeable token\r\n     * @param amount amount of the exchangeable token (how much to pay)\r\n     * @return amount of purchased sale token\r\n     */\r\n    function _getTokenAmount(\r\n        address exToken,\r\n        uint256 amount\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // round down value (v) by multiple (m) = (v / m) * m\r\n        uint256 value = amount\r\n            .mul(_exTokens[exToken].rate)\r\n            .div(1000000000000000000)\r\n            .mul(1000000000000000000);\r\n        return _applyBonus(value);\r\n    }\r\n\r\n    function _applyBonus(\r\n        uint256 amount\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (amount < bonusThreshold) {\r\n            return amount;\r\n        }\r\n\r\n        if (block.timestamp <= tierOneBonusTime) {\r\n            return amount.mul(tierOneBonusRate).div(100);\r\n        } else if (block.timestamp <= tierTwoBonusTime) {\r\n            return amount.mul(tierTwoBonusRate).div(100);\r\n        } else {\r\n            return amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev transfer sale token amounts from token wallet to beneficiary\r\n     * @param beneficiary purchased tokens will transfer to this address\r\n     * @param tokenAmount purchased token amount\r\n     */\r\n    function _processPurchase(\r\n        address beneficiary,\r\n        uint256 tokenAmount\r\n    )\r\n        private\r\n    {\r\n        saleToken.safeTransferFrom(tokenWallet, beneficiary, tokenAmount);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"exToken\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"exToken\",\"type\":\"address\"}],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"threshold\",\"type\":\"uint256\"},{\"name\":\"t1BonusTime\",\"type\":\"uint256\"},{\"name\":\"t1BonusRate\",\"type\":\"uint256\"},{\"name\":\"t2BonusTime\",\"type\":\"uint256\"},{\"name\":\"t2BonusRate\",\"type\":\"uint256\"}],\"name\":\"setBonusConditions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"exToken\",\"type\":\"address\"}],\"name\":\"accepted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tierTwoBonusTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tierOneBonusTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundCollector\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fundCollector\",\"type\":\"address\"}],\"name\":\"setFundCollector\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tierTwoBonusRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tierOneBonusRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"saleToken\",\"type\":\"address\"}],\"name\":\"setSaleToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenWallet\",\"type\":\"address\"}],\"name\":\"setTokenWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exToken\",\"type\":\"address\"},{\"name\":\"accepted\",\"type\":\"bool\"},{\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setExToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"exToken\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exchangeableAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"fundCollector\",\"type\":\"address\"},{\"name\":\"saleToken\",\"type\":\"address\"},{\"name\":\"tokenWallet\",\"type\":\"address\"},{\"name\":\"bonusThreshold\",\"type\":\"uint256\"},{\"name\":\"tierOneBonusTime\",\"type\":\"uint256\"},{\"name\":\"tierOneBonusRate\",\"type\":\"uint256\"},{\"name\":\"tierTwoBonusTime\",\"type\":\"uint256\"},{\"name\":\"tierTwoBonusRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"fundCollector\",\"type\":\"address\"}],\"name\":\"FundCollectorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"saleToken\",\"type\":\"address\"}],\"name\":\"SaleTokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenWallet\",\"type\":\"address\"}],\"name\":\"TokenWalletSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bonusThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tierOneBonusTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tierOneBonusRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tierTwoBonusTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tierTwoBonusRate\",\"type\":\"uint256\"}],\"name\":\"BonusConditionsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"WhitelistSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"exToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"accepted\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"ExTokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"exToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"exTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenSale","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000023a03721afdc75a1879d6e04a5275bdceebe28fb0000000000000000000000001bb7c7f703ce521fa68524286d6a6d177741cd92000000000000000000000000997c031cde0d82ea7b2f43404167327be936309e00000000000000000000000000000000000000000000021e19e0c9bab2400000000000000000000000000000000000000000000000000000000000005d6a9980000000000000000000000000000000000000000000000000000000000000006e000000000000000000000000000000000000000000000000000000005e0b70800000000000000000000000000000000000000000000000000000000000000069","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://aeb685b9edab8056d261a3fcbb5391486951799b039333f2742692fbf5a814bc"}]}