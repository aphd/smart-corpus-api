{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/MathUint.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title Utility Functions for uint\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary MathUint\r\n{\r\n    function mul(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\r\n    }\r\n\r\n    function sub(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        require(b <= a, \"SUB_UNDERFLOW\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"ADD_OVERFLOW\");\r\n    }\r\n\r\n    function decodeFloat(\r\n        uint f\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint value)\r\n    {\r\n        uint numBitsMantissa = 23;\r\n        uint exponent = f >> numBitsMantissa;\r\n        uint mantissa = f & ((1 << numBitsMantissa) - 1);\r\n        value = mantissa * (10 ** exponent);\r\n    }\r\n}\r\n\r\n// File: contracts/iface/IAddressWhitelist.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title IAddressWhitelist\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract IAddressWhitelist\r\n{\r\n    /// @dev Check if a address is whitelisted.\r\n    /// @param user The user to check if being whitelisted.\r\n    /// @param permission An arbitrary data from caller to indicate permission.\r\n    /// @return true if the address is whitelisted\r\n    function isWhitelisted(\r\n        address user,\r\n        bytes   memory permission\r\n        )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/lib/Poseidon.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title Poseidon hash function\r\n///        See: https://eprint.iacr.org/2019/458.pdf\r\n///        Code auto-generated by generate_poseidon_EVM_code.py\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary Poseidon\r\n{\r\n    function hash_t5f6p52(\r\n        uint t0,\r\n        uint t1,\r\n        uint t2,\r\n        uint t3,\r\n        uint t4\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        uint q = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n        // Make sure the inputs can be stored in the SNARK field\r\n        require(t0 < q, \"INVALID_INPUT\");\r\n        require(t1 < q, \"INVALID_INPUT\");\r\n        require(t2 < q, \"INVALID_INPUT\");\r\n        require(t3 < q, \"INVALID_INPUT\");\r\n        require(t4 < q, \"INVALID_INPUT\");\r\n\r\n        assembly {\r\n            function mix(t0, t1, t2, t3, t4, q) -> nt0, nt1, nt2, nt3, nt4 {\r\n                nt0 := mulmod(t0, 4977258759536702998522229302103997878600602264560359702680165243908162277980, q)\r\n                nt0 := addmod(nt0, mulmod(t1, 19167410339349846567561662441069598364702008768579734801591448511131028229281, q), q)\r\n                nt0 := addmod(nt0, mulmod(t2, 14183033936038168803360723133013092560869148726790180682363054735190196956789, q), q)\r\n                nt0 := addmod(nt0, mulmod(t3, 9067734253445064890734144122526450279189023719890032859456830213166173619761, q), q)\r\n                nt0 := addmod(nt0, mulmod(t4, 16378664841697311562845443097199265623838619398287411428110917414833007677155, q), q)\r\n                nt1 := mulmod(t0, 107933704346764130067829474107909495889716688591997879426350582457782826785, q)\r\n                nt1 := addmod(nt1, mulmod(t1, 17034139127218860091985397764514160131253018178110701196935786874261236172431, q), q)\r\n                nt1 := addmod(nt1, mulmod(t2, 2799255644797227968811798608332314218966179365168250111693473252876996230317, q), q)\r\n                nt1 := addmod(nt1, mulmod(t3, 2482058150180648511543788012634934806465808146786082148795902594096349483974, q), q)\r\n                nt1 := addmod(nt1, mulmod(t4, 16563522740626180338295201738437974404892092704059676533096069531044355099628, q), q)\r\n                nt2 := mulmod(t0, 13596762909635538739079656925495736900379091964739248298531655823337482778123, q)\r\n                nt2 := addmod(nt2, mulmod(t1, 18985203040268814769637347880759846911264240088034262814847924884273017355969, q), q)\r\n                nt2 := addmod(nt2, mulmod(t2, 8652975463545710606098548415650457376967119951977109072274595329619335974180, q), q)\r\n                nt2 := addmod(nt2, mulmod(t3, 970943815872417895015626519859542525373809485973005165410533315057253476903, q), q)\r\n                nt2 := addmod(nt2, mulmod(t4, 19406667490568134101658669326517700199745817783746545889094238643063688871948, q), q)\r\n                nt3 := mulmod(t0, 2953507793609469112222895633455544691298656192015062835263784675891831794974, q)\r\n                nt3 := addmod(nt3, mulmod(t1, 19025623051770008118343718096455821045904242602531062247152770448380880817517, q), q)\r\n                nt3 := addmod(nt3, mulmod(t2, 9077319817220936628089890431129759976815127354480867310384708941479362824016, q), q)\r\n                nt3 := addmod(nt3, mulmod(t3, 4770370314098695913091200576539533727214143013236894216582648993741910829490, q), q)\r\n                nt3 := addmod(nt3, mulmod(t4, 4298564056297802123194408918029088169104276109138370115401819933600955259473, q), q)\r\n                nt4 := mulmod(t0, 8336710468787894148066071988103915091676109272951895469087957569358494947747, q)\r\n                nt4 := addmod(nt4, mulmod(t1, 16205238342129310687768799056463408647672389183328001070715567975181364448609, q), q)\r\n                nt4 := addmod(nt4, mulmod(t2, 8303849270045876854140023508764676765932043944545416856530551331270859502246, q), q)\r\n                nt4 := addmod(nt4, mulmod(t3, 20218246699596954048529384569730026273241102596326201163062133863539137060414, q), q)\r\n                nt4 := addmod(nt4, mulmod(t4, 1712845821388089905746651754894206522004527237615042226559791118162382909269, q), q)\r\n            }\r\n\r\n            function ark(t0, t1, t2, t3, t4, q, c) -> nt0, nt1, nt2, nt3, nt4 {\r\n                nt0 := addmod(t0, c, q)\r\n                nt1 := addmod(t1, c, q)\r\n                nt2 := addmod(t2, c, q)\r\n                nt3 := addmod(t3, c, q)\r\n                nt4 := addmod(t4, c, q)\r\n            }\r\n\r\n            function sbox_full(t0, t1, t2, t3, t4, q) -> nt0, nt1, nt2, nt3, nt4 {\r\n                nt0 := mulmod(t0, t0, q)\r\n                nt0 := mulmod(nt0, nt0, q)\r\n                nt0 := mulmod(t0, nt0, q)\r\n                nt1 := mulmod(t1, t1, q)\r\n                nt1 := mulmod(nt1, nt1, q)\r\n                nt1 := mulmod(t1, nt1, q)\r\n                nt2 := mulmod(t2, t2, q)\r\n                nt2 := mulmod(nt2, nt2, q)\r\n                nt2 := mulmod(t2, nt2, q)\r\n                nt3 := mulmod(t3, t3, q)\r\n                nt3 := mulmod(nt3, nt3, q)\r\n                nt3 := mulmod(t3, nt3, q)\r\n                nt4 := mulmod(t4, t4, q)\r\n                nt4 := mulmod(nt4, nt4, q)\r\n                nt4 := mulmod(t4, nt4, q)\r\n            }\r\n\r\n            function sbox_partial(t, q) -> nt {\r\n                nt := mulmod(t, t, q)\r\n                nt := mulmod(nt, nt, q)\r\n                nt := mulmod(t, nt, q)\r\n            }\r\n\r\n            // round 0\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14397397413755236225575615486459253198602422701513067526754101844196324375522)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 1\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10405129301473404666785234951972711717481302463898292859783056520670200613128)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 2\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 5179144822360023508491245509308555580251733042407187134628755730783052214509)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 3\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9132640374240188374542843306219594180154739721841249568925550236430986592615)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 4\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20360807315276763881209958738450444293273549928693737723235350358403012458514)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 5\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17933600965499023212689924809448543050840131883187652471064418452962948061619)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 6\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3636213416533737411392076250708419981662897009810345015164671602334517041153)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 7\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2008540005368330234524962342006691994500273283000229509835662097352946198608)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 8\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16018407964853379535338740313053768402596521780991140819786560130595652651567)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 9\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20653139667070586705378398435856186172195806027708437373983929336015162186471)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 10\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17887713874711369695406927657694993484804203950786446055999405564652412116765)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 11\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4852706232225925756777361208698488277369799648067343227630786518486608711772)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 12\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8969172011633935669771678412400911310465619639756845342775631896478908389850)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 13\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20570199545627577691240476121888846460936245025392381957866134167601058684375)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 14\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16442329894745639881165035015179028112772410105963688121820543219662832524136)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 15\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20060625627350485876280451423010593928172611031611836167979515653463693899374)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 16\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16637282689940520290130302519163090147511023430395200895953984829546679599107)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 17\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15599196921909732993082127725908821049411366914683565306060493533569088698214)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 18\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16894591341213863947423904025624185991098788054337051624251730868231322135455)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 19\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 1197934381747032348421303489683932612752526046745577259575778515005162320212)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 20\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6172482022646932735745595886795230725225293469762393889050804649558459236626)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 21\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21004037394166516054140386756510609698837211370585899203851827276330669555417)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 22\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15262034989144652068456967541137853724140836132717012646544737680069032573006)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 23\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15017690682054366744270630371095785995296470601172793770224691982518041139766)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 24\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15159744167842240513848638419303545693472533086570469712794583342699782519832)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 25\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11178069035565459212220861899558526502477231302924961773582350246646450941231)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 26\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21154888769130549957415912997229564077486639529994598560737238811887296922114)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 27\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20162517328110570500010831422938033120419484532231241180224283481905744633719)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 28\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2777362604871784250419758188173029886707024739806641263170345377816177052018)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 29\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15732290486829619144634131656503993123618032247178179298922551820261215487562)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 30\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6024433414579583476444635447152826813568595303270846875177844482142230009826)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 31\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17677827682004946431939402157761289497221048154630238117709539216286149983245)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 32\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10716307389353583413755237303156291454109852751296156900963208377067748518748)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 33\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14925386988604173087143546225719076187055229908444910452781922028996524347508)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 34\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8940878636401797005293482068100797531020505636124892198091491586778667442523)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 35\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 18911747154199663060505302806894425160044925686870165583944475880789706164410)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 36\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8821532432394939099312235292271438180996556457308429936910969094255825456935)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 37\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20632576502437623790366878538516326728436616723089049415538037018093616927643)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 38\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 71447649211767888770311304010816315780740050029903404046389165015534756512)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 39\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2781996465394730190470582631099299305677291329609718650018200531245670229393)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 40\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 12441376330954323535872906380510501637773629931719508864016287320488688345525)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 41\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2558302139544901035700544058046419714227464650146159803703499681139469546006)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 42\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10087036781939179132584550273563255199577525914374285705149349445480649057058)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 43\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4267692623754666261749551533667592242661271409704769363166965280715887854739)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 44\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4945579503584457514844595640661884835097077318604083061152997449742124905548)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 45\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17742335354489274412669987990603079185096280484072783973732137326144230832311)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 46\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6266270088302506215402996795500854910256503071464802875821837403486057988208)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 47\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2716062168542520412498610856550519519760063668165561277991771577403400784706)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 48\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 19118392018538203167410421493487769944462015419023083813301166096764262134232)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 49\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9386595745626044000666050847309903206827901310677406022353307960932745699524)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 50\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9121640807890366356465620448383131419933298563527245687958865317869840082266)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 51\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3078975275808111706229899605611544294904276390490742680006005661017864583210)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 52\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 7157404299437167354719786626667769956233708887934477609633504801472827442743)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 53\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14056248655941725362944552761799461694550787028230120190862133165195793034373)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 54\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14124396743304355958915937804966111851843703158171757752158388556919187839849)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 55\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11851254356749068692552943732920045260402277343008629727465773766468466181076)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 56\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9799099446406796696742256539758943483211846559715874347178722060519817626047)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 57\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10156146186214948683880719664738535455146137901666656566575307300522957959544)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n        }\r\n        return t0;\r\n    }\r\n}\r\n\r\n\r\n// File: contracts/impl/libexchange/ExchangeBalances.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n/// @title ExchangeBalances.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeBalances\r\n{\r\n    using MathUint  for uint;\r\n\r\n    function verifyAccountBalance(\r\n        uint     merkleRoot,\r\n        uint24   accountID,\r\n        uint16   tokenID,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint32   nonce,\r\n        uint96   balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[30] calldata accountMerkleProof,\r\n        uint[12] calldata balanceMerkleProof\r\n        )\r\n        external\r\n        pure\r\n    {\r\n        bool isCorrect = isAccountBalanceCorrect(\r\n            merkleRoot,\r\n            accountID,\r\n            tokenID,\r\n            pubKeyX,\r\n            pubKeyY,\r\n            nonce,\r\n            balance,\r\n            tradeHistoryRoot,\r\n            accountMerkleProof,\r\n            balanceMerkleProof\r\n        );\r\n        require(isCorrect, \"INVALID_MERKLE_TREE_DATA\");\r\n    }\r\n\r\n    function isAccountBalanceCorrect(\r\n        uint     merkleRoot,\r\n        uint24   accountID,\r\n        uint16   tokenID,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint32   nonce,\r\n        uint96   balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[30] memory accountMerkleProof,\r\n        uint[12] memory balanceMerkleProof\r\n        )\r\n        public\r\n        pure\r\n        returns (bool isCorrect)\r\n    {\r\n        // Verify data\r\n        uint calculatedRoot = getBalancesRoot(\r\n            tokenID,\r\n            balance,\r\n            tradeHistoryRoot,\r\n            balanceMerkleProof\r\n        );\r\n        calculatedRoot = getAccountInternalsRoot(\r\n            accountID,\r\n            pubKeyX,\r\n            pubKeyY,\r\n            nonce,\r\n            calculatedRoot,\r\n            accountMerkleProof\r\n        );\r\n        isCorrect = (calculatedRoot == merkleRoot);\r\n    }\r\n\r\n    function getBalancesRoot(\r\n        uint16   tokenID,\r\n        uint     balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[12] memory balanceMerkleProof\r\n        )\r\n        private\r\n        pure\r\n        returns (uint)\r\n    {\r\n        uint balanceItem = hashImpl(balance, tradeHistoryRoot, 0, 0);\r\n        uint _id = tokenID;\r\n        for (uint depth = 0; depth < 4; depth++) {\r\n            if (_id & 3 == 0) {\r\n                balanceItem = hashImpl(\r\n                    balanceItem,\r\n                    balanceMerkleProof[depth * 3],\r\n                    balanceMerkleProof[depth * 3 + 1],\r\n                    balanceMerkleProof[depth * 3 + 2]\r\n                );\r\n            } else if (_id & 3 == 1) {\r\n                balanceItem = hashImpl(\r\n                    balanceMerkleProof[depth * 3],\r\n                    balanceItem,\r\n                    balanceMerkleProof[depth * 3 + 1],\r\n                    balanceMerkleProof[depth * 3 + 2]\r\n                );\r\n            } else if (_id & 3 == 2) {\r\n                balanceItem = hashImpl(\r\n                    balanceMerkleProof[depth * 3],\r\n                    balanceMerkleProof[depth * 3 + 1],\r\n                    balanceItem,\r\n                    balanceMerkleProof[depth * 3 + 2]\r\n                );\r\n            } else if (_id & 3 == 3) {\r\n                balanceItem = hashImpl(\r\n                    balanceMerkleProof[depth * 3],\r\n                    balanceMerkleProof[depth * 3 + 1],\r\n                    balanceMerkleProof[depth * 3 + 2],\r\n                    balanceItem\r\n                );\r\n            }\r\n            _id = _id >> 2;\r\n        }\r\n        return balanceItem;\r\n    }\r\n\r\n    function getAccountInternalsRoot(\r\n        uint24   accountID,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint     nonce,\r\n        uint     balancesRoot,\r\n        uint[30] memory accountMerkleProof\r\n        )\r\n        private\r\n        pure\r\n        returns (uint)\r\n    {\r\n        uint accountItem = hashImpl(pubKeyX, pubKeyY, nonce, balancesRoot);\r\n        uint _id = accountID;\r\n        for (uint depth = 0; depth < 10; depth++) {\r\n            if (_id & 3 == 0) {\r\n                accountItem = hashImpl(\r\n                    accountItem,\r\n                    accountMerkleProof[depth * 3],\r\n                    accountMerkleProof[depth * 3 + 1],\r\n                    accountMerkleProof[depth * 3 + 2]\r\n                );\r\n            } else if (_id & 3 == 1) {\r\n                accountItem = hashImpl(\r\n                    accountMerkleProof[depth * 3],\r\n                    accountItem,\r\n                    accountMerkleProof[depth * 3 + 1],\r\n                    accountMerkleProof[depth * 3 + 2]\r\n                );\r\n            } else if (_id & 3 == 2) {\r\n                accountItem = hashImpl(\r\n                    accountMerkleProof[depth * 3],\r\n                    accountMerkleProof[depth * 3 + 1],\r\n                    accountItem,\r\n                    accountMerkleProof[depth * 3 + 2]\r\n                );\r\n            } else if (_id & 3 == 3) {\r\n                accountItem = hashImpl(\r\n                    accountMerkleProof[depth * 3],\r\n                    accountMerkleProof[depth * 3 + 1],\r\n                    accountMerkleProof[depth * 3 + 2],\r\n                    accountItem\r\n                );\r\n            }\r\n            _id = _id >> 2;\r\n        }\r\n        return accountItem;\r\n    }\r\n\r\n    function hashImpl(\r\n        uint t0,\r\n        uint t1,\r\n        uint t2,\r\n        uint t3\r\n        )\r\n        private\r\n        pure\r\n        returns (uint)\r\n    {\r\n        return Poseidon.hash_t5f6p52(t0, t1, t2, t3, 0);\r\n    }\r\n}\r\n\r\n// File: contracts/iface/IBlockVerifier.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title IBlockVerifier\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ncontract IBlockVerifier\r\n{\r\n    // -- Events --\r\n\r\n    event CircuitRegistered(\r\n        uint8  indexed blockType,\r\n        bool           onchainDataAvailability,\r\n        uint16         blockSize,\r\n        uint8          blockVersion\r\n    );\r\n\r\n    event CircuitDisabled(\r\n        uint8  indexed blockType,\r\n        bool           onchainDataAvailability,\r\n        uint16         blockSize,\r\n        uint8          blockVersion\r\n    );\r\n\r\n    // -- Public functions --\r\n\r\n    /// @dev Sets the verifying key for the specified circuit.\r\n    ///      Every block permutation needs its own circuit and thus its own set of\r\n    ///      verification keys. Only a limited number of block sizes per block\r\n    ///      type are supported.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @param vk The verification key\r\n    function registerCircuit(\r\n        uint8    blockType,\r\n        bool     onchainDataAvailability,\r\n        uint16   blockSize,\r\n        uint8    blockVersion,\r\n        uint[18] calldata vk\r\n        )\r\n        external;\r\n\r\n    /// @dev Disables the use of the specified circuit.\r\n    ///      This will stop NEW blocks from using the given circuit, blocks that were already committed\r\n    ///      can still be verified.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    function disableCircuit(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external;\r\n\r\n    /// @dev Verify blocks with the given public data and proofs.\r\n    ///      Verifying a block makes sure all requests handled in the block\r\n    ///      are correctly handled by the operator.\r\n    /// @param blockType The type of block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @param publicInputs The hash of all the public data of the blocks\r\n    /// @param proofs The ZK proofs proving that the blocks are correct\r\n    /// @return True if the block is valid, false otherwise\r\n    function verifyProofs(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion,\r\n        uint[] calldata publicInputs,\r\n        uint[] calldata proofs\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Checks if a circuit with the specified parameters is registered.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @return True if the circuit is registered, false otherwise\r\n    function isCircuitRegistered(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Checks if a circuit can still be used to commit new blocks.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @return True if the circuit is enabled, false otherwise\r\n    function isCircuitEnabled(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/lib/Ownable.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title Ownable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev The Ownable contract has an owner address, and provides basic\r\n///      authorization control functions, this simplifies the implementation of\r\n///      \"user permissions\".\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract\r\n    ///      to the sender.\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a\r\n    ///      new owner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/Claimable.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n/// @title Claimable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Extension for the Ownable contract, where the ownership needs\r\n///      to be claimed. This allows the new owner to accept the transfer.\r\ncontract Claimable is Ownable\r\n{\r\n    address public pendingOwner;\r\n\r\n    /// @dev Modifier throws if called by any account other than the pendingOwner.\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to set the pendingOwner address.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /// @dev Allows the pendingOwner address to finalize the transfer.\r\n    function claimOwnership()\r\n        public\r\n        onlyPendingOwner\r\n    {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ReentrancyGuard.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title ReentrancyGuard\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Exposes a modifier that guards a function against reentrancy\r\n///      Changing the value of the same storage value multiple times in a transaction\r\n///      is cheap (starting from Istanbul) so there is no need to minimize\r\n///      the number of times the value is changed\r\ncontract ReentrancyGuard\r\n{\r\n    //The default value must be 0 in order to work behind a proxy.\r\n    uint private _guardValue;\r\n\r\n    // Use this modifier on a function to prevent reentrancy\r\n    modifier nonReentrant()\r\n    {\r\n        // Check if the guard value has its original value\r\n        require(_guardValue == 0, \"REENTRANCY\");\r\n\r\n        // Set the value to something else\r\n        _guardValue = 1;\r\n\r\n        // Function body\r\n        _;\r\n\r\n        // Set the value back\r\n        _guardValue = 0;\r\n    }\r\n}\r\n\r\n// File: contracts/iface/ILoopring.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n/// @title ILoopring\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract ILoopring is Claimable, ReentrancyGuard\r\n{\r\n    address public protocolRegistry;\r\n    address public lrcAddress;\r\n    uint    public exchangeCreationCostLRC;\r\n\r\n    event ExchangeInitialized(\r\n        uint    indexed exchangeId,\r\n        address indexed exchangeAddress,\r\n        address indexed owner,\r\n        address         operator,\r\n        bool            onchainDataAvailability\r\n    );\r\n\r\n    /// @dev Initialize and register an exchange.\r\n    ///      This function should only be callabled by the protocolRegistry contract.\r\n    ///      Also note that this function can only be called once per exchange instance.\r\n    /// @param  exchangeAddress The address of the exchange to initialize and register.\r\n    /// @param  exchangeId The unique exchange id.\r\n    /// @param  owner The owner of the exchange.\r\n    /// @param  operator The operator of the exchange.\r\n    /// @param  onchainDataAvailability True if \"Data Availability\" is turned on for this\r\n    ///         exchange. Note that this value can not be changed once the exchange is initialized.\r\n    /// @return exchangeId The id of the exchange.\r\n    function initializeExchange(\r\n        address exchangeAddress,\r\n        uint    exchangeId,\r\n        address owner,\r\n        address payable operator,\r\n        bool    onchainDataAvailability\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/iface/ILoopringV3.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n/// @title ILoopringV3\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract ILoopringV3 is ILoopring\r\n{\r\n    // == Events ==\r\n\r\n    event ExchangeStakeDeposited(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ExchangeStakeWithdrawn(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ExchangeStakeBurned(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ProtocolFeeStakeDeposited(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ProtocolFeeStakeWithdrawn(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event SettingsUpdated(\r\n        uint            time\r\n    );\r\n\r\n    // == Public Variables ==\r\n    struct Exchange\r\n    {\r\n        address exchangeAddress;\r\n        uint    exchangeStake;\r\n        uint    protocolFeeStake;\r\n    }\r\n\r\n    mapping (uint => Exchange) internal exchanges;\r\n\r\n    uint    public totalStake;\r\n\r\n    address public wethAddress;\r\n    address public exchangeDeployerAddress;\r\n    address public blockVerifierAddress;\r\n    address public downtimeCostCalculator;\r\n    uint    public maxWithdrawalFee;\r\n    uint    public withdrawalFineLRC;\r\n    uint    public tokenRegistrationFeeLRCBase;\r\n    uint    public tokenRegistrationFeeLRCDelta;\r\n    uint    public minExchangeStakeWithDataAvailability;\r\n    uint    public minExchangeStakeWithoutDataAvailability;\r\n    uint    public revertFineLRC;\r\n    uint8   public minProtocolTakerFeeBips;\r\n    uint8   public maxProtocolTakerFeeBips;\r\n    uint8   public minProtocolMakerFeeBips;\r\n    uint8   public maxProtocolMakerFeeBips;\r\n    uint    public targetProtocolTakerFeeStake;\r\n    uint    public targetProtocolMakerFeeStake;\r\n\r\n    address payable public protocolFeeVault;\r\n\r\n    // == Public Functions ==\r\n    /// @dev Update the global exchange settings.\r\n    ///      This function can only be called by the owner of this contract.\r\n    ///\r\n    ///      Warning: these new values will be used by existing and\r\n    ///      new Loopring exchanges.\r\n    function updateSettings(\r\n        address payable _protocolFeeVault,   // address(0) not allowed\r\n        address _blockVerifierAddress,       // address(0) not allowed\r\n        address _downtimeCostCalculator,     // address(0) allowed\r\n        uint    _exchangeCreationCostLRC,\r\n        uint    _maxWithdrawalFee,\r\n        uint    _tokenRegistrationFeeLRCBase,\r\n        uint    _tokenRegistrationFeeLRCDelta,\r\n        uint    _minExchangeStakeWithDataAvailability,\r\n        uint    _minExchangeStakeWithoutDataAvailability,\r\n        uint    _revertFineLRC,\r\n        uint    _withdrawalFineLRC\r\n        )\r\n        external;\r\n\r\n    /// @dev Update the global protocol fee settings.\r\n    ///      This function can only be called by the owner of this contract.\r\n    ///\r\n    ///      Warning: these new values will be used by existing and\r\n    ///      new Loopring exchanges.\r\n    function updateProtocolFeeSettings(\r\n        uint8 _minProtocolTakerFeeBips,\r\n        uint8 _maxProtocolTakerFeeBips,\r\n        uint8 _minProtocolMakerFeeBips,\r\n        uint8 _maxProtocolMakerFeeBips,\r\n        uint  _targetProtocolTakerFeeStake,\r\n        uint  _targetProtocolMakerFeeStake\r\n        )\r\n        external;\r\n\r\n    /// @dev Returns whether the Exchange has staked enough to commit blocks\r\n    ///      Exchanges with on-chain data-availaiblity need to stake at least\r\n    ///      minExchangeStakeWithDataAvailability, exchanges without\r\n    ///      data-availability need to stake at least\r\n    ///      minExchangeStakeWithoutDataAvailability.\r\n    /// @param exchangeId The id of the exchange\r\n    /// @param onchainDataAvailability True if the exchange has on-chain\r\n    ///        data-availability, else false\r\n    /// @return True if the exchange has staked enough, else false\r\n    function canExchangeCommitBlocks(\r\n        uint exchangeId,\r\n        bool onchainDataAvailability\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Get the amount of staked LRC for an exchange.\r\n    /// @param exchangeId The id of the exchange\r\n    /// @return stakedLRC The amount of LRC\r\n    function getExchangeStake(\r\n        uint exchangeId\r\n        )\r\n        public\r\n        view\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Burn a certain amount of staked LRC for a specific exchange.\r\n    ///      This function is meant to be called only from exchange contracts.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @return burnedLRC The amount of LRC burned. If the amount is greater than\r\n    ///         the staked amount, all staked LRC will be burned.\r\n    function burnExchangeStake(\r\n        uint exchangeId,\r\n        uint amount\r\n        )\r\n        external\r\n        returns (uint burnedLRC);\r\n\r\n    /// @dev Stake more LRC for an exchange.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  amountLRC The amount of LRC to stake\r\n    /// @return stakedLRC The total amount of LRC staked for the exchange\r\n    function depositExchangeStake(\r\n        uint exchangeId,\r\n        uint amountLRC\r\n        )\r\n        external\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Withdraw a certain amount of staked LRC for an exchange to the given address.\r\n    ///      This function is meant to be called only from within exchange contracts.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  recipient The address to receive LRC\r\n    /// @param  requestedAmount The amount of LRC to withdraw\r\n    /// @return stakedLRC The amount of LRC withdrawn\r\n    function withdrawExchangeStake(\r\n        uint    exchangeId,\r\n        address recipient,\r\n        uint    requestedAmount\r\n        )\r\n        external\r\n        returns (uint amount);\r\n\r\n    /// @dev Stake more LRC for an exchange.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  amountLRC The amount of LRC to stake\r\n    /// @return stakedLRC The total amount of LRC staked for the exchange\r\n    function depositProtocolFeeStake(\r\n        uint exchangeId,\r\n        uint amountLRC\r\n        )\r\n        external\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Withdraw a certain amount of staked LRC for an exchange to the given address.\r\n    ///      This function is meant to be called only from within exchange contracts.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  recipient The address to receive LRC\r\n    /// @param  amount The amount of LRC to withdraw\r\n    function withdrawProtocolFeeStake(\r\n        uint    exchangeId,\r\n        address recipient,\r\n        uint    amount\r\n        )\r\n        external;\r\n\r\n    /// @dev Get the protocol fee values for an exchange.\r\n    /// @param exchangeId The id of the exchange\r\n    /// @param onchainDataAvailability True if the exchange has on-chain\r\n    ///        data-availability, else false\r\n    /// @return takerFeeBips The protocol taker fee\r\n    /// @return makerFeeBips The protocol maker fee\r\n    function getProtocolFeeValues(\r\n        uint exchangeId,\r\n        bool onchainDataAvailability\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint8 takerFeeBips,\r\n            uint8 makerFeeBips\r\n        );\r\n\r\n    /// @dev Returns the exchange's protocol fee stake.\r\n    /// @param  exchangeId The exchange's id.\r\n    /// @return protocolFeeStake The exchange's protocol fee stake.\r\n    function getProtocolFeeStake(\r\n        uint exchangeId\r\n        )\r\n        external\r\n        view\r\n        returns (uint protocolFeeStake);\r\n}\r\n\r\n// File: contracts/impl/libexchange/ExchangeData.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n/// @title ExchangeData\r\n/// @dev All methods in this lib are internal, therefore, there is no need\r\n///      to deploy this library independently.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeData\r\n{\r\n    // -- Enums --\r\n    enum BlockType\r\n    {\r\n        RING_SETTLEMENT,\r\n        DEPOSIT,\r\n        ONCHAIN_WITHDRAWAL,\r\n        OFFCHAIN_WITHDRAWAL,\r\n        ORDER_CANCELLATION,\r\n        TRANSFER\r\n    }\r\n\r\n    enum BlockState\r\n    {\r\n        // This value should never be seen onchain, but we want to reserve 0 so the\r\n        // relayer can use this as the default for new blocks.\r\n        NEW,            // = 0\r\n\r\n        // The default state when a new block is included onchain.\r\n        COMMITTED,      // = 1\r\n\r\n        // A valid ZK proof has been submitted for this block.\r\n        // The genesis block is VERIFIED by default.\r\n        VERIFIED        // = 2\r\n    }\r\n\r\n    // -- Structs --\r\n    struct Account\r\n    {\r\n        address owner;\r\n\r\n        // pubKeyX and pubKeyY put together is the EdDSA public trading key. Users or their\r\n        // wallet software are supposed to manage the corresponding private key for signing\r\n        // orders and offchain requests.\r\n        //\r\n        // We use EdDSA because it is more circuit friendly than ECDSA. In later versions\r\n        // we may switch back to ECDSA, then we will not need such a dedicated tradig key-pair.\r\n        //\r\n        // We split the public key into two uint to make it more circuit friendly.\r\n        uint    pubKeyX;\r\n        uint    pubKeyY;\r\n    }\r\n\r\n    struct Token\r\n    {\r\n        address token;\r\n        bool    depositDisabled;\r\n    }\r\n\r\n    struct ProtocolFeeData\r\n    {\r\n        uint32 timestamp;\r\n        uint8 takerFeeBips;\r\n        uint8 makerFeeBips;\r\n        uint8 previousTakerFeeBips;\r\n        uint8 previousMakerFeeBips;\r\n    }\r\n\r\n    // This is the (virtual) block an operator needs to submit onchain to maintain the\r\n    // per-exchange (virtual) blockchain.\r\n    struct Block\r\n    {\r\n        // The merkle root of the offchain data stored in a merkle tree. The merkle tree\r\n        // stores balances for users using an account model.\r\n        bytes32 merkleRoot;\r\n\r\n        // The hash of all the public data sent in commitBlock. Committing a block\r\n        // is decoupled from the verification of a block, but we don't want to send\r\n        // the (often) large amount of data (certainly with onchain data availability) again\r\n        // when verifying the proof, so we hash all that data onchain in commitBlock so that we\r\n        // can use it in verifyBlock to verify the block. This also makes the verification cheaper\r\n        // onchain because we only have this single public input.\r\n        bytes32 publicDataHash;\r\n\r\n        // The current state of the block. See @BlockState for more information.\r\n        BlockState state;\r\n\r\n        // The type of the block (i.e. what kind of requests were processed).\r\n        // See @BlockType for more information.\r\n        BlockType blockType;\r\n\r\n        // The number of requests processed in the block. Only a limited number of permutations\r\n        // are available for each block type (because each will need a different circuit\r\n        // and thus different verification key onchain). Use IBlockVerifier.canVerify to find out if\r\n        // the block is supported.\r\n        uint16 blockSize;\r\n\r\n        // The block version (i.e. what circuit version needs to be used to verify the block).\r\n        uint8  blockVersion;\r\n\r\n        // The time the block was created.\r\n        uint32 timestamp;\r\n\r\n        // The number of onchain deposit requests that have been processed\r\n        // up to and including this block.\r\n        uint32 numDepositRequestsCommitted;\r\n\r\n        // The number of onchain withdrawal requests that have been processed\r\n        // up to and including this block.\r\n        uint32 numWithdrawalRequestsCommitted;\r\n\r\n        // Stores whether the fee earned by the operator for processing onchain requests\r\n        // is withdrawn or not.\r\n        bool   blockFeeWithdrawn;\r\n\r\n        // Number of withdrawals distributed using `distributeWithdrawals`\r\n        uint16 numWithdrawalsDistributed;\r\n\r\n        // The approved withdrawal data. Needs to be stored onchain so this data is available\r\n        // once the block is finalized and the funds can be withdrawn using the info stored\r\n        // in this data.\r\n        // For every withdrawal (there are 'blockSize' withdrawals),\r\n        // stored sequentially after each other:\r\n        //    - Token ID: 1 bytes\r\n        //    - Account ID: 2,5 bytes\r\n        //    - Amount: 3,5 bytes\r\n        bytes  withdrawals;\r\n    }\r\n\r\n    // Represents the post-state of an onchain deposit/withdrawal request. We can visualize\r\n    // a deposit request-chain and a withdrawal request-chain, each of which is\r\n    // composed of such Request objects. Please refer to the design doc for more details.\r\n    struct Request\r\n    {\r\n        bytes32 accumulatedHash;\r\n        uint    accumulatedFee;\r\n        uint32  timestamp;\r\n    }\r\n\r\n    // Represents an onchain deposit request.  `tokenID` being `0x0` means depositing Ether.\r\n    struct Deposit\r\n    {\r\n        uint24 accountID;\r\n        uint16 tokenID;\r\n        uint96 amount;\r\n    }\r\n\r\n    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\r\n        // This is the prime number that is used for the alt_bn128 elliptic curve, see EIP-196.\r\n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    }\r\n\r\n    function MAX_PROOF_GENERATION_TIME_IN_SECONDS() internal pure returns (uint32) { return 1 hours; }\r\n    function MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS() internal pure returns (uint32) { return 2500; }\r\n    function MAX_OPEN_DEPOSIT_REQUESTS() internal pure returns (uint16) { return 1024; }\r\n    function MAX_OPEN_WITHDRAWAL_REQUESTS() internal pure returns (uint16) { return 1024; }\r\n    function MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 1 days; }\r\n    function MAX_AGE_REQUEST_UNTIL_FORCED() internal pure returns (uint32) { return 15 minutes; }\r\n    function MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 1 days; }\r\n    function MAX_TIME_IN_SHUTDOWN_BASE() internal pure returns (uint32) { return 1 days; }\r\n    function MAX_TIME_IN_SHUTDOWN_DELTA() internal pure returns (uint32) { return 15 seconds; }\r\n    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 10 minutes; }\r\n    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 8; }\r\n    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 20 - 1; }\r\n    function MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 2 hours; }\r\n    function FEE_BLOCK_FINE_START_TIME() internal pure returns (uint32) { return 5 minutes; }\r\n    function FEE_BLOCK_FINE_MAX_DURATION() internal pure returns (uint32) { return 30 minutes; }\r\n    function MIN_GAS_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 60000; }\r\n    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 1 days; }\r\n    function GAS_LIMIT_SEND_TOKENS() internal pure returns (uint32) { return 30000; }\r\n\r\n    // Represents the entire exchange state except the owner of the exchange.\r\n    struct State\r\n    {\r\n        uint    id;\r\n        uint    exchangeCreationTimestamp;\r\n        address payable operator; // The only address that can submit new blocks.\r\n        bool    onchainDataAvailability;\r\n\r\n        ILoopringV3    loopring;\r\n        IBlockVerifier blockVerifier;\r\n\r\n        address lrcAddress;\r\n\r\n        uint    totalTimeInMaintenanceSeconds;\r\n        uint    numDowntimeMinutes;\r\n        uint    downtimeStart;\r\n\r\n        address addressWhitelist;\r\n        uint    accountCreationFeeETH;\r\n        uint    accountUpdateFeeETH;\r\n        uint    depositFeeETH;\r\n        uint    withdrawalFeeETH;\r\n\r\n        Block[]     blocks;\r\n        Token[]     tokens;\r\n        Account[]   accounts;\r\n        Deposit[]   deposits;\r\n        Request[]   depositChain;\r\n        Request[]   withdrawalChain;\r\n\r\n        // A map from the account owner to accountID + 1\r\n        mapping (address => uint24) ownerToAccountId;\r\n        mapping (address => uint16) tokenToTokenId;\r\n\r\n        // A map from an account owner to a token to if the balance is withdrawn\r\n        mapping (address => mapping (address => bool)) withdrawnInWithdrawMode;\r\n\r\n        // A map from token address to their accumulated balances\r\n        mapping (address => uint) tokenBalances;\r\n\r\n        // A block's state will become FINALIZED when and only when this block is VERIFIED\r\n        // and all previous blocks in the chain have become FINALIZED.\r\n        // The genesis block is FINALIZED by default.\r\n        uint numBlocksFinalized;\r\n\r\n        // Cached data for the protocol fee\r\n        ProtocolFeeData protocolFeeData;\r\n\r\n        // Time when the exchange was shutdown\r\n        uint shutdownStartTime;\r\n    }\r\n}\r\n\r\n// File: contracts/impl/libexchange/ExchangeAccounts.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeAccounts.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeAccounts\r\n{\r\n    using MathUint          for uint;\r\n    using ExchangeBalances  for ExchangeData.State;\r\n\r\n    event AccountCreated(\r\n        address indexed owner,\r\n        uint24  indexed id,\r\n        uint            pubKeyX,\r\n        uint            pubKeyY\r\n    );\r\n\r\n    event AccountUpdated(\r\n        address indexed owner,\r\n        uint24  indexed id,\r\n        uint            pubKeyX,\r\n        uint            pubKeyY\r\n    );\r\n\r\n    // == Public Functions ==\r\n    function getAccount(\r\n        ExchangeData.State storage S,\r\n        address owner\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint24 accountID,\r\n            uint   pubKeyX,\r\n            uint   pubKeyY\r\n        )\r\n    {\r\n        accountID = getAccountID(S, owner);\r\n        ExchangeData.Account storage account = S.accounts[accountID];\r\n        pubKeyX = account.pubKeyX;\r\n        pubKeyY = account.pubKeyY;\r\n    }\r\n\r\n    function createOrUpdateAccount(\r\n        ExchangeData.State storage S,\r\n        uint  pubKeyX,\r\n        uint  pubKeyY,\r\n        bytes calldata permission\r\n        )\r\n        external\r\n        returns (\r\n            uint24 accountID,\r\n            bool   isAccountNew,\r\n            bool   isAccountUpdated\r\n        )\r\n    {\r\n        isAccountNew = (S.ownerToAccountId[msg.sender] == 0);\r\n        if (isAccountNew) {\r\n            if (S.addressWhitelist != address(0)) {\r\n                require(\r\n                    IAddressWhitelist(S.addressWhitelist).isWhitelisted(msg.sender, permission),\r\n                    \"ADDRESS_NOT_WHITELISTED\"\r\n                );\r\n            }\r\n            accountID = createAccount(S, pubKeyX, pubKeyY);\r\n            isAccountUpdated = false;\r\n        } else {\r\n            (accountID, isAccountUpdated) = updateAccount(S, pubKeyX, pubKeyY);\r\n        }\r\n    }\r\n\r\n    function getAccountID(\r\n        ExchangeData.State storage S,\r\n        address owner\r\n        )\r\n        public\r\n        view\r\n        returns (uint24 accountID)\r\n    {\r\n        accountID = S.ownerToAccountId[owner];\r\n        require(accountID != 0, \"ADDRESS_HAS_NO_ACCOUNT\");\r\n\r\n        accountID = accountID - 1;\r\n    }\r\n\r\n    function createAccount(\r\n        ExchangeData.State storage S,\r\n        uint pubKeyX,\r\n        uint pubKeyY\r\n        )\r\n        private\r\n        returns (uint24 accountID)\r\n    {\r\n        require(S.accounts.length < ExchangeData.MAX_NUM_ACCOUNTS(), \"ACCOUNTS_FULL\");\r\n        require(S.ownerToAccountId[msg.sender] == 0, \"ACCOUNT_EXISTS\");\r\n\r\n        accountID = uint24(S.accounts.length);\r\n        ExchangeData.Account memory account = ExchangeData.Account(\r\n            msg.sender,\r\n            pubKeyX,\r\n            pubKeyY\r\n        );\r\n\r\n        S.accounts.push(account);\r\n        S.ownerToAccountId[msg.sender] = accountID + 1;\r\n\r\n        emit AccountCreated(\r\n            msg.sender,\r\n            accountID,\r\n            pubKeyX,\r\n            pubKeyY\r\n        );\r\n    }\r\n\r\n    function updateAccount(\r\n        ExchangeData.State storage S,\r\n        uint pubKeyX,\r\n        uint pubKeyY\r\n        )\r\n        private\r\n        returns (\r\n            uint24 accountID,\r\n            bool   isAccountUpdated\r\n        )\r\n    {\r\n        require(S.ownerToAccountId[msg.sender] != 0, \"ACCOUNT_NOT_EXIST\");\r\n\r\n        accountID = S.ownerToAccountId[msg.sender] - 1;\r\n        ExchangeData.Account storage account = S.accounts[accountID];\r\n\r\n        isAccountUpdated = (account.pubKeyX != pubKeyX || account.pubKeyY != pubKeyY);\r\n        if (isAccountUpdated) {\r\n            account.pubKeyX = pubKeyX;\r\n            account.pubKeyY = pubKeyY;\r\n\r\n            emit AccountUpdated(\r\n                msg.sender,\r\n                accountID,\r\n                pubKeyX,\r\n                pubKeyY\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ERC20.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title ERC20 Token Interface\r\n/// @dev see https://github.com/ethereum/EIPs/issues/20\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract ERC20\r\n{\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    function balanceOf(\r\n        address who\r\n        )\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n        )\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint    value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function approve(\r\n        address spender,\r\n        uint    value\r\n        )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/lib/BurnableERC20.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n/// @title Burnable ERC20 Token Interface\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ncontract BurnableERC20 is ERC20\r\n{\r\n    function burn(\r\n        uint value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function burnFrom(\r\n        address from,\r\n        uint value\r\n        )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/lib/ERC20SafeTransfer.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title ERC20 safe transfer\r\n/// @dev see https://github.com/sec-bit/badERC20Fix\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ERC20SafeTransfer\r\n{\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint    value\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return safeTransferWithGasLimit(\r\n            token,\r\n            to,\r\n            value,\r\n            gasleft()\r\n        );\r\n    }\r\n\r\n    function safeTransferWithGasLimit(\r\n        address token,\r\n        address to,\r\n        uint    value,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        // A transfer is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n\r\n        // bytes4(keccak256(\"transfer(address,uint)\")) = 0xa9059cbb\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            bytes4(0xa9059cbb),\r\n            to,\r\n            value\r\n        );\r\n        (bool success, ) = token.call.gas(gasLimit)(callData);\r\n        return checkReturnValue(success);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint    value\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return safeTransferFromWithGasLimit(\r\n            token,\r\n            from,\r\n            to,\r\n            value,\r\n            gasleft()\r\n        );\r\n    }\r\n\r\n    function safeTransferFromWithGasLimit(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint    value,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        // A transferFrom is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n\r\n        // bytes4(keccak256(\"transferFrom(address,address,uint)\")) = 0x23b872dd\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            bytes4(0x23b872dd),\r\n            from,\r\n            to,\r\n            value\r\n        );\r\n        (bool success, ) = token.call.gas(gasLimit)(callData);\r\n        return checkReturnValue(success);\r\n    }\r\n\r\n    function checkReturnValue(\r\n        bool success\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // A transfer/transferFrom is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n        if (success) {\r\n            assembly {\r\n                switch returndatasize()\r\n                // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded\r\n                case 0 {\r\n                    success := 1\r\n                }\r\n                // Standard ERC20: a single boolean value is returned which needs to be true\r\n                case 32 {\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)\r\n                }\r\n                // None of the above: not successful\r\n                default {\r\n                    success := 0\r\n                }\r\n            }\r\n        }\r\n        return success;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/iface/IDowntimeCostCalculator.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for tßhe specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title IDowntimeCostCalculator\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract IDowntimeCostCalculator\r\n{\r\n    /// @dev Returns the amount LRC required to purchase the given downtime.\r\n    /// @param totalTimeInMaintenanceSeconds The total time a DEX has been in maintain mode.\r\n    /// @param totalDEXLifeTimeSeconds The DEX's total life time since genesis.\r\n    /// @param numDowntimeMinutes The current downtime balance in minutes before purchase.\r\n    /// @param exchangeStakedLRC The number of LRC staked by the DEX's owner.\r\n    /// @param durationToPurchaseMinutes The downtime in minute to purchase.\r\n    /// @return cost The cost in LRC for purchasing the downtime.\r\n    function getDowntimeCostLRC(\r\n        uint  totalTimeInMaintenanceSeconds,\r\n        uint  totalDEXLifeTimeSeconds,\r\n        uint  numDowntimeMinutes,\r\n        uint  exchangeStakedLRC,\r\n        uint  durationToPurchaseMinutes\r\n        )\r\n        external\r\n        view\r\n        returns (uint cost);\r\n}\r\n\r\n// File: contracts/impl/libexchange/ExchangeMode.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n/// @title ExchangeMode.\r\n/// @dev All methods in this lib are internal, therefore, there is no need\r\n///      to deploy this library independently.\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\nlibrary ExchangeMode\r\n{\r\n    using MathUint  for uint;\r\n\r\n    function isInWithdrawalMode(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool result)\r\n    {\r\n        result = false;\r\n        ExchangeData.Block storage currentBlock = S.blocks[S.blocks.length - 1];\r\n\r\n        // Check if there's a deposit request that's too old\r\n        if (currentBlock.numDepositRequestsCommitted < S.depositChain.length) {\r\n            uint32 requestTimestamp = S.depositChain[currentBlock.numDepositRequestsCommitted].timestamp;\r\n            result = requestTimestamp < now.sub(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE());\r\n        }\r\n\r\n        // Check if there's a withdrawal request that's too old\r\n        if (result == false && currentBlock.numWithdrawalRequestsCommitted < S.withdrawalChain.length) {\r\n            uint32 requestTimestamp = S.withdrawalChain[currentBlock.numWithdrawalRequestsCommitted].timestamp;\r\n            result = requestTimestamp < now.sub(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE());\r\n        }\r\n\r\n        // Check if there's an unfinalized block that's too old\r\n        if (result == false) {\r\n            result = isAnyUnfinalizedBlockTooOld(S);\r\n        }\r\n\r\n        // Check if we're longer in a non-initial state while shutdown than allowed\r\n        if (result == false && isShutdown(S) && !isInInitialState(S)) {\r\n            // The max amount of time an exchange can be in shutdown is\r\n            // MAX_TIME_IN_SHUTDOWN_BASE + (accounts.length * MAX_TIME_IN_SHUTDOWN_DELTA)\r\n            uint maxTimeInShutdown = ExchangeData.MAX_TIME_IN_SHUTDOWN_BASE();\r\n            maxTimeInShutdown = maxTimeInShutdown.add(S.accounts.length.mul(ExchangeData.MAX_TIME_IN_SHUTDOWN_DELTA()));\r\n            result = now > S.shutdownStartTime.add(maxTimeInShutdown);\r\n        }\r\n    }\r\n\r\n    function isShutdown(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool)\r\n    {\r\n        return S.shutdownStartTime > 0;\r\n    }\r\n\r\n    function isInMaintenance(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool)\r\n    {\r\n        return S.downtimeStart != 0 && getNumDowntimeMinutesLeft(S) > 0;\r\n    }\r\n\r\n    function isInInitialState(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool)\r\n    {\r\n        ExchangeData.Block storage firstBlock = S.blocks[0];\r\n        ExchangeData.Block storage lastBlock = S.blocks[S.blocks.length - 1];\r\n        return (S.blocks.length == S.numBlocksFinalized) &&\r\n            (lastBlock.numDepositRequestsCommitted == S.depositChain.length) &&\r\n            (lastBlock.merkleRoot == firstBlock.merkleRoot);\r\n    }\r\n\r\n    function areUserRequestsEnabled(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool)\r\n    {\r\n        // User requests are possible when the exchange is not in maintenance mode,\r\n        // the exchange hasn't been shutdown, and the exchange isn't in withdrawal mode\r\n        return !isInMaintenance(S) && !isShutdown(S) && !isInWithdrawalMode(S);\r\n    }\r\n\r\n    function isAnyUnfinalizedBlockTooOld(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (S.numBlocksFinalized < S.blocks.length) {\r\n            uint32 blockTimestamp = S.blocks[S.numBlocksFinalized].timestamp;\r\n            return blockTimestamp < now.sub(ExchangeData.MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE());\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function getNumDowntimeMinutesLeft(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (uint)\r\n    {\r\n        if (S.downtimeStart == 0) {\r\n            return S.numDowntimeMinutes;\r\n        } else {\r\n            // Calculate how long (in minutes) the exchange is in maintenance\r\n            uint numDowntimeMinutesUsed = now.sub(S.downtimeStart) / 60;\r\n            if (S.numDowntimeMinutes > numDowntimeMinutesUsed) {\r\n                return S.numDowntimeMinutes.sub(numDowntimeMinutesUsed);\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/impl/libexchange/ExchangeAdmins.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeAdmins.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeAdmins\r\n{\r\n    using MathUint          for uint;\r\n    using ERC20SafeTransfer for address;\r\n    using ExchangeMode      for ExchangeData.State;\r\n\r\n    event OperatorChanged(\r\n        uint    indexed exchangeId,\r\n        address         oldOperator,\r\n        address         newOperator\r\n    );\r\n\r\n    event AddressWhitelistChanged(\r\n        uint    indexed exchangeId,\r\n        address         oldAddressWhitelist,\r\n        address         newAddressWhitelist\r\n    );\r\n\r\n    event FeesUpdated(\r\n        uint    indexed exchangeId,\r\n        uint            accountCreationFeeETH,\r\n        uint            accountUpdateFeeETH,\r\n        uint            depositFeeETH,\r\n        uint            withdrawalFeeETH\r\n    );\r\n\r\n    function setOperator(\r\n        ExchangeData.State storage S,\r\n        address payable _operator\r\n        )\r\n        external\r\n        returns (address payable oldOperator)\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        require(address(0) != _operator, \"ZERO_ADDRESS\");\r\n        oldOperator = S.operator;\r\n        S.operator = _operator;\r\n\r\n        emit OperatorChanged(\r\n            S.id,\r\n            oldOperator,\r\n            _operator\r\n        );\r\n    }\r\n\r\n    function setAddressWhitelist(\r\n        ExchangeData.State storage S,\r\n        address _addressWhitelist\r\n        )\r\n        external\r\n        returns (address oldAddressWhitelist)\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        require(S.addressWhitelist != _addressWhitelist, \"SAME_ADDRESS\");\r\n\r\n        oldAddressWhitelist = S.addressWhitelist;\r\n        S.addressWhitelist = _addressWhitelist;\r\n\r\n        emit AddressWhitelistChanged(\r\n            S.id,\r\n            oldAddressWhitelist,\r\n            _addressWhitelist\r\n        );\r\n    }\r\n\r\n    function setFees(\r\n        ExchangeData.State storage S,\r\n        uint _accountCreationFeeETH,\r\n        uint _accountUpdateFeeETH,\r\n        uint _depositFeeETH,\r\n        uint _withdrawalFeeETH\r\n        )\r\n        external\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        require(\r\n            _withdrawalFeeETH <= S.loopring.maxWithdrawalFee(),\r\n            \"AMOUNT_TOO_LARGE\"\r\n        );\r\n\r\n        S.accountCreationFeeETH = _accountCreationFeeETH;\r\n        S.accountUpdateFeeETH = _accountUpdateFeeETH;\r\n        S.depositFeeETH = _depositFeeETH;\r\n        S.withdrawalFeeETH = _withdrawalFeeETH;\r\n\r\n        emit FeesUpdated(\r\n            S.id,\r\n            _accountCreationFeeETH,\r\n            _accountUpdateFeeETH,\r\n            _depositFeeETH,\r\n            _withdrawalFeeETH\r\n        );\r\n    }\r\n\r\n    function startOrContinueMaintenanceMode(\r\n        ExchangeData.State storage S,\r\n        uint durationMinutes\r\n        )\r\n        external\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        require(!S.isShutdown(), \"INVALID_MODE\");\r\n        require(durationMinutes > 0, \"INVALID_DURATION\");\r\n\r\n        uint numMinutesLeft = S.getNumDowntimeMinutesLeft();\r\n\r\n        // If we automatically exited maintenance mode first call stop\r\n        if (S.downtimeStart != 0 && numMinutesLeft == 0) {\r\n            stopMaintenanceMode(S);\r\n        }\r\n\r\n        // Purchased downtime from a previous maintenance period or a previous call\r\n        // to startOrContinueMaintenanceMode can be re-used, so we need to calculate\r\n        // how many additional minutes we need to purchase\r\n        if (numMinutesLeft < durationMinutes) {\r\n            uint numMinutesToPurchase = durationMinutes.sub(numMinutesLeft);\r\n            uint costLRC = getDowntimeCostLRC(S, numMinutesToPurchase);\r\n            if (costLRC > 0) {\r\n                require(\r\n                    BurnableERC20(S.lrcAddress).burnFrom(msg.sender, costLRC),\r\n                    \"BURN_FAILURE\"\r\n                );\r\n            }\r\n            S.numDowntimeMinutes = S.numDowntimeMinutes.add(numMinutesToPurchase);\r\n        }\r\n\r\n        // Start maintenance mode if the exchange isn't in maintenance mode yet\r\n        if (S.downtimeStart == 0) {\r\n            S.downtimeStart = now;\r\n        }\r\n    }\r\n\r\n    function getRemainingDowntime(\r\n        ExchangeData.State storage S\r\n        )\r\n        external\r\n        view\r\n        returns (uint duration)\r\n    {\r\n        return S.getNumDowntimeMinutesLeft();\r\n    }\r\n\r\n    function withdrawExchangeStake(\r\n        ExchangeData.State storage S,\r\n        address recipient\r\n        )\r\n        external\r\n        returns (uint)\r\n    {\r\n        ExchangeData.Block storage lastBlock = S.blocks[S.blocks.length - 1];\r\n\r\n        // Exchange needs to be shutdown\r\n        require(S.isShutdown(), \"EXCHANGE_NOT_SHUTDOWN\");\r\n        // All blocks needs to be finalized\r\n        require(S.blocks.length == S.numBlocksFinalized, \"BLOCK_NOT_FINALIZED\");\r\n        // We also require that all deposit requests are processed\r\n        require(\r\n            lastBlock.numDepositRequestsCommitted == S.depositChain.length,\r\n            \"DEPOSITS_NOT_PROCESSED\"\r\n        );\r\n        // Merkle root needs to be reset to the genesis block\r\n        // (i.e. all balances 0 and all other state reset to default values)\r\n        require(S.isInInitialState(), \"MERKLE_ROOT_NOT_REVERTED\");\r\n\r\n        // Another requirement is that the last block needs to be committed\r\n        // longer than MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS so the exchange can still be fined for not\r\n        // automatically distributing the withdrawals (the fine is paid from the stake)\r\n        require(\r\n            now > lastBlock.timestamp + ExchangeData.MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS(),\r\n            \"TOO_EARLY\"\r\n        );\r\n\r\n        // Withdraw the complete stake\r\n        uint amount = S.loopring.getExchangeStake(S.id);\r\n        return S.loopring.withdrawExchangeStake(S.id, recipient, amount);\r\n    }\r\n\r\n    function withdrawTokenNotOwnedByUsers(\r\n        ExchangeData.State storage S,\r\n        address token,\r\n        address payable recipient\r\n        )\r\n        external\r\n        returns (uint amount)\r\n    {\r\n        require(token != address(0), \"ZERO_ADDRESS\");\r\n        require(recipient != address(0), \"ZERO_VALUE\");\r\n\r\n        uint totalBalance = ERC20(token).balanceOf(address(this));\r\n        uint userBalance = S.tokenBalances[token];\r\n\r\n        assert(totalBalance >= userBalance);\r\n        amount = totalBalance - userBalance;\r\n\r\n        if (amount > 0) {\r\n            require(token.safeTransfer(recipient, amount), \"TRANSFER_FAILED\");\r\n        }\r\n    }\r\n\r\n    function stopMaintenanceMode(\r\n        ExchangeData.State storage S\r\n        )\r\n        public\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        require(!S.isShutdown(), \"INVALID_MODE\");\r\n        require(S.downtimeStart != 0, \"NOT_IN_MAINTENANCE_MODE\");\r\n\r\n        // Keep a history of how long the exchange has been in maintenance\r\n        S.totalTimeInMaintenanceSeconds = getTotalTimeInMaintenanceSeconds(S);\r\n\r\n        // Get the number of downtime minutes left\r\n        S.numDowntimeMinutes = S.getNumDowntimeMinutesLeft();\r\n\r\n        // Add an extra fixed cost of 1 minute to mitigate the posibility of abusing\r\n        // the starting/stopping of maintenance mode within a minute or even a single Ethereum block.\r\n        // This is practically the same as rounding down when converting from seconds to minutes.\r\n        if (S.numDowntimeMinutes > 0) {\r\n            S.numDowntimeMinutes -= 1;\r\n        }\r\n\r\n        // Stop maintenance mode\r\n        S.downtimeStart = 0;\r\n    }\r\n\r\n    function getDowntimeCostLRC(\r\n        ExchangeData.State storage S,\r\n        uint durationMinutes\r\n        )\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        if(durationMinutes == 0) {\r\n            return 0;\r\n        }\r\n\r\n        address costCalculatorAddr = S.loopring.downtimeCostCalculator();\r\n        if (costCalculatorAddr == address(0)) {\r\n            return 0;\r\n        }\r\n\r\n        return IDowntimeCostCalculator(costCalculatorAddr).getDowntimeCostLRC(\r\n            S.totalTimeInMaintenanceSeconds,\r\n            now - S.exchangeCreationTimestamp,\r\n            S.numDowntimeMinutes,\r\n            S.loopring.getExchangeStake(S.id),\r\n            durationMinutes\r\n        );\r\n    }\r\n\r\n    function getTotalTimeInMaintenanceSeconds(\r\n        ExchangeData.State storage S\r\n        )\r\n        public\r\n        view\r\n        returns (uint time)\r\n    {\r\n        time = S.totalTimeInMaintenanceSeconds;\r\n        if (S.downtimeStart != 0) {\r\n            if (S.getNumDowntimeMinutesLeft() > 0) {\r\n                time = time.add(now.sub(S.downtimeStart));\r\n            } else {\r\n                time = time.add(S.numDowntimeMinutes.mul(60));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/BytesUtil.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title Utility Functions for bytes\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary BytesUtil\r\n{\r\n    function bytesToBytes32(\r\n        bytes memory b,\r\n        uint  offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return bytes32(bytesToUintX(b, offset, 32));\r\n    }\r\n\r\n    function bytesToUint(\r\n        bytes memory b,\r\n        uint  offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        return bytesToUintX(b, offset, 32);\r\n    }\r\n\r\n    function bytesToAddress(\r\n        bytes memory b,\r\n        uint  offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        return address(bytesToUintX(b, offset, 20) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    }\r\n\r\n    function bytesToUint16(\r\n        bytes memory b,\r\n        uint  offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint16)\r\n    {\r\n        return uint16(bytesToUintX(b, offset, 2) & 0xFFFF);\r\n    }\r\n\r\n    function bytesToUintX(\r\n        bytes memory b,\r\n        uint  offset,\r\n        uint  numBytes\r\n        )\r\n        private\r\n        pure\r\n        returns (uint data)\r\n    {\r\n        require(b.length >= offset + numBytes, \"INVALID_SIZE\");\r\n        assembly {\r\n            data := mload(add(add(b, numBytes), offset))\r\n        }\r\n    }\r\n\r\n    function subBytes(\r\n        bytes memory b,\r\n        uint  offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes memory data)\r\n    {\r\n        require(b.length >= offset + 32, \"INVALID_SIZE\");\r\n        assembly {\r\n            data := add(add(b, 32), offset)\r\n        }\r\n    }\r\n\r\n    function fastSHA256(\r\n        bytes memory data\r\n        )\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        bytes32[] memory result = new bytes32[](1);\r\n        bool success;\r\n        assembly {\r\n             let ptr := add(data, 32)\r\n             success := staticcall(sub(gas, 2000), 2, ptr, mload(data), add(result, 32), 32)\r\n        }\r\n        require(success, \"SHA256_FAILED\");\r\n        return result[0];\r\n    }\r\n}\r\n\r\n// File: contracts/iface/IDecompressor.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title IDecompressor\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ncontract IDecompressor\r\n{\r\n    /// @dev Decompresses the data\r\n    /// @param data The compressed data\r\n    /// @return decompressedData The decompressed data\r\n    function decompress(\r\n        bytes calldata data\r\n        )\r\n        external\r\n        pure\r\n        returns (bytes memory decompressedData);\r\n}\r\n\r\n// File: contracts/impl/libexchange/ExchangeBlocks.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeBlocks.\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\nlibrary ExchangeBlocks\r\n{\r\n    using BytesUtil         for bytes;\r\n    using MathUint          for uint;\r\n    using ExchangeMode      for ExchangeData.State;\r\n\r\n    event BlockCommitted(\r\n        uint    indexed blockIdx,\r\n        bytes32 indexed publicDataHash\r\n    );\r\n\r\n    event BlockFinalized(\r\n        uint    indexed blockIdx\r\n    );\r\n\r\n    event BlockVerified(\r\n        uint    indexed blockIdx\r\n    );\r\n\r\n    event Revert(\r\n        uint    indexed blockIdx\r\n    );\r\n\r\n    event ProtocolFeesUpdated(\r\n        uint8 takerFeeBips,\r\n        uint8 makerFeeBips,\r\n        uint8 previousTakerFeeBips,\r\n        uint8 previousMakerFeeBips\r\n    );\r\n\r\n    function commitBlock(\r\n        ExchangeData.State storage S,\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion,\r\n        bytes  calldata data,\r\n        bytes  calldata /*offchainData*/\r\n        )\r\n        external\r\n    {\r\n        commitBlockInternal(\r\n            S,\r\n            ExchangeData.BlockType(blockType),\r\n            blockSize,\r\n            blockVersion,\r\n            data\r\n        );\r\n    }\r\n\r\n    function verifyBlocks(\r\n        ExchangeData.State storage S,\r\n        uint[] calldata blockIndices,\r\n        uint[] calldata proofs\r\n        )\r\n        external\r\n    {\r\n        // Exchange cannot be in withdrawal mode\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n\r\n        // Check input data\r\n        require(blockIndices.length > 0, \"INVALID_INPUT_ARRAYS\");\r\n        require(proofs.length % 8 == 0, \"INVALID_PROOF_ARRAY\");\r\n        require(proofs.length / 8 == blockIndices.length, \"INVALID_INPUT_ARRAYS\");\r\n\r\n        uint[] memory publicInputs = new uint[](blockIndices.length);\r\n        uint16 blockSize;\r\n        ExchangeData.BlockType blockType;\r\n        uint8 blockVersion;\r\n\r\n        for (uint i = 0; i < blockIndices.length; i++) {\r\n            uint blockIdx = blockIndices[i];\r\n\r\n            require(blockIdx < S.blocks.length, \"INVALID_BLOCK_IDX\");\r\n            ExchangeData.Block storage specifiedBlock = S.blocks[blockIdx];\r\n            require(\r\n                specifiedBlock.state == ExchangeData.BlockState.COMMITTED,\r\n                \"BLOCK_VERIFIED_ALREADY\"\r\n            );\r\n\r\n            // Check if the proof for this block is too early\r\n            // We limit the gap between the last finalized block and the last verified block to limit\r\n            // the number of blocks that can become finalized when a single block is verified\r\n            require(\r\n                blockIdx < S.numBlocksFinalized + ExchangeData.MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS(),\r\n                \"PROOF_TOO_EARLY\"\r\n            );\r\n\r\n            // Check if we still accept a proof for this block\r\n            require(\r\n                now <= specifiedBlock.timestamp + ExchangeData.MAX_PROOF_GENERATION_TIME_IN_SECONDS(),\r\n                \"PROOF_TOO_LATE\"\r\n            );\r\n\r\n            // Strip the 3 least significant bits of the public data hash\r\n            // so we don't have any overflow in the snark field\r\n            publicInputs[i] = uint(specifiedBlock.publicDataHash) >> 3;\r\n            if (i == 0) {\r\n                blockSize = specifiedBlock.blockSize;\r\n                blockType = specifiedBlock.blockType;\r\n                blockVersion = specifiedBlock.blockVersion;\r\n            } else {\r\n                // We only support batch verifying blocks that use the same verifying key\r\n                require(blockType == specifiedBlock.blockType, \"INVALID_BATCH_BLOCK_TYPE\");\r\n                require(blockSize == specifiedBlock.blockSize, \"INVALID_BATCH_BLOCK_SIZE\");\r\n                require(blockVersion == specifiedBlock.blockVersion, \"INVALID_BATCH_BLOCK_VERSION\");\r\n            }\r\n        }\r\n\r\n        // Verify the proofs\r\n        require(\r\n            S.blockVerifier.verifyProofs(\r\n                uint8(blockType),\r\n                S.onchainDataAvailability,\r\n                blockSize,\r\n                blockVersion,\r\n                publicInputs,\r\n                proofs\r\n            ),\r\n            \"INVALID_PROOF\"\r\n        );\r\n\r\n        // Mark the blocks as verified\r\n        for (uint i = 0; i < blockIndices.length; i++) {\r\n            uint blockIdx = blockIndices[i];\r\n            ExchangeData.Block storage specifiedBlock = S.blocks[blockIdx];\r\n            // Check this again to make sure no block is verified twice in a single call to verifyBlocks\r\n            require(\r\n                specifiedBlock.state == ExchangeData.BlockState.COMMITTED,\r\n                \"BLOCK_VERIFIED_ALREADY\"\r\n            );\r\n            specifiedBlock.state = ExchangeData.BlockState.VERIFIED;\r\n            emit BlockVerified(blockIdx);\r\n        }\r\n\r\n        // Update the number of blocks that are finalized\r\n        // The number of blocks after the specified block index is limited\r\n        // by MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS\r\n        // so we don't have to worry about running out of gas in this loop\r\n        uint idx = S.numBlocksFinalized;\r\n        while (idx < S.blocks.length &&\r\n            S.blocks[idx].state == ExchangeData.BlockState.VERIFIED) {\r\n            emit BlockFinalized(idx);\r\n            idx++;\r\n        }\r\n        S.numBlocksFinalized = idx;\r\n    }\r\n\r\n    function revertBlock(\r\n        ExchangeData.State storage S,\r\n        uint blockIdx\r\n        )\r\n        external\r\n    {\r\n        // Exchange cannot be in withdrawal mode\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n\r\n        require(blockIdx < S.blocks.length, \"INVALID_BLOCK_IDX\");\r\n        ExchangeData.Block storage specifiedBlock = S.blocks[blockIdx];\r\n        require(specifiedBlock.state == ExchangeData.BlockState.COMMITTED, \"INVALID_BLOCK_STATE\");\r\n\r\n        // The specified block needs to be the first block not finalized\r\n        // (this way we always revert to a guaranteed valid block and don't revert multiple times)\r\n        require(blockIdx == S.numBlocksFinalized, \"PREV_BLOCK_NOT_FINALIZED\");\r\n\r\n        // Check if this block is verified too late\r\n        require(\r\n            now > specifiedBlock.timestamp + ExchangeData.MAX_PROOF_GENERATION_TIME_IN_SECONDS(),\r\n            \"PROOF_NOT_TOO_LATE\"\r\n        );\r\n\r\n        // Fine the exchange\r\n        uint fine = S.loopring.revertFineLRC();\r\n        S.loopring.burnExchangeStake(S.id, fine);\r\n\r\n        // Remove all blocks after and including blockIdx\r\n        S.blocks.length = blockIdx;\r\n\r\n        emit Revert(blockIdx);\r\n    }\r\n\r\n    // == Internal Functions ==\r\n    function commitBlockInternal(\r\n        ExchangeData.State storage S,\r\n        ExchangeData.BlockType blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion,\r\n        bytes  memory data  // This field already has all the dummy (0-valued) requests padded,\r\n                            // therefore the size of this field totally depends on\r\n                            // `blockSize` instead of the actual user requests processed\r\n                            // in this block. This is fine because 0-bytes consume fewer gas.\r\n        )\r\n        private\r\n    {\r\n        // Exchange cannot be in withdrawal mode\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n\r\n        // Check if this exchange has a minimal amount of LRC staked\r\n        require(\r\n            S.loopring.canExchangeCommitBlocks(S.id, S.onchainDataAvailability),\r\n            \"INSUFFICIENT_EXCHANGE_STAKE\"\r\n        );\r\n\r\n        // Check if the block is supported\r\n        require(\r\n            S.blockVerifier.isCircuitEnabled(\r\n                uint8(blockType),\r\n                S.onchainDataAvailability,\r\n                blockSize,\r\n                blockVersion\r\n            ),\r\n            \"CANNOT_VERIFY_BLOCK\"\r\n        );\r\n\r\n        // Extract the exchange ID from the data\r\n        uint32 exchangeIdInData = 0;\r\n        assembly {\r\n            exchangeIdInData := and(mload(add(data, 4)), 0xFFFFFFFF)\r\n        }\r\n        require(exchangeIdInData == S.id, \"INVALID_EXCHANGE_ID\");\r\n\r\n        // Get the current block\r\n        ExchangeData.Block storage prevBlock = S.blocks[S.blocks.length - 1];\r\n\r\n        // Get the old and new Merkle roots\r\n        bytes32 merkleRootBefore;\r\n        bytes32 merkleRootAfter;\r\n        assembly {\r\n            merkleRootBefore := mload(add(data, 36))\r\n            merkleRootAfter := mload(add(data, 68))\r\n        }\r\n        require(merkleRootBefore == prevBlock.merkleRoot, \"INVALID_MERKLE_ROOT\");\r\n\r\n        uint32 numDepositRequestsCommitted = uint32(prevBlock.numDepositRequestsCommitted);\r\n        uint32 numWithdrawalRequestsCommitted = uint32(prevBlock.numWithdrawalRequestsCommitted);\r\n\r\n        // When the exchange is shutdown:\r\n        // - First force all outstanding deposits to be done\r\n        // - Allow withdrawing using the special shutdown mode of ONCHAIN_WITHDRAWAL (with\r\n        //   count == 0)\r\n        if (S.isShutdown()) {\r\n            if (numDepositRequestsCommitted < S.depositChain.length) {\r\n                require(blockType == ExchangeData.BlockType.DEPOSIT, \"SHUTDOWN_DEPOSIT_BLOCK_FORCED\");\r\n            } else {\r\n                require(blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL, \"SHUTDOWN_WITHDRAWAL_BLOCK_FORCED\");\r\n            }\r\n        }\r\n\r\n        // Check if the operator is forced to commit a deposit or withdraw block\r\n        // We give priority to withdrawals. If a withdraw block is forced it needs to\r\n        // be processed first, even if there is also a deposit block forced.\r\n        if (isWithdrawalRequestForced(S, numWithdrawalRequestsCommitted)) {\r\n            require(blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL, \"WITHDRAWAL_BLOCK_FORCED\");\r\n        } else if (isDepositRequestForced(S, numDepositRequestsCommitted)) {\r\n            require(blockType == ExchangeData.BlockType.DEPOSIT, \"DEPOSIT_BLOCK_FORCED\");\r\n        }\r\n\r\n        if (blockType == ExchangeData.BlockType.RING_SETTLEMENT) {\r\n            require(S.areUserRequestsEnabled(), \"SETTLEMENT_SUSPENDED\");\r\n            uint32 inputTimestamp;\r\n            uint8 protocolTakerFeeBips;\r\n            uint8 protocolMakerFeeBips;\r\n            assembly {\r\n                inputTimestamp := and(mload(add(data, 72)), 0xFFFFFFFF)\r\n                protocolTakerFeeBips := and(mload(add(data, 73)), 0xFF)\r\n                protocolMakerFeeBips := and(mload(add(data, 74)), 0xFF)\r\n            }\r\n            require(\r\n                inputTimestamp > now - ExchangeData.TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() &&\r\n                inputTimestamp < now + ExchangeData.TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS(),\r\n                \"INVALID_TIMESTAMP\"\r\n            );\r\n            require(\r\n                validateAndUpdateProtocolFeeValues(S, protocolTakerFeeBips, protocolMakerFeeBips),\r\n                \"INVALID_PROTOCOL_FEES\"\r\n            );\r\n        } else if (blockType == ExchangeData.BlockType.DEPOSIT) {\r\n            uint startIdx = 0;\r\n            uint count = 0;\r\n            assembly {\r\n                startIdx := and(mload(add(data, 136)), 0xFFFFFFFF)\r\n                count := and(mload(add(data, 140)), 0xFFFFFFFF)\r\n            }\r\n            require (startIdx == numDepositRequestsCommitted, \"INVALID_REQUEST_RANGE\");\r\n            require (count <= blockSize, \"INVALID_REQUEST_RANGE\");\r\n            require (startIdx + count <= S.depositChain.length, \"INVALID_REQUEST_RANGE\");\r\n\r\n            bytes32 startingHash = S.depositChain[startIdx - 1].accumulatedHash;\r\n            bytes32 endingHash = S.depositChain[startIdx + count - 1].accumulatedHash;\r\n            // Pad the block so it's full\r\n            for (uint i = count; i < blockSize; i++) {\r\n                endingHash = sha256(\r\n                    abi.encodePacked(\r\n                        endingHash,\r\n                        uint24(0),\r\n                        uint(0),\r\n                        uint(0),\r\n                        uint8(0),\r\n                        uint96(0)\r\n                    )\r\n                );\r\n            }\r\n            bytes32 inputStartingHash = 0x0;\r\n            bytes32 inputEndingHash = 0x0;\r\n            assembly {\r\n                inputStartingHash := mload(add(data, 100))\r\n                inputEndingHash := mload(add(data, 132))\r\n            }\r\n            require(inputStartingHash == startingHash, \"INVALID_STARTING_HASH\");\r\n            require(inputEndingHash == endingHash, \"INVALID_ENDING_HASH\");\r\n\r\n            numDepositRequestsCommitted += uint32(count);\r\n        } else if (blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL) {\r\n            uint startIdx = 0;\r\n            uint count = 0;\r\n            assembly {\r\n                startIdx := and(mload(add(data, 136)), 0xFFFFFFFF)\r\n                count := and(mload(add(data, 140)), 0xFFFFFFFF)\r\n            }\r\n            require (startIdx == numWithdrawalRequestsCommitted, \"INVALID_REQUEST_RANGE\");\r\n            require (count <= blockSize, \"INVALID_REQUEST_RANGE\");\r\n            require (startIdx + count <= S.withdrawalChain.length, \"INVALID_REQUEST_RANGE\");\r\n\r\n            if (S.isShutdown()) {\r\n                require (count == 0, \"INVALID_WITHDRAWAL_COUNT\");\r\n                // Don't check anything here, the operator can do all necessary withdrawals\r\n                // in any order he wants (the circuit still ensures the withdrawals are valid)\r\n            } else {\r\n                require (count > 0, \"INVALID_WITHDRAWAL_COUNT\");\r\n                bytes32 startingHash = S.withdrawalChain[startIdx - 1].accumulatedHash;\r\n                bytes32 endingHash = S.withdrawalChain[startIdx + count - 1].accumulatedHash;\r\n                // Pad the block so it's full\r\n                for (uint i = count; i < blockSize; i++) {\r\n                    endingHash = sha256(\r\n                        abi.encodePacked(\r\n                            endingHash,\r\n                            uint24(0),\r\n                            uint8(0),\r\n                            uint96(0)\r\n                        )\r\n                    );\r\n                }\r\n                bytes32 inputStartingHash = 0x0;\r\n                bytes32 inputEndingHash = 0x0;\r\n                assembly {\r\n                    inputStartingHash := mload(add(data, 100))\r\n                    inputEndingHash := mload(add(data, 132))\r\n                }\r\n                require(inputStartingHash == startingHash, \"INVALID_STARTING_HASH\");\r\n                require(inputEndingHash == endingHash, \"INVALID_ENDING_HASH\");\r\n                numWithdrawalRequestsCommitted += uint32(count);\r\n            }\r\n        } else if (\r\n            blockType != ExchangeData.BlockType.OFFCHAIN_WITHDRAWAL &&\r\n            blockType != ExchangeData.BlockType.ORDER_CANCELLATION &&\r\n            blockType != ExchangeData.BlockType.TRANSFER) {\r\n            revert(\"UNSUPPORTED_BLOCK_TYPE\");\r\n        }\r\n\r\n        // Hash all the public data to a single value which is used as the input for the circuit\r\n        bytes32 publicDataHash = data.fastSHA256();\r\n\r\n        // Store the approved withdrawal data onchain\r\n        bytes memory withdrawals = new bytes(0);\r\n        if (blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL ||\r\n            blockType == ExchangeData.BlockType.OFFCHAIN_WITHDRAWAL) {\r\n            uint start = 4 + 32 + 32;\r\n            if (blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL) {\r\n                start += 32 + 32 + 4 + 4;\r\n            }\r\n            uint length = 7 * blockSize;\r\n            assembly {\r\n                withdrawals := add(data, start)\r\n                mstore(withdrawals, length)\r\n            }\r\n        }\r\n\r\n        // Create a new block with the updated merkle roots\r\n        ExchangeData.Block memory newBlock = ExchangeData.Block(\r\n            merkleRootAfter,\r\n            publicDataHash,\r\n            ExchangeData.BlockState.COMMITTED,\r\n            blockType,\r\n            blockSize,\r\n            blockVersion,\r\n            uint32(now),\r\n            numDepositRequestsCommitted,\r\n            numWithdrawalRequestsCommitted,\r\n            false,\r\n            0,\r\n            withdrawals\r\n        );\r\n\r\n        S.blocks.push(newBlock);\r\n\r\n        emit BlockCommitted(S.blocks.length - 1, publicDataHash);\r\n    }\r\n\r\n    function validateAndUpdateProtocolFeeValues(\r\n        ExchangeData.State storage S,\r\n        uint8 takerFeeBips,\r\n        uint8 makerFeeBips\r\n        )\r\n        private\r\n        returns (bool)\r\n    {\r\n        ExchangeData.ProtocolFeeData storage data = S.protocolFeeData;\r\n        if (now > data.timestamp + ExchangeData.MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED()) {\r\n            // Store the current protocol fees in the previous protocol fees\r\n            data.previousTakerFeeBips = data.takerFeeBips;\r\n            data.previousMakerFeeBips = data.makerFeeBips;\r\n            // Get the latest protocol fees for this exchange\r\n            (data.takerFeeBips, data.makerFeeBips) = S.loopring.getProtocolFeeValues(\r\n                S.id,\r\n                S.onchainDataAvailability\r\n            );\r\n            data.timestamp = uint32(now);\r\n\r\n            bool feeUpdated = (data.takerFeeBips != data.previousTakerFeeBips) ||\r\n                (data.makerFeeBips != data.previousMakerFeeBips);\r\n\r\n            if (feeUpdated) {\r\n                emit ProtocolFeesUpdated(\r\n                    data.takerFeeBips,\r\n                    data.makerFeeBips,\r\n                    data.previousTakerFeeBips,\r\n                    data.previousMakerFeeBips\r\n                );\r\n            }\r\n        }\r\n        // The given fee values are valid if they are the current or previous protocol fee values\r\n        return (takerFeeBips == data.takerFeeBips && makerFeeBips == data.makerFeeBips) ||\r\n            (takerFeeBips == data.previousTakerFeeBips && makerFeeBips == data.previousMakerFeeBips);\r\n    }\r\n\r\n    function isDepositRequestForced(\r\n        ExchangeData.State storage S,\r\n        uint numRequestsCommitted\r\n        )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (numRequestsCommitted == S.depositChain.length) {\r\n            return false;\r\n        } else {\r\n            return S.depositChain[numRequestsCommitted].timestamp < now.sub(\r\n                ExchangeData.MAX_AGE_REQUEST_UNTIL_FORCED());\r\n        }\r\n    }\r\n\r\n    function isWithdrawalRequestForced(\r\n        ExchangeData.State storage S,\r\n        uint numRequestsCommitted\r\n        )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (numRequestsCommitted == S.withdrawalChain.length) {\r\n            return false;\r\n        } else {\r\n            return S.withdrawalChain[numRequestsCommitted].timestamp < now.sub(\r\n                ExchangeData.MAX_AGE_REQUEST_UNTIL_FORCED());\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/AddressUtil.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title Utility Functions for addresses\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary AddressUtil\r\n{\r\n    using AddressUtil for *;\r\n\r\n    function isContract(\r\n        address addr\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint32 size;\r\n        assembly { size := extcodesize(addr) }\r\n        return (size > 0);\r\n    }\r\n\r\n    function toPayable(\r\n        address addr\r\n        )\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return address(uint160(addr));\r\n    }\r\n\r\n    // Works like address.send but with a customizable gas limit\r\n    // Make sure your code is safe for reentrancy when using this function!\r\n    function sendETH(\r\n        address to,\r\n        uint    amount,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n        address payable recipient = to.toPayable();\r\n        /* solium-disable-next-line */\r\n        (success, ) = recipient.call.value(amount).gas(gasLimit)(\"\");\r\n    }\r\n\r\n    // Works like address.transfer but with a customizable gas limit\r\n    // Make sure your code is safe for reentrancy when using this function!\r\n    function transferETH(\r\n        address to,\r\n        uint    amount,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        success = to.sendETH(amount, gasLimit);\r\n        require(success, \"TRANSFER_FAILURE\");\r\n    }\r\n}\r\n\r\n// File: contracts/impl/libexchange/ExchangeTokens.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeTokens.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeTokens\r\n{\r\n    using MathUint          for uint;\r\n    using ExchangeMode      for ExchangeData.State;\r\n\r\n    event TokenRegistered(\r\n        address indexed token,\r\n        uint16  indexed tokenId\r\n    );\r\n\r\n    function registerToken(\r\n        ExchangeData.State storage S,\r\n        address tokenAddress\r\n        )\r\n        external\r\n        returns (uint16 tokenID)\r\n    {\r\n        tokenID = registerToken(\r\n            S,\r\n            tokenAddress,\r\n            getLRCFeeForRegisteringOneMoreToken(S)\r\n        );\r\n    }\r\n\r\n    function getTokenAddress(\r\n        ExchangeData.State storage S,\r\n        uint16 tokenID\r\n        )\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        require(tokenID < S.tokens.length, \"INVALID_TOKEN_ID\");\r\n        return S.tokens[tokenID].token;\r\n    }\r\n\r\n    function getLRCFeeForRegisteringOneMoreToken(\r\n        ExchangeData.State storage S\r\n        )\r\n        public\r\n        view\r\n        returns (uint feeLRC)\r\n    {\r\n        return S.loopring.tokenRegistrationFeeLRCBase().add(\r\n            S.loopring.tokenRegistrationFeeLRCDelta().mul(S.tokens.length)\r\n        );\r\n    }\r\n\r\n    function registerToken(\r\n        ExchangeData.State storage S,\r\n        address tokenAddress,\r\n        uint    amountToBurn\r\n        )\r\n        public\r\n        returns (uint16 tokenID)\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        require(S.tokenToTokenId[tokenAddress] == 0, \"TOKEN_ALREADY_EXIST\");\r\n        require(S.tokens.length < ExchangeData.MAX_NUM_TOKENS(), \"TOKEN_REGISTRY_FULL\");\r\n\r\n        if (amountToBurn > 0) {\r\n            require(BurnableERC20(S.lrcAddress).burnFrom(msg.sender, amountToBurn), \"BURN_FAILURE\");\r\n        }\r\n\r\n        ExchangeData.Token memory token = ExchangeData.Token(tokenAddress, false);\r\n        S.tokens.push(token);\r\n        tokenID = uint16(S.tokens.length - 1);\r\n        S.tokenToTokenId[tokenAddress] = tokenID + 1;\r\n\r\n        emit TokenRegistered(tokenAddress, tokenID);\r\n    }\r\n\r\n    function getTokenID(\r\n        ExchangeData.State storage S,\r\n        address tokenAddress\r\n        )\r\n        public\r\n        view\r\n        returns (uint16 tokenID)\r\n    {\r\n        tokenID = S.tokenToTokenId[tokenAddress];\r\n        require(tokenID != 0, \"TOKEN_NOT_FOUND\");\r\n        tokenID = tokenID - 1;\r\n    }\r\n\r\n    function disableTokenDeposit(\r\n        ExchangeData.State storage S,\r\n        address tokenAddress\r\n        )\r\n        external\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n\r\n        require(tokenAddress != address(0), \"ETHER_CANNOT_BE_DISABLED\");\r\n        require(tokenAddress != S.loopring.wethAddress(), \"WETH_CANNOT_BE_DISABLED\");\r\n        require(tokenAddress != S.loopring.lrcAddress(), \"LRC_CANNOT_BE_DISABLED\");\r\n\r\n        uint16 tokenID = getTokenID(S, tokenAddress);\r\n        ExchangeData.Token storage token = S.tokens[tokenID];\r\n        require(!token.depositDisabled, \"TOKEN_DEPOSIT_ALREADY_DISABLED\");\r\n        token.depositDisabled = true;\r\n    }\r\n\r\n    function enableTokenDeposit(\r\n        ExchangeData.State storage S,\r\n        address tokenAddress\r\n        )\r\n        external\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        uint16 tokenID = getTokenID(S, tokenAddress);\r\n        ExchangeData.Token storage token = S.tokens[tokenID];\r\n        require(token.depositDisabled, \"TOKEN_DEPOSIT_ALREADY_ENABLED\");\r\n        token.depositDisabled = false;\r\n    }\r\n}\r\n\r\n// File: contracts/impl/libexchange/ExchangeDeposits.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeDeposits.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeDeposits\r\n{\r\n    using AddressUtil       for address payable;\r\n    using MathUint          for uint;\r\n    using ERC20SafeTransfer for address;\r\n    using ExchangeAccounts  for ExchangeData.State;\r\n    using ExchangeMode      for ExchangeData.State;\r\n    using ExchangeTokens    for ExchangeData.State;\r\n\r\n    event DepositRequested(\r\n        uint    indexed depositIdx,\r\n        uint24  indexed accountID,\r\n        uint16  indexed tokenID,\r\n        uint96          amount,\r\n        uint            pubKeyX,\r\n        uint            pubKeyY\r\n    );\r\n\r\n    function getDepositRequest(\r\n        ExchangeData.State storage S,\r\n        uint index\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n          bytes32 accumulatedHash,\r\n          uint    accumulatedFee,\r\n          uint32  timestamp\r\n        )\r\n    {\r\n        require(index < S.depositChain.length, \"INVALID_INDEX\");\r\n        ExchangeData.Request storage request = S.depositChain[index];\r\n        accumulatedHash = request.accumulatedHash;\r\n        accumulatedFee = request.accumulatedFee;\r\n        timestamp = request.timestamp;\r\n    }\r\n\r\n    function depositTo(\r\n        ExchangeData.State storage S,\r\n        address recipient,\r\n        address tokenAddress,\r\n        uint96  amount,  // can be zero\r\n        uint    additionalFeeETH\r\n        )\r\n        external\r\n    {\r\n        require(recipient != address(0), \"ZERO_ADDRESS\");\r\n        require(S.areUserRequestsEnabled(), \"USER_REQUEST_SUSPENDED\");\r\n        require(getNumAvailableDepositSlots(S) > 0, \"TOO_MANY_REQUESTS_OPEN\");\r\n\r\n        uint16 tokenID = S.getTokenID(tokenAddress);\r\n        require(!S.tokens[tokenID].depositDisabled, \"TOKEN_DEPOSIT_DISABLED\");\r\n\r\n        uint24 accountID = S.getAccountID(recipient);\r\n        ExchangeData.Account storage account = S.accounts[accountID];\r\n\r\n        // Total fee to be paid by the user\r\n        uint feeETH = additionalFeeETH.add(S.depositFeeETH);\r\n\r\n        // Transfer the tokens to this contract\r\n        transferDeposit(\r\n            account.owner,\r\n            tokenAddress,\r\n            amount,\r\n            feeETH\r\n        );\r\n\r\n        // We allow invalid public keys to be set for accounts to\r\n        // disable offchain request signing.\r\n        // Make sure we can detect accounts that were not yet created in the circuits\r\n        // by forcing the pubKeyX to be non-zero.\r\n        require(account.pubKeyX > 0, \"INVALID_PUBKEY\");\r\n        // Make sure the public key can be stored in the SNARK field\r\n        require(account.pubKeyX < ExchangeData.SNARK_SCALAR_FIELD(), \"INVALID_PUBKEY\");\r\n        require(account.pubKeyY < ExchangeData.SNARK_SCALAR_FIELD(), \"INVALID_PUBKEY\");\r\n\r\n        // Add the request to the deposit chain\r\n        ExchangeData.Request storage prevRequest = S.depositChain[S.depositChain.length - 1];\r\n        ExchangeData.Request memory request = ExchangeData.Request(\r\n            sha256(\r\n                abi.encodePacked(\r\n                    prevRequest.accumulatedHash,\r\n                    accountID,\r\n                    account.pubKeyX,  // Include the pubKey to allow using the same circuit for\r\n                                      // account creation, account updating and depositing.\r\n                                      // In the circuit we always overwrite the public keys in\r\n                                      // the Account leaf with the data given onchain.\r\n                    account.pubKeyY,\r\n                    uint8(tokenID),\r\n                    amount\r\n                )\r\n            ),\r\n            prevRequest.accumulatedFee.add(feeETH),\r\n            uint32(now)\r\n        );\r\n        S.depositChain.push(request);\r\n\r\n        // Store deposit info onchain so we can withdraw from uncommitted deposit blocks\r\n        ExchangeData.Deposit memory _deposit = ExchangeData.Deposit(\r\n            accountID,\r\n            tokenID,\r\n            amount\r\n        );\r\n        S.deposits.push(_deposit);\r\n\r\n        S.tokenBalances[tokenAddress] = S.tokenBalances[tokenAddress].add(amount);\r\n\r\n        emit DepositRequested(\r\n            uint32(S.depositChain.length - 1),\r\n            accountID,\r\n            tokenID,\r\n            amount,\r\n            account.pubKeyX,\r\n            account.pubKeyY\r\n        );\r\n    }\r\n\r\n    function getNumDepositRequestsProcessed(\r\n        ExchangeData.State storage S\r\n        )\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        ExchangeData.Block storage currentBlock = S.blocks[S.blocks.length - 1];\r\n        return currentBlock.numDepositRequestsCommitted;\r\n    }\r\n\r\n    function getNumAvailableDepositSlots(\r\n        ExchangeData.State storage S\r\n        )\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint numOpenRequests = S.depositChain.length - getNumDepositRequestsProcessed(S);\r\n        return ExchangeData.MAX_OPEN_DEPOSIT_REQUESTS() - numOpenRequests;\r\n    }\r\n\r\n    function transferDeposit(\r\n        address accountOwner,\r\n        address tokenAddress,\r\n        uint    amount,\r\n        uint    feeETH\r\n        )\r\n        private\r\n    {\r\n        uint totalRequiredETH = feeETH;\r\n        if (tokenAddress == address(0)) {\r\n            totalRequiredETH = totalRequiredETH.add(amount);\r\n        }\r\n\r\n        require(msg.value >= totalRequiredETH, \"INSUFFICIENT_FEE\");\r\n        uint feeSurplus = msg.value.sub(totalRequiredETH);\r\n        msg.sender.transferETH(feeSurplus, gasleft());\r\n\r\n        // Transfer the tokens from the owner into this contract\r\n        if (amount > 0 && tokenAddress != address(0)) {\r\n            require(\r\n                tokenAddress.safeTransferFrom(\r\n                    accountOwner,\r\n                    address(this),\r\n                    amount\r\n                ),\r\n                \"INSUFFICIENT_FUND\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/impl/libexchange/ExchangeGenesis.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeGenesis.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeGenesis\r\n{\r\n    using ExchangeAccounts  for ExchangeData.State;\r\n    using ExchangeTokens    for ExchangeData.State;\r\n\r\n    function initializeGenesisBlock(\r\n        ExchangeData.State storage S,\r\n        uint    _id,\r\n        address _loopringAddress,\r\n        address payable _operator,\r\n        bool    _onchainDataAvailability,\r\n        bytes32 _genesisBlockHash\r\n        )\r\n        external\r\n    {\r\n        require(0 != _id, \"INVALID_ID\");\r\n        require(address(0) != _loopringAddress, \"ZERO_ADDRESS\");\r\n        require(address(0) != _operator, \"ZERO_ADDRESS\");\r\n        require(_genesisBlockHash != 0, \"ZERO_GENESIS_BLOCK_HASH\");\r\n        require(S.id == 0, \"INITIALIZED_ALREADY\");\r\n\r\n        S.id = _id;\r\n        S.exchangeCreationTimestamp = now;\r\n        S.loopring = ILoopringV3(_loopringAddress);\r\n        S.operator = _operator;\r\n        S.onchainDataAvailability = _onchainDataAvailability;\r\n\r\n        ILoopringV3 loopring = ILoopringV3(_loopringAddress);\r\n        S.blockVerifier = IBlockVerifier(loopring.blockVerifierAddress());\r\n        S.lrcAddress = loopring.lrcAddress();\r\n\r\n        ExchangeData.Block memory genesisBlock = ExchangeData.Block(\r\n            _genesisBlockHash,\r\n            0x0,\r\n            ExchangeData.BlockState.VERIFIED,\r\n            ExchangeData.BlockType(0),\r\n            0,\r\n            0,\r\n            uint32(now),\r\n            1,\r\n            1,\r\n            true,\r\n            0,\r\n            new bytes(0)\r\n        );\r\n        S.blocks.push(genesisBlock);\r\n        S.numBlocksFinalized = 1;\r\n\r\n        ExchangeData.Request memory genesisRequest = ExchangeData.Request(\r\n            0,\r\n            0,\r\n            0xFFFFFFFF\r\n        );\r\n        S.depositChain.push(genesisRequest);\r\n        S.withdrawalChain.push(genesisRequest);\r\n\r\n        // Create an account for the protocol fees. This account is also used\r\n        // for padding deposits and on-chain withdrawal requests.\r\n        ExchangeData.Account memory protocolFeePoolAccount = ExchangeData.Account(\r\n            address(0),\r\n            uint(0),\r\n            uint(0)\r\n        );\r\n\r\n        S.accounts.push(protocolFeePoolAccount);\r\n        S.ownerToAccountId[protocolFeePoolAccount.owner] = uint24(S.accounts.length);\r\n\r\n        // Get the protocol fees for this exchange\r\n        S.protocolFeeData.timestamp = uint32(0);\r\n        S.protocolFeeData.takerFeeBips = S.loopring.maxProtocolTakerFeeBips();\r\n        S.protocolFeeData.makerFeeBips = S.loopring.maxProtocolMakerFeeBips();\r\n        S.protocolFeeData.previousTakerFeeBips = S.protocolFeeData.takerFeeBips;\r\n        S.protocolFeeData.previousMakerFeeBips = S.protocolFeeData.makerFeeBips;\r\n\r\n        // Call these after the main state has been set up\r\n        S.registerToken(address(0), 0);\r\n        S.registerToken(loopring.wethAddress(), 0);\r\n        S.registerToken(S.lrcAddress, 0);\r\n    }\r\n}\r\n\r\n// File: contracts/impl/libexchange/ExchangeWithdrawals.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeWithdrawals.\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\nlibrary ExchangeWithdrawals\r\n{\r\n    using AddressUtil       for address;\r\n    using AddressUtil       for address payable;\r\n    using MathUint          for uint;\r\n    using ERC20SafeTransfer for address;\r\n    using ExchangeAccounts  for ExchangeData.State;\r\n    using ExchangeBalances  for ExchangeData.State;\r\n    using ExchangeMode      for ExchangeData.State;\r\n    using ExchangeTokens    for ExchangeData.State;\r\n\r\n    event BlockFeeWithdrawn(\r\n        uint    indexed blockIdx,\r\n        uint            amount\r\n    );\r\n\r\n    event WithdrawalRequested(\r\n        uint    indexed withdrawalIdx,\r\n        uint24  indexed accountID,\r\n        uint16  indexed tokenID,\r\n        uint96          amount\r\n    );\r\n\r\n    event WithdrawalCompleted(\r\n        uint24  indexed accountID,\r\n        uint16  indexed tokenID,\r\n        address         to,\r\n        uint96          amount\r\n    );\r\n\r\n    event WithdrawalFailed(\r\n        uint24  indexed accountID,\r\n        uint16  indexed tokenID,\r\n        address         to,\r\n        uint96          amount\r\n    );\r\n\r\n    function getWithdrawRequest(\r\n        ExchangeData.State storage S,\r\n        uint index\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 accumulatedHash,\r\n            uint    accumulatedFee,\r\n            uint32  timestamp\r\n        )\r\n    {\r\n        require(index < S.withdrawalChain.length, \"INVALID_INDEX\");\r\n        ExchangeData.Request storage request = S.withdrawalChain[index];\r\n        accumulatedHash = request.accumulatedHash;\r\n        accumulatedFee = request.accumulatedFee;\r\n        timestamp = request.timestamp;\r\n    }\r\n\r\n    function withdraw(\r\n        ExchangeData.State storage S,\r\n        uint24  accountID,\r\n        address token,\r\n        uint96  amount\r\n        )\r\n        external\r\n    {\r\n        require(amount > 0, \"ZERO_VALUE\");\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        require(S.areUserRequestsEnabled(), \"USER_REQUEST_SUSPENDED\");\r\n        require(getNumAvailableWithdrawalSlots(S) > 0, \"TOO_MANY_REQUESTS_OPEN\");\r\n\r\n        uint16 tokenID = S.getTokenID(token);\r\n\r\n        // Check ETH value sent, can be larger than the expected withdraw fee\r\n        require(msg.value >= S.withdrawalFeeETH, \"INSUFFICIENT_FEE\");\r\n        // Send surplus of ETH back to the sender\r\n        msg.sender.transferETH(msg.value.sub(S.withdrawalFeeETH), gasleft());\r\n        // Add the withdraw to the withdraw chain\r\n        ExchangeData.Request storage prevRequest = S.withdrawalChain[S.withdrawalChain.length - 1];\r\n        ExchangeData.Request memory request = ExchangeData.Request(\r\n            sha256(\r\n                abi.encodePacked(\r\n                    prevRequest.accumulatedHash,\r\n                    accountID,\r\n                    uint8(tokenID),\r\n                    amount\r\n                )\r\n            ),\r\n            prevRequest.accumulatedFee.add(S.withdrawalFeeETH),\r\n            uint32(now)\r\n        );\r\n        S.withdrawalChain.push(request);\r\n\r\n        emit WithdrawalRequested(\r\n            uint32(S.withdrawalChain.length - 1),\r\n            accountID,\r\n            tokenID,\r\n            amount\r\n        );\r\n    }\r\n\r\n    // We still alow anyone to withdraw these funds for the account owner\r\n    function withdrawFromMerkleTreeFor(\r\n        ExchangeData.State storage S,\r\n        address  owner,\r\n        address  token,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint32   nonce,\r\n        uint96   balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[30] calldata accountMerkleProof,\r\n        uint[12] calldata balanceMerkleProof\r\n        )\r\n        external\r\n    {\r\n        require(S.isInWithdrawalMode(), \"NOT_IN_WITHDRAW_MODE\");\r\n\r\n        ExchangeData.Block storage lastFinalizedBlock = S.blocks[S.numBlocksFinalized - 1];\r\n\r\n        uint24 accountID = S.getAccountID(owner);\r\n        uint16 tokenID = S.getTokenID(token);\r\n        require(S.withdrawnInWithdrawMode[owner][token] == false, \"WITHDRAWN_ALREADY\");\r\n\r\n        ExchangeBalances.verifyAccountBalance(\r\n            uint(lastFinalizedBlock.merkleRoot),\r\n            accountID,\r\n            tokenID,\r\n            pubKeyX,\r\n            pubKeyY,\r\n            nonce,\r\n            balance,\r\n            tradeHistoryRoot,\r\n            accountMerkleProof,\r\n            balanceMerkleProof\r\n        );\r\n\r\n        // Make sure the balance can only be withdrawn once\r\n        S.withdrawnInWithdrawMode[owner][token] = true;\r\n\r\n        // Transfer the tokens\r\n        transferTokens(\r\n            S,\r\n            accountID,\r\n            tokenID,\r\n            balance,\r\n            false\r\n        );\r\n    }\r\n\r\n    function getNumWithdrawalRequestsProcessed(\r\n        ExchangeData.State storage S\r\n        )\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        ExchangeData.Block storage currentBlock = S.blocks[S.blocks.length - 1];\r\n        return currentBlock.numWithdrawalRequestsCommitted;\r\n    }\r\n\r\n    function getNumAvailableWithdrawalSlots(\r\n        ExchangeData.State storage S\r\n        )\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint numOpenRequests = S.withdrawalChain.length - getNumWithdrawalRequestsProcessed(S);\r\n        return ExchangeData.MAX_OPEN_WITHDRAWAL_REQUESTS() - numOpenRequests;\r\n    }\r\n\r\n    function withdrawFromDepositRequest(\r\n        ExchangeData.State storage S,\r\n        uint depositIdx\r\n        )\r\n        external\r\n    {\r\n        require(S.isInWithdrawalMode(), \"NOT_IN_WITHDRAW_MODE\");\r\n\r\n        ExchangeData.Block storage lastFinalizedBlock = S.blocks[S.numBlocksFinalized - 1];\r\n        require(depositIdx >= lastFinalizedBlock.numDepositRequestsCommitted, \"REQUEST_INCLUDED_IN_FINALIZED_BLOCK\");\r\n\r\n        // The deposit info is stored at depositIdx - 1\r\n        ExchangeData.Deposit storage _deposit = S.deposits[depositIdx.sub(1)];\r\n\r\n        uint amount = _deposit.amount;\r\n        require(amount > 0, \"WITHDRAWN_ALREADY\");\r\n\r\n        // Set the amount to 0 so it cannot be withdrawn again\r\n        _deposit.amount = 0;\r\n\r\n        // Transfer the tokens\r\n        transferTokens(\r\n            S,\r\n            _deposit.accountID,\r\n            _deposit.tokenID,\r\n            amount,\r\n            false\r\n        );\r\n    }\r\n\r\n    function withdrawFromApprovedWithdrawal(\r\n        ExchangeData.State storage S,\r\n        uint blockIdx,\r\n        ExchangeData.Block storage withdrawBlock,\r\n        uint slotIdx,\r\n        bool allowFailure\r\n        )\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(slotIdx < withdrawBlock.blockSize, \"INVALID_SLOT_IDX\");\r\n        // Only allow withdrawing on finalized blocks\r\n        require(blockIdx < S.numBlocksFinalized, \"BLOCK_NOT_FINALIZED\");\r\n\r\n        // Get the withdrawal data from storage for the given slot\r\n        uint[] memory slice = new uint[](2);\r\n        uint slot = (7 * slotIdx) / 32;\r\n        uint offset = (7 * (slotIdx + 1)) - (slot * 32);\r\n        uint sc = 0;\r\n        uint data = 0;\r\n        // Short byte arrays (length <= 31) are stored differently in storage\r\n        if (withdrawBlock.withdrawals.length >= 32) {\r\n            bytes storage withdrawals = withdrawBlock.withdrawals;\r\n            uint dataSlot1 = 0;\r\n            uint dataSlot2 = 0;\r\n            assembly {\r\n                // keccak hash to get the contents of the array\r\n                mstore(0x0, withdrawals_slot)\r\n                sc := keccak256(0x0, 0x20)\r\n                dataSlot1 := sload(add(sc, slot))\r\n                dataSlot2 := sload(add(sc, add(slot, 1)))\r\n            }\r\n            // Stitch the data together so we can extract the data in a single uint\r\n            // (withdrawal data is at the LSBs)\r\n            slice[0] = dataSlot1;\r\n            slice[1] = dataSlot2;\r\n            assembly {\r\n                data := mload(add(slice, offset))\r\n            }\r\n        } else {\r\n            bytes memory mWithdrawals = withdrawBlock.withdrawals;\r\n            assembly {\r\n                data := mload(add(mWithdrawals, offset))\r\n            }\r\n        }\r\n\r\n        // Extract the withdrawal data\r\n        uint16 tokenID = uint16((data >> 48) & 0xFF);\r\n        uint24 accountID = uint24((data >> 28) & 0xFFFFF);\r\n        uint amount = (data & 0xFFFFFFF).decodeFloat();\r\n\r\n        // Transfer the tokens\r\n        success = transferTokens(\r\n            S,\r\n            accountID,\r\n            tokenID,\r\n            amount,\r\n            allowFailure\r\n        );\r\n\r\n        if (success && amount > 0) {\r\n            // Set everything to 0 for this withdrawal so it cannot be used anymore\r\n            data = data & uint(~((1 << (7 * 8)) - 1));\r\n\r\n            // Update the data in storage\r\n            if (withdrawBlock.withdrawals.length >= 32) {\r\n                assembly {\r\n                    mstore(add(slice, offset), data)\r\n                }\r\n                uint dataSlot1 = slice[0];\r\n                uint dataSlot2 = slice[1];\r\n                assembly {\r\n                    sstore(add(sc, slot), dataSlot1)\r\n                    sstore(add(sc, add(slot, 1)), dataSlot2)\r\n                }\r\n            } else {\r\n                bytes memory mWithdrawals = withdrawBlock.withdrawals;\r\n                assembly {\r\n                    mstore(add(mWithdrawals, offset), data)\r\n                }\r\n                withdrawBlock.withdrawals = mWithdrawals;\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdrawBlockFee(\r\n        ExchangeData.State storage S,\r\n        uint blockIdx,\r\n        address payable feeRecipient\r\n        )\r\n        external\r\n        returns (uint feeAmountToOperator)\r\n    {\r\n        require(blockIdx > 0 && blockIdx < S.blocks.length, \"INVALID_BLOCK_IDX\");\r\n        ExchangeData.Block storage requestedBlock = S.blocks[blockIdx];\r\n        ExchangeData.Block storage previousBlock = S.blocks[blockIdx - 1];\r\n\r\n        require(blockIdx < S.numBlocksFinalized, \"BLOCK_NOT_FINALIZED\");\r\n        require(requestedBlock.blockFeeWithdrawn == false, \"FEE_WITHDRAWN_ALREADY\");\r\n\r\n        uint feeAmount = 0;\r\n        uint32 lastRequestTimestamp = 0;\r\n        {\r\n        uint startIndex = previousBlock.numDepositRequestsCommitted;\r\n        uint endIndex = requestedBlock.numDepositRequestsCommitted;\r\n        if(endIndex > startIndex) {\r\n            feeAmount = S.depositChain[endIndex - 1].accumulatedFee.sub(\r\n                S.depositChain[startIndex - 1].accumulatedFee\r\n            );\r\n            lastRequestTimestamp = S.depositChain[endIndex - 1].timestamp;\r\n        } else {\r\n            startIndex = previousBlock.numWithdrawalRequestsCommitted;\r\n            endIndex = requestedBlock.numWithdrawalRequestsCommitted;\r\n\r\n            if(endIndex > startIndex) {\r\n                feeAmount = S.withdrawalChain[endIndex - 1].accumulatedFee.sub(\r\n                    S.withdrawalChain[startIndex - 1].accumulatedFee\r\n                );\r\n                lastRequestTimestamp = S.withdrawalChain[endIndex - 1].timestamp;\r\n            } else {\r\n                revert(\"BLOCK_HAS_NO_OPERATOR_FEE\");\r\n            }\r\n        }\r\n        }\r\n\r\n        // Calculate how much of the fee the operator gets for the block\r\n        // If there are many requests than lastRequestTimestamp ~= firstRequestTimestamp so\r\n        // all requests will need to be done in FEE_BLOCK_FINE_START_TIME minutes to get the complete fee.\r\n        // If there are very few requests than lastRequestTimestamp >> firstRequestTimestamp and we don't want\r\n        // to fine the operator for waiting until he can fill a complete block.\r\n        // This is why we use the timestamp of the last request included in the block.\r\n        uint32 blockTimestamp = requestedBlock.timestamp;\r\n        uint32 startTime = lastRequestTimestamp + ExchangeData.FEE_BLOCK_FINE_START_TIME();\r\n        uint fine = 0;\r\n        if (blockTimestamp > startTime) {\r\n            fine = feeAmount.mul(blockTimestamp - startTime) / ExchangeData.FEE_BLOCK_FINE_MAX_DURATION();\r\n        }\r\n        uint feeAmountToBurn = (fine > feeAmount) ? feeAmount : fine;\r\n        feeAmountToOperator = feeAmount - feeAmountToBurn;\r\n\r\n        // Make sure it can't be withdrawn again\r\n        requestedBlock.blockFeeWithdrawn = true;\r\n\r\n        // Burn part of the fee by sending it to the protocol fee manager\r\n        S.loopring.protocolFeeVault().transferETH(feeAmountToBurn, gasleft());\r\n        // Transfer the fee to the operator\r\n        feeRecipient.transferETH(feeAmountToOperator, gasleft());\r\n\r\n        emit BlockFeeWithdrawn(blockIdx, feeAmount);\r\n    }\r\n\r\n    function distributeWithdrawals(\r\n        ExchangeData.State storage S,\r\n        uint blockIdx,\r\n        uint maxNumWithdrawals\r\n        )\r\n        external\r\n    {\r\n        require(blockIdx < S.blocks.length, \"INVALID_BLOCK_IDX\");\r\n        require(maxNumWithdrawals > 0, \"INVALID_MAX_NUM_WITHDRAWALS\");\r\n        ExchangeData.Block storage withdrawBlock = S.blocks[blockIdx];\r\n\r\n        // Check if this is a withdrawal block\r\n        require(\r\n            withdrawBlock.blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL ||\r\n            withdrawBlock.blockType == ExchangeData.BlockType.OFFCHAIN_WITHDRAWAL,\r\n            \"INVALID_BLOCK_TYPE\"\r\n        );\r\n\r\n        // Only allow withdrawing on finalized blocks\r\n        require(blockIdx < S.numBlocksFinalized, \"BLOCK_NOT_FINALIZED\");\r\n        // Check if the withdrawals were already completely distributed\r\n        require(withdrawBlock.numWithdrawalsDistributed < withdrawBlock.blockSize, \"WITHDRAWALS_ALREADY_DISTRIBUTED\");\r\n\r\n        // Only allow the operator to distribute withdrawals at first, if he doesn't do it in time\r\n        // anyone can do it and get paid a part of the exchange stake\r\n        bool bOnlyOperator = now < withdrawBlock.timestamp + ExchangeData.MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS();\r\n        if (bOnlyOperator) {\r\n            require(msg.sender == S.operator, \"UNAUTHORIZED\");\r\n        }\r\n\r\n        // Calculate the range of withdrawals we'll do\r\n        uint start = withdrawBlock.numWithdrawalsDistributed;\r\n        uint end = start.add(maxNumWithdrawals);\r\n        if (end > withdrawBlock.blockSize) {\r\n            end = withdrawBlock.blockSize;\r\n        }\r\n\r\n        // Do the withdrawals\r\n        uint gasLimit = ExchangeData.MIN_GAS_TO_DISTRIBUTE_WITHDRAWALS();\r\n        uint totalNumWithdrawn = start;\r\n        while (totalNumWithdrawn < end && gasleft() >= gasLimit) {\r\n            // Don't check the return value here, the withdrawal is allowed to fail.\r\n            // The automatic token disribution by the operator is a best effort only.\r\n            // The account owner can always manually withdraw without any limits.\r\n            withdrawFromApprovedWithdrawal(\r\n                S,\r\n                blockIdx,\r\n                withdrawBlock,\r\n                totalNumWithdrawn,\r\n                true\r\n            );\r\n            totalNumWithdrawn++;\r\n        }\r\n        withdrawBlock.numWithdrawalsDistributed = uint16(totalNumWithdrawn);\r\n\r\n        // Fine the exchange if the withdrawals are done too late\r\n        if (!bOnlyOperator) {\r\n            // We use the stake of the exchange to punish withdrawals that are distributed too late\r\n            uint numWithdrawn = totalNumWithdrawn.sub(start);\r\n            uint totalFine = S.loopring.withdrawalFineLRC().mul(numWithdrawn);\r\n            // Burn 50% of the fine, reward the distributer the rest\r\n            uint amountToBurn = totalFine / 2;\r\n            uint amountToDistributer = totalFine - amountToBurn;\r\n            S.loopring.burnExchangeStake(S.id, amountToBurn);\r\n            S.loopring.withdrawExchangeStake(S.id, msg.sender, amountToDistributer);\r\n        }\r\n    }\r\n\r\n\r\n    // == Internal and Private Functions ==\r\n\r\n    // If allowFailure is true the transfer can fail because of a transfer error or\r\n    // because the transfer uses more than GAS_LIMIT_SEND_TOKENS gas. The function\r\n    // will return true when successful, false otherwise.\r\n    // If allowFailure is false the transfer is guaranteed to succeed using\r\n    // as much gas as needed, otherwise it throws. The function always returns true.\r\n    function transferTokens(\r\n        ExchangeData.State storage S,\r\n        uint24  accountID,\r\n        uint16  tokenID,\r\n        uint    amount,\r\n        bool    allowFailure\r\n        )\r\n        private\r\n        returns (bool success)\r\n    {\r\n        // If we're withdrawing from the protocol fee account send the tokens\r\n        // directly to the protocol fee vault.\r\n        // If we're withdrawing to an unknown account (can currently happen while\r\n        // distributing tokens in shutdown) send the tokens to the protocol fee vault as well.\r\n        address to;\r\n        if (accountID == 0 || accountID >= S.accounts.length) {\r\n            to = S.loopring.protocolFeeVault();\r\n        } else {\r\n            to = S.accounts[accountID].owner;\r\n        }\r\n\r\n        address token = S.getTokenAddress(tokenID);\r\n        // Either limit the gas by ExchangeData.GAS_LIMIT_SEND_TOKENS() or forward all gas\r\n        uint gasLimit = allowFailure ? ExchangeData.GAS_LIMIT_SEND_TOKENS() : gasleft();\r\n\r\n        // Transfer the tokens from the contract to the owner\r\n        if (amount > 0) {\r\n            if (token == address(0)) {\r\n                // ETH\r\n                success = to.sendETH(amount, gasLimit);\r\n            } else {\r\n                // ERC20 token\r\n                success = token.safeTransferWithGasLimit(to, amount, gasLimit);\r\n            }\r\n        } else {\r\n            success = true;\r\n        }\r\n\r\n        if (!allowFailure) {\r\n            require(success, \"TRANSFER_FAILURE\");\r\n        }\r\n\r\n        if (success) {\r\n            if (amount > 0) {\r\n                S.tokenBalances[token] = S.tokenBalances[token].sub(amount);\r\n            }\r\n\r\n            if (accountID > 0 || tokenID > 0 || amount > 0) {\r\n                // Only emit an event when the withdrawal data hasn't been reset yet\r\n                // by a previous successful withdrawal\r\n                emit WithdrawalCompleted(\r\n                    accountID,\r\n                    tokenID,\r\n                    to,\r\n                    uint96(amount)\r\n                );\r\n            }\r\n        } else {\r\n            emit WithdrawalFailed(\r\n                accountID,\r\n                tokenID,\r\n                to,\r\n                uint96(amount)\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/thirdparty/Cloneable.sol\r\n\r\n// This code is taken from https://gist.github.com/holiman/069de8d056a531575d2b786df3345665\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\nlibrary Cloneable {\r\n    function clone(address a)\r\n        external\r\n        returns (address)\r\n    {\r\n\r\n    /*\r\n    Assembly of the code that we want to use as init-code in the new contract,\r\n    along with stack values:\r\n                    # bottom [ STACK ] top\r\n     PUSH1 00       # [ 0 ]\r\n     DUP1           # [ 0, 0 ]\r\n     PUSH20\r\n     <address>      # [0,0, address]\r\n     DUP1           # [0,0, address ,address]\r\n     EXTCODESIZE    # [0,0, address, size ]\r\n     DUP1           # [0,0, address, size, size]\r\n     SWAP4          # [ size, 0, address, size, 0]\r\n     DUP1           # [ size, 0, address ,size, 0,0]\r\n     SWAP2          # [ size, 0, address, 0, 0, size]\r\n     SWAP3          # [ size, 0, size, 0, 0, address]\r\n     EXTCODECOPY    # [ size, 0]\r\n     RETURN\r\n\r\n    The code above weighs in at 33 bytes, which is _just_ above fitting into a uint.\r\n    So a modified version is used, where the initial PUSH1 00 is replaced by `PC`.\r\n    This is one byte smaller, and also a bit cheaper Wbase instead of Wverylow. It only costs 2 gas.\r\n\r\n     PC             # [ 0 ]\r\n     DUP1           # [ 0, 0 ]\r\n     PUSH20\r\n     <address>      # [0,0, address]\r\n     DUP1           # [0,0, address ,address]\r\n     EXTCODESIZE    # [0,0, address, size ]\r\n     DUP1           # [0,0, address, size, size]\r\n     SWAP4          # [ size, 0, address, size, 0]\r\n     DUP1           # [ size, 0, address ,size, 0,0]\r\n     SWAP2          # [ size, 0, address, 0, 0, size]\r\n     SWAP3          # [ size, 0, size, 0, 0, address]\r\n     EXTCODECOPY    # [ size, 0]\r\n     RETURN\r\n\r\n    The opcodes are:\r\n    58 80 73 <address> 80 3b 80 93 80 91 92 3c F3\r\n    We get <address> in there by OR:ing the upshifted address into the 0-filled space.\r\n      5880730000000000000000000000000000000000000000803b80938091923cF3\r\n     +000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx000000000000000000\r\n     -----------------------------------------------------------------\r\n      588073xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx00000803b80938091923cF3\r\n\r\n    This is simply stored at memory position 0, and create is invoked.\r\n    */\r\n        address retval;\r\n        assembly{\r\n            mstore(0x0, or (0x5880730000000000000000000000000000000000000000803b80938091923cF3 ,mul(a,0x1000000000000000000)))\r\n            retval := create(0,0, 32)\r\n        }\r\n        return retval;\r\n    }\r\n}\r\n\r\n// File: contracts/iface/IExchange.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n\r\n/// @title IExchange\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract IExchange is Claimable, ReentrancyGuard\r\n{\r\n    string  constant public version          = \"\"; // must override this\r\n    bytes32 constant public genesisBlockHash = 0;  // must override this\r\n\r\n    /// @dev Clone an exchange without any initialization\r\n    /// @return  cloneAddress The address of the new exchange.\r\n    function clone()\r\n        external\r\n        nonReentrant\r\n        returns (address cloneAddress)\r\n    {\r\n        address origin = address(this);\r\n        cloneAddress = Cloneable.clone(origin);\r\n\r\n        assert(cloneAddress != origin);\r\n        assert(cloneAddress != address(0));\r\n    }\r\n}\r\n\r\n// File: contracts/iface/IExchangeV3.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n/// @title IExchangeV3\r\n/// @dev Note that Claimable and RentrancyGuard are inherited here to\r\n///      ensure all data members are declared on IExchangeV3 to make it\r\n///      easy to support upgradability through proxies.\r\n///\r\n///      Subclasses of this contract must NOT define constructor to\r\n///      initialize data.\r\n///\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract IExchangeV3 is IExchange\r\n{\r\n    // -- Events --\r\n    // We need to make sure all events defined in exchange/*.sol\r\n    // are aggregrated here.\r\n    event AccountCreated(\r\n        address indexed owner,\r\n        uint24  indexed id,\r\n        uint            pubKeyX,\r\n        uint            pubKeyY\r\n    );\r\n\r\n    event AccountUpdated(\r\n        address indexed owner,\r\n        uint24  indexed id,\r\n        uint            pubKeyX,\r\n        uint            pubKeyY\r\n    );\r\n\r\n    event TokenRegistered(\r\n        address indexed token,\r\n        uint16  indexed tokenId\r\n    );\r\n\r\n    event OperatorChanged(\r\n        uint    indexed exchangeId,\r\n        address         oldOperator,\r\n        address         newOperator\r\n    );\r\n\r\n    event AddressWhitelistChanged(\r\n        uint    indexed exchangeId,\r\n        address         oldAddressWhitelist,\r\n        address         newAddressWhitelist\r\n    );\r\n\r\n    event FeesUpdated(\r\n        uint    indexed exchangeId,\r\n        uint            accountCreationFeeETH,\r\n        uint            accountUpdateFeeETH,\r\n        uint            depositFeeETH,\r\n        uint            withdrawalFeeETH\r\n    );\r\n\r\n    event Shutdown(\r\n        uint            timestamp\r\n    );\r\n\r\n    event BlockCommitted(\r\n        uint    indexed blockIdx,\r\n        bytes32 indexed publicDataHash\r\n    );\r\n\r\n    event BlockVerified(\r\n        uint    indexed blockIdx\r\n    );\r\n\r\n    event BlockFinalized(\r\n        uint    indexed blockIdx\r\n    );\r\n\r\n    event Revert(\r\n        uint    indexed blockIdx\r\n    );\r\n\r\n    event DepositRequested(\r\n        uint    indexed depositIdx,\r\n        uint24  indexed accountID,\r\n        uint16  indexed tokenID,\r\n        uint96          amount,\r\n        uint            pubKeyX,\r\n        uint            pubKeyY\r\n    );\r\n\r\n    event BlockFeeWithdrawn(\r\n        uint    indexed blockIdx,\r\n        uint            amount\r\n    );\r\n\r\n    event WithdrawalRequested(\r\n        uint    indexed withdrawalIdx,\r\n        uint24  indexed accountID,\r\n        uint16  indexed tokenID,\r\n        uint96          amount\r\n    );\r\n\r\n    event WithdrawalCompleted(\r\n        uint24  indexed accountID,\r\n        uint16  indexed tokenID,\r\n        address         to,\r\n        uint96          amount\r\n    );\r\n\r\n    event WithdrawalFailed(\r\n        uint24  indexed accountID,\r\n        uint16  indexed tokenID,\r\n        address         to,\r\n        uint96          amount\r\n    );\r\n\r\n    event ProtocolFeesUpdated(\r\n        uint8 takerFeeBips,\r\n        uint8 makerFeeBips,\r\n        uint8 previousTakerFeeBips,\r\n        uint8 previousMakerFeeBips\r\n    );\r\n\r\n    // -- Initialization --\r\n    /// @dev Initializes this exchange. This method can only be called once.\r\n    /// @param  owner The owner of this exchange.\r\n    /// @param  exchangeId The id of this exchange.\r\n    /// @param  operator The operator address of the exchange who will be responsible for\r\n    ///         submitting blocks and proofs.\r\n    /// @param  loopringAddress The corresponding ILoopring contract address.\r\n    /// @param  onchainDataAvailability True if \"Data Availability\" is turned on for this\r\n    ///         exchange. Note that this value can not be changed once the exchange is initialized.\r\n    function initialize(\r\n        address loopringAddress,\r\n        address owner,\r\n        uint    exchangeId,\r\n        address payable operator,\r\n        bool    onchainDataAvailability\r\n        )\r\n        external;\r\n\r\n    // -- Mode --\r\n    /// @dev Whether the exchange is in withdrawal mode.\r\n    /// @return Returns true if the exchange is in withdrawal mode, else false\r\n    function isInWithdrawalMode()\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Whether the exchange is shutdown.\r\n    /// @return Returns true if the exchange is shutdown, else false\r\n    function isShutdown()\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    // -- Accounts --\r\n\r\n    /// @dev Gets the number of accounts registered on this exchange.\r\n    /// @return The number of accounts registered\r\n    function getNumAccounts()\r\n        external\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Get the account information for a given address.\r\n    /// @param  owner The owning address of the account\r\n    /// @return accountID The account's ID\r\n    /// @return pubKeyX The first part of the account's trading EdDSA public key\r\n    /// @return pubKeyY The second part of the account's trading EdDSA public key\r\n    function getAccount(\r\n        address owner\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint24 accountID,\r\n            uint   pubKeyX,\r\n            uint   pubKeyY\r\n        );\r\n\r\n    /// @dev Submit an onchain request to create a new account for msg.sender or\r\n    ///      update its existing account by replacing its trading public key.\r\n    ///      The total fee in ETH that the user needs to pay is:\r\n    ///          depositFee +\r\n    ///          (isAccountNew ? accountCreationFee : 0) +\r\n    ///          (isAccountUpdated ? accountUpdateFee : 0)\r\n    ///      If the user sends too much ETH the surplus is sent back immediately.\r\n    ///\r\n    ///      Note that after such an operation, it will take the operator some\r\n    ///      time (no more than MAX_AGE_REQUEST_UNTIL_FORCED) to process the request\r\n    ///      and create or update the offchain account.\r\n    ///\r\n    ///      Calling this method with a different trading public key will effectively\r\n    ///      cancel all existing orders within MAX_AGE_REQUEST_UNTIL_FORCED.\r\n    ///\r\n    /// @param  pubKeyX The first part of the account's trading EdDSA public key\r\n    /// @param  pubKeyY The second part of the account's trading EdDSA public key.\r\n    ///                 Note that pubkeyX and pubKeyY cannot be both `1`.\r\n    /// @param  permission Data used for checking address whitelisting prior to\r\n    ///                    account creation.\r\n    /// @return accountID The account's ID\r\n    /// @return isAccountNew True if this account is newly created, false if the account existed\r\n    /// @return isAccountUpdated True if this account was updated, false otherwise\r\n    function createOrUpdateAccount(\r\n        uint  pubKeyX,\r\n        uint  pubKeyY,\r\n        bytes calldata permission\r\n        )\r\n        external\r\n        payable\r\n        returns (\r\n            uint24 accountID,\r\n            bool   isAccountNew,\r\n            bool   isAccountUpdated\r\n        );\r\n\r\n    // -- Balances --\r\n    /// @dev Verifies that the given information is stored in the merkle tree with\r\n    ///      the specified merkle root.\r\n    /// @param  merkleRoot The merkle tree root of all account data\r\n    /// @param  accountID The ID of the account the balance is verified for\r\n    /// @param  tokenID The ID of the token the balance is verified for\r\n    /// @param  pubKeyX The first part of the public key of the account\r\n    /// @param  pubKeyY The second part of the public key of the account\r\n    /// @param  nonce The nonce of the account\r\n    /// @param  balance The balance of the account for the given token\r\n    /// @param  tradeHistoryRoot The merkle root of the trade history of the given token\r\n    /// @param  accountMerkleProof The merkle proof (side node hashes) for the account.\r\n    ///                      The deepest hash in the tree is the 1st element of the array.\r\n    /// @param  balanceMerkleProof he merkle proof (side node hashes) for the balance of the\r\n    ///                      token for the account. The deepest hash in the tree is the\r\n    ///                      1st element of the array.\r\n    /// @return True if the given information is stored in the merkle tree, false otherwise\r\n    function isAccountBalanceCorrect(\r\n        uint     merkleRoot,\r\n        uint24   accountID,\r\n        uint16   tokenID,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint32   nonce,\r\n        uint96   balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[30] calldata accountMerkleProof,\r\n        uint[12] calldata balanceMerkleProof\r\n        )\r\n        external\r\n        pure\r\n        returns (bool);\r\n\r\n    // -- Tokens --\r\n\r\n    /// @dev Get the required amount of LRC to burn for registering one more token.\r\n    /// @return feeLRC The amount of LRC to burn.\r\n    function getLRCFeeForRegisteringOneMoreToken()\r\n        external\r\n        view\r\n        returns (uint feeLRC);\r\n\r\n    /// @dev Register an ERC20 token for a token id. Note that different exchanges may have\r\n    ///      different ids for the same ERC20 token.\r\n    ///\r\n    ///      Please note that 1 is reserved for Ether (ETH), 2 is reserved for Wrapped Ether (ETH),\r\n    ///      and 3 is reserved for Loopring Token (LRC).\r\n    ///\r\n    ///      This function is only callable by the exchange owner.\r\n    ///\r\n    /// @param  tokenAddress The token's address\r\n    /// @return tokenID The token's ID in this exchanges.\r\n    /// @return isAccountNew True if this account is newly created, false if the account existed\r\n    function registerToken(\r\n        address tokenAddress\r\n        )\r\n        external\r\n        returns (uint16 tokenID);\r\n\r\n    /// @dev Returns the id of a registered token.\r\n    /// @param  tokenAddress The token's address\r\n    /// @return tokenID The token's ID in this exchanges.\r\n    function getTokenID(\r\n        address tokenAddress\r\n        )\r\n        external\r\n        view\r\n        returns (uint16 tokenID);\r\n\r\n    /// @dev Returns the address of a registered token.\r\n    /// @param  tokenID The token's ID in this exchanges.\r\n    /// @return tokenAddress The token's address\r\n    function getTokenAddress(\r\n        uint16 tokenID\r\n        )\r\n        external\r\n        view\r\n        returns (address tokenAddress);\r\n\r\n    /// @dev Disable users to submit onchain deposit requests for a token.\r\n    ///      This function is only callable by the exchange owner.\r\n    /// @param  tokenAddress The token's address\r\n    function disableTokenDeposit(\r\n        address tokenAddress\r\n        )\r\n        external;\r\n\r\n    /// @dev Enable users to submit onchain deposit requests for a token.\r\n    ///      This function is only callable by the exchange owner.\r\n    /// @param  tokenAddress The token's address\r\n    function enableTokenDeposit(\r\n        address tokenAddress\r\n        )\r\n        external;\r\n\r\n    // -- Stakes --\r\n    /// @dev Get the amount of LRC the owner has staked onchain for this exchange.\r\n    ///      The stake will be burned if the exchange does not fulfill its duty by\r\n    ///      processing user requests in time. Please note that order matching may potentially\r\n    ///      performed by another party and is not part of the exchange's duty.\r\n    ///\r\n    /// @return The amount of LRC staked\r\n    function getExchangeStake()\r\n        external\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Withdraws the amount staked for this exchange.\r\n    ///      This can only be done if the exchange has been correctly shutdown:\r\n    ///      - The exchange owner has shutdown the exchange\r\n    ///      - All deposit requests are processed\r\n    ///      - All funds are returned to the users (merkle root is reset to initial state)\r\n    ///\r\n    ///      Can only be called by the exchange owner.\r\n    ///\r\n    /// @return The amount of LRC withdrawn\r\n    function withdrawExchangeStake(\r\n        address recipient\r\n        )\r\n        external\r\n        returns (uint);\r\n\r\n    /// @dev Withdraws all tokens not owned by users, e.g., candies, airdrops.\r\n    ///      Can only be called by the exchange owner.\r\n    ///\r\n    /// @param tokenAddress The adderss of the token.\r\n    /// @param recipient The address to send the token or ether.\r\n    /// @return The amount of token withdrawn\r\n    function withdrawTokenNotOwnedByUsers(\r\n        address tokenAddress,\r\n        address payable recipient\r\n        )\r\n        external\r\n        returns (uint);\r\n\r\n    /// @dev Withdraws the amount staked for this exchange.\r\n    ///      This can always be called.\r\n    ///      Can only be called by the exchange owner.\r\n    /// @param  recipient The recipient of the withdrawn LRC\r\n    /// @param  amount The amount of LRC that needs to be withdrawn\r\n    function withdrawProtocolFeeStake(\r\n        address recipient,\r\n        uint    amount\r\n        )\r\n        external;\r\n\r\n    /// @dev Can by called by anyone to burn the stake of the exchange when certain\r\n    ///      conditions are fulfilled.\r\n    ///\r\n    ///      Currently this will only burn the stake of the exchange if there are\r\n    ///      unfinalized blocks and the exchange is in withdrawal mode.\r\n    function burnExchangeStake()\r\n        external;\r\n\r\n    // -- Blocks --\r\n    /// @dev Get the height of this exchange's virtual blockchain. The block height for a\r\n    ///      new exchange is 0.\r\n    /// @return The virtual blockchain height which is the index of the last block.\r\n    function getBlockHeight()\r\n        external\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Get the number of finalized (i.e. irreversible) blocks.\r\n    /// @return The number of finalized blocks which is the index of the last finalized block.\r\n    function getNumBlocksFinalized()\r\n        external\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Returns the block data for the specified block index.\r\n    /// @param  blockIdx The block index\r\n    /// @return merkleRoot The merkle root\r\n    /// @return publicDataHash The hash of all public data. Used as public input for the ZKP.\r\n    /// @return blockState The current state of the block\r\n    /// @return blockType The type of work done in the block\r\n    /// @return blockSize The number of requests handled in the block\r\n    /// @return timestamp The time the block was committed on-chain\r\n    /// @return blockState The current state of the block\r\n    /// @return numDepositRequestsCommitted The total number of deposit requests committed\r\n    /// @return numWithdrawalRequestsCommitted The total number of withdrawal requests committed\r\n    /// @return blockFeeWithdrawn True if the block fee has been withdrawn, else false\r\n    /// @return numWithdrawalsDistributed The number of withdrawals that have been done for this block\r\n    function getBlock(\r\n        uint blockIdx\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 merkleRoot,\r\n            bytes32 publicDataHash,\r\n            uint8   blockState,\r\n            uint8   blockType,\r\n            uint16  blockSize,\r\n            uint32  timestamp,\r\n            uint32  numDepositRequestsCommitted,\r\n            uint32  numWithdrawalRequestsCommitted,\r\n            bool    blockFeeWithdrawn,\r\n            uint16  numWithdrawalsDistributed\r\n        );\r\n\r\n    /// @dev Commit a new block to the virtual blockchain without the proof.\r\n    ///      This function is only callable by the exchange operator.\r\n    ///\r\n    /// @param blockType The type of the new block\r\n    /// @param blockSize The number of onchain or offchain requests/settlements\r\n    ///        that have been processed in this block\r\n    /// @param blockVersion The circuit version to use for verifying the block\r\n    /// @param data The data for this block -\r\n    ///        For all block types:\r\n    ///            - Compression type: 1 bytes\r\n    ///            - Exchange ID: 4 bytes\r\n    ///            - Old merkle root: 32 bytes\r\n    ///            - New merkle root: 32 bytes\r\n    ///        For RING_SETTLEMENT blocks add the following data:\r\n    ///            - timestamp used in the block: 4 bytes\r\n    ///            - protocolTakerFeeBips: 1 bytes\r\n    ///            - protocolMakerFeeBips: 1 bytes\r\n    ///            - Label hash: 32 bytes\r\n    ///        For DEPOSIT blocks add the following data:\r\n    ///            - Starting hash: 32 bytes\r\n    ///            - Ending hash: 32 bytes\r\n    ///            - Start index (in deposit chain): 4 bytes\r\n    ///            - Number of deposits processed: 4 bytes\r\n    ///        For ONCHAIN_WITHDRAWAL blocks add the following data:\r\n    ///            - Starting hash: 32 bytes\r\n    ///            - Ending hash: 32 bytes\r\n    ///            - Start index (in withdrawal chain): 4 bytes\r\n    ///            - Number of withdrawals processed: 4 bytes\r\n    ///            - For every withdrawal:\r\n    ///                - Token ID: 1 bytes\r\n    ///                - Account ID: 2,5 bytes\r\n    ///                - Amount: 3,5 bytes\r\n    ///        For OFFCHAIN_WITHDRAWAL blocks add the following data:\r\n    ///            - For every withdrawal:\r\n    ///                - Token ID: 1 bytes\r\n    ///                - Account ID: 2,5 bytes\r\n    ///                - Amount: 3,5 bytes\r\n    ///            - Label hash: 32 bytes\r\n    ///        For ORDER_CANCELLATION blocks add the following data:\r\n    ///            - Label hash: 32 bytes\r\n    ///\r\n    ///        The 'onchain data availability' data (if enabled) is added\r\n    ///        at the end. This allows anyone to recreate the merkle tree\r\n    ///        just by using data published on the Ethereum blockchain.\r\n    ///\r\n    ///        For RING_SETTLEMENT blocks add the following data:\r\n    ///            - Operator account ID: 3 bytes\r\n    ///            - For every ring\r\n    ///                - OrderA.orderID: 2,5 bytes\r\n    ///                - OrderB.orderID: 2,5 bytes\r\n    ///                - OrderA.accountID: 2,5 bytes\r\n    ///                - OrderB.accountID: 2,5 bytes\r\n    ///                - For both Orders:\r\n    ///                    - TokenS: 1 bytes\r\n    ///                    - FillS: 3 bytes\r\n    ///                    - OrderData: isBuyOrder (1 bit) | isRebate (1 bit) |\r\n    ///                                 feeOrRebateBips (6 bits)\r\n    ///        For DEPOSIT blocks add the following data:\r\n    ///            - None\r\n    ///        For ONCHAIN_WITHDRAWAL blocks add the following data:\r\n    ///            - None\r\n    ///        For OFFCHAIN_WITHDRAWALAL blocks add the following data:\r\n    ///            - Operator account ID: 3 bytes\r\n    ///            - For every withdrawal:\r\n    ///                - Fee token ID: 1 bytes\r\n    ///                - Fee amount: 2 bytes\r\n    ///        For ORDER_CANCELLATION blocks add the following data:\r\n    ///            - Operator account ID: 3 bytes\r\n    ///            - For every cancel:\r\n    ///                - Account ID: 2,5 bytes\r\n    ///                - Order ID: 2,5 bytes\r\n    ///                - Token ID: 1 bytes\r\n    ///                - Fee token ID: 1 bytes\r\n    ///                - Fee amount: 2 bytes\r\n    ///\r\n    ///        The RING_SETTLEMENT data availability data is further transformed\r\n    ///        to make it more compressible:\r\n    ///        - To group more similar data together we don't store all data\r\n    ///          for a ring next to each other but group them together for all rings.\r\n    ///          For ALL rings, sequentially:\r\n    ///             - orderA.orderID + orderB.orderID\r\n    ///             - orderA.accountID + orderB.accountID\r\n    ///             - orderA.tokenS + orderB.tokenS\r\n    ///             - orderA.fillS + orderB.fillS\r\n    ///             - orderA.orderData\r\n    ///             - orderB.orderData\r\n    ///\r\n    ///        The data can be sent on-chain compressed. The data will be decompressed respecting the\r\n    ///        Compression type (the first byte in 'data'):\r\n    ///            - Mode 0: No compression. The data following the mode byte is used as is.\r\n    ///            - Mode 1: An IDecompressor address (20 bytes) is stored after the mode byte.\r\n    ///                      IDecompressor.decompress() will be called to decompress the following data.\r\n    /// @param offchainData Arbitrary data, mainly for off-chain data-availability, i.e.,\r\n    ///        the multihash of the IPFS file that contains the block data.\r\n    function commitBlock(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion,\r\n        bytes  calldata data,\r\n        bytes  calldata offchainData\r\n        )\r\n        external;\r\n\r\n    /// @dev Submits ZK proofs onchain to verify previously committed blocks. Submitting an\r\n    ///      invalid proof will not change the state of the exchange. Note that proofs can\r\n    ///      be submitted in a different order than the blocks themselves.\r\n    ///\r\n    ///      Multiple blocks can be verified at once (in any order) IF they use the same circuit.\r\n    ///      This function will throw if blocks using different circuits need to be verified.\r\n    ///\r\n    ///      This method can only be called by the operator.\r\n    ///\r\n    /// @param blockIndices The 0-based index of the blocks to be verified with the given proofs\r\n    /// @param proofs The ZK proof for all blockIndices (proofs.length % 8 == 0).\r\n    function verifyBlocks(\r\n        uint[] calldata blockIndices,\r\n        uint[] calldata proofs\r\n        )\r\n        external;\r\n\r\n    /// @dev Revert the exchange's virtual blockchain until a specific block index.\r\n    ///      After MAX_PROOF_GENERATION_TIME_IN_SECONDS seconds (the timeout), if a valid\r\n    ///      proof is still not submitted onchain, the operator can call this method to trigger\r\n    ///      the blockchain to revert.\r\n    ///\r\n    ///      If more than one blocks (A, B) are missing proofs after the required timeout,\r\n    ///      one can only trigger the blockchain to revert until A.\r\n    ///\r\n    ///      This method can only be called by the operator when not in withdrawal mode.\r\n    ///\r\n    ///      In withdrawal mode anyone can call burnStake so the exchange still gets punished\r\n    ///      for committing blocks it does not prove.\r\n    ///\r\n    /// @param blockIdx The 0-based index of the block that does not have a valid proof within\r\n    ///        MAX_PROOF_GENERATION_TIME_IN_SECONDS seconds.\r\n    function revertBlock(\r\n        uint blockIdx\r\n        )\r\n        external;\r\n\r\n    // -- Deposits --\r\n    /// @dev Returns the index of the first deposit request that wasn't yet included\r\n    ///      in a block. Can be used to check if a deposit with a given depositIdx\r\n    ///      (as specified in the DepositRequested event) was processed by the operator.\r\n    /// @return The num of the processed deposit requests\r\n    function getNumDepositRequestsProcessed()\r\n        external\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Get the number of available onchain deposit slots.\r\n    /// @return The number of slots avalable for deposits.\r\n    function getNumAvailableDepositSlots()\r\n        external\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Get an item from deposit request-chain.\r\n    /// @param index The 0-based index of the request\r\n    /// @return accumulatedHash See @Request\r\n    /// @return accumulatedFee  See @Request\r\n    /// @return timestamp       See @Request\r\n    function getDepositRequest(\r\n        uint index\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n          bytes32 accumulatedHash,\r\n          uint    accumulatedFee,\r\n          uint32  timestamp\r\n        );\r\n\r\n    /// @dev Deposit Ether or ERC20 tokens to the sender's account.\r\n    ///      This function will create a new account if no account exists\r\n    ///      for msg.sender, or update the existing account with the given trading\r\n    ///      public key when the account exists.\r\n    ///\r\n    ///      The total fee in ETH that the user needs to pay is:\r\n    ///          depositFee +\r\n    ///          (isAccountNew ? accountCreationFee : 0) +\r\n    ///          (isAccountUpdated ? accountUpdateFee : 0)\r\n    ///      If the user sends too much ETH the surplus is sent back immediately.\r\n    ///\r\n    ///      Note that after such an operation, it will take the operator some\r\n    ///      time (no more than MAX_AGE_REQUEST_UNTIL_FORCED) to process the request\r\n    ///      and create the deposit to the offchain account.\r\n    ///\r\n    ///      Calling this method with a different trading public key will effectively\r\n    ///      cancel all existing orders within MAX_AGE_REQUEST_UNTIL_FORCED.\r\n    ///\r\n    /// @param  pubKeyX The first part of the account's trading EdDSA public key\r\n    /// @param  pubKeyY The second part of the account's trading EdDSA public key\r\n    /// @param  permission Data used for checking address whitelisting prior to\r\n    ///                    account creation.\r\n    /// @param  tokenAddress The adderss of the token, use `0x0` for Ether.\r\n    /// @param  amount The amount of tokens to deposit\r\n    /// @return accountID The id of the account\r\n    /// @return isAccountNew True if this account is newly created, false if the account existed\r\n    /// @return isAccountUpdated True if this account was updated, false otherwise\r\n    function updateAccountAndDeposit(\r\n        uint    pubKeyX,\r\n        uint    pubKeyY,\r\n        address tokenAddress,\r\n        uint96  amount,\r\n        bytes   calldata permission\r\n        )\r\n        external\r\n        payable\r\n        returns (\r\n            uint24 accountID,\r\n            bool   isAccountNew,\r\n            bool   isAccountUpdated\r\n        );\r\n\r\n    /// @dev Deposit Ether or ERC20 tokens to the sender's account.\r\n    ///\r\n    ///      The total fee in ETH that the user needs to pay is 'depositFee'.\r\n    ///      If the user sends too much ETH the surplus is sent back immediately.\r\n    ///\r\n    ///      Note that after such an operation, it will take the operator some\r\n    ///      time (no more than MAX_AGE_REQUEST_UNTIL_FORCED) to process the request\r\n    ///      and create the deposit to the offchain account.\r\n    ///\r\n    ///      Warning: the DEX UI should warn their users not to deposit more than 2^96 - 1\r\n    ///               tokens in total. If that happens, the user may lose token.\r\n    ///               This token balance upper limit, however, is large enough for most scenarios.\r\n    ///\r\n    /// @param tokenAddress The address of the token, use `0x0` for Ether.\r\n    /// @param amount The amount of tokens to deposit\r\n    function deposit(\r\n        address tokenAddress,\r\n        uint96  amount\r\n        )\r\n        external\r\n        payable;\r\n\r\n    /// @dev Deposit Ether or ERC20 tokens to a recipient account.\r\n    ///\r\n    ///      The total fee in ETH that the user needs to pay is 'depositFee'.\r\n    ///      If the user sends too much ETH the surplus is sent back immediately.\r\n    ///\r\n    ///      Note that after such an operation, it will take the operator some\r\n    ///      time (no more than MAX_AGE_REQUEST_UNTIL_FORCED) to process the request\r\n    ///      and create the deposit to the offchain account.\r\n    ///\r\n    ///      Warning: the DEX UI should warn their users not to deposit more than 2^96 - 1\r\n    ///               tokens in total. If that happens, the user may lose token.\r\n    ///               This token balance upper limit, however, is large enough for most scenarios.\r\n    ///\r\n    /// @param recipient The address of the recipient\r\n    /// @param tokenAddress The adderss of the token, use `0x0` for Ether.\r\n    /// @param amount The amount of tokens to deposit\r\n    function depositTo(\r\n        address recipient,\r\n        address tokenAddress,\r\n        uint96  amount\r\n        )\r\n        external\r\n        payable;\r\n\r\n    // -- Withdrawals --\r\n    /// @dev Returns the index of the first withdrawal request that wasn't yet included\r\n    ///      in a block. Can be used to check if a withdrawal with a given withdrawalIdx\r\n    ///      (as specified in the WithdrawalRequested event) was processed by the operator.\r\n    /// @return The num of processed withdrawal requests\r\n    function getNumWithdrawalRequestsProcessed()\r\n        external\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Get the number of available onchain withdrawal slots.\r\n    /// @return The number of slots available for withdrawals\r\n    function getNumAvailableWithdrawalSlots(\r\n        )\r\n        external\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Get an item from withdrawal request-chain.\r\n    /// @param index The 0-based index of the request\r\n    /// @return accumulatedHash See @Request\r\n    /// @return accumulatedFee  See @Request\r\n    /// @return timestamp       See @Request\r\n    function getWithdrawRequest(\r\n        uint index\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 accumulatedHash,\r\n            uint    accumulatedFee,\r\n            uint32  timestamp\r\n        );\r\n\r\n    /// @dev Submit an onchain request to withdraw Ether or ERC20 tokens. To withdraw\r\n    ///      all the balance, use a very large number for `amount`.\r\n    ///\r\n    ///      Only the owner of the account can request a withdrawal.\r\n    ///\r\n    ///      The total fee in ETH that the user needs to pay is 'withdrawalFee'.\r\n    ///      If the user sends too much ETH the surplus is sent back immediately.\r\n    ///\r\n    ///      Note that after such an operation, it will take the operator some\r\n    ///      time (no more than MAX_AGE_REQUEST_UNTIL_FORCED) to process the request\r\n    ///      and create the deposit to the offchain account.\r\n    ///\r\n    /// @param tokenAddress The address of the token, use `0x0` for Ether.\r\n    /// @param amount The amount of tokens to deposit\r\n    function withdraw(\r\n        address tokenAddress,\r\n        uint96  amount\r\n        )\r\n        external\r\n        payable;\r\n\r\n    /// @dev Submit an onchain request to withdraw Ether or ERC20 tokens from the\r\n    ///      protocol fees account. The complete balance is always withdrawn.\r\n    ///\r\n    ///      Anyone can request a withdrawal of the protocol fees.\r\n    ///\r\n    ///      Note that after such an operation, it will take the operator some\r\n    ///      time (no more than MAX_AGE_REQUEST_UNTIL_FORCED) to process the request\r\n    ///      and create the deposit to the offchain account.\r\n    ///\r\n    /// @param tokenAddress The address of the token, use `0x0` for Ether.\r\n    function withdrawProtocolFees(\r\n        address tokenAddress\r\n        )\r\n        external\r\n        payable;\r\n\r\n    /// @dev Allows an account owner to withdraw his funds using the balances stored\r\n    ///      in the merkle tree. The funds will be sent to the owner of the account.\r\n    ///\r\n    ///      Trading pubKey matching the offchain Merkle tree need to be provided.\r\n    ///      The pubKey may already be reset to 0 when the exchange is shutdown.\r\n    ///      The pubKey passed in here is used to calculate the Merkle root, which\r\n    ///      needs to match perfectly with the offchain Merkle root. The onchain pubKey\r\n    ///      doesn't matter at all in withdrawal mode.\r\n    ///\r\n    ///      Can only be used in withdrawal mode (i.e. when the operator has stopped\r\n    ///      committing blocks and is not able to commit anymore blocks).\r\n    ///\r\n    ///      This will NOT modify the onchain merkle root! The merkle root stored\r\n    ///      onchain will remain the same after the withdrawal. We store if the user\r\n    ///      has withdrawn the balance in State.withdrawnInWithdrawMode.\r\n    ///\r\n    /// @param  token The address of the token to withdraw the tokens for\r\n    /// @param  pubKeyX The first part of the public key of the account\r\n    /// @param  pubKeyY The second part of the public key of the account\r\n    /// @param  nonce The nonce of the account\r\n    /// @param  balance The balance of the account for the given token\r\n    /// @param  tradeHistoryRoot The merkle root of the trade history of the given token\r\n    /// @param  accountMerkleProof The merkle proof (side node hashes) for the account.\r\n    ///                      The deepest hash in the tree is the 1st element of the array.\r\n    /// @param  balanceMerkleProof he merkle proof (side node hashes) for the balance of the\r\n    ///                      token for the account. The deepest hash in the tree is the\r\n    ///                      1st element of the array.\r\n    function withdrawFromMerkleTree(\r\n        address  token,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint32   nonce,\r\n        uint96   balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[30] calldata accountMerkleProof,\r\n        uint[12] calldata balanceMerkleProof\r\n        )\r\n        external;\r\n\r\n    /// @dev Allows anyone to withdraw funds for a specified user using the balances stored\r\n    ///      in the merkle tree. The funds will be sent to the owner of the acount.\r\n    ///\r\n    ///      Can only be used in withdrawal mode (i.e. when the operator has stopped\r\n    ///      committing blocks and is not able to commit anymore blocks).\r\n    ///\r\n    ///      This will NOT modify the onchain merkle root! The merkle root stored\r\n    ///      onchain will remain the same after the withdrawal. We store if the user\r\n    ///      has withdrawn the balance in State.withdrawnInWithdrawMode.\r\n    ///\r\n    /// @param  owner The owner of the account to withdraw the funds for.\r\n    /// @param  token The address of the token to withdraw the tokens for\r\n    /// @param  pubKeyX The first part of the public key of the account\r\n    /// @param  pubKeyY The second part of the public key of the account\r\n    /// @param  nonce The nonce of the account\r\n    /// @param  balance The balance of the account for the given token\r\n    /// @param  tradeHistoryRoot The merkle root of the trade history of the given token\r\n    /// @param  accountMerkleProof The merkle proof (side node hashes) for the account.\r\n    ///                      The deepest hash in the tree is the 1st element of the array.\r\n    /// @param  balanceMerkleProof he merkle proof (side node hashes) for the balance of the\r\n    ///                      token for the account. The deepest hash in the tree is the\r\n    ///                      1st element of the array.\r\n    function withdrawFromMerkleTreeFor(\r\n        address  owner,\r\n        address  token,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint32   nonce,\r\n        uint96   balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[30] calldata accountMerkleProof,\r\n        uint[12] calldata balanceMerkleProof\r\n        )\r\n        external;\r\n\r\n    /// @dev Allows withdrawing funds deposited to the contract in a deposit request when\r\n    ///      it was never committed in a block (so the balance in the merkle tree was\r\n    ///      not updated).\r\n    ///\r\n    ///      Can be called by anyone. The deposited tokens will be sent back to\r\n    ///      the owner of the account they were deposited in.\r\n    ///\r\n    ///      Can only be used in withdrawal mode (i.e. when the operator has stopped\r\n    ///      committing blocks and is not able to commit anymore blocks).\r\n    ///\r\n    /// @param  depositIdx The index of the deposit request (as given in the\r\n    ///                    depositIdx field in the DepositRequested event)\r\n    function withdrawFromDepositRequest(\r\n        uint depositIdx\r\n        )\r\n        external;\r\n\r\n    /// @dev Allows withdrawing funds after a withdrawal request (either onchain\r\n    ///      or offchain) was committed in a block by the operator.\r\n    ///\r\n    ///      Can be called by anyone. The withdrawn tokens will be sent to\r\n    ///      the owner of the account they were withdrawn out.\r\n    ///\r\n    ///      Normally it is should not be needed for users to call this manually.\r\n    ///      Funds from withdrawal requests will be sent to the account owner\r\n    ///      by the operator in distributeWithdrawals. The user can however\r\n    ///      choose to withdraw earlier if he wants, or will need to call this\r\n    ///      manually if nobody calls distributeWithdrawals.\r\n    ///\r\n    ///      Funds can only be withdrawn from requests processed in a\r\n    ///      finalized block (i.e. a block that can never be reverted).\r\n    ///\r\n    /// @param  blockIdx The block the withdrawal requests was committed in\r\n    /// @param  slotIdx The index in the list of withdrawals that were processed\r\n    ///                 by the operator. It is not possible for users to know\r\n    ///                 what this index will be for their withdrawal request.\r\n    function withdrawFromApprovedWithdrawal(\r\n        uint blockIdx,\r\n        uint slotIdx\r\n        )\r\n        external;\r\n\r\n    /// @dev Allows the operator to withdraw the fees he earned by processing the\r\n    ///      deposit and onchain withdrawal requests.\r\n    ///\r\n    ///      This function is only callable by the exchange operator.\r\n    ///\r\n    ///      The block fee can only be withdrawn from finalized blocks\r\n    ///      (i.e. blocks that can never be reverted).\r\n    ///\r\n    /// @param  blockIdx The block index to withdraw the funds for\r\n    /// @param  feeRecipient The address that receives the block fee\r\n    /// @return feeAmount The amount of ETH earned in the block and sent to the operator\r\n    function withdrawBlockFee(\r\n        uint    blockIdx,\r\n        address payable feeRecipient\r\n        )\r\n        external\r\n        returns (uint feeAmount);\r\n\r\n    /// @dev Distributes the the funds to the account owners after their withdrawal\r\n    ///      requests were processed by the operator.\r\n    ///\r\n    ///      Needs to be called by the operator after submitting a block processing\r\n    ///      withdrawal requests (either onchain or offchain requests) after the block\r\n    ///      is finalized and before the block is MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS seconds old.\r\n    ///\r\n    ///      If the operator fails to do so anyone will be able to call this function\r\n    ///      and the stake of the exchange will be used to reward the caller of this function.\r\n    ///      The amount of staked LRC withdrawn is calculated as follows:\r\n    ///\r\n    ///      totalFine = withdrawalFineLRC * numWithdrawalRequestsInBlock\r\n    ///      The caller of the function will be rewarded half this amount,\r\n    ///      the other half is burned.\r\n    ///\r\n    ///      Only withdrawals processed in finalized blocks can be distributed.\r\n    ///\r\n    ///      The withdrawals can be done in multiple transactions because the token transfers\r\n    ///      are more expensive than committing and proving a block, so it's possible more\r\n    ///      withdrawals requests are processed in a block than can be distributed\r\n    ///      in an Ethereum block.\r\n    ///      This function will automatically stop distributing the withdrawals when the amount\r\n    ///      of gas left is less than MIN_GAS_TO_DISTRIBUTE_WITHDRAWALS.\r\n    ///      So there are 2 ways to  limit the number of withdrawals:\r\n    ///          - using the maxNumWithdrawals parameter\r\n    ///          - limiting the amount of gas in the transaction\r\n    ///\r\n    /// @param  blockIdx The block index to distribute the funds from the withdrawal requests for\r\n    /// @param  maxNumWithdrawals The max number of withdrawals to distribute. Can be lower than the\r\n    ///         number of withdrawal requests processed in the block. Withdrawals are distributed\r\n    ///         in the same order the withdrawal requests were processed in the block.\r\n    ///         If the withdrawals are done in multiple parts we always start from the\r\n    ///         first withdrawal that was not yet distributed.\r\n    function distributeWithdrawals(\r\n        uint blockIdx,\r\n        uint maxNumWithdrawals\r\n        )\r\n        external;\r\n\r\n    // -- Admins --\r\n\r\n    /// @dev Set the operator address.\r\n    /// @param _operator The new operator's address\r\n    /// @return oldOperator The old operator's address\r\n    function setOperator(\r\n        address payable _operator\r\n        )\r\n        external\r\n        returns (address payable oldOperator);\r\n\r\n    /// @dev Set the address whitelist contract address.\r\n    ///      Can only be called by the exchange owner.\r\n    /// @param _addressWhitelist The new address whitelist contract address\r\n    /// @return oldAddressWhitelist The old address whitelist contract address\r\n    function setAddressWhitelist(\r\n        address _addressWhitelist\r\n        )\r\n        external\r\n        returns (address oldAddressWhitelist);\r\n\r\n    /// @dev Update fee settings.\r\n    ///      This function is only callable by the exchange owner.\r\n    /// @param _accountCreationFeeETH The fee in ETH for account creation\r\n    /// @param _accountUpdateFeeETH The fee in ETH for account update\r\n    /// @param _depositFeeETH The fee in ETH for deposits\r\n    /// @param _withdrawalFeeETH The fee in ETH for onchain withdrawal requests\r\n    function setFees(\r\n        uint _accountCreationFeeETH,\r\n        uint _accountUpdateFeeETH,\r\n        uint _depositFeeETH,\r\n        uint _withdrawalFeeETH\r\n        )\r\n        external;\r\n\r\n    /// @dev Get current fee settings.\r\n    /// @return _accountCreationFeeETH The fee in ETH for account creation\r\n    /// @return _accountUpdateFeeETH The fee in ETH for account update\r\n    /// @return _depositFeeETH The fee in ETH for deposits\r\n    /// @return _withdrawalFeeETH The fee in ETH for onchain withdrawal requests\r\n    function getFees()\r\n        external\r\n        view\r\n        returns (\r\n            uint _accountCreationFeeETH,\r\n            uint _accountUpdateFeeETH,\r\n            uint _depositFeeETH,\r\n            uint _withdrawalFeeETH\r\n        );\r\n\r\n    /// @dev Starts or continues maintenance mode for the specified duration.\r\n    ///      The necessary additional downtime minutes will be purchased. The number of\r\n    ///      downtime minutes still available for use can be checked with getRemainingDowntime().\r\n    ///      In maintenance mode, all onchain user requests, including account creation,\r\n    ///      account update, deposits, and withdrawal requests are disabled.\r\n    ///\r\n    ///      The remaining downtime time will be extended so that the exchange can stay in\r\n    ///      maintenance mode for at least `durationMinutes`.\r\n    ///\r\n    ///      The exchange owner can exit maintenance mode by calling stopMaintenanceMode()\r\n    ///      or by waiting until the remaining downtime is reduced to 0.\r\n    ///\r\n    ///      Once entering the maintenance mode, the operator should still fulfill his duty\r\n    ///      by submitting blocks and proofs until all pending user requests have been taken\r\n    ///      care of within the required timeouts. In the maintenance mode, operator can no longer\r\n    ///      submit settlement blocks.\r\n    ///\r\n    ///      After all pending onchain requests have been handled, the operator can no longer\r\n    ///      submit blocks of any type until maintenance mode is no longer active.\r\n    ///\r\n    ///      This function is only callable by the exchange owner.\r\n    ///\r\n    /// @param durationMinutes The duration in minutes that this exchange can remain in\r\n    ///                        the maintenance mode.\r\n    function startOrContinueMaintenanceMode(\r\n        uint durationMinutes\r\n        )\r\n        external;\r\n\r\n    /// @dev Gets the exchange out of maintenance mode.\r\n    ///\r\n    ///      This function is only callable by the exchange owner.\r\n    function stopMaintenanceMode()\r\n        external;\r\n\r\n    /// @dev Get the remaining downtime.\r\n    /// @return durationSeconds Remaining downtime in second.\r\n    function getRemainingDowntime()\r\n        external\r\n        view\r\n        returns (uint durationMinutes);\r\n\r\n    /// @dev Get the amount of LRC to burn for buying the downtime.\r\n    /// @return costLRC The amount of LRC to burn\r\n    function getDowntimeCostLRC(\r\n        uint durationMinutes\r\n        )\r\n        external\r\n        view\r\n        returns (uint costLRC);\r\n\r\n    /// @dev Gets the total amount of time in seconds the exchange has ever been in maintenance.\r\n    /// @return timeInSeconds The total time in maintenance.\r\n    function getTotalTimeInMaintenanceSeconds()\r\n        external\r\n        view\r\n        returns (uint timeInSeconds);\r\n\r\n    /// @dev Gets the time the exchange was created.\r\n    /// @return timestamp The time the exchange was created.\r\n    function getExchangeCreationTimestamp()\r\n        external\r\n        view\r\n        returns (uint timestamp);\r\n\r\n    /// @dev Shuts down the exchange.\r\n    ///      Once the exchange is shutdown all onchain requests are permanently disabled.\r\n    ///      When all requirements are fulfilled the exchange owner can withdraw\r\n    ///      the exchange stake with withdrawStake.\r\n    ///\r\n    ///      Note that the exchange can still enter the withdrawal mode after this function\r\n    ///      has been invoked successfully. To prevent entering the withdrawal mode, exchange\r\n    ///      operators need to reset the Merkle tree to its initial state by doing withdrawals\r\n    ///      within MAX_TIME_IN_SHUTDOWN_BASE + (accounts.length * MAX_TIME_IN_SHUTDOWN_DELTA)\r\n    ///      seconds.\r\n    ///\r\n    ///      Can only be called by the exchange owner.\r\n    ///\r\n    /// @return success True if the exchange is shutdown, else False\r\n    function shutdown()\r\n        external\r\n        returns (bool success);\r\n\r\n    /// @dev Get number of available/processed deposits/withdrawals.\r\n    /// @return numDepositRequestsProcessed The num of the processed deposit requests\r\n    /// @return numAvailableDepositSlots The number of slots available for deposits\r\n    /// @return numWithdrawalRequestsProcessed The num of processed withdrawal requests\r\n    /// @return numAvailableWithdrawalSlots The number of slots available for withdrawals\r\n    function getRequestStats()\r\n        external\r\n        view\r\n        returns(\r\n            uint numDepositRequestsProcessed,\r\n            uint numAvailableDepositSlots,\r\n            uint numWithdrawalRequestsProcessed,\r\n            uint numAvailableWithdrawalSlots\r\n        );\r\n\r\n    /// @dev Get the protocol fees for this exchange.\r\n    /// @return timestamp The timestamp the protocol fees were last updated\r\n    /// @return takerFeeBips The protocol taker fee\r\n    /// @return makerFeeBips The protocol maker fee\r\n    /// @return previousTakerFeeBips The previous protocol taker fee\r\n    /// @return previousMakerFeeBips The previous protocol maker fee\r\n    function getProtocolFeeValues()\r\n        external\r\n        view\r\n        returns (\r\n            uint32 timestamp,\r\n            uint8 takerFeeBips,\r\n            uint8 makerFeeBips,\r\n            uint8 previousTakerFeeBips,\r\n            uint8 previousMakerFeeBips\r\n        );\r\n}\r\n\r\n// File: contracts/impl/ExchangeV3.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title An Implementation of IExchangeV3.\r\n/// @dev This contract supports upgradability proxy, therefore its constructor\r\n///      must do NOTHING.\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract ExchangeV3 is IExchangeV3\r\n{\r\n    string  constant public version = \"3.0-beta3\";\r\n    bytes32 constant public genesisBlockHash =\r\n        0x2b4827daf74c0ab30deb68b1c337dec40579bb3ff45ce9478288e1a2b83a3a01;\r\n\r\n    using ExchangeAdmins        for ExchangeData.State;\r\n    using ExchangeAccounts      for ExchangeData.State;\r\n    using ExchangeBalances      for ExchangeData.State;\r\n    using ExchangeBlocks        for ExchangeData.State;\r\n    using ExchangeDeposits      for ExchangeData.State;\r\n    using ExchangeGenesis       for ExchangeData.State;\r\n    using ExchangeMode          for ExchangeData.State;\r\n    using ExchangeTokens        for ExchangeData.State;\r\n    using ExchangeWithdrawals   for ExchangeData.State;\r\n\r\n    ExchangeData.State private state;\r\n\r\n    modifier onlyOperator()\r\n    {\r\n        require(msg.sender == state.operator, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenUninitialized()\r\n    {\r\n        require(owner == address(0) && state.id == 0, \"INITIALIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev The constructor must do NOTHING to support proxy.\r\n    constructor() public {}\r\n\r\n    // -- Initialization --\r\n    function initialize(\r\n        address _loopringAddress,\r\n        address _owner,\r\n        uint    _id,\r\n        address payable _operator,\r\n        bool    _onchainDataAvailability\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyWhenUninitialized\r\n    {\r\n        require(address(0) != _owner, \"ZERO_ADDRESS\");\r\n        owner = _owner;\r\n\r\n        state.initializeGenesisBlock(\r\n            _id,\r\n            _loopringAddress,\r\n            _operator,\r\n            _onchainDataAvailability,\r\n            genesisBlockHash\r\n        );\r\n    }\r\n\r\n    // -- Mode --\r\n    function isInWithdrawalMode()\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return state.isInWithdrawalMode();\r\n    }\r\n\r\n    function isShutdown()\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return state.isShutdown();\r\n    }\r\n\r\n    function isInMaintenance()\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return state.isInMaintenance();\r\n    }\r\n\r\n    // -- Accounts --\r\n    function getNumAccounts()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return state.accounts.length;\r\n    }\r\n\r\n    function getAccount(\r\n        address owner\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint24 accountID,\r\n            uint   pubKeyX,\r\n            uint   pubKeyY\r\n        )\r\n    {\r\n        return state.getAccount(owner);\r\n    }\r\n\r\n    function createOrUpdateAccount(\r\n        uint  pubKeyX,\r\n        uint  pubKeyY,\r\n        bytes calldata permission\r\n        )\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (\r\n            uint24 accountID,\r\n            bool   isAccountNew,\r\n            bool   isAccountUpdated\r\n        )\r\n    {\r\n        return updateAccountAndDepositInternal(\r\n            pubKeyX,\r\n            pubKeyY,\r\n            address(0),\r\n            0,\r\n            permission\r\n        );\r\n    }\r\n\r\n    // -- Balances --\r\n    function isAccountBalanceCorrect(\r\n        uint     merkleRoot,\r\n        uint24   accountID,\r\n        uint16   tokenID,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint32   nonce,\r\n        uint96   balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[30] calldata accountPath,\r\n        uint[12] calldata balancePath\r\n        )\r\n        external\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return ExchangeBalances.isAccountBalanceCorrect(\r\n            merkleRoot,\r\n            accountID,\r\n            tokenID,\r\n            pubKeyX,\r\n            pubKeyY,\r\n            nonce,\r\n            balance,\r\n            tradeHistoryRoot,\r\n            accountPath,\r\n            balancePath\r\n        );\r\n    }\r\n\r\n    // -- Tokens --\r\n    function getLRCFeeForRegisteringOneMoreToken()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return state.getLRCFeeForRegisteringOneMoreToken();\r\n    }\r\n\r\n    function registerToken(\r\n        address tokenAddress\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n        returns (uint16)\r\n    {\r\n        return state.registerToken(tokenAddress);\r\n    }\r\n\r\n    function getTokenID(\r\n        address tokenAddress\r\n        )\r\n        external\r\n        view\r\n        returns (uint16)\r\n    {\r\n        return state.getTokenID(tokenAddress);\r\n    }\r\n\r\n    function getTokenAddress(\r\n        uint16 tokenID\r\n        )\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return state.getTokenAddress(tokenID);\r\n    }\r\n\r\n    function disableTokenDeposit(\r\n        address tokenAddress\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n    {\r\n        state.disableTokenDeposit(tokenAddress);\r\n    }\r\n\r\n    function enableTokenDeposit(\r\n        address tokenAddress\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n    {\r\n        state.enableTokenDeposit(tokenAddress);\r\n    }\r\n\r\n    // -- Stakes --\r\n    function getExchangeStake()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return state.loopring.getExchangeStake(state.id);\r\n    }\r\n\r\n    function withdrawExchangeStake(\r\n        address recipient\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n        returns (uint)\r\n    {\r\n        return state.withdrawExchangeStake(recipient);\r\n    }\r\n\r\n    function withdrawTokenNotOwnedByUsers(\r\n        address tokenAddress,\r\n        address payable recipient\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n        returns(uint)\r\n    {\r\n        return state.withdrawTokenNotOwnedByUsers(tokenAddress, recipient);\r\n    }\r\n\r\n    function withdrawProtocolFeeStake(\r\n        address recipient,\r\n        uint amount\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n    {\r\n        state.loopring.withdrawProtocolFeeStake(state.id, recipient, amount);\r\n    }\r\n\r\n    function burnExchangeStake()\r\n        external\r\n        nonReentrant\r\n    {\r\n        // Allow burning the complete exchange stake when the exchange gets into withdrawal mode\r\n        if(state.isInWithdrawalMode()) {\r\n            // Burn the complete stake of the exchange\r\n            uint stake = state.loopring.getExchangeStake(state.id);\r\n            state.loopring.burnExchangeStake(state.id, stake);\r\n        }\r\n    }\r\n\r\n    // -- Blocks --\r\n    function getBlockHeight()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return state.blocks.length - 1;\r\n    }\r\n\r\n    function getNumBlocksFinalized()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return state.numBlocksFinalized - 1;\r\n    }\r\n\r\n    function getBlock(\r\n        uint blockIdx\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 merkleRoot,\r\n            bytes32 publicDataHash,\r\n            uint8   blockState,\r\n            uint8   blockType,\r\n            uint16  blockSize,\r\n            uint32  timestamp,\r\n            uint32  numDepositRequestsCommitted,\r\n            uint32  numWithdrawalRequestsCommitted,\r\n            bool    blockFeeWithdrawn,\r\n            uint16  numWithdrawalsDistributed\r\n        )\r\n    {\r\n        require(blockIdx < state.blocks.length, \"INVALID_BLOCK_IDX\");\r\n        ExchangeData.Block storage specifiedBlock = state.blocks[blockIdx];\r\n\r\n        merkleRoot = specifiedBlock.merkleRoot;\r\n        publicDataHash = specifiedBlock.publicDataHash;\r\n        blockState = uint8(specifiedBlock.state);\r\n        blockType = uint8(specifiedBlock.blockType);\r\n        blockSize = specifiedBlock.blockSize;\r\n        timestamp = specifiedBlock.timestamp;\r\n        numDepositRequestsCommitted = specifiedBlock.numDepositRequestsCommitted;\r\n        numWithdrawalRequestsCommitted = specifiedBlock.numWithdrawalRequestsCommitted;\r\n        blockFeeWithdrawn = specifiedBlock.blockFeeWithdrawn;\r\n        numWithdrawalsDistributed = specifiedBlock.numWithdrawalsDistributed;\r\n    }\r\n\r\n    function commitBlock(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion,\r\n        bytes  calldata /*data*/,\r\n        bytes  calldata offchainData\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOperator\r\n    {\r\n        // Decompress the data here so we can extract the data directly from calldata\r\n        bytes4 selector = IDecompressor(0x0).decompress.selector;\r\n        bytes memory decompressed;\r\n        assembly {\r\n          // Calldata layout:\r\n          //   0: selector\r\n          //   4: blockType\r\n          //  36: blockSize\r\n          //  68: blockVersion\r\n          // 100: offset data\r\n          // 132: offset offchainData\r\n          let dataOffset := add(calldataload(100), 4)\r\n          let mode := and(calldataload(add(dataOffset, 1)), 0xFF)\r\n          switch mode\r\n          case 0 {\r\n              // No compression\r\n              let length := sub(calldataload(dataOffset), 1)\r\n\r\n              let data := mload(0x40)\r\n              calldatacopy(add(data, 32), add(dataOffset, 33), length)\r\n              mstore(data, length)\r\n              decompressed := data\r\n              mstore(0x40, add(add(decompressed, length), 32))\r\n          }\r\n          case 1 {\r\n              // External contract\r\n              let contractAddress := and(\r\n                calldataload(add(dataOffset, 21)),\r\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n              let length := sub(calldataload(dataOffset), 21)\r\n\r\n              let data := mload(0x40)\r\n              mstore(data, selector)\r\n              mstore(add(data,  4), 32)\r\n              mstore(add(data, 36), length)\r\n              calldatacopy(add(data, 68), add(dataOffset, 53), length)\r\n\r\n              let success := call(gas, contractAddress, 0, data, add(68, length), 0x0, 0)\r\n              if eq(success, 0) {\r\n                revert(0, 0)\r\n              }\r\n\r\n              returndatacopy(data, 32, sub(returndatasize(), 32))\r\n              decompressed := data\r\n              mstore(0x40, add(add(decompressed, mload(decompressed)), 32))\r\n          }\r\n          default {\r\n              revert(0, 0)\r\n          }\r\n        }\r\n        state.commitBlock(blockType, blockSize, blockVersion, decompressed, offchainData);\r\n    }\r\n\r\n    function verifyBlocks(\r\n        uint[] calldata blockIndices,\r\n        uint[] calldata proofs\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOperator\r\n    {\r\n        state.verifyBlocks(blockIndices, proofs);\r\n    }\r\n\r\n    function revertBlock(\r\n        uint blockIdx\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOperator\r\n    {\r\n        state.revertBlock(blockIdx);\r\n    }\r\n\r\n    // -- Deposits --\r\n    function getNumDepositRequestsProcessed()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return state.getNumDepositRequestsProcessed();\r\n    }\r\n\r\n    function getNumAvailableDepositSlots()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return state.getNumAvailableDepositSlots();\r\n    }\r\n\r\n    function getDepositRequest(\r\n        uint index\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n          bytes32 accumulatedHash,\r\n          uint    accumulatedFee,\r\n          uint32  timestamp\r\n        )\r\n    {\r\n        return state.getDepositRequest(index);\r\n    }\r\n\r\n    function updateAccountAndDeposit(\r\n        uint    pubKeyX,\r\n        uint    pubKeyY,\r\n        address token,\r\n        uint96  amount,\r\n        bytes   calldata permission\r\n        )\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (\r\n            uint24 accountID,\r\n            bool   isAccountNew,\r\n            bool   isAccountUpdated\r\n        )\r\n    {\r\n        return updateAccountAndDepositInternal(\r\n            pubKeyX,\r\n            pubKeyY,\r\n            token,\r\n            amount,\r\n            permission\r\n        );\r\n    }\r\n\r\n    function deposit(\r\n        address token,\r\n        uint96  amount\r\n        )\r\n        external\r\n        payable\r\n        nonReentrant\r\n    {\r\n        state.depositTo(msg.sender, token, amount, 0);\r\n    }\r\n\r\n    function depositTo(\r\n        address recipient,\r\n        address tokenAddress,\r\n        uint96  amount\r\n        )\r\n        external\r\n        payable\r\n        nonReentrant\r\n    {\r\n        state.depositTo(recipient, tokenAddress, amount, 0);\r\n    }\r\n\r\n    // -- Withdrawals --\r\n    function getNumWithdrawalRequestsProcessed()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return state.getNumWithdrawalRequestsProcessed();\r\n    }\r\n\r\n    function getNumAvailableWithdrawalSlots()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return state.getNumAvailableWithdrawalSlots();\r\n    }\r\n\r\n    function getWithdrawRequest(\r\n        uint index\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 accumulatedHash,\r\n            uint    accumulatedFee,\r\n            uint32  timestamp\r\n        )\r\n    {\r\n        return state.getWithdrawRequest(index);\r\n    }\r\n\r\n    function withdraw(\r\n        address token,\r\n        uint96 amount\r\n        )\r\n        external\r\n        payable\r\n        nonReentrant\r\n    {\r\n        uint24 accountID = state.getAccountID(msg.sender);\r\n        state.withdraw(accountID, token, amount);\r\n    }\r\n\r\n    function withdrawProtocolFees(\r\n        address token\r\n        )\r\n        external\r\n        payable\r\n        nonReentrant\r\n    {\r\n        // Always request the maximum amount so the complete balance is withdrawn\r\n        state.withdraw(0, token, ~uint96(0));\r\n    }\r\n\r\n    function withdrawFromMerkleTree(\r\n        address  token,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint32   nonce,\r\n        uint96   balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[30] calldata accountPath,\r\n        uint[12] calldata balancePath\r\n        )\r\n        external\r\n        nonReentrant\r\n    {\r\n        state.withdrawFromMerkleTreeFor(\r\n            msg.sender,\r\n            token,\r\n            pubKeyX,\r\n            pubKeyY,\r\n            nonce,\r\n            balance,\r\n            tradeHistoryRoot,\r\n            accountPath,\r\n            balancePath\r\n        );\r\n    }\r\n\r\n    // We still alow anyone to withdraw these funds for the account owner\r\n    function withdrawFromMerkleTreeFor(\r\n        address  owner,\r\n        address  token,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint32   nonce,\r\n        uint96   balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[30] calldata accountPath,\r\n        uint[12] calldata balancePath\r\n        )\r\n        external\r\n        nonReentrant\r\n    {\r\n        state.withdrawFromMerkleTreeFor(\r\n            owner,\r\n            token,\r\n            pubKeyX,\r\n            pubKeyY,\r\n            nonce,\r\n            balance,\r\n            tradeHistoryRoot,\r\n            accountPath,\r\n            balancePath\r\n        );\r\n    }\r\n\r\n    function withdrawFromDepositRequest(\r\n        uint depositIdx\r\n        )\r\n        external\r\n        nonReentrant\r\n    {\r\n        state.withdrawFromDepositRequest(depositIdx);\r\n    }\r\n\r\n    function withdrawFromApprovedWithdrawal(\r\n        uint blockIdx,\r\n        uint slotIdx\r\n        )\r\n        external\r\n        nonReentrant\r\n    {\r\n        require(blockIdx < state.blocks.length, \"INVALID_BLOCK_IDX\");\r\n        ExchangeData.Block storage withdrawBlock = state.blocks[blockIdx];\r\n        state.withdrawFromApprovedWithdrawal(\r\n            blockIdx,\r\n            withdrawBlock,\r\n            slotIdx,\r\n            false\r\n        );\r\n    }\r\n\r\n    function withdrawBlockFee(\r\n        uint blockIdx,\r\n        address payable feeRecipient\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOperator\r\n        returns (uint)\r\n    {\r\n        return state.withdrawBlockFee(blockIdx, feeRecipient);\r\n    }\r\n\r\n    function distributeWithdrawals(\r\n        uint blockIdx,\r\n        uint maxNumWithdrawals\r\n        )\r\n        external\r\n        nonReentrant\r\n    {\r\n        state.distributeWithdrawals(blockIdx, maxNumWithdrawals);\r\n    }\r\n\r\n    // -- Admins --\r\n    function setOperator(\r\n        address payable _operator\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n        returns (address payable)\r\n    {\r\n        return state.setOperator(_operator);\r\n    }\r\n\r\n    function setAddressWhitelist(\r\n        address _addressWhitelist\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n        returns (address)\r\n    {\r\n        return state.setAddressWhitelist(_addressWhitelist);\r\n    }\r\n\r\n    function setFees(\r\n        uint _accountCreationFeeETH,\r\n        uint _accountUpdateFeeETH,\r\n        uint _depositFeeETH,\r\n        uint _withdrawalFeeETH\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n    {\r\n        state.setFees(\r\n            _accountCreationFeeETH,\r\n            _accountUpdateFeeETH,\r\n            _depositFeeETH,\r\n            _withdrawalFeeETH\r\n        );\r\n    }\r\n\r\n    function getFees()\r\n        external\r\n        view\r\n        returns (\r\n            uint _accountCreationFeeETH,\r\n            uint _accountUpdateFeeETH,\r\n            uint _depositFeeETH,\r\n            uint _withdrawalFeeETH\r\n        )\r\n    {\r\n        _accountCreationFeeETH = state.accountCreationFeeETH;\r\n        _accountUpdateFeeETH = state.accountUpdateFeeETH;\r\n        _depositFeeETH = state.depositFeeETH;\r\n        _withdrawalFeeETH = state.withdrawalFeeETH;\r\n    }\r\n\r\n    function startOrContinueMaintenanceMode(\r\n        uint durationMinutes\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n    {\r\n        state.startOrContinueMaintenanceMode(durationMinutes);\r\n    }\r\n\r\n    function stopMaintenanceMode()\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n    {\r\n        state.stopMaintenanceMode();\r\n    }\r\n\r\n    function getRemainingDowntime()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return state.getRemainingDowntime();\r\n    }\r\n\r\n    function getDowntimeCostLRC(\r\n        uint durationMinutes\r\n        )\r\n        external\r\n        view\r\n        returns (uint costLRC)\r\n    {\r\n        return state.getDowntimeCostLRC(durationMinutes);\r\n    }\r\n\r\n    function getTotalTimeInMaintenanceSeconds()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return state.getTotalTimeInMaintenanceSeconds();\r\n    }\r\n\r\n    function getExchangeCreationTimestamp()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return state.exchangeCreationTimestamp;\r\n    }\r\n\r\n    function shutdown()\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n        returns (bool success)\r\n    {\r\n        require(!state.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        require(!state.isShutdown(), \"ALREADY_SHUTDOWN\");\r\n        state.shutdownStartTime = now;\r\n        emit Shutdown(state.shutdownStartTime);\r\n        return true;\r\n    }\r\n\r\n    function getRequestStats()\r\n        external\r\n        view\r\n        returns(\r\n            uint numDepositRequestsProcessed,\r\n            uint numAvailableDepositSlots,\r\n            uint numWithdrawalRequestsProcessed,\r\n            uint numAvailableWithdrawalSlots\r\n        )\r\n    {\r\n        numDepositRequestsProcessed = state.getNumDepositRequestsProcessed();\r\n        numAvailableDepositSlots = state.getNumAvailableDepositSlots();\r\n        numWithdrawalRequestsProcessed = state.getNumWithdrawalRequestsProcessed();\r\n        numAvailableWithdrawalSlots = state.getNumAvailableWithdrawalSlots();\r\n    }\r\n\r\n    function getProtocolFeeValues()\r\n        external\r\n        view\r\n        returns (\r\n            uint32 timestamp,\r\n            uint8  takerFeeBips,\r\n            uint8  makerFeeBips,\r\n            uint8  previousTakerFeeBips,\r\n            uint8  previousMakerFeeBips\r\n        )\r\n    {\r\n        timestamp = state.protocolFeeData.timestamp;\r\n        takerFeeBips = state.protocolFeeData.takerFeeBips;\r\n        makerFeeBips = state.protocolFeeData.makerFeeBips;\r\n        previousTakerFeeBips = state.protocolFeeData.previousTakerFeeBips;\r\n        previousMakerFeeBips = state.protocolFeeData.previousMakerFeeBips;\r\n    }\r\n\r\n    // == Internal Functions ==\r\n    function updateAccountAndDepositInternal(\r\n        uint    pubKeyX,\r\n        uint    pubKeyY,\r\n        address token,\r\n        uint96  amount,\r\n        bytes   memory permission\r\n        )\r\n        internal\r\n        returns (\r\n            uint24 accountID,\r\n            bool   isAccountNew,\r\n            bool   isAccountUpdated\r\n        )\r\n    {\r\n        (accountID, isAccountNew, isAccountUpdated) = state.createOrUpdateAccount(\r\n            pubKeyX,\r\n            pubKeyY,\r\n            permission\r\n        );\r\n        uint additionalFeeETH = 0;\r\n        if (isAccountNew) {\r\n            additionalFeeETH = state.accountCreationFeeETH;\r\n        } else if (isAccountUpdated) {\r\n            additionalFeeETH = state.accountUpdateFeeETH;\r\n        }\r\n        state.depositTo(msg.sender, token, amount, additionalFeeETH);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getLRCFeeForRegisteringOneMoreToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"getBlock\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"publicDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"blockState\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numDepositRequestsCommitted\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numWithdrawalRequestsCommitted\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"blockFeeWithdrawn\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"numWithdrawalsDistributed\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"registerToken\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"cloneAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"durationMinutes\",\"type\":\"uint256\"}],\"name\":\"getDowntimeCostLRC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"costLRC\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressWhitelist\",\"type\":\"address\"}],\"name\":\"setAddressWhitelist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"blockIndices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"proofs\",\"type\":\"uint256[]\"}],\"name\":\"verifyBlocks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumBlocksFinalized\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInMaintenance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"disableTokenDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"revertBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"genesisBlockHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawProtocolFees\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"tradeHistoryRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256[30]\",\"name\":\"accountPath\",\"type\":\"uint256[30]\"},{\"internalType\":\"uint256[12]\",\"name\":\"balancePath\",\"type\":\"uint256[12]\"}],\"name\":\"withdrawFromMerkleTree\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"offchainData\",\"type\":\"bytes\"}],\"name\":\"commitBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"tradeHistoryRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256[30]\",\"name\":\"accountPath\",\"type\":\"uint256[30]\"},{\"internalType\":\"uint256[12]\",\"name\":\"balancePath\",\"type\":\"uint256[12]\"}],\"name\":\"withdrawFromMerkleTreeFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProtocolFeeValues\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"takerFeeBips\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"makerFeeBips\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"previousTakerFeeBips\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"previousMakerFeeBips\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalTimeInMaintenanceSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenID\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getDepositRequest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"accumulatedHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedFee\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"permission\",\"type\":\"bytes\"}],\"name\":\"updateAccountAndDeposit\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isAccountNew\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAccountUpdated\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountCreationFeeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_accountUpdateFeeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_depositFeeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawalFeeETH\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"enableTokenDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumDepositRequestsProcessed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExchangeCreationTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRemainingDowntime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInWithdrawalMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"durationMinutes\",\"type\":\"uint256\"}],\"name\":\"startOrContinueMaintenanceMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnExchangeStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawProtocolFeeStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawTokenNotOwnedByUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"depositTo\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositIdx\",\"type\":\"uint256\"}],\"name\":\"withdrawFromDepositRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumAvailableDepositSlots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"name\":\"withdrawBlockFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isShutdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRequestStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numDepositRequestsProcessed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numAvailableDepositSlots\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numWithdrawalRequestsProcessed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numAvailableWithdrawalSlots\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loopringAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_onchainDataAvailability\",\"type\":\"bool\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getWithdrawRequest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"accumulatedHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedFee\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawExchangeStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopMaintenanceMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountCreationFeeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_accountUpdateFeeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_depositFeeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawalFeeETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumAvailableWithdrawalSlots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumWithdrawalRequestsProcessed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxNumWithdrawals\",\"type\":\"uint256\"}],\"name\":\"distributeWithdrawals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permission\",\"type\":\"bytes\"}],\"name\":\"createOrUpdateAccount\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isAccountNew\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAccountUpdated\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotIdx\",\"type\":\"uint256\"}],\"name\":\"withdrawFromApprovedWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExchangeStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"tradeHistoryRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256[30]\",\"name\":\"accountPath\",\"type\":\"uint256[30]\"},{\"internalType\":\"uint256[12]\",\"name\":\"balancePath\",\"type\":\"uint256[12]\"}],\"name\":\"isAccountBalanceCorrect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAccount\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"id\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"}],\"name\":\"AccountCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"id\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"}],\"name\":\"AccountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"TokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddressWhitelist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddressWhitelist\",\"type\":\"address\"}],\"name\":\"AddressWhitelistChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountCreationFeeETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountUpdateFeeETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositFeeETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawalFeeETH\",\"type\":\"uint256\"}],\"name\":\"FeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Shutdown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"publicDataHash\",\"type\":\"bytes32\"}],\"name\":\"BlockCommitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"BlockVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"BlockFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"Revert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"depositIdx\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"}],\"name\":\"DepositRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BlockFeeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"withdrawalIdx\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"WithdrawalRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"WithdrawalCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"WithdrawalFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"takerFeeBips\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"makerFeeBips\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"previousTakerFeeBips\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"previousMakerFeeBips\",\"type\":\"uint8\"}],\"name\":\"ProtocolFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ExchangeV3","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"ExchangeBalances:0fbdb0aceb333e99f68b700ed5ffe824bb9205ee;ExchangeAccounts:db329730b1bc025c2d1282ad3d5a42dad9341412;ExchangeAdmins:85c215db2ff44e415f722fd87f28a92bc3e661c9;ExchangeBlocks:b53c2585c1cd51f72336b78817bc6b25c7b61561;ExchangeTokens:df8fb256604474142d397356c86dba131f160170;ExchangeGenesis:32e0f87ffb0a61d76703950982dfe74f5a3e9d04;ExchangeDeposits:cdfd26d39a9a1a57ffca67a95b2b292d0d422e62;ExchangeWithdrawals:d7faf0e0d3aeefce849f1585180059ed74e1bcd4;Cloneable:d9de8997aaf50a2e0b2a86fbff9de3d7da3a3342","LicenseType":"Apache-2.0","SwarmSource":"bzzr://f5d0ce3573b14dd46c047f638958872cd34223a2a0f7e0d56e3b3d7959600c3c"}]}