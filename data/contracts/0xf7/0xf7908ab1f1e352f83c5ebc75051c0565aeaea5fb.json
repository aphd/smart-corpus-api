{"status":"1","message":"OK","result":[{"SourceCode":"//  simple planet invitation management contract\r\n//  https://azimuth.network\r\n\r\npragma solidity 0.4.24;\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n//  Imports\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n// OpenZeppelin's Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// Azimuth's SafeMath8.sol\r\n\r\n/**\r\n * @title SafeMath8\r\n * @dev Math operations for uint8 with safety checks that throw on error\r\n */\r\nlibrary SafeMath8 {\r\n  function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n    uint8 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint8 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n    uint8 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// Azimuth's SafeMath16.sol\r\n\r\n/**\r\n * @title SafeMath16\r\n * @dev Math operations for uint16 with safety checks that throw on error\r\n */\r\nlibrary SafeMath16 {\r\n  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    uint16 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint16 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    uint16 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// OpenZeppelin's SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// OpenZeppelin's ERC165.sol\r\n\r\n/**\r\n * @title ERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface ERC165 {\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n// OpenZeppelin's SupportsInterfaceWithLookup.sol\r\n\r\n/**\r\n * @title SupportsInterfaceWithLookup\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract SupportsInterfaceWithLookup is ERC165 {\r\n\r\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\r\n  /**\r\n   * 0x01ffc9a7 ===\r\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\r\n   */\r\n\r\n  /**\r\n   * @dev a mapping of interface id to whether or not it's supported\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev A contract implementing SupportsInterfaceWithLookup\r\n   * implement ERC165 itself\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    _registerInterface(InterfaceId_ERC165);\r\n  }\r\n\r\n  /**\r\n   * @dev implement supportsInterface(bytes4) using a lookup table\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceId];\r\n  }\r\n\r\n  /**\r\n   * @dev private method for registering an interface\r\n   */\r\n  function _registerInterface(bytes4 _interfaceId)\r\n    internal\r\n  {\r\n    require(_interfaceId != 0xffffffff);\r\n    supportedInterfaces[_interfaceId] = true;\r\n  }\r\n}\r\n\r\n// OpenZeppelin's ERC721Basic.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic is ERC165 {\r\n\r\n  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\r\n  /*\r\n   * 0x80ac58cd ===\r\n   *   bytes4(keccak256('balanceOf(address)')) ^\r\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n   *   bytes4(keccak256('approve(address,uint256)')) ^\r\n   *   bytes4(keccak256('getApproved(uint256)')) ^\r\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n  /*\r\n   * 0x4f558e79 ===\r\n   *   bytes4(keccak256('exists(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n  /**\r\n   * 0x780e9d63 ===\r\n   *   bytes4(keccak256('totalSupply()')) ^\r\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n  /**\r\n   * 0x5b5e139f ===\r\n   *   bytes4(keccak256('name()')) ^\r\n   *   bytes4(keccak256('symbol()')) ^\r\n   *   bytes4(keccak256('tokenURI(uint256)'))\r\n   */\r\n\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId)\r\n    public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n// OpenZeppelin's ERC721.sol\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 _tokenId);\r\n\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() external view returns (string _name);\r\n  function symbol() external view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n// OpenZeppelin's ERC721Receiver.sol\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   * after a `safetransfer`. This function MAY throw to revert and reject the\r\n   * transfer. Return of other than the magic value MUST result in the\r\n   * transaction being reverted.\r\n   * Note: the contract address is always the message sender.\r\n   * @param _operator The address which called `safeTransferFrom` function\r\n   * @param _from The address which previously owned the token\r\n   * @param _tokenId The NFT identifier which is being transferred\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    returns(bytes4);\r\n}\r\n\r\n// OpenZeppelin's AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param _addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address _addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(_addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// Azimuth's Azimuth.sol\r\n\r\n//  Azimuth: point state data contract\r\n//\r\n//    This contract is used for storing all data related to Azimuth points\r\n//    and their ownership. Consider this contract the Azimuth ledger.\r\n//\r\n//    It also contains permissions data, which ties in to ERC721\r\n//    functionality. Operators of an address are allowed to transfer\r\n//    ownership of all points owned by their associated address\r\n//    (ERC721's approveAll()). A transfer proxy is allowed to transfer\r\n//    ownership of a single point (ERC721's approve()).\r\n//    Separate from ERC721 are managers, assigned per point. They are\r\n//    allowed to perform \"low-impact\" operations on the owner's points,\r\n//    like configuring public keys and making escape requests.\r\n//\r\n//    Since data stores are difficult to upgrade, this contract contains\r\n//    as little actual business logic as possible. Instead, the data stored\r\n//    herein can only be modified by this contract's owner, which can be\r\n//    changed and is thus upgradable/replaceable.\r\n//\r\n//    This contract will be owned by the Ecliptic contract.\r\n//\r\ncontract Azimuth is Ownable\r\n{\r\n//\r\n//  Events\r\n//\r\n\r\n  //  OwnerChanged: :point is now owned by :owner\r\n  //\r\n  event OwnerChanged(uint32 indexed point, address indexed owner);\r\n\r\n  //  Activated: :point is now active\r\n  //\r\n  event Activated(uint32 indexed point);\r\n\r\n  //  Spawned: :prefix has spawned :child\r\n  //\r\n  event Spawned(uint32 indexed prefix, uint32 indexed child);\r\n\r\n  //  EscapeRequested: :point has requested a new :sponsor\r\n  //\r\n  event EscapeRequested(uint32 indexed point, uint32 indexed sponsor);\r\n\r\n  //  EscapeCanceled: :point's :sponsor request was canceled or rejected\r\n  //\r\n  event EscapeCanceled(uint32 indexed point, uint32 indexed sponsor);\r\n\r\n  //  EscapeAccepted: :point confirmed with a new :sponsor\r\n  //\r\n  event EscapeAccepted(uint32 indexed point, uint32 indexed sponsor);\r\n\r\n  //  LostSponsor: :point's :sponsor is now refusing it service\r\n  //\r\n  event LostSponsor(uint32 indexed point, uint32 indexed sponsor);\r\n\r\n  //  ChangedKeys: :point has new network public keys\r\n  //\r\n  event ChangedKeys( uint32 indexed point,\r\n                     bytes32 encryptionKey,\r\n                     bytes32 authenticationKey,\r\n                     uint32 cryptoSuiteVersion,\r\n                     uint32 keyRevisionNumber );\r\n\r\n  //  BrokeContinuity: :point has a new continuity number, :number\r\n  //\r\n  event BrokeContinuity(uint32 indexed point, uint32 number);\r\n\r\n  //  ChangedSpawnProxy: :spawnProxy can now spawn using :point\r\n  //\r\n  event ChangedSpawnProxy(uint32 indexed point, address indexed spawnProxy);\r\n\r\n  //  ChangedTransferProxy: :transferProxy can now transfer ownership of :point\r\n  //\r\n  event ChangedTransferProxy( uint32 indexed point,\r\n                              address indexed transferProxy );\r\n\r\n  //  ChangedManagementProxy: :managementProxy can now manage :point\r\n  //\r\n  event ChangedManagementProxy( uint32 indexed point,\r\n                                address indexed managementProxy );\r\n\r\n  //  ChangedVotingProxy: :votingProxy can now vote using :point\r\n  //\r\n  event ChangedVotingProxy(uint32 indexed point, address indexed votingProxy);\r\n\r\n  //  ChangedDns: dnsDomains have been updated\r\n  //\r\n  event ChangedDns(string primary, string secondary, string tertiary);\r\n\r\n//\r\n//  Structures\r\n//\r\n\r\n  //  Size: kinds of points registered on-chain\r\n  //\r\n  //    NOTE: the order matters, because of Solidity enum numbering\r\n  //\r\n  enum Size\r\n  {\r\n    Galaxy, // = 0\r\n    Star,   // = 1\r\n    Planet  // = 2\r\n  }\r\n\r\n  //  Point: state of a point\r\n  //\r\n  //    While the ordering of the struct members is semantically chaotic,\r\n  //    they are ordered to tightly pack them into Ethereum's 32-byte storage\r\n  //    slots, which reduces gas costs for some function calls.\r\n  //    The comment ticks indicate assumed slot boundaries.\r\n  //\r\n  struct Point\r\n  {\r\n    //  encryptionKey: (curve25519) encryption public key, or 0 for none\r\n    //\r\n    bytes32 encryptionKey;\r\n  //\r\n    //  authenticationKey: (ed25519) authentication public key, or 0 for none\r\n    //\r\n    bytes32 authenticationKey;\r\n  //\r\n    //  spawned: for stars and galaxies, all :active children\r\n    //\r\n    uint32[] spawned;\r\n  //\r\n    //  hasSponsor: true if the sponsor still supports the point\r\n    //\r\n    bool hasSponsor;\r\n\r\n    //  active: whether point can be linked\r\n    //\r\n    //    false: point belongs to prefix, cannot be configured or linked\r\n    //    true: point no longer belongs to prefix, can be configured and linked\r\n    //\r\n    bool active;\r\n\r\n    //  escapeRequested: true if the point has requested to change sponsors\r\n    //\r\n    bool escapeRequested;\r\n\r\n    //  sponsor: the point that supports this one on the network, or,\r\n    //           if :hasSponsor is false, the last point that supported it.\r\n    //           (by default, the point's half-width prefix)\r\n    //\r\n    uint32 sponsor;\r\n\r\n    //  escapeRequestedTo: if :escapeRequested is true, new sponsor requested\r\n    //\r\n    uint32 escapeRequestedTo;\r\n\r\n    //  cryptoSuiteVersion: version of the crypto suite used for the pubkeys\r\n    //\r\n    uint32 cryptoSuiteVersion;\r\n\r\n    //  keyRevisionNumber: incremented every time the public keys change\r\n    //\r\n    uint32 keyRevisionNumber;\r\n\r\n    //  continuityNumber: incremented to indicate network-side state loss\r\n    //\r\n    uint32 continuityNumber;\r\n  }\r\n\r\n  //  Deed: permissions for a point\r\n  //\r\n  struct Deed\r\n  {\r\n    //  owner: address that owns this point\r\n    //\r\n    address owner;\r\n\r\n    //  managementProxy: 0, or another address with the right to perform\r\n    //                   low-impact, managerial operations on this point\r\n    //\r\n    address managementProxy;\r\n\r\n    //  spawnProxy: 0, or another address with the right to spawn children\r\n    //              of this point\r\n    //\r\n    address spawnProxy;\r\n\r\n    //  votingProxy: 0, or another address with the right to vote as this point\r\n    //\r\n    address votingProxy;\r\n\r\n    //  transferProxy: 0, or another address with the right to transfer\r\n    //                 ownership of this point\r\n    //\r\n    address transferProxy;\r\n  }\r\n\r\n//\r\n//  General state\r\n//\r\n\r\n  //  points: per point, general network-relevant point state\r\n  //\r\n  mapping(uint32 => Point) public points;\r\n\r\n  //  rights: per point, on-chain ownership and permissions\r\n  //\r\n  mapping(uint32 => Deed) public rights;\r\n\r\n  //  operators: per owner, per address, has the right to transfer ownership\r\n  //             of all the owner's points (ERC721)\r\n  //\r\n  mapping(address => mapping(address => bool)) public operators;\r\n\r\n  //  dnsDomains: base domains for contacting galaxies\r\n  //\r\n  //    dnsDomains[0] is primary, the others are used as fallbacks\r\n  //\r\n  string[3] public dnsDomains;\r\n\r\n//\r\n//  Lookups\r\n//\r\n\r\n  //  sponsoring: per point, the points they are sponsoring\r\n  //\r\n  mapping(uint32 => uint32[]) public sponsoring;\r\n\r\n  //  sponsoringIndexes: per point, per point, (index + 1) in\r\n  //                     the sponsoring array\r\n  //\r\n  mapping(uint32 => mapping(uint32 => uint256)) public sponsoringIndexes;\r\n\r\n  //  escapeRequests: per point, the points they have open escape requests from\r\n  //\r\n  mapping(uint32 => uint32[]) public escapeRequests;\r\n\r\n  //  escapeRequestsIndexes: per point, per point, (index + 1) in\r\n  //                         the escapeRequests array\r\n  //\r\n  mapping(uint32 => mapping(uint32 => uint256)) public escapeRequestsIndexes;\r\n\r\n  //  pointsOwnedBy: per address, the points they own\r\n  //\r\n  mapping(address => uint32[]) public pointsOwnedBy;\r\n\r\n  //  pointOwnerIndexes: per owner, per point, (index + 1) in\r\n  //                     the pointsOwnedBy array\r\n  //\r\n  //    We delete owners by moving the last entry in the array to the\r\n  //    newly emptied slot, which is (n - 1) where n is the value of\r\n  //    pointOwnerIndexes[owner][point].\r\n  //\r\n  mapping(address => mapping(uint32 => uint256)) public pointOwnerIndexes;\r\n\r\n  //  managerFor: per address, the points they are the management proxy for\r\n  //\r\n  mapping(address => uint32[]) public managerFor;\r\n\r\n  //  managerForIndexes: per address, per point, (index + 1) in\r\n  //                     the managerFor array\r\n  //\r\n  mapping(address => mapping(uint32 => uint256)) public managerForIndexes;\r\n\r\n  //  spawningFor: per address, the points they can spawn with\r\n  //\r\n  mapping(address => uint32[]) public spawningFor;\r\n\r\n  //  spawningForIndexes: per address, per point, (index + 1) in\r\n  //                      the spawningFor array\r\n  //\r\n  mapping(address => mapping(uint32 => uint256)) public spawningForIndexes;\r\n\r\n  //  votingFor: per address, the points they can vote with\r\n  //\r\n  mapping(address => uint32[]) public votingFor;\r\n\r\n  //  votingForIndexes: per address, per point, (index + 1) in\r\n  //                    the votingFor array\r\n  //\r\n  mapping(address => mapping(uint32 => uint256)) public votingForIndexes;\r\n\r\n  //  transferringFor: per address, the points they can transfer\r\n  //\r\n  mapping(address => uint32[]) public transferringFor;\r\n\r\n  //  transferringForIndexes: per address, per point, (index + 1) in\r\n  //                          the transferringFor array\r\n  //\r\n  mapping(address => mapping(uint32 => uint256)) public transferringForIndexes;\r\n\r\n//\r\n//  Logic\r\n//\r\n\r\n  //  constructor(): configure default dns domains\r\n  //\r\n  constructor()\r\n    public\r\n  {\r\n    setDnsDomains(\"example.com\", \"example.com\", \"example.com\");\r\n  }\r\n\r\n  //  setDnsDomains(): set the base domains used for contacting galaxies\r\n  //\r\n  //    Note: since a string is really just a byte[], and Solidity can't\r\n  //    work with two-dimensional arrays yet, we pass in the three\r\n  //    domains as individual strings.\r\n  //\r\n  function setDnsDomains(string _primary, string _secondary, string _tertiary)\r\n    onlyOwner\r\n    public\r\n  {\r\n    dnsDomains[0] = _primary;\r\n    dnsDomains[1] = _secondary;\r\n    dnsDomains[2] = _tertiary;\r\n    emit ChangedDns(_primary, _secondary, _tertiary);\r\n  }\r\n\r\n  //\r\n  //  Point reading\r\n  //\r\n\r\n    //  isActive(): return true if _point is active\r\n    //\r\n    function isActive(uint32 _point)\r\n      view\r\n      external\r\n      returns (bool equals)\r\n    {\r\n      return points[_point].active;\r\n    }\r\n\r\n    //  getKeys(): returns the public keys and their details, as currently\r\n    //             registered for _point\r\n    //\r\n    function getKeys(uint32 _point)\r\n      view\r\n      external\r\n      returns (bytes32 crypt, bytes32 auth, uint32 suite, uint32 revision)\r\n    {\r\n      Point storage point = points[_point];\r\n      return (point.encryptionKey,\r\n              point.authenticationKey,\r\n              point.cryptoSuiteVersion,\r\n              point.keyRevisionNumber);\r\n    }\r\n\r\n    //  getKeyRevisionNumber(): gets the revision number of _point's current\r\n    //                          public keys\r\n    //\r\n    function getKeyRevisionNumber(uint32 _point)\r\n      view\r\n      external\r\n      returns (uint32 revision)\r\n    {\r\n      return points[_point].keyRevisionNumber;\r\n    }\r\n\r\n    //  hasBeenLinked(): returns true if the point has ever been assigned keys\r\n    //\r\n    function hasBeenLinked(uint32 _point)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return ( points[_point].keyRevisionNumber > 0 );\r\n    }\r\n\r\n    //  isLive(): returns true if _point currently has keys properly configured\r\n    //\r\n    function isLive(uint32 _point)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      Point storage point = points[_point];\r\n      return ( point.encryptionKey != 0 &&\r\n               point.authenticationKey != 0 &&\r\n               point.cryptoSuiteVersion != 0 );\r\n    }\r\n\r\n    //  getContinuityNumber(): returns _point's current continuity number\r\n    //\r\n    function getContinuityNumber(uint32 _point)\r\n      view\r\n      external\r\n      returns (uint32 continuityNumber)\r\n    {\r\n      return points[_point].continuityNumber;\r\n    }\r\n\r\n    //  getSpawnCount(): return the number of children spawned by _point\r\n    //\r\n    function getSpawnCount(uint32 _point)\r\n      view\r\n      external\r\n      returns (uint32 spawnCount)\r\n    {\r\n      uint256 len = points[_point].spawned.length;\r\n      assert(len < 2**32);\r\n      return uint32(len);\r\n    }\r\n\r\n    //  getSpawned(): return array of points created under _point\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getSpawned(uint32 _point)\r\n      view\r\n      external\r\n      returns (uint32[] spawned)\r\n    {\r\n      return points[_point].spawned;\r\n    }\r\n\r\n    //  hasSponsor(): returns true if _point's sponsor is providing it service\r\n    //\r\n    function hasSponsor(uint32 _point)\r\n      view\r\n      external\r\n      returns (bool has)\r\n    {\r\n      return points[_point].hasSponsor;\r\n    }\r\n\r\n    //  getSponsor(): returns _point's current (or most recent) sponsor\r\n    //\r\n    function getSponsor(uint32 _point)\r\n      view\r\n      external\r\n      returns (uint32 sponsor)\r\n    {\r\n      return points[_point].sponsor;\r\n    }\r\n\r\n    //  isSponsor(): returns true if _sponsor is currently providing service\r\n    //               to _point\r\n    //\r\n    function isSponsor(uint32 _point, uint32 _sponsor)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      Point storage point = points[_point];\r\n      return ( point.hasSponsor &&\r\n               (point.sponsor == _sponsor) );\r\n    }\r\n\r\n    //  getSponsoringCount(): returns the number of points _sponsor is\r\n    //                        providing service to\r\n    //\r\n    function getSponsoringCount(uint32 _sponsor)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return sponsoring[_sponsor].length;\r\n    }\r\n\r\n    //  getSponsoring(): returns a list of points _sponsor is providing\r\n    //                   service to\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getSponsoring(uint32 _sponsor)\r\n      view\r\n      external\r\n      returns (uint32[] sponsees)\r\n    {\r\n      return sponsoring[_sponsor];\r\n    }\r\n\r\n    //  escaping\r\n\r\n    //  isEscaping(): returns true if _point has an outstanding escape request\r\n    //\r\n    function isEscaping(uint32 _point)\r\n      view\r\n      external\r\n      returns (bool escaping)\r\n    {\r\n      return points[_point].escapeRequested;\r\n    }\r\n\r\n    //  getEscapeRequest(): returns _point's current escape request\r\n    //\r\n    //    the returned escape request is only valid as long as isEscaping()\r\n    //    returns true\r\n    //\r\n    function getEscapeRequest(uint32 _point)\r\n      view\r\n      external\r\n      returns (uint32 escape)\r\n    {\r\n      return points[_point].escapeRequestedTo;\r\n    }\r\n\r\n    //  isRequestingEscapeTo(): returns true if _point has an outstanding\r\n    //                          escape request targetting _sponsor\r\n    //\r\n    function isRequestingEscapeTo(uint32 _point, uint32 _sponsor)\r\n      view\r\n      public\r\n      returns (bool equals)\r\n    {\r\n      Point storage point = points[_point];\r\n      return (point.escapeRequested && (point.escapeRequestedTo == _sponsor));\r\n    }\r\n\r\n    //  getEscapeRequestsCount(): returns the number of points _sponsor\r\n    //                            is providing service to\r\n    //\r\n    function getEscapeRequestsCount(uint32 _sponsor)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return escapeRequests[_sponsor].length;\r\n    }\r\n\r\n    //  getEscapeRequests(): get the points _sponsor has received escape\r\n    //                       requests from\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getEscapeRequests(uint32 _sponsor)\r\n      view\r\n      external\r\n      returns (uint32[] requests)\r\n    {\r\n      return escapeRequests[_sponsor];\r\n    }\r\n\r\n  //\r\n  //  Point writing\r\n  //\r\n\r\n    //  activatePoint(): activate a point, register it as spawned by its prefix\r\n    //\r\n    function activatePoint(uint32 _point)\r\n      onlyOwner\r\n      external\r\n    {\r\n      //  make a point active, setting its sponsor to its prefix\r\n      //\r\n      Point storage point = points[_point];\r\n      require(!point.active);\r\n      point.active = true;\r\n      registerSponsor(_point, true, getPrefix(_point));\r\n      emit Activated(_point);\r\n    }\r\n\r\n    //  setKeys(): set network public keys of _point to _encryptionKey and\r\n    //            _authenticationKey, with the specified _cryptoSuiteVersion\r\n    //\r\n    function setKeys(uint32 _point,\r\n                     bytes32 _encryptionKey,\r\n                     bytes32 _authenticationKey,\r\n                     uint32 _cryptoSuiteVersion)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Point storage point = points[_point];\r\n      if ( point.encryptionKey == _encryptionKey &&\r\n           point.authenticationKey == _authenticationKey &&\r\n           point.cryptoSuiteVersion == _cryptoSuiteVersion )\r\n      {\r\n        return;\r\n      }\r\n\r\n      point.encryptionKey = _encryptionKey;\r\n      point.authenticationKey = _authenticationKey;\r\n      point.cryptoSuiteVersion = _cryptoSuiteVersion;\r\n      point.keyRevisionNumber++;\r\n\r\n      emit ChangedKeys(_point,\r\n                       _encryptionKey,\r\n                       _authenticationKey,\r\n                       _cryptoSuiteVersion,\r\n                       point.keyRevisionNumber);\r\n    }\r\n\r\n    //  incrementContinuityNumber(): break continuity for _point\r\n    //\r\n    function incrementContinuityNumber(uint32 _point)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Point storage point = points[_point];\r\n      point.continuityNumber++;\r\n      emit BrokeContinuity(_point, point.continuityNumber);\r\n    }\r\n\r\n    //  registerSpawn(): add a point to its prefix's list of spawned points\r\n    //\r\n    function registerSpawned(uint32 _point)\r\n      onlyOwner\r\n      external\r\n    {\r\n      //  if a point is its own prefix (a galaxy) then don't register it\r\n      //\r\n      uint32 prefix = getPrefix(_point);\r\n      if (prefix == _point)\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  register a new spawned point for the prefix\r\n      //\r\n      points[prefix].spawned.push(_point);\r\n      emit Spawned(prefix, _point);\r\n    }\r\n\r\n    //  loseSponsor(): indicates that _point's sponsor is no longer providing\r\n    //                 it service\r\n    //\r\n    function loseSponsor(uint32 _point)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Point storage point = points[_point];\r\n      if (!point.hasSponsor)\r\n      {\r\n        return;\r\n      }\r\n      registerSponsor(_point, false, point.sponsor);\r\n      emit LostSponsor(_point, point.sponsor);\r\n    }\r\n\r\n    //  setEscapeRequest(): for _point, start an escape request to _sponsor\r\n    //\r\n    function setEscapeRequest(uint32 _point, uint32 _sponsor)\r\n      onlyOwner\r\n      external\r\n    {\r\n      if (isRequestingEscapeTo(_point, _sponsor))\r\n      {\r\n        return;\r\n      }\r\n      registerEscapeRequest(_point, true, _sponsor);\r\n      emit EscapeRequested(_point, _sponsor);\r\n    }\r\n\r\n    //  cancelEscape(): for _point, stop the current escape request, if any\r\n    //\r\n    function cancelEscape(uint32 _point)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Point storage point = points[_point];\r\n      if (!point.escapeRequested)\r\n      {\r\n        return;\r\n      }\r\n      uint32 request = point.escapeRequestedTo;\r\n      registerEscapeRequest(_point, false, 0);\r\n      emit EscapeCanceled(_point, request);\r\n    }\r\n\r\n    //  doEscape(): perform the requested escape\r\n    //\r\n    function doEscape(uint32 _point)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Point storage point = points[_point];\r\n      require(point.escapeRequested);\r\n      registerSponsor(_point, true, point.escapeRequestedTo);\r\n      registerEscapeRequest(_point, false, 0);\r\n      emit EscapeAccepted(_point, point.sponsor);\r\n    }\r\n\r\n  //\r\n  //  Point utils\r\n  //\r\n\r\n    //  getPrefix(): compute prefix (\"parent\") of _point\r\n    //\r\n    function getPrefix(uint32 _point)\r\n      pure\r\n      public\r\n      returns (uint16 prefix)\r\n    {\r\n      if (_point < 0x10000)\r\n      {\r\n        return uint16(_point % 0x100);\r\n      }\r\n      return uint16(_point % 0x10000);\r\n    }\r\n\r\n    //  getPointSize(): return the size of _point\r\n    //\r\n    function getPointSize(uint32 _point)\r\n      external\r\n      pure\r\n      returns (Size _size)\r\n    {\r\n      if (_point < 0x100) return Size.Galaxy;\r\n      if (_point < 0x10000) return Size.Star;\r\n      return Size.Planet;\r\n    }\r\n\r\n    //  internal use\r\n\r\n    //  registerSponsor(): set the sponsorship state of _point and update the\r\n    //                     reverse lookup for sponsors\r\n    //\r\n    function registerSponsor(uint32 _point, bool _hasSponsor, uint32 _sponsor)\r\n      internal\r\n    {\r\n      Point storage point = points[_point];\r\n      bool had = point.hasSponsor;\r\n      uint32 prev = point.sponsor;\r\n\r\n      //  if we didn't have a sponsor, and won't get one,\r\n      //  or if we get the sponsor we already have,\r\n      //  nothing will change, so jump out early.\r\n      //\r\n      if ( (!had && !_hasSponsor) ||\r\n           (had && _hasSponsor && prev == _sponsor) )\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different sponsor, do some gymnastics\r\n      //  to keep the reverse lookup gapless.  delete the point from the old\r\n      //  sponsor's list, then fill that gap with the list tail.\r\n      //\r\n      if (had)\r\n      {\r\n        //  i: current index in previous sponsor's list of sponsored points\r\n        //\r\n        uint256 i = sponsoringIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :sponsoringIndexes reference\r\n        //\r\n        uint32[] storage prevSponsoring = sponsoring[prev];\r\n        uint256 last = prevSponsoring.length - 1;\r\n        uint32 moved = prevSponsoring[last];\r\n        prevSponsoring[i] = moved;\r\n        sponsoringIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(prevSponsoring[last]);\r\n        prevSponsoring.length = last;\r\n        sponsoringIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      if (_hasSponsor)\r\n      {\r\n        uint32[] storage newSponsoring = sponsoring[_sponsor];\r\n        newSponsoring.push(_point);\r\n        sponsoringIndexes[_sponsor][_point] = newSponsoring.length;\r\n      }\r\n\r\n      point.sponsor = _sponsor;\r\n      point.hasSponsor = _hasSponsor;\r\n    }\r\n\r\n    //  registerEscapeRequest(): set the escape state of _point and update the\r\n    //                           reverse lookup for sponsors\r\n    //\r\n    function registerEscapeRequest( uint32 _point,\r\n                                    bool _isEscaping, uint32 _sponsor )\r\n      internal\r\n    {\r\n      Point storage point = points[_point];\r\n      bool was = point.escapeRequested;\r\n      uint32 prev = point.escapeRequestedTo;\r\n\r\n      //  if we weren't escaping, and won't be,\r\n      //  or if we were escaping, and the new target is the same,\r\n      //  nothing will change, so jump out early.\r\n      //\r\n      if ( (!was && !_isEscaping) ||\r\n           (was && _isEscaping && prev == _sponsor) )\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different request, do some gymnastics\r\n      //  to keep the reverse lookup gapless.  delete the point from the old\r\n      //  sponsor's list, then fill that gap with the list tail.\r\n      //\r\n      if (was)\r\n      {\r\n        //  i: current index in previous sponsor's list of sponsored points\r\n        //\r\n        uint256 i = escapeRequestsIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :escapeRequestsIndexes reference\r\n        //\r\n        uint32[] storage prevRequests = escapeRequests[prev];\r\n        uint256 last = prevRequests.length - 1;\r\n        uint32 moved = prevRequests[last];\r\n        prevRequests[i] = moved;\r\n        escapeRequestsIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(prevRequests[last]);\r\n        prevRequests.length = last;\r\n        escapeRequestsIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      if (_isEscaping)\r\n      {\r\n        uint32[] storage newRequests = escapeRequests[_sponsor];\r\n        newRequests.push(_point);\r\n        escapeRequestsIndexes[_sponsor][_point] = newRequests.length;\r\n      }\r\n\r\n      point.escapeRequestedTo = _sponsor;\r\n      point.escapeRequested = _isEscaping;\r\n    }\r\n\r\n  //\r\n  //  Deed reading\r\n  //\r\n\r\n    //  owner\r\n\r\n    //  getOwner(): return owner of _point\r\n    //\r\n    function getOwner(uint32 _point)\r\n      view\r\n      external\r\n      returns (address owner)\r\n    {\r\n      return rights[_point].owner;\r\n    }\r\n\r\n    //  isOwner(): true if _point is owned by _address\r\n    //\r\n    function isOwner(uint32 _point, address _address)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return (rights[_point].owner == _address);\r\n    }\r\n\r\n    //  getOwnedPointCount(): return length of array of points that _whose owns\r\n    //\r\n    function getOwnedPointCount(address _whose)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return pointsOwnedBy[_whose].length;\r\n    }\r\n\r\n    //  getOwnedPoints(): return array of points that _whose owns\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getOwnedPoints(address _whose)\r\n      view\r\n      external\r\n      returns (uint32[] ownedPoints)\r\n    {\r\n      return pointsOwnedBy[_whose];\r\n    }\r\n\r\n    //  getOwnedPointAtIndex(): get point at _index from array of points that\r\n    //                         _whose owns\r\n    //\r\n    function getOwnedPointAtIndex(address _whose, uint256 _index)\r\n      view\r\n      external\r\n      returns (uint32 point)\r\n    {\r\n      uint32[] storage owned = pointsOwnedBy[_whose];\r\n      require(_index < owned.length);\r\n      return owned[_index];\r\n    }\r\n\r\n    //  management proxy\r\n\r\n    //  getManagementProxy(): returns _point's current management proxy\r\n    //\r\n    function getManagementProxy(uint32 _point)\r\n      view\r\n      external\r\n      returns (address manager)\r\n    {\r\n      return rights[_point].managementProxy;\r\n    }\r\n\r\n    //  isManagementProxy(): returns true if _proxy is _point's management proxy\r\n    //\r\n    function isManagementProxy(uint32 _point, address _proxy)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return (rights[_point].managementProxy == _proxy);\r\n    }\r\n\r\n    //  canManage(): true if _who is the owner or manager of _point\r\n    //\r\n    function canManage(uint32 _point, address _who)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      return ( (0x0 != _who) &&\r\n               ( (_who == deed.owner) ||\r\n                 (_who == deed.managementProxy) ) );\r\n    }\r\n\r\n    //  getManagerForCount(): returns the amount of points _proxy can manage\r\n    //\r\n    function getManagerForCount(address _proxy)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return managerFor[_proxy].length;\r\n    }\r\n\r\n    //  getManagerFor(): returns the points _proxy can manage\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getManagerFor(address _proxy)\r\n      view\r\n      external\r\n      returns (uint32[] mfor)\r\n    {\r\n      return managerFor[_proxy];\r\n    }\r\n\r\n    //  spawn proxy\r\n\r\n    //  getSpawnProxy(): returns _point's current spawn proxy\r\n    //\r\n    function getSpawnProxy(uint32 _point)\r\n      view\r\n      external\r\n      returns (address spawnProxy)\r\n    {\r\n      return rights[_point].spawnProxy;\r\n    }\r\n\r\n    //  isSpawnProxy(): returns true if _proxy is _point's spawn proxy\r\n    //\r\n    function isSpawnProxy(uint32 _point, address _proxy)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return (rights[_point].spawnProxy == _proxy);\r\n    }\r\n\r\n    //  canSpawnAs(): true if _who is the owner or spawn proxy of _point\r\n    //\r\n    function canSpawnAs(uint32 _point, address _who)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      return ( (0x0 != _who) &&\r\n               ( (_who == deed.owner) ||\r\n                 (_who == deed.spawnProxy) ) );\r\n    }\r\n\r\n    //  getSpawningForCount(): returns the amount of points _proxy\r\n    //                         can spawn with\r\n    //\r\n    function getSpawningForCount(address _proxy)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return spawningFor[_proxy].length;\r\n    }\r\n\r\n    //  getSpawningFor(): get the points _proxy can spawn with\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getSpawningFor(address _proxy)\r\n      view\r\n      external\r\n      returns (uint32[] sfor)\r\n    {\r\n      return spawningFor[_proxy];\r\n    }\r\n\r\n    //  voting proxy\r\n\r\n    //  getVotingProxy(): returns _point's current voting proxy\r\n    //\r\n    function getVotingProxy(uint32 _point)\r\n      view\r\n      external\r\n      returns (address voter)\r\n    {\r\n      return rights[_point].votingProxy;\r\n    }\r\n\r\n    //  isVotingProxy(): returns true if _proxy is _point's voting proxy\r\n    //\r\n    function isVotingProxy(uint32 _point, address _proxy)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return (rights[_point].votingProxy == _proxy);\r\n    }\r\n\r\n    //  canVoteAs(): true if _who is the owner of _point,\r\n    //               or the voting proxy of _point's owner\r\n    //\r\n    function canVoteAs(uint32 _point, address _who)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      return ( (0x0 != _who) &&\r\n               ( (_who == deed.owner) ||\r\n                 (_who == deed.votingProxy) ) );\r\n    }\r\n\r\n    //  getVotingForCount(): returns the amount of points _proxy can vote as\r\n    //\r\n    function getVotingForCount(address _proxy)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return votingFor[_proxy].length;\r\n    }\r\n\r\n    //  getVotingFor(): returns the points _proxy can vote as\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getVotingFor(address _proxy)\r\n      view\r\n      external\r\n      returns (uint32[] vfor)\r\n    {\r\n      return votingFor[_proxy];\r\n    }\r\n\r\n    //  transfer proxy\r\n\r\n    //  getTransferProxy(): returns _point's current transfer proxy\r\n    //\r\n    function getTransferProxy(uint32 _point)\r\n      view\r\n      external\r\n      returns (address transferProxy)\r\n    {\r\n      return rights[_point].transferProxy;\r\n    }\r\n\r\n    //  isTransferProxy(): returns true if _proxy is _point's transfer proxy\r\n    //\r\n    function isTransferProxy(uint32 _point, address _proxy)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return (rights[_point].transferProxy == _proxy);\r\n    }\r\n\r\n    //  canTransfer(): true if _who is the owner or transfer proxy of _point,\r\n    //                 or is an operator for _point's current owner\r\n    //\r\n    function canTransfer(uint32 _point, address _who)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      return ( (0x0 != _who) &&\r\n               ( (_who == deed.owner) ||\r\n                 (_who == deed.transferProxy) ||\r\n                 operators[deed.owner][_who] ) );\r\n    }\r\n\r\n    //  getTransferringForCount(): returns the amount of points _proxy\r\n    //                             can transfer\r\n    //\r\n    function getTransferringForCount(address _proxy)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return transferringFor[_proxy].length;\r\n    }\r\n\r\n    //  getTransferringFor(): get the points _proxy can transfer\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getTransferringFor(address _proxy)\r\n      view\r\n      external\r\n      returns (uint32[] tfor)\r\n    {\r\n      return transferringFor[_proxy];\r\n    }\r\n\r\n    //  isOperator(): returns true if _operator is allowed to transfer\r\n    //                ownership of _owner's points\r\n    //\r\n    function isOperator(address _owner, address _operator)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return operators[_owner][_operator];\r\n    }\r\n\r\n  //\r\n  //  Deed writing\r\n  //\r\n\r\n    //  setOwner(): set owner of _point to _owner\r\n    //\r\n    //    Note: setOwner() only implements the minimal data storage\r\n    //    logic for a transfer; the full transfer is implemented in\r\n    //    Ecliptic.\r\n    //\r\n    //    Note: _owner must not be the zero address.\r\n    //\r\n    function setOwner(uint32 _point, address _owner)\r\n      onlyOwner\r\n      external\r\n    {\r\n      //  prevent burning of points by making zero the owner\r\n      //\r\n      require(0x0 != _owner);\r\n\r\n      //  prev: previous owner, if any\r\n      //\r\n      address prev = rights[_point].owner;\r\n\r\n      if (prev == _owner)\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different owner, do some gymnastics to\r\n      //  keep the list of owned points gapless.  delete this point from the\r\n      //  list, then fill that gap with the list tail.\r\n      //\r\n      if (0x0 != prev)\r\n      {\r\n        //  i: current index in previous owner's list of owned points\r\n        //\r\n        uint256 i = pointOwnerIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :pointOwnerIndexes reference\r\n        //\r\n        uint32[] storage owner = pointsOwnedBy[prev];\r\n        uint256 last = owner.length - 1;\r\n        uint32 moved = owner[last];\r\n        owner[i] = moved;\r\n        pointOwnerIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(owner[last]);\r\n        owner.length = last;\r\n        pointOwnerIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      //  update the owner list and the owner's index list\r\n      //\r\n      rights[_point].owner = _owner;\r\n      pointsOwnedBy[_owner].push(_point);\r\n      pointOwnerIndexes[_owner][_point] = pointsOwnedBy[_owner].length;\r\n      emit OwnerChanged(_point, _owner);\r\n    }\r\n\r\n    //  setManagementProxy(): makes _proxy _point's management proxy\r\n    //\r\n    function setManagementProxy(uint32 _point, address _proxy)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      address prev = deed.managementProxy;\r\n      if (prev == _proxy)\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different manager, do some gymnastics\r\n      //  to keep the reverse lookup gapless.  delete the point from the\r\n      //  old manager's list, then fill that gap with the list tail.\r\n      //\r\n      if (0x0 != prev)\r\n      {\r\n        //  i: current index in previous manager's list of managed points\r\n        //\r\n        uint256 i = managerForIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :managerForIndexes reference\r\n        //\r\n        uint32[] storage prevMfor = managerFor[prev];\r\n        uint256 last = prevMfor.length - 1;\r\n        uint32 moved = prevMfor[last];\r\n        prevMfor[i] = moved;\r\n        managerForIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(prevMfor[last]);\r\n        prevMfor.length = last;\r\n        managerForIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      if (0x0 != _proxy)\r\n      {\r\n        uint32[] storage mfor = managerFor[_proxy];\r\n        mfor.push(_point);\r\n        managerForIndexes[_proxy][_point] = mfor.length;\r\n      }\r\n\r\n      deed.managementProxy = _proxy;\r\n      emit ChangedManagementProxy(_point, _proxy);\r\n    }\r\n\r\n    //  setSpawnProxy(): makes _proxy _point's spawn proxy\r\n    //\r\n    function setSpawnProxy(uint32 _point, address _proxy)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      address prev = deed.spawnProxy;\r\n      if (prev == _proxy)\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different spawn proxy, do some\r\n      //  gymnastics to keep the reverse lookup gapless.  delete the point\r\n      //  from the old proxy's list, then fill that gap with the list tail.\r\n      //\r\n      if (0x0 != prev)\r\n      {\r\n        //  i: current index in previous proxy's list of spawning points\r\n        //\r\n        uint256 i = spawningForIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :spawningForIndexes reference\r\n        //\r\n        uint32[] storage prevSfor = spawningFor[prev];\r\n        uint256 last = prevSfor.length - 1;\r\n        uint32 moved = prevSfor[last];\r\n        prevSfor[i] = moved;\r\n        spawningForIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(prevSfor[last]);\r\n        prevSfor.length = last;\r\n        spawningForIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      if (0x0 != _proxy)\r\n      {\r\n        uint32[] storage sfor = spawningFor[_proxy];\r\n        sfor.push(_point);\r\n        spawningForIndexes[_proxy][_point] = sfor.length;\r\n      }\r\n\r\n      deed.spawnProxy = _proxy;\r\n      emit ChangedSpawnProxy(_point, _proxy);\r\n    }\r\n\r\n    //  setVotingProxy(): makes _proxy _point's voting proxy\r\n    //\r\n    function setVotingProxy(uint32 _point, address _proxy)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      address prev = deed.votingProxy;\r\n      if (prev == _proxy)\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different voter, do some gymnastics\r\n      //  to keep the reverse lookup gapless.  delete the point from the\r\n      //  old voter's list, then fill that gap with the list tail.\r\n      //\r\n      if (0x0 != prev)\r\n      {\r\n        //  i: current index in previous voter's list of points it was\r\n        //     voting for\r\n        //\r\n        uint256 i = votingForIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :votingForIndexes reference\r\n        //\r\n        uint32[] storage prevVfor = votingFor[prev];\r\n        uint256 last = prevVfor.length - 1;\r\n        uint32 moved = prevVfor[last];\r\n        prevVfor[i] = moved;\r\n        votingForIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(prevVfor[last]);\r\n        prevVfor.length = last;\r\n        votingForIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      if (0x0 != _proxy)\r\n      {\r\n        uint32[] storage vfor = votingFor[_proxy];\r\n        vfor.push(_point);\r\n        votingForIndexes[_proxy][_point] = vfor.length;\r\n      }\r\n\r\n      deed.votingProxy = _proxy;\r\n      emit ChangedVotingProxy(_point, _proxy);\r\n    }\r\n\r\n    //  setTransferProxy(): makes _proxy _point's transfer proxy\r\n    //\r\n    function setTransferProxy(uint32 _point, address _proxy)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      address prev = deed.transferProxy;\r\n      if (prev == _proxy)\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different transfer proxy, do some\r\n      //  gymnastics to keep the reverse lookup gapless.  delete the point\r\n      //  from the old proxy's list, then fill that gap with the list tail.\r\n      //\r\n      if (0x0 != prev)\r\n      {\r\n        //  i: current index in previous proxy's list of transferable points\r\n        //\r\n        uint256 i = transferringForIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :transferringForIndexes reference\r\n        //\r\n        uint32[] storage prevTfor = transferringFor[prev];\r\n        uint256 last = prevTfor.length - 1;\r\n        uint32 moved = prevTfor[last];\r\n        prevTfor[i] = moved;\r\n        transferringForIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(prevTfor[last]);\r\n        prevTfor.length = last;\r\n        transferringForIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      if (0x0 != _proxy)\r\n      {\r\n        uint32[] storage tfor = transferringFor[_proxy];\r\n        tfor.push(_point);\r\n        transferringForIndexes[_proxy][_point] = tfor.length;\r\n      }\r\n\r\n      deed.transferProxy = _proxy;\r\n      emit ChangedTransferProxy(_point, _proxy);\r\n    }\r\n\r\n    //  setOperator(): dis/allow _operator to transfer ownership of all points\r\n    //                 owned by _owner\r\n    //\r\n    //    operators are part of the ERC721 standard\r\n    //\r\n    function setOperator(address _owner, address _operator, bool _approved)\r\n      onlyOwner\r\n      external\r\n    {\r\n      operators[_owner][_operator] = _approved;\r\n    }\r\n}\r\n\r\n// Azimuth's ReadsAzimuth.sol\r\n\r\n//  ReadsAzimuth: referring to and testing against the Azimuth\r\n//                data contract\r\n//\r\n//    To avoid needless repetition, this contract provides common\r\n//    checks and operations using the Azimuth contract.\r\n//\r\ncontract ReadsAzimuth\r\n{\r\n  //  azimuth: points data storage contract.\r\n  //\r\n  Azimuth public azimuth;\r\n\r\n  //  constructor(): set the Azimuth data contract's address\r\n  //\r\n  constructor(Azimuth _azimuth)\r\n    public\r\n  {\r\n    azimuth = _azimuth;\r\n  }\r\n\r\n  //  activePointOwner(): require that :msg.sender is the owner of _point,\r\n  //                      and that _point is active\r\n  //\r\n  modifier activePointOwner(uint32 _point)\r\n  {\r\n    require( azimuth.isOwner(_point, msg.sender) &&\r\n             azimuth.isActive(_point) );\r\n    _;\r\n  }\r\n\r\n  //  activePointManager(): require that :msg.sender can manage _point,\r\n  //                        and that _point is active\r\n  //\r\n  modifier activePointManager(uint32 _point)\r\n  {\r\n    require( azimuth.canManage(_point, msg.sender) &&\r\n             azimuth.isActive(_point) );\r\n    _;\r\n  }\r\n}\r\n\r\n// Azimuth's Polls.sol\r\n\r\n//  Polls: proposals & votes data contract\r\n//\r\n//    This contract is used for storing all data related to the proposals\r\n//    of the senate (galaxy owners) and their votes on those proposals.\r\n//    It keeps track of votes and uses them to calculate whether a majority\r\n//    is in favor of a proposal.\r\n//\r\n//    Every galaxy can only vote on a proposal exactly once. Votes cannot\r\n//    be changed. If a proposal fails to achieve majority within its\r\n//    duration, it can be restarted after its cooldown period has passed.\r\n//\r\n//    The requirements for a proposal to achieve majority are as follows:\r\n//    - At least 1/4 of the currently active voters (rounded down) must have\r\n//      voted in favor of the proposal,\r\n//    - More than half of the votes cast must be in favor of the proposal,\r\n//      and this can no longer change, either because\r\n//      - the poll duration has passed, or\r\n//      - not enough voters remain to take away the in-favor majority.\r\n//    As soon as these conditions are met, no further interaction with\r\n//    the proposal is possible. Achieving majority is permanent.\r\n//\r\n//    Since data stores are difficult to upgrade, all of the logic unrelated\r\n//    to the voting itself (that is, determining who is eligible to vote)\r\n//    is expected to be implemented by this contract's owner.\r\n//\r\n//    This contract will be owned by the Ecliptic contract.\r\n//\r\ncontract Polls is Ownable\r\n{\r\n  using SafeMath for uint256;\r\n  using SafeMath16 for uint16;\r\n  using SafeMath8 for uint8;\r\n\r\n  //  UpgradePollStarted: a poll on :proposal has opened\r\n  //\r\n  event UpgradePollStarted(address proposal);\r\n\r\n  //  DocumentPollStarted: a poll on :proposal has opened\r\n  //\r\n  event DocumentPollStarted(bytes32 proposal);\r\n\r\n  //  UpgradeMajority: :proposal has achieved majority\r\n  //\r\n  event UpgradeMajority(address proposal);\r\n\r\n  //  DocumentMajority: :proposal has achieved majority\r\n  //\r\n  event DocumentMajority(bytes32 proposal);\r\n\r\n  //  Poll: full poll state\r\n  //\r\n  struct Poll\r\n  {\r\n    //  start: the timestamp at which the poll was started\r\n    //\r\n    uint256 start;\r\n\r\n    //  voted: per galaxy, whether they have voted on this poll\r\n    //\r\n    bool[256] voted;\r\n\r\n    //  yesVotes: amount of votes in favor of the proposal\r\n    //\r\n    uint16 yesVotes;\r\n\r\n    //  noVotes: amount of votes against the proposal\r\n    //\r\n    uint16 noVotes;\r\n\r\n    //  duration: amount of time during which the poll can be voted on\r\n    //\r\n    uint256 duration;\r\n\r\n    //  cooldown: amount of time before the (non-majority) poll can be reopened\r\n    //\r\n    uint256 cooldown;\r\n  }\r\n\r\n  //  pollDuration: duration set for new polls. see also Poll.duration above\r\n  //\r\n  uint256 public pollDuration;\r\n\r\n  //  pollCooldown: cooldown set for new polls. see also Poll.cooldown above\r\n  //\r\n  uint256 public pollCooldown;\r\n\r\n  //  totalVoters: amount of active galaxies\r\n  //\r\n  uint16 public totalVoters;\r\n\r\n  //  upgradeProposals: list of all upgrades ever proposed\r\n  //\r\n  //    this allows clients to discover the existence of polls.\r\n  //    from there, they can do liveness checks on the polls themselves.\r\n  //\r\n  address[] public upgradeProposals;\r\n\r\n  //  upgradePolls: per address, poll held to determine if that address\r\n  //                will become the new ecliptic\r\n  //\r\n  mapping(address => Poll) public upgradePolls;\r\n\r\n  //  upgradeHasAchievedMajority: per address, whether that address\r\n  //                              has ever achieved majority\r\n  //\r\n  //    If we did not store this, we would have to look at old poll data\r\n  //    to see whether or not a proposal has ever achieved majority.\r\n  //    Since the outcome of a poll is calculated based on :totalVoters,\r\n  //    which may not be consistent across time, we need to store outcomes\r\n  //    explicitly instead of re-calculating them. This allows us to always\r\n  //    tell with certainty whether or not a majority was achieved,\r\n  //    regardless of the current :totalVoters.\r\n  //\r\n  mapping(address => bool) public upgradeHasAchievedMajority;\r\n\r\n  //  documentProposals: list of all documents ever proposed\r\n  //\r\n  //    this allows clients to discover the existence of polls.\r\n  //    from there, they can do liveness checks on the polls themselves.\r\n  //\r\n  bytes32[] public documentProposals;\r\n\r\n  //  documentPolls: per hash, poll held to determine if the corresponding\r\n  //                 document is accepted by the galactic senate\r\n  //\r\n  mapping(bytes32 => Poll) public documentPolls;\r\n\r\n  //  documentHasAchievedMajority: per hash, whether that hash has ever\r\n  //                               achieved majority\r\n  //\r\n  //    the note for upgradeHasAchievedMajority above applies here as well\r\n  //\r\n  mapping(bytes32 => bool) public documentHasAchievedMajority;\r\n\r\n  //  documentMajorities: all hashes that have achieved majority\r\n  //\r\n  bytes32[] public documentMajorities;\r\n\r\n  //  constructor(): initial contract configuration\r\n  //\r\n  constructor(uint256 _pollDuration, uint256 _pollCooldown)\r\n    public\r\n  {\r\n    reconfigure(_pollDuration, _pollCooldown);\r\n  }\r\n\r\n  //  reconfigure(): change poll duration and cooldown\r\n  //\r\n  function reconfigure(uint256 _pollDuration, uint256 _pollCooldown)\r\n    public\r\n    onlyOwner\r\n  {\r\n    require( (5 days <= _pollDuration) && (_pollDuration <= 90 days) &&\r\n             (5 days <= _pollCooldown) && (_pollCooldown <= 90 days) );\r\n    pollDuration = _pollDuration;\r\n    pollCooldown = _pollCooldown;\r\n  }\r\n\r\n  //  incrementTotalVoters(): increase the amount of registered voters\r\n  //\r\n  function incrementTotalVoters()\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(totalVoters < 256);\r\n    totalVoters = totalVoters.add(1);\r\n  }\r\n\r\n  //  getAllUpgradeProposals(): return array of all upgrade proposals ever made\r\n  //\r\n  //    Note: only useful for clients, as Solidity does not currently\r\n  //    support returning dynamic arrays.\r\n  //\r\n  function getUpgradeProposals()\r\n    external\r\n    view\r\n    returns (address[] proposals)\r\n  {\r\n    return upgradeProposals;\r\n  }\r\n\r\n  //  getUpgradeProposalCount(): get the number of unique proposed upgrades\r\n  //\r\n  function getUpgradeProposalCount()\r\n    external\r\n    view\r\n    returns (uint256 count)\r\n  {\r\n    return upgradeProposals.length;\r\n  }\r\n\r\n  //  getAllDocumentProposals(): return array of all upgrade proposals ever made\r\n  //\r\n  //    Note: only useful for clients, as Solidity does not currently\r\n  //    support returning dynamic arrays.\r\n  //\r\n  function getDocumentProposals()\r\n    external\r\n    view\r\n    returns (bytes32[] proposals)\r\n  {\r\n    return documentProposals;\r\n  }\r\n\r\n  //  getDocumentProposalCount(): get the number of unique proposed upgrades\r\n  //\r\n  function getDocumentProposalCount()\r\n    external\r\n    view\r\n    returns (uint256 count)\r\n  {\r\n    return documentProposals.length;\r\n  }\r\n\r\n  //  getDocumentMajorities(): return array of all document majorities\r\n  //\r\n  //    Note: only useful for clients, as Solidity does not currently\r\n  //    support returning dynamic arrays.\r\n  //\r\n  function getDocumentMajorities()\r\n    external\r\n    view\r\n    returns (bytes32[] majorities)\r\n  {\r\n    return documentMajorities;\r\n  }\r\n\r\n  //  hasVotedOnUpgradePoll(): returns true if _galaxy has voted\r\n  //                           on the _proposal\r\n  //\r\n  function hasVotedOnUpgradePoll(uint8 _galaxy, address _proposal)\r\n    external\r\n    view\r\n    returns (bool result)\r\n  {\r\n    return upgradePolls[_proposal].voted[_galaxy];\r\n  }\r\n\r\n  //  hasVotedOnDocumentPoll(): returns true if _galaxy has voted\r\n  //                            on the _proposal\r\n  //\r\n  function hasVotedOnDocumentPoll(uint8 _galaxy, bytes32 _proposal)\r\n    external\r\n    view\r\n    returns (bool result)\r\n  {\r\n    return documentPolls[_proposal].voted[_galaxy];\r\n  }\r\n\r\n  //  startUpgradePoll(): open a poll on making _proposal the new ecliptic\r\n  //\r\n  function startUpgradePoll(address _proposal)\r\n    external\r\n    onlyOwner\r\n  {\r\n    //  _proposal must not have achieved majority before\r\n    //\r\n    require(!upgradeHasAchievedMajority[_proposal]);\r\n\r\n    Poll storage poll = upgradePolls[_proposal];\r\n\r\n    //  if the proposal is being made for the first time, register it.\r\n    //\r\n    if (0 == poll.start)\r\n    {\r\n      upgradeProposals.push(_proposal);\r\n    }\r\n\r\n    startPoll(poll);\r\n    emit UpgradePollStarted(_proposal);\r\n  }\r\n\r\n  //  startDocumentPoll(): open a poll on accepting the document\r\n  //                       whose hash is _proposal\r\n  //\r\n  function startDocumentPoll(bytes32 _proposal)\r\n    external\r\n    onlyOwner\r\n  {\r\n    //  _proposal must not have achieved majority before\r\n    //\r\n    require(!documentHasAchievedMajority[_proposal]);\r\n\r\n    Poll storage poll = documentPolls[_proposal];\r\n\r\n    //  if the proposal is being made for the first time, register it.\r\n    //\r\n    if (0 == poll.start)\r\n    {\r\n      documentProposals.push(_proposal);\r\n    }\r\n\r\n    startPoll(poll);\r\n    emit DocumentPollStarted(_proposal);\r\n  }\r\n\r\n  //  startPoll(): open a new poll, or re-open an old one\r\n  //\r\n  function startPoll(Poll storage _poll)\r\n    internal\r\n  {\r\n    //  check that the poll has cooled down enough to be started again\r\n    //\r\n    //    for completely new polls, the values used will be zero\r\n    //\r\n    require( block.timestamp > ( _poll.start.add(\r\n                                 _poll.duration.add(\r\n                                 _poll.cooldown )) ) );\r\n\r\n    //  set started poll state\r\n    //\r\n    _poll.start = block.timestamp;\r\n    delete _poll.voted;\r\n    _poll.yesVotes = 0;\r\n    _poll.noVotes = 0;\r\n    _poll.duration = pollDuration;\r\n    _poll.cooldown = pollCooldown;\r\n  }\r\n\r\n  //  castUpgradeVote(): as galaxy _as, cast a vote on the _proposal\r\n  //\r\n  //    _vote is true when in favor of the proposal, false otherwise\r\n  //\r\n  function castUpgradeVote(uint8 _as, address _proposal, bool _vote)\r\n    external\r\n    onlyOwner\r\n    returns (bool majority)\r\n  {\r\n    Poll storage poll = upgradePolls[_proposal];\r\n    processVote(poll, _as, _vote);\r\n    return updateUpgradePoll(_proposal);\r\n  }\r\n\r\n  //  castDocumentVote(): as galaxy _as, cast a vote on the _proposal\r\n  //\r\n  //    _vote is true when in favor of the proposal, false otherwise\r\n  //\r\n  function castDocumentVote(uint8 _as, bytes32 _proposal, bool _vote)\r\n    external\r\n    onlyOwner\r\n    returns (bool majority)\r\n  {\r\n    Poll storage poll = documentPolls[_proposal];\r\n    processVote(poll, _as, _vote);\r\n    return updateDocumentPoll(_proposal);\r\n  }\r\n\r\n  //  processVote(): record a vote from _as on the _poll\r\n  //\r\n  function processVote(Poll storage _poll, uint8 _as, bool _vote)\r\n    internal\r\n  {\r\n    //  assist symbolic execution tools\r\n    //\r\n    assert(block.timestamp >= _poll.start);\r\n\r\n    require( //  may only vote once\r\n             //\r\n             !_poll.voted[_as] &&\r\n             //\r\n             //  may only vote when the poll is open\r\n             //\r\n             (block.timestamp < _poll.start.add(_poll.duration)) );\r\n\r\n    //  update poll state to account for the new vote\r\n    //\r\n    _poll.voted[_as] = true;\r\n    if (_vote)\r\n    {\r\n      _poll.yesVotes = _poll.yesVotes.add(1);\r\n    }\r\n    else\r\n    {\r\n      _poll.noVotes = _poll.noVotes.add(1);\r\n    }\r\n  }\r\n\r\n  //  updateUpgradePoll(): check whether the _proposal has achieved\r\n  //                            majority, updating state, sending an event,\r\n  //                            and returning true if it has\r\n  //\r\n  function updateUpgradePoll(address _proposal)\r\n    public\r\n    onlyOwner\r\n    returns (bool majority)\r\n  {\r\n    //  _proposal must not have achieved majority before\r\n    //\r\n    require(!upgradeHasAchievedMajority[_proposal]);\r\n\r\n    //  check for majority in the poll\r\n    //\r\n    Poll storage poll = upgradePolls[_proposal];\r\n    majority = checkPollMajority(poll);\r\n\r\n    //  if majority was achieved, update the state and send an event\r\n    //\r\n    if (majority)\r\n    {\r\n      upgradeHasAchievedMajority[_proposal] = true;\r\n      emit UpgradeMajority(_proposal);\r\n    }\r\n    return majority;\r\n  }\r\n\r\n  //  updateDocumentPoll(): check whether the _proposal has achieved majority,\r\n  //                        updating the state and sending an event if it has\r\n  //\r\n  //    this can be called by anyone, because the ecliptic does not\r\n  //    need to be aware of the result\r\n  //\r\n  function updateDocumentPoll(bytes32 _proposal)\r\n    public\r\n    returns (bool majority)\r\n  {\r\n    //  _proposal must not have achieved majority before\r\n    //\r\n    require(!documentHasAchievedMajority[_proposal]);\r\n\r\n    //  check for majority in the poll\r\n    //\r\n    Poll storage poll = documentPolls[_proposal];\r\n    majority = checkPollMajority(poll);\r\n\r\n    //  if majority was achieved, update state and send an event\r\n    //\r\n    if (majority)\r\n    {\r\n      documentHasAchievedMajority[_proposal] = true;\r\n      documentMajorities.push(_proposal);\r\n      emit DocumentMajority(_proposal);\r\n    }\r\n    return majority;\r\n  }\r\n\r\n  //  checkPollMajority(): returns true if the majority is in favor of\r\n  //                       the subject of the poll\r\n  //\r\n  function checkPollMajority(Poll _poll)\r\n    internal\r\n    view\r\n    returns (bool majority)\r\n  {\r\n    return ( //  poll must have at least the minimum required yes-votes\r\n             //\r\n             (_poll.yesVotes >= (totalVoters / 4)) &&\r\n             //\r\n             //  and have a majority...\r\n             //\r\n             (_poll.yesVotes > _poll.noVotes) &&\r\n             //\r\n             //  ...that is indisputable\r\n             //\r\n             ( //  either because the poll has ended\r\n               //\r\n               (block.timestamp > _poll.start.add(_poll.duration)) ||\r\n               //\r\n               //  or there are more yes votes than there can be no votes\r\n               //\r\n               ( _poll.yesVotes > totalVoters.sub(_poll.yesVotes) ) ) );\r\n  }\r\n}\r\n\r\n// Azimuth's Claims.sol\r\n\r\n//  Claims: simple identity management\r\n//\r\n//    This contract allows points to document claims about their owner.\r\n//    Most commonly, these are about identity, with a claim's protocol\r\n//    defining the context or platform of the claim, and its dossier\r\n//    containing proof of its validity.\r\n//    Points are limited to a maximum of 16 claims.\r\n//\r\n//    For existing claims, the dossier can be updated, or the claim can\r\n//    be removed entirely. It is recommended to remove any claims associated\r\n//    with a point when it is about to be transferred to a new owner.\r\n//    For convenience, the owner of the Azimuth contract (the Ecliptic)\r\n//    is allowed to clear claims for any point, allowing it to do this for\r\n//    you on-transfer.\r\n//\r\ncontract Claims is ReadsAzimuth\r\n{\r\n  //  ClaimAdded: a claim was added by :by\r\n  //\r\n  event ClaimAdded( uint32 indexed by,\r\n                    string _protocol,\r\n                    string _claim,\r\n                    bytes _dossier );\r\n\r\n  //  ClaimRemoved: a claim was removed by :by\r\n  //\r\n  event ClaimRemoved(uint32 indexed by, string _protocol, string _claim);\r\n\r\n  //  maxClaims: the amount of claims that can be registered per point\r\n  //\r\n  uint8 constant maxClaims = 16;\r\n\r\n  //  Claim: claim details\r\n  //\r\n  struct Claim\r\n  {\r\n    //  protocol: context of the claim\r\n    //\r\n    string protocol;\r\n\r\n    //  claim: the claim itself\r\n    //\r\n    string claim;\r\n\r\n    //  dossier: data relating to the claim, as proof\r\n    //\r\n    bytes dossier;\r\n  }\r\n\r\n  //  per point, list of claims\r\n  //\r\n  mapping(uint32 => Claim[maxClaims]) public claims;\r\n\r\n  //  constructor(): register the azimuth contract.\r\n  //\r\n  constructor(Azimuth _azimuth)\r\n    ReadsAzimuth(_azimuth)\r\n    public\r\n  {\r\n    //\r\n  }\r\n\r\n  //  addClaim(): register a claim as _point\r\n  //\r\n  function addClaim(uint32 _point,\r\n                    string _protocol,\r\n                    string _claim,\r\n                    bytes _dossier)\r\n    external\r\n    activePointManager(_point)\r\n  {\r\n    //  cur: index + 1 of the claim if it already exists, 0 otherwise\r\n    //\r\n    uint8 cur = findClaim(_point, _protocol, _claim);\r\n\r\n    //  if the claim doesn't yet exist, store it in state\r\n    //\r\n    if (cur == 0)\r\n    {\r\n      //  if there are no empty slots left, this throws\r\n      //\r\n      uint8 empty = findEmptySlot(_point);\r\n      claims[_point][empty] = Claim(_protocol, _claim, _dossier);\r\n    }\r\n    //\r\n    //  if the claim has been made before, update the version in state\r\n    //\r\n    else\r\n    {\r\n      claims[_point][cur-1] = Claim(_protocol, _claim, _dossier);\r\n    }\r\n    emit ClaimAdded(_point, _protocol, _claim, _dossier);\r\n  }\r\n\r\n  //  removeClaim(): unregister a claim as _point\r\n  //\r\n  function removeClaim(uint32 _point, string _protocol, string _claim)\r\n    external\r\n    activePointManager(_point)\r\n  {\r\n    //  i: current index + 1 in _point's list of claims\r\n    //\r\n    uint256 i = findClaim(_point, _protocol, _claim);\r\n\r\n    //  we store index + 1, because 0 is the eth default value\r\n    //  can only delete an existing claim\r\n    //\r\n    require(i > 0);\r\n    i--;\r\n\r\n    //  clear out the claim\r\n    //\r\n    delete claims[_point][i];\r\n\r\n    emit ClaimRemoved(_point, _protocol, _claim);\r\n  }\r\n\r\n  //  clearClaims(): unregister all of _point's claims\r\n  //\r\n  //    can also be called by the ecliptic during point transfer\r\n  //\r\n  function clearClaims(uint32 _point)\r\n    external\r\n  {\r\n    //  both point owner and ecliptic may do this\r\n    //\r\n    //    We do not necessarily need to check for _point's active flag here,\r\n    //    since inactive points cannot have claims set. Doing the check\r\n    //    anyway would make this function slightly harder to think about due\r\n    //    to its relation to Ecliptic's transferPoint().\r\n    //\r\n    require( azimuth.canManage(_point, msg.sender) ||\r\n             ( msg.sender == azimuth.owner() ) );\r\n\r\n    Claim[maxClaims] storage currClaims = claims[_point];\r\n\r\n    //  clear out all claims\r\n    //\r\n    for (uint8 i = 0; i < maxClaims; i++)\r\n    {\r\n      delete currClaims[i];\r\n    }\r\n  }\r\n\r\n  //  findClaim(): find the index of the specified claim\r\n  //\r\n  //    returns 0 if not found, index + 1 otherwise\r\n  //\r\n  function findClaim(uint32 _whose, string _protocol, string _claim)\r\n    public\r\n    view\r\n    returns (uint8 index)\r\n  {\r\n    //  we use hashes of the string because solidity can't do string\r\n    //  comparison yet\r\n    //\r\n    bytes32 protocolHash = keccak256(bytes(_protocol));\r\n    bytes32 claimHash = keccak256(bytes(_claim));\r\n    Claim[maxClaims] storage theirClaims = claims[_whose];\r\n    for (uint8 i = 0; i < maxClaims; i++)\r\n    {\r\n      Claim storage thisClaim = theirClaims[i];\r\n      if ( ( protocolHash == keccak256(bytes(thisClaim.protocol)) ) &&\r\n           ( claimHash == keccak256(bytes(thisClaim.claim)) ) )\r\n      {\r\n        return i+1;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  //  findEmptySlot(): find the index of the first empty claim slot\r\n  //\r\n  //    returns the index of the slot, throws if there are no empty slots\r\n  //\r\n  function findEmptySlot(uint32 _whose)\r\n    internal\r\n    view\r\n    returns (uint8 index)\r\n  {\r\n    Claim[maxClaims] storage theirClaims = claims[_whose];\r\n    for (uint8 i = 0; i < maxClaims; i++)\r\n    {\r\n      Claim storage thisClaim = theirClaims[i];\r\n      if ( (0 == bytes(thisClaim.protocol).length) &&\r\n           (0 == bytes(thisClaim.claim).length) )\r\n      {\r\n        return i;\r\n      }\r\n    }\r\n    revert();\r\n  }\r\n}\r\n\r\n// Azimuth's EclipticBase.sol\r\n\r\n//  EclipticBase: upgradable ecliptic\r\n//\r\n//    This contract implements the upgrade logic for the Ecliptic.\r\n//    Newer versions of the Ecliptic are expected to provide at least\r\n//    the onUpgrade() function. If they don't, upgrading to them will\r\n//    fail.\r\n//\r\n//    Note that even though this contract doesn't specify any required\r\n//    interface members aside from upgrade() and onUpgrade(), contracts\r\n//    and clients may still rely on the presence of certain functions\r\n//    provided by the Ecliptic proper. Keep this in mind when writing\r\n//    new versions of it.\r\n//\r\ncontract EclipticBase is Ownable, ReadsAzimuth\r\n{\r\n  //  Upgraded: _to is the new canonical Ecliptic\r\n  //\r\n  event Upgraded(address to);\r\n\r\n  //  polls: senate voting contract\r\n  //\r\n  Polls public polls;\r\n\r\n  //  previousEcliptic: address of the previous ecliptic this\r\n  //                    instance expects to upgrade from, stored and\r\n  //                    checked for to prevent unexpected upgrade paths\r\n  //\r\n  address public previousEcliptic;\r\n\r\n  constructor( address _previous,\r\n               Azimuth _azimuth,\r\n               Polls _polls )\r\n    ReadsAzimuth(_azimuth)\r\n    internal\r\n  {\r\n    previousEcliptic = _previous;\r\n    polls = _polls;\r\n  }\r\n\r\n  //  onUpgrade(): called by previous ecliptic when upgrading\r\n  //\r\n  //    in future ecliptics, this might perform more logic than\r\n  //    just simple checks and verifications.\r\n  //    when overriding this, make sure to call this original as well.\r\n  //\r\n  function onUpgrade()\r\n    external\r\n  {\r\n    //  make sure this is the expected upgrade path,\r\n    //  and that we have gotten the ownership we require\r\n    //\r\n    require( msg.sender == previousEcliptic &&\r\n             this == azimuth.owner() &&\r\n             this == polls.owner() );\r\n  }\r\n\r\n  //  upgrade(): transfer ownership of the ecliptic data to the new\r\n  //             ecliptic contract, notify it, then self-destruct.\r\n  //\r\n  //    Note: any eth that have somehow ended up in this contract\r\n  //          are also sent to the new ecliptic.\r\n  //\r\n  function upgrade(EclipticBase _new)\r\n    internal\r\n  {\r\n    //  transfer ownership of the data contracts\r\n    //\r\n    azimuth.transferOwnership(_new);\r\n    polls.transferOwnership(_new);\r\n\r\n    //  trigger upgrade logic on the target contract\r\n    //\r\n    _new.onUpgrade();\r\n\r\n    //  emit event and destroy this contract\r\n    //\r\n    emit Upgraded(_new);\r\n    selfdestruct(_new);\r\n  }\r\n}\r\n\r\n// Azimuth's Ecliptic\r\n\r\n//  Ecliptic: logic for interacting with the Azimuth ledger\r\n//\r\n//    This contract is the point of entry for all operations on the Azimuth\r\n//    ledger as stored in the Azimuth data contract. The functions herein\r\n//    are responsible for performing all necessary business logic.\r\n//    Examples of such logic include verifying permissions of the caller\r\n//    and ensuring a requested change is actually valid.\r\n//    Point owners can always operate on their own points. Ethereum addresses\r\n//    can also perform specific operations if they've been given the\r\n//    appropriate permissions. (For example, managers for general management,\r\n//    spawn proxies for spawning child points, etc.)\r\n//\r\n//    This contract uses external contracts (Azimuth, Polls) for data storage\r\n//    so that it itself can easily be replaced in case its logic needs to\r\n//    be changed. In other words, it can be upgraded. It does this by passing\r\n//    ownership of the data contracts to a new Ecliptic contract.\r\n//\r\n//    Because of this, it is advised for clients to not store this contract's\r\n//    address directly, but rather ask the Azimuth contract for its owner\r\n//    attribute to ensure transactions get sent to the latest Ecliptic.\r\n//    Alternatively, the ENS name ecliptic.eth will resolve to the latest\r\n//    Ecliptic as well.\r\n//\r\n//    Upgrading happens based on polls held by the senate (galaxy owners).\r\n//    Through this contract, the senate can submit proposals, opening polls\r\n//    for the senate to cast votes on. These proposals can be either hashes\r\n//    of documents or addresses of new Ecliptics.\r\n//    If an ecliptic proposal gains majority, this contract will transfer\r\n//    ownership of the data storage contracts to that address, so that it may\r\n//    operate on the data they contain. This contract will selfdestruct at\r\n//    the end of the upgrade process.\r\n//\r\n//    This contract implements the ERC721 interface for non-fungible tokens,\r\n//    allowing points to be managed using generic clients that support the\r\n//    standard. It also implements ERC165 to allow this to be discovered.\r\n//\r\ncontract Ecliptic is EclipticBase, SupportsInterfaceWithLookup, ERC721Metadata\r\n{\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  //  Transfer: This emits when ownership of any NFT changes by any mechanism.\r\n  //            This event emits when NFTs are created (`from` == 0) and\r\n  //            destroyed (`to` == 0). At the time of any transfer, the\r\n  //            approved address for that NFT (if any) is reset to none.\r\n  //\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n\r\n  //  Approval: This emits when the approved address for an NFT is changed or\r\n  //            reaffirmed. The zero address indicates there is no approved\r\n  //            address. When a Transfer event emits, this also indicates that\r\n  //            the approved address for that NFT (if any) is reset to none.\r\n  //\r\n  event Approval(address indexed _owner, address indexed _approved,\r\n                 uint256 _tokenId);\r\n\r\n  //  ApprovalForAll: This emits when an operator is enabled or disabled for an\r\n  //                  owner. The operator can manage all NFTs of the owner.\r\n  //\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator,\r\n                       bool _approved);\r\n\r\n  // erc721Received: equal to:\r\n  //        bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\r\n  //                 which can be also obtained as:\r\n  //        ERC721Receiver(0).onERC721Received.selector`\r\n  bytes4 constant erc721Received = 0x150b7a02;\r\n\r\n  //  claims: contract reference, for clearing claims on-transfer\r\n  //\r\n  Claims public claims;\r\n\r\n  //  constructor(): set data contract addresses and signal interface support\r\n  //\r\n  //    Note: during first deploy, ownership of these data contracts must\r\n  //    be manually transferred to this contract.\r\n  //\r\n  constructor(address _previous,\r\n              Azimuth _azimuth,\r\n              Polls _polls,\r\n              Claims _claims)\r\n    EclipticBase(_previous, _azimuth, _polls)\r\n    public\r\n  {\r\n    claims = _claims;\r\n\r\n    //  register supported interfaces for ERC165\r\n    //\r\n    _registerInterface(0x80ac58cd); // ERC721\r\n    _registerInterface(0x5b5e139f); // ERC721Metadata\r\n    _registerInterface(0x7f5828d0); // ERC173 (ownership)\r\n  }\r\n\r\n  //\r\n  //  ERC721 interface\r\n  //\r\n\r\n    //  balanceOf(): get the amount of points owned by _owner\r\n    //\r\n    function balanceOf(address _owner)\r\n      public\r\n      view\r\n      returns (uint256 balance)\r\n    {\r\n      require(0x0 != _owner);\r\n      return azimuth.getOwnedPointCount(_owner);\r\n    }\r\n\r\n    //  ownerOf(): get the current owner of point _tokenId\r\n    //\r\n    function ownerOf(uint256 _tokenId)\r\n      public\r\n      view\r\n      validPointId(_tokenId)\r\n      returns (address owner)\r\n    {\r\n      uint32 id = uint32(_tokenId);\r\n\r\n      //  this will throw if the owner is the zero address,\r\n      //  active points always have a valid owner.\r\n      //\r\n      require(azimuth.isActive(id));\r\n\r\n      return azimuth.getOwner(id);\r\n    }\r\n\r\n    //  exists(): returns true if point _tokenId is active\r\n    //\r\n    function exists(uint256 _tokenId)\r\n      public\r\n      view\r\n      returns (bool doesExist)\r\n    {\r\n      return ( (_tokenId < 0x100000000) &&\r\n               azimuth.isActive(uint32(_tokenId)) );\r\n    }\r\n\r\n    //  safeTransferFrom(): transfer point _tokenId from _from to _to\r\n    //\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n      public\r\n    {\r\n      //  transfer with empty data\r\n      //\r\n      safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    //  safeTransferFrom(): transfer point _tokenId from _from to _to,\r\n    //                      and call recipient if it's a contract\r\n    //\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId,\r\n                              bytes _data)\r\n      public\r\n    {\r\n      //  perform raw transfer\r\n      //\r\n      transferFrom(_from, _to, _tokenId);\r\n\r\n      //  do the callback last to avoid re-entrancy\r\n      //\r\n      if (_to.isContract())\r\n      {\r\n        bytes4 retval = ERC721Receiver(_to)\r\n                        .onERC721Received(msg.sender, _from, _tokenId, _data);\r\n        //\r\n        //  standard return idiom to confirm contract semantics\r\n        //\r\n        require(retval == erc721Received);\r\n      }\r\n    }\r\n\r\n    //  transferFrom(): transfer point _tokenId from _from to _to,\r\n    //                  WITHOUT notifying recipient contract\r\n    //\r\n    function transferFrom(address _from, address _to, uint256 _tokenId)\r\n      public\r\n      validPointId(_tokenId)\r\n    {\r\n      uint32 id = uint32(_tokenId);\r\n      require(azimuth.isOwner(id, _from));\r\n\r\n      //  the ERC721 operator/approved address (if any) is\r\n      //  accounted for in transferPoint()\r\n      //\r\n      transferPoint(id, _to, true);\r\n    }\r\n\r\n    //  approve(): allow _approved to transfer ownership of point\r\n    //             _tokenId\r\n    //\r\n    function approve(address _approved, uint256 _tokenId)\r\n      public\r\n      validPointId(_tokenId)\r\n    {\r\n      setTransferProxy(uint32(_tokenId), _approved);\r\n    }\r\n\r\n    //  setApprovalForAll(): allow or disallow _operator to\r\n    //                       transfer ownership of ALL points\r\n    //                       owned by :msg.sender\r\n    //\r\n    function setApprovalForAll(address _operator, bool _approved)\r\n      public\r\n    {\r\n      require(0x0 != _operator);\r\n      azimuth.setOperator(msg.sender, _operator, _approved);\r\n      emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    //  getApproved(): get the approved address for point _tokenId\r\n    //\r\n    function getApproved(uint256 _tokenId)\r\n      public\r\n      view\r\n      validPointId(_tokenId)\r\n      returns (address approved)\r\n    {\r\n      //NOTE  redundant, transfer proxy cannot be set for\r\n      //      inactive points\r\n      //\r\n      require(azimuth.isActive(uint32(_tokenId)));\r\n      return azimuth.getTransferProxy(uint32(_tokenId));\r\n    }\r\n\r\n    //  isApprovedForAll(): returns true if _operator is an\r\n    //                      operator for _owner\r\n    //\r\n    function isApprovedForAll(address _owner, address _operator)\r\n      public\r\n      view\r\n      returns (bool result)\r\n    {\r\n      return azimuth.isOperator(_owner, _operator);\r\n    }\r\n\r\n  //\r\n  //  ERC721Metadata interface\r\n  //\r\n\r\n    //  name(): returns the name of a collection of points\r\n    //\r\n    function name()\r\n      external\r\n      view\r\n      returns (string)\r\n    {\r\n      return \"Azimuth Points\";\r\n    }\r\n\r\n    //  symbol(): returns an abbreviates name for points\r\n    //\r\n    function symbol()\r\n      external\r\n      view\r\n      returns (string)\r\n    {\r\n      return \"AZP\";\r\n    }\r\n\r\n    //  tokenURI(): returns a URL to an ERC-721 standard JSON file\r\n    //\r\n    function tokenURI(uint256 _tokenId)\r\n      public\r\n      view\r\n      validPointId(_tokenId)\r\n      returns (string _tokenURI)\r\n    {\r\n      _tokenURI = \"https://azimuth.network/erc721/0000000000.json\";\r\n      bytes memory _tokenURIBytes = bytes(_tokenURI);\r\n      _tokenURIBytes[31] = byte(48+(_tokenId / 1000000000) % 10);\r\n      _tokenURIBytes[32] = byte(48+(_tokenId / 100000000) % 10);\r\n      _tokenURIBytes[33] = byte(48+(_tokenId / 10000000) % 10);\r\n      _tokenURIBytes[34] = byte(48+(_tokenId / 1000000) % 10);\r\n      _tokenURIBytes[35] = byte(48+(_tokenId / 100000) % 10);\r\n      _tokenURIBytes[36] = byte(48+(_tokenId / 10000) % 10);\r\n      _tokenURIBytes[37] = byte(48+(_tokenId / 1000) % 10);\r\n      _tokenURIBytes[38] = byte(48+(_tokenId / 100) % 10);\r\n      _tokenURIBytes[39] = byte(48+(_tokenId / 10) % 10);\r\n      _tokenURIBytes[40] = byte(48+(_tokenId / 1) % 10);\r\n    }\r\n\r\n  //\r\n  //  Points interface\r\n  //\r\n\r\n    //  configureKeys(): configure _point with network public keys\r\n    //                   _encryptionKey, _authenticationKey,\r\n    //                   and corresponding _cryptoSuiteVersion,\r\n    //                   incrementing the point's continuity number if needed\r\n    //\r\n    function configureKeys(uint32 _point,\r\n                           bytes32 _encryptionKey,\r\n                           bytes32 _authenticationKey,\r\n                           uint32 _cryptoSuiteVersion,\r\n                           bool _discontinuous)\r\n      external\r\n      activePointManager(_point)\r\n    {\r\n      if (_discontinuous)\r\n      {\r\n        azimuth.incrementContinuityNumber(_point);\r\n      }\r\n      azimuth.setKeys(_point,\r\n                      _encryptionKey,\r\n                      _authenticationKey,\r\n                      _cryptoSuiteVersion);\r\n    }\r\n\r\n    //  spawn(): spawn _point, then either give, or allow _target to take,\r\n    //           ownership of _point\r\n    //\r\n    //    if _target is the :msg.sender, _targets owns the _point right away.\r\n    //    otherwise, _target becomes the transfer proxy of _point.\r\n    //\r\n    //    Requirements:\r\n    //    - _point must not be active\r\n    //    - _point must not be a planet with a galaxy prefix\r\n    //    - _point's prefix must be linked and under its spawn limit\r\n    //    - :msg.sender must be either the owner of _point's prefix,\r\n    //      or an authorized spawn proxy for it\r\n    //\r\n    function spawn(uint32 _point, address _target)\r\n      external\r\n    {\r\n      //  only currently unowned (and thus also inactive) points can be spawned\r\n      //\r\n      require(azimuth.isOwner(_point, 0x0));\r\n\r\n      //  prefix: half-width prefix of _point\r\n      //\r\n      uint16 prefix = azimuth.getPrefix(_point);\r\n\r\n      //  only allow spawning of points of the size directly below the prefix\r\n      //\r\n      //    this is possible because of how the address space works,\r\n      //    but supporting it introduces complexity through broken assumptions.\r\n      //\r\n      //    example:\r\n      //    0x0000.0000 - galaxy zero\r\n      //    0x0000.0100 - the first star of galaxy zero\r\n      //    0x0001.0100 - the first planet of the first star\r\n      //    0x0001.0000 - the first planet of galaxy zero\r\n      //\r\n      require( (uint8(azimuth.getPointSize(prefix)) + 1) ==\r\n               uint8(azimuth.getPointSize(_point)) );\r\n\r\n      //  prefix point must be linked and able to spawn\r\n      //\r\n      require( (azimuth.hasBeenLinked(prefix)) &&\r\n               ( azimuth.getSpawnCount(prefix) <\r\n                 getSpawnLimit(prefix, block.timestamp) ) );\r\n\r\n      //  the owner of a prefix can always spawn its children;\r\n      //  other addresses need explicit permission (the role\r\n      //  of \"spawnProxy\" in the Azimuth contract)\r\n      //\r\n      require( azimuth.canSpawnAs(prefix, msg.sender) );\r\n\r\n      //  if the caller is spawning the point to themselves,\r\n      //  assume it knows what it's doing and resolve right away\r\n      //\r\n      if (msg.sender == _target)\r\n      {\r\n        doSpawn(_point, _target, true, 0x0);\r\n      }\r\n      //\r\n      //  when sending to a \"foreign\" address, enforce a withdraw pattern\r\n      //  making the _point prefix's owner the _point owner in the mean time\r\n      //\r\n      else\r\n      {\r\n        doSpawn(_point, _target, false, azimuth.getOwner(prefix));\r\n      }\r\n    }\r\n\r\n    //  doSpawn(): actual spawning logic, used in spawn(). creates _point,\r\n    //             making the _target its owner if _direct, or making the\r\n    //             _holder the owner and the _target the transfer proxy\r\n    //             if not _direct.\r\n    //\r\n    function doSpawn( uint32 _point,\r\n                      address _target,\r\n                      bool _direct,\r\n                      address _holder )\r\n      internal\r\n    {\r\n      //  register the spawn for _point's prefix, incrementing spawn count\r\n      //\r\n      azimuth.registerSpawned(_point);\r\n\r\n      //  if the spawn is _direct, assume _target knows what they're doing\r\n      //  and resolve right away\r\n      //\r\n      if (_direct)\r\n      {\r\n        //  make the point active and set its new owner\r\n        //\r\n        azimuth.activatePoint(_point);\r\n        azimuth.setOwner(_point, _target);\r\n\r\n        emit Transfer(0x0, _target, uint256(_point));\r\n      }\r\n      //\r\n      //  when spawning indirectly, enforce a withdraw pattern by approving\r\n      //  the _target for transfer of the _point instead.\r\n      //  we make the _holder the owner of this _point in the mean time,\r\n      //  so that it may cancel the transfer (un-approve) if _target flakes.\r\n      //  we don't make _point active yet, because it still doesn't really\r\n      //  belong to anyone.\r\n      //\r\n      else\r\n      {\r\n        //  have _holder hold on to the _point while _target gets to transfer\r\n        //  ownership of it\r\n        //\r\n        azimuth.setOwner(_point, _holder);\r\n        azimuth.setTransferProxy(_point, _target);\r\n\r\n        emit Transfer(0x0, _holder, uint256(_point));\r\n        emit Approval(_holder, _target, uint256(_point));\r\n      }\r\n    }\r\n\r\n    //  transferPoint(): transfer _point to _target, clearing all permissions\r\n    //                   data and keys if _reset is true\r\n    //\r\n    //    Note: the _reset flag is useful when transferring the point to\r\n    //    a recipient who doesn't trust the previous owner.\r\n    //\r\n    //    Requirements:\r\n    //    - :msg.sender must be either _point's current owner, authorized\r\n    //      to transfer _point, or authorized to transfer the current\r\n    //      owner's points (as in ERC721's operator)\r\n    //    - _target must not be the zero address\r\n    //\r\n    function transferPoint(uint32 _point, address _target, bool _reset)\r\n      public\r\n    {\r\n      //  transfer is legitimate if the caller is the current owner, or\r\n      //  an operator for the current owner, or the _point's transfer proxy\r\n      //\r\n      require(azimuth.canTransfer(_point, msg.sender));\r\n\r\n      //  if the point wasn't active yet, that means transferring it\r\n      //  is part of the \"spawn\" flow, so we need to activate it\r\n      //\r\n      if ( !azimuth.isActive(_point) )\r\n      {\r\n        azimuth.activatePoint(_point);\r\n      }\r\n\r\n      //  if the owner would actually change, change it\r\n      //\r\n      //    the only time this deliberately wouldn't be the case is when a\r\n      //    prefix owner wants to activate a spawned but untransferred child.\r\n      //\r\n      if ( !azimuth.isOwner(_point, _target) )\r\n      {\r\n        //  remember the previous owner, to be included in the Transfer event\r\n        //\r\n        address old = azimuth.getOwner(_point);\r\n\r\n        azimuth.setOwner(_point, _target);\r\n\r\n        //  according to ERC721, the approved address (here, transfer proxy)\r\n        //  gets cleared during every Transfer event\r\n        //\r\n        azimuth.setTransferProxy(_point, 0);\r\n\r\n        emit Transfer(old, _target, uint256(_point));\r\n      }\r\n\r\n      //  reset sensitive data\r\n      //  used when transferring the point to a new owner\r\n      //\r\n      if ( _reset )\r\n      {\r\n        //  clear the network public keys and break continuity,\r\n        //  but only if the point has already been linked\r\n        //\r\n        if ( azimuth.hasBeenLinked(_point) )\r\n        {\r\n          azimuth.incrementContinuityNumber(_point);\r\n          azimuth.setKeys(_point, 0, 0, 0);\r\n        }\r\n\r\n        //  clear management proxy\r\n        //\r\n        azimuth.setManagementProxy(_point, 0);\r\n\r\n        //  clear voting proxy\r\n        //\r\n        azimuth.setVotingProxy(_point, 0);\r\n\r\n        //  clear transfer proxy\r\n        //\r\n        //    in most cases this is done above, during the ownership transfer,\r\n        //    but we might not hit that and still be expected to reset the\r\n        //    transfer proxy.\r\n        //    doing it a second time is a no-op in Azimuth.\r\n        //\r\n        azimuth.setTransferProxy(_point, 0);\r\n\r\n        //  clear spawning proxy\r\n        //\r\n        azimuth.setSpawnProxy(_point, 0);\r\n\r\n        //  clear claims\r\n        //\r\n        claims.clearClaims(_point);\r\n      }\r\n    }\r\n\r\n    //  escape(): request escape as _point to _sponsor\r\n    //\r\n    //    if an escape request is already active, this overwrites\r\n    //    the existing request\r\n    //\r\n    //    Requirements:\r\n    //    - :msg.sender must be the owner or manager of _point,\r\n    //    - _point must be able to escape to _sponsor as per to canEscapeTo()\r\n    //\r\n    function escape(uint32 _point, uint32 _sponsor)\r\n      external\r\n      activePointManager(_point)\r\n    {\r\n      require(canEscapeTo(_point, _sponsor));\r\n      azimuth.setEscapeRequest(_point, _sponsor);\r\n    }\r\n\r\n    //  cancelEscape(): cancel the currently set escape for _point\r\n    //\r\n    function cancelEscape(uint32 _point)\r\n      external\r\n      activePointManager(_point)\r\n    {\r\n      azimuth.cancelEscape(_point);\r\n    }\r\n\r\n    //  adopt(): as the relevant sponsor, accept the _point\r\n    //\r\n    //    Requirements:\r\n    //    - :msg.sender must be the owner or management proxy\r\n    //      of _point's requested sponsor\r\n    //\r\n    function adopt(uint32 _point)\r\n      external\r\n    {\r\n      require( azimuth.isEscaping(_point) &&\r\n               azimuth.canManage( azimuth.getEscapeRequest(_point),\r\n                                  msg.sender ) );\r\n\r\n      //  _sponsor becomes _point's sponsor\r\n      //  its escape request is reset to \"not escaping\"\r\n      //\r\n      azimuth.doEscape(_point);\r\n    }\r\n\r\n    //  reject(): as the relevant sponsor, deny the _point's request\r\n    //\r\n    //    Requirements:\r\n    //    - :msg.sender must be the owner or management proxy\r\n    //      of _point's requested sponsor\r\n    //\r\n    function reject(uint32 _point)\r\n      external\r\n    {\r\n      require( azimuth.isEscaping(_point) &&\r\n               azimuth.canManage( azimuth.getEscapeRequest(_point),\r\n                                  msg.sender ) );\r\n\r\n      //  reset the _point's escape request to \"not escaping\"\r\n      //\r\n      azimuth.cancelEscape(_point);\r\n    }\r\n\r\n    //  detach(): as the _sponsor, stop sponsoring the _point\r\n    //\r\n    //    Requirements:\r\n    //    - :msg.sender must be the owner or management proxy\r\n    //      of _point's current sponsor\r\n    //\r\n    function detach(uint32 _point)\r\n      external\r\n    {\r\n      require( azimuth.hasSponsor(_point) &&\r\n               azimuth.canManage(azimuth.getSponsor(_point), msg.sender) );\r\n\r\n      //  signal that its sponsor no longer supports _point\r\n      //\r\n      azimuth.loseSponsor(_point);\r\n    }\r\n\r\n  //\r\n  //  Point rules\r\n  //\r\n\r\n    //  getSpawnLimit(): returns the total number of children the _point\r\n    //                   is allowed to spawn at _time.\r\n    //\r\n    function getSpawnLimit(uint32 _point, uint256 _time)\r\n      public\r\n      view\r\n      returns (uint32 limit)\r\n    {\r\n      Azimuth.Size size = azimuth.getPointSize(_point);\r\n\r\n      if ( size == Azimuth.Size.Galaxy )\r\n      {\r\n        return 255;\r\n      }\r\n      else if ( size == Azimuth.Size.Star )\r\n      {\r\n        //  in 2019, stars may spawn at most 1024 planets. this limit doubles\r\n        //  for every subsequent year.\r\n        //\r\n        //    Note: 1546300800 corresponds to 2019-01-01\r\n        //\r\n        uint256 yearsSince2019 = (_time - 1546300800) / 365 days;\r\n        if (yearsSince2019 < 6)\r\n        {\r\n          limit = uint32( 1024 * (2 ** yearsSince2019) );\r\n        }\r\n        else\r\n        {\r\n          limit = 65535;\r\n        }\r\n        return limit;\r\n      }\r\n      else  //  size == Azimuth.Size.Planet\r\n      {\r\n        //  planets can create moons, but moons aren't on the chain\r\n        //\r\n        return 0;\r\n      }\r\n    }\r\n\r\n    //  canEscapeTo(): true if _point could try to escape to _sponsor\r\n    //\r\n    function canEscapeTo(uint32 _point, uint32 _sponsor)\r\n      public\r\n      view\r\n      returns (bool canEscape)\r\n    {\r\n      //  can't escape to a sponsor that hasn't been linked\r\n      //\r\n      if ( !azimuth.hasBeenLinked(_sponsor) ) return false;\r\n\r\n      //  Can only escape to a point one size higher than ourselves,\r\n      //  except in the special case where the escaping point hasn't\r\n      //  been linked yet -- in that case we may escape to points of\r\n      //  the same size, to support lightweight invitation chains.\r\n      //\r\n      //  The use case for lightweight invitations is that a planet\r\n      //  owner should be able to invite their friends onto an\r\n      //  Azimuth network in a two-party transaction, without a new\r\n      //  star relationship.\r\n      //  The lightweight invitation process works by escaping your\r\n      //  own active (but never linked) point to one of your own\r\n      //  points, then transferring the point to your friend.\r\n      //\r\n      //  These planets can, in turn, sponsor other unlinked planets,\r\n      //  so the \"planet sponsorship chain\" can grow to arbitrary\r\n      //  length. Most users, especially deep down the chain, will\r\n      //  want to improve their performance by switching to direct\r\n      //  star sponsors eventually.\r\n      //\r\n      Azimuth.Size pointSize = azimuth.getPointSize(_point);\r\n      Azimuth.Size sponsorSize = azimuth.getPointSize(_sponsor);\r\n      return ( //  normal hierarchical escape structure\r\n               //\r\n               ( (uint8(sponsorSize) + 1) == uint8(pointSize) ) ||\r\n               //\r\n               //  special peer escape\r\n               //\r\n               ( (sponsorSize == pointSize) &&\r\n                 //\r\n                 //  peer escape is only for points that haven't been linked\r\n                 //  yet, because it's only for lightweight invitation chains\r\n                 //\r\n                 !azimuth.hasBeenLinked(_point) ) );\r\n    }\r\n\r\n  //\r\n  //  Permission management\r\n  //\r\n\r\n    //  setManagementProxy(): configure the management proxy for _point\r\n    //\r\n    //    The management proxy may perform \"reversible\" operations on\r\n    //    behalf of the owner. This includes public key configuration and\r\n    //    operations relating to sponsorship.\r\n    //\r\n    function setManagementProxy(uint32 _point, address _manager)\r\n      external\r\n      activePointOwner(_point)\r\n    {\r\n      azimuth.setManagementProxy(_point, _manager);\r\n    }\r\n\r\n    //  setSpawnProxy(): give _spawnProxy the right to spawn points\r\n    //                   with the prefix _prefix\r\n    //\r\n    function setSpawnProxy(uint16 _prefix, address _spawnProxy)\r\n      external\r\n      activePointOwner(_prefix)\r\n    {\r\n      azimuth.setSpawnProxy(_prefix, _spawnProxy);\r\n    }\r\n\r\n    //  setVotingProxy(): configure the voting proxy for _galaxy\r\n    //\r\n    //    the voting proxy is allowed to start polls and cast votes\r\n    //    on the point's behalf.\r\n    //\r\n    function setVotingProxy(uint8 _galaxy, address _voter)\r\n      external\r\n      activePointOwner(_galaxy)\r\n    {\r\n      azimuth.setVotingProxy(_galaxy, _voter);\r\n    }\r\n\r\n    //  setTransferProxy(): give _transferProxy the right to transfer _point\r\n    //\r\n    //    Requirements:\r\n    //    - :msg.sender must be either _point's current owner,\r\n    //      or be an operator for the current owner\r\n    //\r\n    function setTransferProxy(uint32 _point, address _transferProxy)\r\n      public\r\n    {\r\n      //  owner: owner of _point\r\n      //\r\n      address owner = azimuth.getOwner(_point);\r\n\r\n      //  caller must be :owner, or an operator designated by the owner.\r\n      //\r\n      require((owner == msg.sender) || azimuth.isOperator(owner, msg.sender));\r\n\r\n      //  set transfer proxy field in Azimuth contract\r\n      //\r\n      azimuth.setTransferProxy(_point, _transferProxy);\r\n\r\n      //  emit Approval event\r\n      //\r\n      emit Approval(owner, _transferProxy, uint256(_point));\r\n    }\r\n\r\n  //\r\n  //  Poll actions\r\n  //\r\n\r\n    //  startUpgradePoll(): as _galaxy, start a poll for the ecliptic\r\n    //                      upgrade _proposal\r\n    //\r\n    //    Requirements:\r\n    //    - :msg.sender must be the owner or voting proxy of _galaxy,\r\n    //    - the _proposal must expect to be upgraded from this specific\r\n    //      contract, as indicated by its previousEcliptic attribute\r\n    //\r\n    function startUpgradePoll(uint8 _galaxy, EclipticBase _proposal)\r\n      external\r\n      activePointVoter(_galaxy)\r\n    {\r\n      //  ensure that the upgrade target expects this contract as the source\r\n      //\r\n      require(_proposal.previousEcliptic() == address(this));\r\n      polls.startUpgradePoll(_proposal);\r\n    }\r\n\r\n    //  startDocumentPoll(): as _galaxy, start a poll for the _proposal\r\n    //\r\n    //    the _proposal argument is the keccak-256 hash of any arbitrary\r\n    //    document or string of text\r\n    //\r\n    function startDocumentPoll(uint8 _galaxy, bytes32 _proposal)\r\n      external\r\n      activePointVoter(_galaxy)\r\n    {\r\n      polls.startDocumentPoll(_proposal);\r\n    }\r\n\r\n    //  castUpgradeVote(): as _galaxy, cast a _vote on the ecliptic\r\n    //                     upgrade _proposal\r\n    //\r\n    //    _vote is true when in favor of the proposal, false otherwise\r\n    //\r\n    //    If this vote results in a majority for the _proposal, it will\r\n    //    be upgraded to immediately.\r\n    //\r\n    function castUpgradeVote(uint8 _galaxy,\r\n                              EclipticBase _proposal,\r\n                              bool _vote)\r\n      external\r\n      activePointVoter(_galaxy)\r\n    {\r\n      //  majority: true if the vote resulted in a majority, false otherwise\r\n      //\r\n      bool majority = polls.castUpgradeVote(_galaxy, _proposal, _vote);\r\n\r\n      //  if a majority is in favor of the upgrade, it happens as defined\r\n      //  in the ecliptic base contract\r\n      //\r\n      if (majority)\r\n      {\r\n        upgrade(_proposal);\r\n      }\r\n    }\r\n\r\n    //  castDocumentVote(): as _galaxy, cast a _vote on the _proposal\r\n    //\r\n    //    _vote is true when in favor of the proposal, false otherwise\r\n    //\r\n    function castDocumentVote(uint8 _galaxy, bytes32 _proposal, bool _vote)\r\n      external\r\n      activePointVoter(_galaxy)\r\n    {\r\n      polls.castDocumentVote(_galaxy, _proposal, _vote);\r\n    }\r\n\r\n    //  updateUpgradePoll(): check whether the _proposal has achieved\r\n    //                      majority, upgrading to it if it has\r\n    //\r\n    function updateUpgradePoll(EclipticBase _proposal)\r\n      external\r\n    {\r\n      //  majority: true if the poll ended in a majority, false otherwise\r\n      //\r\n      bool majority = polls.updateUpgradePoll(_proposal);\r\n\r\n      //  if a majority is in favor of the upgrade, it happens as defined\r\n      //  in the ecliptic base contract\r\n      //\r\n      if (majority)\r\n      {\r\n        upgrade(_proposal);\r\n      }\r\n    }\r\n\r\n    //  updateDocumentPoll(): check whether the _proposal has achieved majority\r\n    //\r\n    //    Note: the polls contract publicly exposes the function this calls,\r\n    //    but we offer it in the ecliptic interface as a convenience\r\n    //\r\n    function updateDocumentPoll(bytes32 _proposal)\r\n      external\r\n    {\r\n      polls.updateDocumentPoll(_proposal);\r\n    }\r\n\r\n  //\r\n  //  Contract owner operations\r\n  //\r\n\r\n    //  createGalaxy(): grant _target ownership of the _galaxy and register\r\n    //                  it for voting\r\n    //\r\n    function createGalaxy(uint8 _galaxy, address _target)\r\n      external\r\n      onlyOwner\r\n    {\r\n      //  only currently unowned (and thus also inactive) galaxies can be\r\n      //  created, and only to non-zero addresses\r\n      //\r\n      require( azimuth.isOwner(_galaxy, 0x0) &&\r\n               0x0 != _target );\r\n\r\n      //  new galaxy means a new registered voter\r\n      //\r\n      polls.incrementTotalVoters();\r\n\r\n      //  if the caller is sending the galaxy to themselves,\r\n      //  assume it knows what it's doing and resolve right away\r\n      //\r\n      if (msg.sender == _target)\r\n      {\r\n        doSpawn(_galaxy, _target, true, 0x0);\r\n      }\r\n      //\r\n      //  when sending to a \"foreign\" address, enforce a withdraw pattern,\r\n      //  making the caller the owner in the mean time\r\n      //\r\n      else\r\n      {\r\n        doSpawn(_galaxy, _target, false, msg.sender);\r\n      }\r\n    }\r\n\r\n    function setDnsDomains(string _primary, string _secondary, string _tertiary)\r\n      external\r\n      onlyOwner\r\n    {\r\n      azimuth.setDnsDomains(_primary, _secondary, _tertiary);\r\n    }\r\n\r\n  //\r\n  //  Function modifiers for this contract\r\n  //\r\n\r\n    //  validPointId(): require that _id is a valid point\r\n    //\r\n    modifier validPointId(uint256 _id)\r\n    {\r\n      require(_id < 0x100000000);\r\n      _;\r\n    }\r\n\r\n    //  activePointVoter(): require that :msg.sender can vote as _point,\r\n    //                      and that _point is active\r\n    //\r\n    modifier activePointVoter(uint32 _point)\r\n    {\r\n      require( azimuth.canVoteAs(_point, msg.sender) &&\r\n               azimuth.isActive(_point) );\r\n      _;\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n//  Delegated Sending\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n//  DelegatedSending: invite-like point sending\r\n//\r\n//    This contract allows planet owners to gift planets to their friends,\r\n//    if a star has allowed it.\r\n//\r\n//    Star owners can grant a number of \"invites\" to planets. An \"invite\" in\r\n//    the context of this contract means a planet from the same parent star,\r\n//    that can be sent to an Ethereum address that owns no points.\r\n//    Planets that were sent as invites are also allowed to send invites, but\r\n//    instead of adhering to a star-set limit, they will use up invites from\r\n//    the same \"pool\" as their inviter.\r\n//\r\n//    To allow planets to be sent by this contract, stars must set it as\r\n//    their spawnProxy using the Ecliptic.\r\n//\r\ncontract DelegatedSending is ReadsAzimuth\r\n{\r\n  //  Pool: :who was given their own pool by :prefix, of :size invites\r\n  //\r\n  event Pool(uint16 indexed prefix, uint32 indexed who, uint16 size);\r\n\r\n  //  Sent: :by sent :point\r\n  //\r\n  event Sent( uint16 indexed prefix,\r\n              uint32 indexed fromPool,\r\n              uint32 by,\r\n              uint32 point,\r\n              address to);\r\n\r\n  //  pools: per pool, the amount of planets that can still be given away\r\n  //         per star by the pool's planet itself or the ones it invited\r\n  //\r\n  //    pools are associated with planets by number,\r\n  //    then with stars by number.\r\n  //    pool 0 does not exist, and is used symbolically by :fromPool.\r\n  //\r\n  mapping(uint32 => mapping(uint16 => uint16)) public pools;\r\n\r\n  //  fromPool: per planet, the pool from which they send invites\r\n  //\r\n  //    when invited by planet n, the invitee sends from n's pool.\r\n  //    a pool of 0 means the planet has its own invite pool.\r\n  //\r\n  mapping(uint32 => uint32) public fromPool;\r\n\r\n  //  poolStars: per pool, the stars from which it has received invites\r\n  //\r\n  mapping(uint32 => uint16[]) public poolStars;\r\n\r\n  //  poolStarsRegistered: per pool, per star, whether or not it is in\r\n  //                       the :poolStars array\r\n  //\r\n  mapping(uint32 => mapping(uint16 => bool)) public poolStarsRegistered;\r\n\r\n  //  inviters: points with their own pools, invite tree roots\r\n  //\r\n  uint32[] public inviters;\r\n\r\n  //  isInviter: whether or not a point is in the :inviters list\r\n  //\r\n  mapping(uint32 => bool) public isInviter;\r\n\r\n  //  invited: for each point, the points they invited\r\n  //\r\n  mapping(uint32 => uint32[]) public invited;\r\n\r\n  //  invitedBy: for each point, the point they were invited by\r\n  //\r\n  mapping(uint32 => uint32) public invitedBy;\r\n\r\n  //  constructor(): register the azimuth contract\r\n  //\r\n  constructor(Azimuth _azimuth)\r\n    ReadsAzimuth(_azimuth)\r\n    public\r\n  {\r\n    //\r\n  }\r\n\r\n  //  setPoolSize(): give _for their own pool if they don't have one already,\r\n  //                 and allow them to send _size points from _as\r\n  //\r\n  function setPoolSize(uint16 _as, uint32 _for, uint16 _size)\r\n    external\r\n    activePointOwner(_as)\r\n  {\r\n    fromPool[_for] = 0;\r\n    pools[_for][_as] = _size;\r\n\r\n    //  register star as having given invites to pool,\r\n    //  if that hasn't happened yet\r\n    //\r\n    if (false == poolStarsRegistered[_for][_as]) {\r\n      poolStars[_for].push(_as);\r\n      poolStarsRegistered[_for][_as] = true;\r\n    }\r\n\r\n    //  add _for as an invite tree root\r\n    //\r\n    if (false == isInviter[_for])\r\n    {\r\n      isInviter[_for] = true;\r\n      inviters.push(_for);\r\n    }\r\n\r\n    emit Pool(_as, _for, _size);\r\n  }\r\n\r\n  //  sendPoint(): as the point _as, spawn the point _point to _to.\r\n  //\r\n  //    Requirements:\r\n  //    - :msg.sender must be the owner of _as,\r\n  //    - _to must not be the :msg.sender,\r\n  //    - _as must be able to send the _point according to canSend()\r\n  //\r\n  function sendPoint(uint32 _as, uint32 _point, address _to)\r\n    external\r\n    activePointOwner(_as)\r\n  {\r\n    require(canSend(_as, _point));\r\n\r\n    //  caller may not send to themselves\r\n    //\r\n    require(msg.sender != _to);\r\n\r\n    //  recipient must be eligible to receive a planet from this contract\r\n    //\r\n    require(canReceive(_to));\r\n\r\n    //  remove an invite from _as' current pool\r\n    //\r\n    uint32 pool = getPool(_as);\r\n    uint16 prefix = azimuth.getPrefix(_point);\r\n    pools[pool][prefix]--;\r\n\r\n    //  associate the _point with this pool\r\n    //\r\n    fromPool[_point] = pool;\r\n\r\n    //  add _point to _as' invite tree\r\n    //\r\n    invited[_as].push(_point);\r\n    invitedBy[_point] = _as;\r\n\r\n    //  spawn _point to _to, they still need to accept the transfer manually\r\n    //\r\n    Ecliptic(azimuth.owner()).spawn(_point, _to);\r\n\r\n    emit Sent(prefix, pool, _as, _point, _to);\r\n  }\r\n\r\n  //  canSend(): check whether current conditions allow _as to send _point\r\n  //\r\n  function canSend(uint32 _as, uint32 _point)\r\n    public\r\n    view\r\n    returns (bool result)\r\n  {\r\n    uint16 prefix = azimuth.getPrefix(_point);\r\n    uint32 pool = getPool(_as);\r\n    return ( //  _as' pool for this prefix must not have been exhausted yet\r\n             //\r\n             (0 < pools[pool][prefix]) &&\r\n             //\r\n             //  _point needs to not be (in the process of being) spawned\r\n             //\r\n             azimuth.isOwner(_point, 0x0) &&\r\n             //\r\n             //  this contract must have permission to spawn points\r\n             //\r\n             azimuth.isSpawnProxy(prefix, this) &&\r\n             //\r\n             //  the prefix must be linked\r\n             //\r\n             azimuth.hasBeenLinked(prefix) &&\r\n             //\r\n             //  the prefix must not have hit its spawn limit yet\r\n             //\r\n             ( azimuth.getSpawnCount(prefix) <\r\n               Ecliptic(azimuth.owner())\r\n               .getSpawnLimit(prefix, block.timestamp) ) );\r\n  }\r\n\r\n  //  getPool(): get the invite pool _point belongs to\r\n  //\r\n  function getPool(uint32 _point)\r\n    public\r\n    view\r\n    returns (uint32 pool)\r\n  {\r\n    pool = fromPool[_point];\r\n\r\n    //  no pool explicitly registered means they have their own pool,\r\n    //  because they either were not invited by this contract, or have\r\n    //  been granted their own pool by their star.\r\n    //\r\n    if (0 == pool)\r\n    {\r\n      //  send from the planet's own pool, see also :fromPool\r\n      //\r\n      return _point;\r\n    }\r\n\r\n    return pool;\r\n  }\r\n\r\n  //  canReceive(): whether the _recipient is eligible to receive a planet\r\n  //                from this contract or not\r\n  //\r\n  //    only those who don't own or are entitled to any points may receive\r\n  //\r\n  function canReceive(address _recipient)\r\n    public\r\n    view\r\n    returns (bool result)\r\n  {\r\n    return ( 0 == azimuth.getOwnedPointCount(_recipient) &&\r\n             0 == azimuth.getTransferringForCount(_recipient) );\r\n  }\r\n\r\n  //  getPoolStars(): returns a list of stars _who has pools for\r\n  //\r\n  function getPoolStars(uint32 _who)\r\n    external\r\n    view\r\n    returns (uint16[] stars)\r\n  {\r\n    return poolStars[_who];\r\n  }\r\n\r\n  //  getInviters(): returns a list of all points with their own pools\r\n  //\r\n  function getInviters()\r\n    external\r\n    view\r\n    returns (uint32[] invs)\r\n  {\r\n    return inviters;\r\n  }\r\n\r\n  //  getInvited(): returns a list of points invited by _who\r\n  //\r\n  function getInvited(uint32 _who)\r\n    external\r\n    view\r\n    returns (uint32[] invd)\r\n  {\r\n    return invited[_who];\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getInviters\",\"outputs\":[{\"name\":\"invs\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"isInviter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"poolStarsRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"invitedBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"pools\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_as\",\"type\":\"uint32\"},{\"name\":\"_point\",\"type\":\"uint32\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"sendPoint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"fromPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_as\",\"type\":\"uint32\"},{\"name\":\"_point\",\"type\":\"uint32\"}],\"name\":\"canSend\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"inviters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolStars\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"canReceive\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"invited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_point\",\"type\":\"uint32\"}],\"name\":\"getPool\",\"outputs\":[{\"name\":\"pool\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"uint32\"}],\"name\":\"getPoolStars\",\"outputs\":[{\"name\":\"stars\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"azimuth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"uint32\"}],\"name\":\"getInvited\",\"outputs\":[{\"name\":\"invd\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_as\",\"type\":\"uint16\"},{\"name\":\"_for\",\"type\":\"uint32\"},{\"name\":\"_size\",\"type\":\"uint16\"}],\"name\":\"setPoolSize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_azimuth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prefix\",\"type\":\"uint16\"},{\"indexed\":true,\"name\":\"who\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"size\",\"type\":\"uint16\"}],\"name\":\"Pool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prefix\",\"type\":\"uint16\"},{\"indexed\":true,\"name\":\"fromPool\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"by\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"point\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Sent\",\"type\":\"event\"}]","ContractName":"DelegatedSending","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000223c067f8cf28ae173ee5cafea60ca44c335fecb","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://c3e090bdc98c036b421a1fe9195484d6c637a7cbd60674bdb2b7c38412122e01"}]}