{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\r\n\r\n/**\r\n * @title ERC20 compatible token interface\r\n *\r\n * - Implements ERC 20 Token standard\r\n * - Implements short address attack fix\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IToken { \r\n\r\n    /** \r\n     * Get the total supply of tokens\r\n     * \r\n     * @return The total supply\r\n     */\r\n    function totalSupply() external view returns (uint);\r\n\r\n\r\n    /** \r\n     * Get balance of `_owner` \r\n     * \r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `msg.sender`\r\n     * \r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint _value) external returns (bool);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     * \r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool);\r\n\r\n\r\n    /** \r\n     * `msg.sender` approves `_spender` to spend `_value` tokens\r\n     * \r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint _value) external returns (bool);\r\n\r\n\r\n    /** \r\n     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\r\n     * \r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) external view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * @title ManagedToken interface\r\n *\r\n * Adds the following functionality to the basic ERC20 token\r\n * - Locking\r\n * - Issuing\r\n * - Burning \r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IManagedToken is IToken { \r\n\r\n    /** \r\n     * Returns true if the token is locked\r\n     * \r\n     * @return Whether the token is locked\r\n     */\r\n    function isLocked() external view returns (bool);\r\n\r\n\r\n    /**\r\n     * Locks the token so that the transfering of value is disabled \r\n     *\r\n     * @return Whether the unlocking was successful or not\r\n     */\r\n    function lock() external returns (bool);\r\n\r\n\r\n    /**\r\n     * Unlocks the token so that the transfering of value is enabled \r\n     *\r\n     * @return Whether the unlocking was successful or not\r\n     */\r\n    function unlock() external returns (bool);\r\n\r\n\r\n    /**\r\n     * Issues `_value` new tokens to `_to`\r\n     *\r\n     * @param _to The address to which the tokens will be issued\r\n     * @param _value The amount of new tokens to issue\r\n     * @return Whether the tokens where sucessfully issued or not\r\n     */\r\n    function issue(address _to, uint _value) external returns (bool);\r\n\r\n\r\n    /**\r\n     * Burns `_value` tokens of `_from`\r\n     *\r\n     * @param _from The address that owns the tokens to be burned\r\n     * @param _value The amount of tokens to be burned\r\n     * @return Whether the tokens where sucessfully burned or not \r\n     */\r\n    function burn(address _from, uint _value) external returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title Token observer interface\r\n *\r\n * Allows a token smart-contract to notify observers \r\n * when tokens are received\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract ITokenObserver {\r\n\r\n\r\n    /**\r\n     * Called by the observed token smart-contract in order \r\n     * to notify the token observer when tokens are received\r\n     *\r\n     * @param _from The address that the tokens where send from\r\n     * @param _value The amount of tokens that was received\r\n     */\r\n    function notifyTokensReceived(address _from, uint _value) external;\r\n}\r\n\r\n\r\n/**\r\n * @title Abstract token observer\r\n *\r\n * Allows observers to be notified by an observed token smart-contract\r\n * when tokens are received\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenObserver is ITokenObserver {\r\n\r\n\r\n    /**\r\n     * Called by the observed token smart-contract in order \r\n     * to notify the token observer when tokens are received\r\n     *\r\n     * @param _from The address that the tokens where send from\r\n     * @param _value The amount of tokens that was received\r\n     */\r\n    function notifyTokensReceived(address _from, uint _value) public {\r\n        onTokensReceived(msg.sender, _from, _value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Event handler\r\n     * \r\n     * Called by `_token` when a token amount is received\r\n     *\r\n     * @param _token The token contract that received the transaction\r\n     * @param _from The account or contract that send the transaction\r\n     * @param _value The value of tokens that where received\r\n     */\r\n    function onTokensReceived(address _token, address _from, uint _value) internal;\r\n}\r\n\r\n\r\n/**\r\n * @title Token retrieve interface\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract ITokenRetriever {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) external;\r\n}\r\n\r\n\r\n/**\r\n * @title Token retrieve\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 18/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenRetriever is ITokenRetriever {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public {\r\n        IToken tokenInstance = IToken(_tokenContract);\r\n        uint tokenBalance = tokenInstance.balanceOf(address(this));\r\n        if (tokenBalance > 0) {\r\n            tokenInstance.transfer(msg.sender, tokenBalance);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Observable interface\r\n *\r\n * Allows observers to register and unregister with the \r\n * implementing smart-contract that is observable\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IObservable {\r\n\r\n\r\n    /**\r\n     * Returns true if `_account` is a registered observer\r\n     * \r\n     * @param _account The account to test against\r\n     * @return Whether the account is a registered observer\r\n     */\r\n    function isObserver(address _account) external view returns (bool);\r\n\r\n\r\n    /**\r\n     * Gets the amount of registered observers\r\n     * \r\n     * @return The amount of registered observers\r\n     */\r\n    function getObserverCount() external view returns (uint);\r\n\r\n\r\n    /**\r\n     * Gets the observer at `_index`\r\n     * \r\n     * @param _index The index of the observer\r\n     * @return The observers address\r\n     */\r\n    function getObserverAtIndex(uint _index) external view returns (address);\r\n\r\n\r\n    /**\r\n     * Register `_observer` as an observer\r\n     * \r\n     * @param _observer The account to add as an observer\r\n     */\r\n    function registerObserver(address _observer) external;\r\n\r\n\r\n    /**\r\n     * Unregister `_observer` as an observer\r\n     * \r\n     * @param _observer The account to remove as an observer\r\n     */\r\n    function unregisterObserver(address _observer) external;\r\n}\r\n\r\n\r\n/**\r\n * @title Ownership interface\r\n *\r\n * Perminent ownership\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IOwnership {\r\n\r\n    /**\r\n     * Returns true if `_account` is the current owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Gets the current owner\r\n     *\r\n     * @return address The current owner\r\n     */\r\n    function getOwner() public view returns (address);\r\n}\r\n\r\n\r\n/**\r\n * @title Ownership\r\n *\r\n * Perminent ownership\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract Ownership is IOwnership {\r\n\r\n    // Owner\r\n    address internal owner;\r\n\r\n\r\n    /**\r\n     * The publisher is the inital owner\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * Access is restricted to the current owner\r\n     */\r\n    modifier only_owner() {\r\n        require(msg.sender == owner, \"m:only_owner\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_account` is the current owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) public view returns (bool) {\r\n        return _account == owner;\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets the current owner\r\n     *\r\n     * @return address The current owner\r\n     */\r\n    function getOwner() public view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Transferable ownership interface\r\n *\r\n * Enhances ownership by allowing the current owner to \r\n * transfer ownership to a new owner\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract ITransferableOwnership {\r\n    \r\n\r\n    /**\r\n     * Transfer ownership to `_newOwner`\r\n     *\r\n     * @param _newOwner The address of the account that will become the new owner \r\n     */\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n\r\n\r\n/**\r\n * @title Transferable ownership\r\n *\r\n * Enhances ownership by allowing the current owner to \r\n * transfer ownership to a new owner\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TransferableOwnership is ITransferableOwnership, Ownership {\r\n\r\n\r\n    /**\r\n     * Transfer ownership to `_newOwner`\r\n     *\r\n     * @param _newOwner The address of the account that will become the new owner \r\n     */\r\n    function transferOwnership(address _newOwner) public only_owner {\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Multi-owned interface\r\n *\r\n * Interface that allows multiple owners\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IMultiOwned {\r\n\r\n    /**\r\n     * Returns true if `_account` is an owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Returns the amount of owners\r\n     *\r\n     * @return The amount of owners\r\n     */\r\n    function getOwnerCount() public view returns (uint);\r\n\r\n\r\n    /**\r\n     * Gets the owner at `_index`\r\n     *\r\n     * @param _index The index of the owner\r\n     * @return The address of the owner found at `_index`\r\n     */\r\n    function getOwnerAt(uint _index) public view returns (address);\r\n\r\n\r\n     /**\r\n     * Adds `_account` as a new owner\r\n     *\r\n     * @param _account The account to add as an owner\r\n     */\r\n    function addOwner(address _account) public;\r\n\r\n\r\n    /**\r\n     * Removes `_account` as an owner\r\n     *\r\n     * @param _account The account to remove as an owner\r\n     */\r\n    function removeOwner(address _account) public;\r\n}\r\n\r\n/**\r\n * @title IAuthenticator \r\n *\r\n * Authenticator interface\r\n *\r\n * #created 15/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IAuthenticator {\r\n    \r\n\r\n    /**\r\n     * Authenticate \r\n     *\r\n     * Returns whether `_account` is authenticated or not\r\n     *\r\n     * @param _account The account to authenticate\r\n     * @return whether `_account` is successfully authenticated\r\n     */\r\n    function authenticate(address _account) public view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title Dcorp Dissolvement Proposal\r\n *\r\n * Serves as a placeholder for the Dcorp funds, allowing the community the ability \r\n * to claim their part of the ether. \r\n *\r\n * This contact is deployed upon receiving the Ether that is currently held by the previous proxy contract.\r\n *\r\n * #created 18/7/2019\r\n * #author Frank Bonnet\r\n */\r\ncontract DcorpDissolvementProposal is TokenObserver, TransferableOwnership, TokenRetriever {\r\n\r\n    enum Stages {\r\n        Deploying,\r\n        Deployed,\r\n        Executed\r\n    }\r\n\r\n    struct Balance {\r\n        uint drps;\r\n        uint drpu;\r\n        uint index;\r\n    }\r\n\r\n    // State\r\n    Stages private stage;\r\n\r\n    // Settings\r\n    uint public constant CLAIMING_DURATION = 60 days;\r\n    uint public constant WITHDRAW_DURATION = 60 days;\r\n    uint public constant DISSOLVEMENT_AMOUNT = 1888 ether; // +- 355000 euro\r\n\r\n    // Alocated balances\r\n    mapping (address => Balance) private allocated;\r\n    address[] private allocatedIndex;\r\n\r\n    // Whitelist\r\n    IAuthenticator public authenticator;\r\n\r\n    // Tokens\r\n    IToken public drpsToken;\r\n    IToken public drpuToken;\r\n\r\n    // Previous proxy\r\n    address public prevProxy;\r\n    uint public prevProxyRecordedBalance;\r\n\r\n    // Dissolvement\r\n    address payable public dissolvementFund;\r\n\r\n    uint public claimTotalWeight;\r\n    uint public claimTotalEther;\r\n    uint public claimDeadline;\r\n    uint public withdrawDeadline;\r\n    \r\n\r\n    /**\r\n     * Require that the sender is authentcated\r\n     */\r\n    modifier only_authenticated() {\r\n        require(authenticator.authenticate(msg.sender), \"m:only_authenticated\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require that the contract is in `_stage` \r\n     */\r\n    modifier only_at_stage(Stages _stage) {\r\n        require(stage == _stage, \"m:only_at_stage\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require `_token` to be one of the drp tokens\r\n     *\r\n     * @param _token The address to test against\r\n     */\r\n    modifier only_accepted_token(address _token) {\r\n        require(_token == address(drpsToken) || _token == address(drpuToken), \"m:only_accepted_token\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require that `_token` is not one of the drp tokens\r\n     *\r\n     * @param _token The address to test against\r\n     */\r\n    modifier not_accepted_token(address _token) {\r\n        require(_token != address(drpsToken) && _token != address(drpuToken), \"m:not_accepted_token\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require that sender has more than zero tokens \r\n     */\r\n    modifier only_token_holder() {\r\n        require(allocated[msg.sender].drps > 0 || allocated[msg.sender].drpu > 0, \"m:only_token_holder\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require that the claiming period for the proposal has\r\n     * not yet ended\r\n     */\r\n    modifier only_during_claiming_period() {\r\n        require(claimDeadline > 0 && now <= claimDeadline, \"m:only_during_claiming_period\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require that the claiming period for the proposal has ended\r\n     */\r\n    modifier only_after_claiming_period() {\r\n        require(claimDeadline > 0 && now > claimDeadline, \"m:only_after_claiming_period\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require that the withdraw period for the proposal has\r\n     * not yet ended\r\n     */\r\n    modifier only_during_withdraw_period() {\r\n        require(withdrawDeadline > 0 && now <= withdrawDeadline, \"m:only_during_withdraw_period\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require that the withdraw period for the proposal has ended\r\n     */\r\n    modifier only_after_withdraw_period() {\r\n        require(withdrawDeadline > 0 && now > withdrawDeadline, \"m:only_after_withdraw_period\");\r\n        _;\r\n    }\r\n    \r\n\r\n    /**\r\n     * Construct the proxy\r\n     *\r\n     * @param _authenticator Whitelist\r\n     * @param _drpsToken The new security token\r\n     * @param _drpuToken The new utility token\r\n     * @param _prevProxy Proxy accepts and requires ether from the prev proxy\r\n     * @param _dissolvementFund Ether to be used for the dissolvement of DCORP\r\n     */\r\n    constructor(address _authenticator, address _drpsToken, address _drpuToken, address _prevProxy, address payable _dissolvementFund) public {\r\n        authenticator = IAuthenticator(_authenticator);\r\n        drpsToken = IToken(_drpsToken);\r\n        drpuToken = IToken(_drpuToken);\r\n        prevProxy = _prevProxy;\r\n        prevProxyRecordedBalance = _prevProxy.balance;\r\n        dissolvementFund = _dissolvementFund;\r\n        stage = Stages.Deploying;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns whether the proposal is being deployed\r\n     *\r\n     * @return Whether the proposal is in the deploying stage\r\n     */\r\n    function isDeploying() public view returns (bool) {\r\n        return stage == Stages.Deploying;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns whether the proposal is deployed. The proposal is deployed \r\n     * when it receives Ether from the prev proxy contract\r\n     *\r\n     * @return Whether the proposal is deployed\r\n     */\r\n    function isDeployed() public view returns (bool) {\r\n        return stage == Stages.Deployed;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns whether the proposal is executed\r\n     *\r\n     * @return Whether the proposal is deployed\r\n     */\r\n    function isExecuted() public view returns (bool) {\r\n        return stage == Stages.Executed;\r\n    }\r\n\r\n\r\n    /**\r\n     * Accept eth from the prev proxy while deploying\r\n     */\r\n    function () external payable only_at_stage(Stages.Deploying) {\r\n        require(msg.sender == address(prevProxy), \"f:fallback;e:invalid_sender\");\r\n    }\r\n\r\n\r\n    /**\r\n     * Deploy the proposal\r\n     */\r\n    function deploy() public only_owner only_at_stage(Stages.Deploying) {\r\n        require(address(this).balance >= prevProxyRecordedBalance, \"f:deploy;e:invalid_balance\");\r\n\r\n        // Mark deployed\r\n        stage = Stages.Deployed;\r\n        \r\n        // Start claiming period\r\n        claimDeadline = now + CLAIMING_DURATION;\r\n\r\n        // Remove prev proxy as observer\r\n        IObservable(address(drpsToken)).unregisterObserver(prevProxy);\r\n        IObservable(address(drpuToken)).unregisterObserver(prevProxy);\r\n\r\n        // Register this proxy as observer\r\n        IObservable(address(drpsToken)).registerObserver(address(this));\r\n        IObservable(address(drpuToken)).registerObserver(address(this));\r\n\r\n        // Transfer dissolvement funds\r\n        uint amountToTransfer = DISSOLVEMENT_AMOUNT;\r\n        if (amountToTransfer > address(this).balance) {\r\n            amountToTransfer = address(this).balance;\r\n        }\r\n\r\n        dissolvementFund.transfer(amountToTransfer);\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the combined total supply of all drp tokens\r\n     *\r\n     * @return The combined total drp supply\r\n     */\r\n    function getTotalSupply() public view returns (uint) {\r\n        uint sum = 0; \r\n        sum += drpsToken.totalSupply();\r\n        sum += drpuToken.totalSupply();\r\n        return sum;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_owner` has a balance allocated\r\n     *\r\n     * @param _owner The account that the balance is allocated for\r\n     * @return True if there is a balance that belongs to `_owner`\r\n     */\r\n    function hasBalance(address _owner) public view returns (bool) {\r\n        return allocatedIndex.length > 0 && _owner == allocatedIndex[allocated[_owner].index];\r\n    }\r\n\r\n\r\n    /** \r\n     * Get the allocated drps or drpu token balance of `_owner`\r\n     * \r\n     * @param _token The address to test against\r\n     * @param _owner The address from which the allocated token balance will be retrieved\r\n     * @return The allocated drps token balance\r\n     */\r\n    function balanceOf(address _token, address _owner) public view returns (uint) {\r\n        uint balance = 0;\r\n        if (address(drpsToken) == _token) {\r\n            balance = allocated[_owner].drps;\r\n        } \r\n        \r\n        else if (address(drpuToken) == _token) {\r\n            balance = allocated[_owner].drpu;\r\n        }\r\n\r\n        return balance;\r\n    }\r\n\r\n\r\n    /**\r\n     * Executes the proposal\r\n     *\r\n     * Dissolves DCORP Decentralized and allows the ether to be withdrawn\r\n     *\r\n     * Should only be called after the claiming period\r\n     */\r\n    function execute() public only_at_stage(Stages.Deployed) only_after_claiming_period {\r\n        \r\n        // Mark as executed\r\n        stage = Stages.Executed;\r\n        withdrawDeadline = now + WITHDRAW_DURATION;\r\n\r\n        // Remaining balance is claimable\r\n        claimTotalEther = address(this).balance;\r\n\r\n        // Disable tokens\r\n        IManagedToken(address(drpsToken)).lock();\r\n        IManagedToken(address(drpuToken)).lock();\r\n\r\n        // Remove self token as owner\r\n        IMultiOwned(address(drpsToken)).removeOwner(address(this));\r\n        IMultiOwned(address(drpuToken)).removeOwner(address(this));\r\n    }\r\n\r\n\r\n    /**\r\n     * Allows an account to claim ether during the claiming period\r\n     */\r\n    function withdraw() public only_at_stage(Stages.Executed) only_during_withdraw_period only_token_holder only_authenticated {\r\n        Balance storage b = allocated[msg.sender];\r\n        uint weight = b.drpu + _convertDrpsWeight(b.drps);\r\n\r\n        // Mark claimed\r\n        b.drpu = 0;\r\n        b.drps = 0;\r\n\r\n        // Transfer amount\r\n        uint amountToTransfer = weight * claimTotalEther / claimTotalWeight;\r\n        msg.sender.transfer(amountToTransfer);\r\n    }\r\n\r\n\r\n    /**\r\n     * Event handler that initializes the token conversion\r\n     * \r\n     * Called by `_token` when a token amount is received on \r\n     * the address of this token changer\r\n     *\r\n     * @param _token The token contract that received the transaction\r\n     * @param _from The account or contract that send the transaction\r\n     * @param _value The value of tokens that where received\r\n     */\r\n    function onTokensReceived(address _token, address _from, uint _value) internal only_during_claiming_period only_accepted_token(_token) {\r\n        require(_token == msg.sender, \"f:onTokensReceived;e:only_receiving_token\");\r\n\r\n        // Allocate tokens\r\n        if (!hasBalance(_from)) {\r\n            allocated[_from] = Balance(\r\n                0, 0, allocatedIndex.push(_from) - 1);\r\n        }\r\n\r\n        Balance storage b = allocated[_from];\r\n        if (_token == address(drpsToken)) {\r\n            b.drps += _value;\r\n            claimTotalWeight += _convertDrpsWeight(_value);\r\n        } else {\r\n            b.drpu += _value;\r\n            claimTotalWeight += _value;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Failsafe mechanism\r\n     * \r\n     * Allows the owner to retrieve ether from the contract that was not claimed \r\n     * within the claiming period.\r\n     */\r\n    function retrieveEther() public only_owner only_after_withdraw_period {\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * Failsafe mechanism\r\n     * \r\n     * Allows the owner to retrieve tokens (other than DRPS and DRPU tokens) from the contract that \r\n     * might have been send there by accident\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public only_owner not_accepted_token(_tokenContract) {\r\n        super.retrieveTokens(_tokenContract);\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts the weight for DRPS tokens\r\n     * \r\n     * @param _value The amount of tokens to convert\r\n     */\r\n    function _convertDrpsWeight(uint _value) private pure returns (uint) {\r\n        return _value * 2;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"claimTotalWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prevProxyRecordedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isExecuted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"retrieveEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authenticator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"drpsToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLAIMING_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prevProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deploy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WITHDRAW_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"notifyTokensReceived\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimTotalEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"drpuToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DISSOLVEMENT_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"retrieveTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dissolvementFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDeployed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDeploying\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_authenticator\",\"type\":\"address\"},{\"name\":\"_drpsToken\",\"type\":\"address\"},{\"name\":\"_drpuToken\",\"type\":\"address\"},{\"name\":\"_prevProxy\",\"type\":\"address\"},{\"name\":\"_dissolvementFund\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"DcorpDissolvementProposal","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000dd5cec9019ec8449a5d01d0d8175e6519530d2760000000000000000000000003e250a4f78410c29cfc39463a81f14a226690eb4000000000000000000000000e30e02f049957e2a5907589e06ba646fb2c321ba00000000000000000000000001d5d0108589f3c52fcce6e65503bb6515e66698000000000000000000000000a96fd4994168bf4a15aef72142ac605cf45b6d8e","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://55c3bd96d7c491d006af27fbb8738fc6b4afd39cf0aefc1dd55e590d3286a01c"}]}