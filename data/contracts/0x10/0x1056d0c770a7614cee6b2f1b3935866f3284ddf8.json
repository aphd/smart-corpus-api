{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n\r\n// @title SafeMath: overflow/underflow checks\r\n// @notice Math operations with safety checks that throw on error\r\nlibrary SafeMath {\r\n\r\n  // @notice Multiplies two numbers, throws on overflow.\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  // @notice Integer division of two numbers, truncating the quotient.\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  // @notice Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  // @notice Adds two numbers, throws on overflow.\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  // @notice Returns fractional amount\r\n  function getFractionalAmount(uint256 _amount, uint256 _percentage)\r\n  internal\r\n  pure\r\n  returns (uint256) {\r\n    return div(mul(_amount, _percentage), 100);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface ERC20 {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address _who) external view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/DividendInterface.sol\r\n\r\ninterface DividendInterface{\r\n  function issueDividends(uint _amount) external payable returns (bool);\r\n\r\n  // @dev Total number of tokens in existence\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function getERC20() external view returns (address);\r\n}\r\n\r\n// File: contracts/interfaces/KyberInterface.sol\r\n\r\n// @notice Trade via the Kyber Proxy Contract\r\ninterface KyberInterface {\r\n  function getExpectedRate(address src, address dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\r\n  function trade(address src, uint srcAmount, address dest, address destAddress, uint maxDestAmount,uint minConversionRate, address walletId) external payable returns(uint);\r\n}\r\n\r\n// File: contracts/interfaces/MinterInterface.sol\r\n\r\ninterface MinterInterface {\r\n  function cloneToken(string _uri, address _erc20Address) external returns (address asset);\r\n\r\n  function mintAssetTokens(address _assetAddress, address _receiver, uint256 _amount) external returns (bool);\r\n\r\n  function changeTokenController(address _assetAddress, address _newController) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/CrowdsaleReserveInterface.sol\r\n\r\ninterface CrowdsaleReserveInterface {\r\n  function issueETH(address _receiver, uint256 _amount) external returns (bool);\r\n  function receiveETH(address _payer) external payable returns (bool);\r\n  function refundETHAsset(address _asset, uint256 _amount) external returns (bool);\r\n  function issueERC20(address _receiver, uint256 _amount, address _tokenAddress) external returns (bool);\r\n  function requestERC20(address _payer, uint256 _amount, address _tokenAddress) external returns (bool);\r\n  function approveERC20(address _receiver, uint256 _amount, address _tokenAddress) external returns (bool);\r\n  function refundERC20Asset(address _asset, uint256 _amount, address _tokenAddress) external returns (bool);\r\n}\r\n\r\n// File: contracts/crowdsale/CrowdsaleERC20.sol\r\n\r\ninterface Events {\r\n  function transaction(string _message, address _from, address _to, uint _amount, address _token)  external;\r\n  function asset(string _message, string _uri, address _assetAddress, address _manager);\r\n}\r\ninterface DB {\r\n  function addressStorage(bytes32 _key) external view returns (address);\r\n  function uintStorage(bytes32 _key) external view returns (uint);\r\n  function setUint(bytes32 _key, uint _value) external;\r\n  function deleteUint(bytes32 _key) external;\r\n  function setBool(bytes32 _key, bool _value) external;\r\n  function boolStorage(bytes32 _key) external view returns (bool);\r\n}\r\n\r\n// @title An asset crowdsale contract which accepts funding from ERC20 tokens.\r\n// @notice Begins a crowdfunding period for a digital asset, minting asset dividend tokens to investors when particular ERC20 token is received\r\n// @author Kyle Dewhurst, MyBit Foundation\r\n// @notice creates a dividend token to represent the newly created asset.\r\ncontract CrowdsaleERC20{\r\n  using SafeMath for uint256;\r\n\r\n  DB private database;\r\n  Events private events;\r\n  MinterInterface private minter;\r\n  CrowdsaleReserveInterface private reserve;\r\n  KyberInterface private kyber;\r\n\r\n  // @notice Constructor: initializes database instance\r\n  // @param: The address for the platform database\r\n  constructor(address _database, address _events, address _kyber)\r\n  public{\r\n      database = DB(_database);\r\n      events = Events(_events);\r\n      minter = MinterInterface(database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"Minter\"))));\r\n      reserve = CrowdsaleReserveInterface(database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"CrowdsaleReserve\"))));\r\n      kyber = KyberInterface(_kyber);\r\n  }\r\n\r\n  // @notice Investors can send ERC20 tokens here to fund an asset, receiving an equivalent number of asset-tokens.\r\n  // @dev investor must approve this contract to transfer tokens\r\n  // @param (address) _assetAddress = The address of the asset tokens, investor wishes to purchase\r\n  // @param (uint) _amount = The amount to spend purchasing this asset\r\n  function buyAssetOrderERC20(address _assetAddress, uint _amount, address _paymentToken)\r\n  external\r\n  payable\r\n  returns (bool) {\r\n    require(database.addressStorage(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress))) != address(0), \"Invalid asset\");\r\n    require(now <= database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress))), \"Past deadline\");\r\n    require(!database.boolStorage(keccak256(abi.encodePacked(\"crowdsale.finalized\", _assetAddress))), \"Crowdsale finalized\");\r\n\r\n    if(_paymentToken == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)){\r\n      require(msg.value == _amount, 'Msg.value does not match amount');\r\n    } else {\r\n      require(msg.value == 0, 'Msg.value should equal zero');\r\n    }\r\n    ERC20 fundingToken = ERC20(DividendInterface(_assetAddress).getERC20());\r\n    uint fundingRemaining = database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.remaining\", _assetAddress)));\r\n    uint collected; //This will be the value received by the contract after any conversions\r\n    uint amount; //The number of tokens that will be minted\r\n    //Check if the payment token is the same as the funding token. If not, convert, else just collect the funds\r\n    if(_paymentToken == address(fundingToken)){\r\n      collected = collectPayment(msg.sender, _amount, fundingRemaining, fundingToken);\r\n    } else {\r\n      collected = convertTokens(msg.sender, _amount, fundingToken, ERC20(_paymentToken), fundingRemaining);\r\n    }\r\n    require(collected > 0);\r\n    if(collected < fundingRemaining){\r\n      amount = collected.mul(100).div(uint(100).add(database.uintStorage(keccak256(abi.encodePacked(\"platform.fee\")))));\r\n      database.setUint(keccak256(abi.encodePacked(\"crowdsale.remaining\", _assetAddress)), fundingRemaining.sub(collected));\r\n      require(minter.mintAssetTokens(_assetAddress, msg.sender, amount), \"Investor minting failed\");\r\n      require(fundingToken.transfer(address(reserve), collected));\r\n    } else {\r\n      amount = fundingRemaining.mul(100).div(uint(100).add(database.uintStorage(keccak256(abi.encodePacked(\"platform.fee\")))));\r\n      database.setBool(keccak256(abi.encodePacked(\"crowdsale.finalized\", _assetAddress)), true);\r\n      database.deleteUint(keccak256(abi.encodePacked(\"crowdsale.remaining\", _assetAddress)));\r\n      require(minter.mintAssetTokens(_assetAddress, msg.sender, amount), \"Investor minting failed\");   // Send remaining asset tokens to investor\r\n      require(fundingToken.transfer(address(reserve), fundingRemaining));\r\n      events.asset('Crowdsale finalized', '', _assetAddress, msg.sender);\r\n      if(collected > fundingRemaining){\r\n        require(fundingToken.transfer(msg.sender, collected.sub(fundingRemaining)));    // return extra funds\r\n      }\r\n    }\r\n    events.transaction('Asset purchased', address(this), msg.sender, amount, _assetAddress);\r\n    return true;\r\n  }\r\n\r\n  // @notice This is called once funding has succeeded. Sends Ether to a distribution contract where operator/assetManager can withdraw\r\n  // @dev The contract manager needs to know  the address PlatformDistribution contract\r\n  function payoutERC20(address _assetAddress)\r\n  external\r\n  whenNotPaused\r\n  returns (bool) {\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\"crowdsale.finalized\", _assetAddress))), \"Crowdsale not finalized\");\r\n    require(!database.boolStorage(keccak256(abi.encodePacked(\"crowdsale.paid\", _assetAddress))), \"Crowdsale has paid out\");\r\n    //Set paid to true\r\n    database.setBool(keccak256(abi.encodePacked(\"crowdsale.paid\", _assetAddress)), true);\r\n    //Setup token\r\n    address fundingToken = DividendInterface(_assetAddress).getERC20();\r\n    //Mint tokens for the asset manager and platform\r\n    address platformAssetsWallet = database.addressStorage(keccak256(abi.encodePacked(\"platform.wallet.assets\")));\r\n    require(platformAssetsWallet != address(0), \"Platform assets wallet not set\");\r\n    require(minter.mintAssetTokens(_assetAddress, database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"AssetManagerFunds\"))), database.uintStorage(keccak256(abi.encodePacked(\"asset.managerTokens\", _assetAddress)))), \"Manager minting failed\");\r\n    require(minter.mintAssetTokens(_assetAddress, platformAssetsWallet, database.uintStorage(keccak256(abi.encodePacked(\"asset.platformTokens\", _assetAddress)))), \"Platform minting failed\");\r\n    //Get the addresses for the receiver and platform\r\n    address receiver = database.addressStorage(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress)));\r\n    address platformFundsWallet = database.addressStorage(keccak256(abi.encodePacked(\"platform.wallet.funds\")));\r\n    require(receiver != address(0) && platformFundsWallet != address(0), \"Platform funds walllet or receiver address not set\");\r\n    //Calculate amounts for platform and receiver\r\n    uint amount = database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.goal\", _assetAddress)));\r\n    uint platformFee = amount.getFractionalAmount(database.uintStorage(keccak256(abi.encodePacked(\"platform.fee\"))));\r\n    //Transfer funds to receiver and platform\r\n    require(reserve.issueERC20(platformFundsWallet, platformFee, fundingToken), 'Platform funds not paid');\r\n    require(reserve.issueERC20(receiver, amount, fundingToken), 'Receiver funds not paid');\r\n    //Delete crowdsale start time\r\n    database.deleteUint(keccak256(abi.encodePacked(\"crowdsale.start\", _assetAddress)));\r\n    //Increase asset count for manager\r\n    address manager = database.addressStorage(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress)));\r\n    database.setUint(keccak256(abi.encodePacked(\"manager.assets\", manager)), database.uintStorage(keccak256(abi.encodePacked(\"manager.assets\", manager))).add(1));\r\n    //Emit event\r\n    events.transaction('Asset payout', _assetAddress, receiver, amount, fundingToken);\r\n    return true;\r\n  }\r\n\r\n  function cancel(address _assetAddress)\r\n  external\r\n  whenNotPaused\r\n  validAsset(_assetAddress)\r\n  beforeDeadline(_assetAddress)\r\n  notFinalized(_assetAddress)\r\n  returns (bool){\r\n    require(msg.sender == database.addressStorage(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress))));\r\n    database.setUint(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress)), 1);\r\n    refund(_assetAddress);\r\n  }\r\n\r\n  // @notice Contributors can retrieve their funds here if crowdsale has paased deadline\r\n  // @param (address) _assetAddress =  The address of the asset which didn't reach it's crowdfunding goals\r\n  function refund(address _assetAddress)\r\n  public\r\n  whenNotPaused\r\n  validAsset(_assetAddress)\r\n  afterDeadline(_assetAddress)\r\n  notFinalized(_assetAddress)\r\n  returns (bool) {\r\n    require(database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress))) != 0);\r\n    database.deleteUint(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress)));\r\n    DividendInterface assetToken = DividendInterface(_assetAddress);\r\n    address tokenAddress = assetToken.getERC20();\r\n    uint refundValue = assetToken.totalSupply().mul(uint(100).add(database.uintStorage(keccak256(abi.encodePacked(\"platform.fee\"))))).div(100); //total supply plus platform fees\r\n    reserve.refundERC20Asset(_assetAddress, refundValue, tokenAddress);\r\n    return true;\r\n  }\r\n\r\n  //------------------------------------------------------------------------------------------------------------------\r\n  //                                            Internal Functions\r\n  //------------------------------------------------------------------------------------------------------------------\r\n\r\n  function collectPayment(address user, uint amount, uint max, ERC20 token)\r\n  private\r\n  returns (uint){\r\n    if(amount > max){\r\n      token.transferFrom(user, address(this), max);\r\n      return max;\r\n    } else {\r\n      token.transferFrom(user, address(this), amount);\r\n      return amount;\r\n    }\r\n  }\r\n\r\n  /*\r\n  function fundBurn(address _investor, uint _amount, bytes4 _sig, ERC20 _burnToken)\r\n  private\r\n  returns (uint) {\r\n    require(_burnToken.transferFrom(_investor, address(this), _amount), \"Transfer failed\"); // transfer investors tokens into contract\r\n    uint balanceBefore = _burnToken.balanceOf(this);\r\n    require(burner.burn(address(this), database.uintStorage(keccak256(abi.encodePacked(_sig, address(this)))), address(_burnToken)));\r\n    uint change = _burnToken.balanceOf(this) - balanceBefore;\r\n    return change;\r\n  }\r\n  */\r\n\r\n  function convertTokens(address _investor, uint _amount, /*bytes4 _sig,*/ ERC20 _fundingToken, ERC20 _paymentToken, uint _maxTokens)\r\n  private\r\n  returns (uint) {\r\n    //( , uint minRate) = kyber.getExpectedRate(address(_paymentToken), address(_fundingToken), 0);\r\n    uint paymentBalanceBefore;\r\n    uint fundingBalanceBefore;\r\n    uint change;\r\n    uint investment;\r\n    if(address(_paymentToken) == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)){\r\n      paymentBalanceBefore = address(this).balance;\r\n      fundingBalanceBefore = _fundingToken.balanceOf(this);\r\n      //Convert remaining funds into the funding token\r\n      kyber.trade.value(_amount)(address(_paymentToken), _amount, address(_fundingToken), address(this), _maxTokens, 0, 0);\r\n      change = _amount.sub(paymentBalanceBefore.sub(address(this).balance));\r\n      investment = _fundingToken.balanceOf(this).sub(fundingBalanceBefore);\r\n      if(change > 0){\r\n        _investor.transfer(change);\r\n      }\r\n    } else {\r\n      //Collect funds\r\n      collectPayment(_investor, _amount, _amount, _paymentToken);\r\n      // Mitigate ERC20 Approve front-running attack, by initially setting\r\n      // allowance to 0\r\n      require(_paymentToken.approve(address(kyber), 0));\r\n      // Approve tokens so network can take them during the swap\r\n      _paymentToken.approve(address(kyber), _amount);\r\n      paymentBalanceBefore = _paymentToken.balanceOf(this);\r\n      fundingBalanceBefore = _fundingToken.balanceOf(this);\r\n      //Convert remaining funds into the funding token\r\n      kyber.trade(address(_paymentToken), _amount, address(_fundingToken), address(this), _maxTokens, 0, 0);\r\n      // Return any remaining source tokens to user\r\n      change = _amount.sub(paymentBalanceBefore.sub(_paymentToken.balanceOf(this)));\r\n      investment = _fundingToken.balanceOf(this).sub(fundingBalanceBefore);\r\n      if(change > 0){\r\n        _paymentToken.transfer(_investor, change);\r\n      }\r\n    }\r\n\r\n    emit Convert(address(_paymentToken), change, investment);\r\n    return investment;\r\n  }\r\n\r\n  // @notice platform owners can recover tokens here\r\n  function recoverTokens(address _erc20Token)\r\n  onlyOwner\r\n  external {\r\n    ERC20 thisToken = ERC20(_erc20Token);\r\n    uint contractBalance = thisToken.balanceOf(address(this));\r\n    thisToken.transfer(msg.sender, contractBalance);\r\n  }\r\n\r\n  // @notice platform owners can destroy contract here\r\n  function destroy()\r\n  onlyOwner\r\n  external {\r\n    events.transaction('CrowdsaleERC20 destroyed', address(this), msg.sender, address(this).balance, address(0));\r\n    //emit LogDestruction(address(this).balance, msg.sender);\r\n    selfdestruct(msg.sender);\r\n  }\r\n\r\n  // @notice fallback function. We need to receive Ether from Kyber Network\r\n  function ()\r\n  external\r\n  payable {\r\n    emit EtherReceived(msg.sender, msg.value);\r\n  }\r\n\r\n  //------------------------------------------------------------------------------------------------------------------\r\n  //                                            Modifiers\r\n  //------------------------------------------------------------------------------------------------------------------\r\n\r\n  // @notice Sender must be a registered owner\r\n  modifier onlyOwner {\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\"owner\", msg.sender))), \"Not owner\");\r\n    _;\r\n  }\r\n\r\n  // @notice function won't run if owners have paused this contract\r\n  modifier whenNotPaused {\r\n    require(!database.boolStorage(keccak256(abi.encodePacked(\"paused\", address(this)))));\r\n    _;\r\n  }\r\n\r\n  // @notice reverts if the asset does not have a token address set in the database\r\n  modifier validAsset(address _assetAddress) {\r\n    require(database.addressStorage(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress))) != address(0), \"Invalid asset\");\r\n    _;\r\n  }\r\n\r\n  // @notice reverts if the funding deadline has not passed\r\n  modifier beforeDeadline(address _assetAddress) {\r\n    require(now < database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress))), \"Before deadline\");\r\n    _;\r\n  }\r\n\r\n  // @notice reverts if the funding deadline has already past or crowsale has not started\r\n  modifier betweenDeadlines(address _assetAddress) {\r\n    require(now <= database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress))), \"Past deadline\");\r\n    require(now >= database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.start\", _assetAddress))), \"Before start time\");\r\n    _;\r\n  }\r\n\r\n  // @notice reverts if the funding deadline has already past\r\n  modifier afterDeadline(address _assetAddress) {\r\n    require(now > database.uintStorage(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress))), \"Before deadline\");\r\n    _;\r\n  }\r\n\r\n  // @notice returns true if crowdsale is finshed\r\n  modifier finalized(address _assetAddress) {\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\"crowdsale.finalized\", _assetAddress))), \"Crowdsale not finalized\");\r\n    _;\r\n  }\r\n\r\n  // @notice returns true if crowdsale is not finshed\r\n  modifier notFinalized(address _assetAddress) {\r\n    require(!database.boolStorage(keccak256(abi.encodePacked(\"crowdsale.finalized\", _assetAddress))), \"Crowdsale finalized\");\r\n    _;\r\n  }\r\n\r\n  // @notice returns true if crowdsale has not paid out\r\n  modifier notPaid(address _assetAddress) {\r\n    require(!database.boolStorage(keccak256(abi.encodePacked(\"crowdsale.paid\", _assetAddress))), \"Crowdsale has paid out\");\r\n    _;\r\n  }\r\n\r\n  event Convert(address token, uint change, uint investment);\r\n  event EtherReceived(address sender, uint amount);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"payoutERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_erc20Token\",\"type\":\"address\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"cancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_paymentToken\",\"type\":\"address\"}],\"name\":\"buyAssetOrderERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_database\",\"type\":\"address\"},{\"name\":\"_events\",\"type\":\"address\"},{\"name\":\"_kyber\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"change\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"}],\"name\":\"Convert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"}]","ContractName":"CrowdsaleERC20","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005fcebeb70b88e86dd880352684e775b0f4d57c71000000000000000000000000eb6533f29a54c2c18bb2ce2a100de717692a518f000000000000000000000000818e6fecd516ecc3849daf6845e3ec868087b755","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://c6bcf07a691e9e1f466dc6642530d89e1f60d7e0773e0d409a18ee36d775f4d5"}]}