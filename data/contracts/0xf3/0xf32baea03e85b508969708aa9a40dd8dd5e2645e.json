{"status":"1","message":"OK","result":[{"SourceCode":"{\"DateTime.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\n// https://github.com/pipermerriam/ethereum-datetime\\ncontract DateTime {\\n  struct _DateTime {\\n    uint16 year;\\n    uint8 month;\\n    uint8 day;\\n    uint8 hour;\\n    uint8 minute;\\n    uint8 second;\\n    uint8 weekday;\\n  }\\n\\n  uint constant DAY_IN_SECONDS = 86400;\\n  uint constant YEAR_IN_SECONDS = 31536000;\\n  uint constant LEAP_YEAR_IN_SECONDS = 31622400;\\n\\n  uint constant HOUR_IN_SECONDS = 3600;\\n  uint constant MINUTE_IN_SECONDS = 60;\\n\\n  uint16 constant ORIGIN_YEAR = 1970;\\n\\n  function isLeapYear(uint16 year) internal pure returns (bool) {\\n    if (year % 4 != 0) {\\n      return false;\\n    }\\n    if (year % 100 != 0) {\\n      return true;\\n    }\\n    if (year % 400 != 0) {\\n      return false;\\n    }\\n    return true;\\n  }\\n\\n  function leapYearsBefore(uint year) internal pure returns (uint) {\\n    year -= 1;\\n    return year / 4 - year / 100 + year / 400;\\n  }\\n\\n  function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\\n    if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\n      return 31;\\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\\n      return 30;\\n    } else if (isLeapYear(year)) {\\n      return 29;\\n    } else {\\n      return 28;\\n    }\\n  }\\n\\n  function parseTimestamp(uint timestamp) internal pure returns (_DateTime memory dt) {\\n    uint secondsAccountedFor = 0;\\n    uint buf;\\n    uint8 i;\\n\\n    // Year\\n    dt.year = getYear(timestamp);\\n    buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\\n    secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\\n\\n    // Month\\n    uint secondsInMonth;\\n    for (i = 1; i \\u003c= 12; i++) {\\n      secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\\n      if (secondsInMonth + secondsAccountedFor \\u003e timestamp) {\\n        dt.month = i;\\n        break;\\n      }\\n      secondsAccountedFor += secondsInMonth;\\n    }\\n\\n    // Day\\n    for (i = 1; i \\u003c= getDaysInMonth(dt.month, dt.year); i++) {\\n      if (DAY_IN_SECONDS + secondsAccountedFor \\u003e timestamp) {\\n        dt.day = i;\\n        break;\\n      }\\n      secondsAccountedFor += DAY_IN_SECONDS;\\n    }\\n\\n    // Hour\\n    dt.hour = getHour(timestamp);\\n\\n    // Minute\\n    dt.minute = getMinute(timestamp);\\n\\n    // Second\\n    dt.second = getSecond(timestamp);\\n    dt.weekday = getWeekday(timestamp);\\n  }\\n\\n  function getYear(uint timestamp) internal pure returns (uint16) {\\n    uint secondsAccountedFor = 0;\\n    uint16 year;\\n    uint numLeapYears;\\n\\n    // Year\\n    year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\\n    numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\\n    secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\\n\\n    while (secondsAccountedFor \\u003e timestamp) {\\n      if (isLeapYear(uint16(year - 1))) {\\n        secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\\n      } else {\\n        secondsAccountedFor -= YEAR_IN_SECONDS;\\n      }\\n      year -= 1;\\n    }\\n    return year;\\n  }\\n\\n  function getMonth(uint timestamp) internal pure returns (uint8) {\\n    return parseTimestamp(timestamp).month;\\n  }\\n\\n  function getDay(uint timestamp) internal pure returns (uint8) {\\n    return parseTimestamp(timestamp).day;\\n  }\\n\\n  function getHour(uint timestamp) internal pure returns (uint8) {\\n    return uint8((timestamp / 60 / 60) % 24);\\n  }\\n\\n  function getMinute(uint timestamp) internal pure returns (uint8) {\\n    return uint8((timestamp / 60) % 60);\\n  }\\n\\n  function getSecond(uint timestamp) internal pure returns (uint8) {\\n    return uint8(timestamp % 60);\\n  }\\n\\n  function getWeekday(uint timestamp) internal pure returns (uint8) {\\n    return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\\n  }\\n\\n  function toTimestamp(uint16 year, uint8 month, uint8 day) internal pure returns (uint timestamp) {\\n    return toTimestamp(year, month, day, 0, 0, 0);\\n  }\\n\\n  function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) internal pure returns (uint timestamp) {\\n    return toTimestamp(year, month, day, hour, 0, 0);\\n  }\\n\\n  function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute)\\n    internal\\n    pure\\n    returns (uint timestamp)\\n  {\\n    return toTimestamp(year, month, day, hour, minute, 0);\\n  }\\n\\n  function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second)\\n    internal\\n    pure\\n    returns (uint timestamp)\\n  {\\n    uint16 i;\\n\\n    // Year\\n    for (i = ORIGIN_YEAR; i \\u003c year; i++) {\\n      if (isLeapYear(i)) {\\n        timestamp += LEAP_YEAR_IN_SECONDS;\\n      } else {\\n        timestamp += YEAR_IN_SECONDS;\\n      }\\n    }\\n\\n    // Month\\n    uint8[12] memory monthDayCounts;\\n    monthDayCounts[0] = 31;\\n    if (isLeapYear(year)) {\\n      monthDayCounts[1] = 29;\\n    } else {\\n      monthDayCounts[1] = 28;\\n    }\\n    monthDayCounts[2] = 31;\\n    monthDayCounts[3] = 30;\\n    monthDayCounts[4] = 31;\\n    monthDayCounts[5] = 30;\\n    monthDayCounts[6] = 31;\\n    monthDayCounts[7] = 31;\\n    monthDayCounts[8] = 30;\\n    monthDayCounts[9] = 31;\\n    monthDayCounts[10] = 30;\\n    monthDayCounts[11] = 31;\\n\\n    for (i = 1; i \\u003c month; i++) {\\n      timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\\n    }\\n\\n    // Day\\n    timestamp += DAY_IN_SECONDS * (day - 1);\\n\\n    // Hour\\n    timestamp += HOUR_IN_SECONDS * (hour);\\n\\n    // Minute\\n    timestamp += MINUTE_IN_SECONDS * (minute);\\n\\n    // Second\\n    timestamp += second;\\n\\n    return timestamp;\\n  }\\n}\\n\"},\"DepositPlan.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\n/*\\n * \\u0027Bolton Holding Group\\u0027 CORPORATE BOND Subscription contract\\n *\\n * Token                : Bolton Coin (BFCL)\\n * Interest rate        : 22% yearly\\n * Duration subscription: 24 months\\n *\\n * Copyright (C) 2019 Raffaele Bini - 5esse Informatica (https://www.5esse.it)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with this program. If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n */\\n\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Whitelist.sol\\\";\\nimport \\\"./Vault.sol\\\";\\nimport \\\"./PriceManagerRole.sol\\\";\\nimport \\\"./DateTime.sol\\\";\\n\\ncontract DepositPlan is Ownable, ReentrancyGuard, PriceManagerRole, DateTime {\\n  using SafeMath for uint;\\n\\n  enum Currency {BFCL, EURO}\\n\\n  event AddInvestor(address indexed investor);\\n  event CloseAccount(address indexed investor);\\n  event InvestorDeposit(address indexed investor, uint bfclAmount, uint euroAmount, uint depositTime);\\n  event Reinvest(\\n    uint oldBfcl,\\n    uint oldEuro,\\n    uint oldLastWithdrawTime,\\n    uint bfclDividends,\\n    uint euroDividends,\\n    uint lastWithdrawTime\\n  );\\n  event DeleteDebt(address indexed investor, uint index);\\n  event DeleteDeposit(address indexed investor, uint index);\\n  event AddDebt(address indexed investor, uint bfclDebt, uint euroDebt);\\n\\n  uint internal constant RATE_MULTIPLIER = 10 ** 18;\\n  uint internal constant MIN_INVESTMENT_EURO_CENT = 50000 * RATE_MULTIPLIER; // 50k EURO in cents\\n  uint internal constant MIN_REPLENISH_EURO_CENT = 1000 * RATE_MULTIPLIER; // 1k EURO in cents\\n  uint internal HUNDRED_PERCENTS = 10000; // 100%\\n  uint internal PERCENT_PER_YEAR = 2200; // 22%\\n\\n  IERC20 public bfclToken;\\n  IERC20 public euroToken;\\n  Whitelist public whitelist;\\n  address public tokensWallet;\\n  uint public bfclEuroRateFor72h; // 1 EUR = bfclEuroRateFor72h BFCL / 10^18\\n  bool public isStopped;\\n\\n  mapping(address =\\u003e Account) public accounts;\\n  mapping(address =\\u003e Deposit[]) public deposits;\\n  mapping(address =\\u003e Debt[]) public debts;\\n\\n  struct Account {\\n    Vault vault;\\n    uint firstDepositTimestamp;\\n    uint stopTime;\\n  }\\n\\n  struct Deposit {\\n    uint bfcl;\\n    uint euro;\\n    uint lastWithdrawTime;\\n  }\\n\\n  struct Debt {\\n    uint bfcl;\\n    uint euro;\\n  }\\n\\n  constructor(IERC20 _bfclToken, Whitelist _whitelist, address _tokensWallet, uint _initialBfclEuroRateFor72h) public {\\n    bfclToken = _bfclToken;\\n    whitelist = _whitelist;\\n    tokensWallet = _tokensWallet;\\n    bfclEuroRateFor72h = _initialBfclEuroRateFor72h;\\n  }\\n\\n  modifier onlyIfWhitelisted() {\\n    require(whitelist.isWhitelisted(msg.sender), \\\"Not whitelisted\\\");\\n    _;\\n  }\\n\\n  // reverts ETH transfers\\n  function() external {\\n    revert();\\n  }\\n\\n  // reverts erc223 token transfers\\n  function tokenFallback(address, uint, bytes calldata) external pure {\\n    revert();\\n  }\\n\\n  function transferErc20(IERC20 _token, address _to, uint _value) external onlyOwner nonReentrant {\\n    _token.transfer(_to, _value);\\n  }\\n\\n  function transferBfcl(address _to, uint _value) external onlyOwner nonReentrant {\\n    bfclToken.transfer(_to, _value);\\n  }\\n\\n  function stop() external onlyOwner {\\n    isStopped = true;\\n  }\\n\\n  function invest(uint _bfclAmount) external onlyIfWhitelisted nonReentrant {\\n    require(!isStopped, \\\"Contract stopped. You can no longer invest.\\\");\\n\\n    uint bfclAmount;\\n    uint euroAmount;\\n\\n    address investor = msg.sender;\\n    Account storage account = accounts[investor];\\n    if (account.vault == Vault(0)) {\\n      // first deposit\\n      bfclAmount = _bfclAmount;\\n      euroAmount = _bfclAmount.mul(RATE_MULTIPLIER).div(bfclEuroRateFor72h);\\n      require(euroAmount \\u003e= MIN_INVESTMENT_EURO_CENT, \\\"Should be more than minimum\\\");\\n      account.vault = new Vault(investor, bfclToken);\\n      account.firstDepositTimestamp = now;\\n      account.stopTime = now + 730 days;\\n\\n      emit AddInvestor(investor);\\n    } else {\\n      // replenish\\n      require(now \\u003c account.stopTime, \\\"2 years have passed. You can no longer replenish.\\\");\\n      uint oneKEuroInBfcl = bfclEuroRateFor72h.mul(MIN_REPLENISH_EURO_CENT).div(RATE_MULTIPLIER);\\n      uint times = _bfclAmount.div(oneKEuroInBfcl);\\n      bfclAmount = times.mul(oneKEuroInBfcl);\\n      euroAmount = times.mul(MIN_REPLENISH_EURO_CENT);\\n      require(euroAmount \\u003e= MIN_REPLENISH_EURO_CENT, \\\"Should be more than minimum\\\");\\n    }\\n\\n    require(bfclToken.allowance(investor, address(this)) \\u003e= bfclAmount, \\\"Allowance should not be less than amount\\\");\\n    bfclToken.transferFrom(investor, address(account.vault), bfclAmount);\\n\\n    deposits[investor].push(Deposit(bfclAmount, euroAmount, now));\\n\\n    emit InvestorDeposit(investor, bfclAmount, euroAmount, now);\\n  }\\n\\n  function withdraw() external nonReentrant {\\n    address investor = msg.sender;\\n    Account storage account = accounts[investor];\\n    Currency currency = address(euroToken) == address(0) ? Currency.BFCL : Currency.EURO;\\n    uint result;\\n    result += _tryToWithdrawDividends(investor, account, currency);\\n    result += _tryToWithdrawDebts(investor, currency);\\n    require(result \\u003e 0, \\\"Nothing to withdraw\\\");\\n    _checkAndCloseAccount(investor);\\n  }\\n\\n  function _tryToWithdrawDividends(address _investor, Account storage _account, Currency _currency)\\n    internal\\n    returns (uint result)\\n  {\\n    if (isInIntervals(now) || now \\u003e= _account.stopTime) {\\n      uint depositCount = deposits[_investor].length;\\n      if (depositCount \\u003e 0) {\\n        for (uint i = 0; i \\u003c depositCount; i++) {\\n          if (_withdrawOneDividend(_investor, _account, _currency, i)) {\\n            result++;\\n          }\\n        }\\n\\n        if (now \\u003e= _account.stopTime) {\\n          for (uint i = depositCount; i \\u003e 0; i--) {\\n            _withdrawDeposit(_investor, i - 1);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  function _tryToWithdrawDebts(address _investor, Currency _currency) internal returns (uint result) {\\n    uint debtCount = debts[_investor].length;\\n    if (debtCount \\u003e 0) {\\n      for (uint i = 0; i \\u003c debtCount; i++) {\\n        if (_withdrawOneDebt(_investor, _currency, i)) {\\n          result++;\\n        }\\n      }\\n\\n      for (uint i = debtCount; i \\u003e 0; i--) {\\n        _deleteDebt(_investor, i - 1);\\n      }\\n    }\\n  }\\n\\n  function _withdrawDeposit(address _investor, uint _index) internal {\\n    Vault vault = accounts[_investor].vault;\\n    Deposit storage deposit = deposits[_investor][_index];\\n    uint mustPay = deposit.bfcl;\\n\\n    uint toPayFromVault;\\n    uint toPayFromWallet;\\n    if (vault.getBalance() \\u003e= mustPay) {\\n      toPayFromVault = mustPay;\\n    } else {\\n      toPayFromVault = vault.getBalance();\\n      toPayFromWallet = mustPay.sub(toPayFromVault);\\n    }\\n\\n    _deleteDeposit(_investor, _index);\\n\\n    if (toPayFromVault \\u003e 0) {\\n      vault.withdrawToInvestor(toPayFromVault);\\n    }\\n\\n    if (toPayFromWallet \\u003e 0) {\\n      _send(_investor, toPayFromWallet, 0, Currency.BFCL);\\n    }\\n  }\\n\\n  function withdrawDividends() external nonReentrant {\\n    address investor = msg.sender;\\n    Account storage account = accounts[investor];\\n    require(isInIntervals(now) || now \\u003e= account.stopTime, \\\"Should be in interval or after 2 years\\\");\\n    require(deposits[investor].length \\u003e 0, \\\"There is no deposits for your address\\\");\\n    uint result;\\n    Currency currency = address(euroToken) == address(0) ? Currency.BFCL : Currency.EURO;\\n    result += _tryToWithdrawDividends(investor, account, currency);\\n    require(result \\u003e 0, \\\"Nothing to withdraw\\\");\\n    _checkAndCloseAccount(investor);\\n  }\\n\\n  function withdrawOneDividend(uint index) external nonReentrant {\\n    address investor = msg.sender;\\n    Account storage account = accounts[investor];\\n    require(isInIntervals(now) || now \\u003e= account.stopTime, \\\"Should be in interval or after 2 years\\\");\\n    require(deposits[investor].length \\u003e 0, \\\"There is no deposits for your address\\\");\\n\\n    Currency currency = address(euroToken) == address(0) ? Currency.BFCL : Currency.EURO;\\n    require(_withdrawOneDividend(investor, account, currency, index), \\\"Nothing to withdraw\\\");\\n    if (now \\u003e= account.stopTime) {\\n      _withdrawDeposit(investor, index);\\n    }\\n    _checkAndCloseAccount(investor);\\n  }\\n\\n  function withdrawDebts() external nonReentrant {\\n    address investor = msg.sender;\\n    require(debts[investor].length \\u003e 0, \\\"There is no deposits for your address\\\");\\n\\n    uint result;\\n    Currency currency = address(euroToken) == address(0) ? Currency.BFCL : Currency.EURO;\\n    result += _tryToWithdrawDebts(investor, currency);\\n    require(result \\u003e 0, \\\"Nothing to withdraw\\\");\\n    _checkAndCloseAccount(investor);\\n  }\\n\\n  function withdrawOneDebt(uint index) external nonReentrant {\\n    address investor = msg.sender;\\n    require(debts[investor].length \\u003e 0, \\\"There is no deposits for your address\\\");\\n\\n    Currency currency = address(euroToken) == address(0) ? Currency.BFCL : Currency.EURO;\\n    require(_withdrawOneDebt(investor, currency, index), \\\"Nothing to withdraw\\\");\\n    _deleteDebt(investor, index);\\n    _checkAndCloseAccount(investor);\\n  }\\n\\n  function setBfclEuroRateFor72h(uint _rate) public onlyPriceManager {\\n    bfclEuroRateFor72h = _rate;\\n  }\\n\\n  function switchToBfcl() public onlyOwner {\\n    require(address(euroToken) != address(0), \\\"You are already using BFCL\\\");\\n    euroToken = IERC20(address(0));\\n  }\\n\\n  function switchToEuro(IERC20 _euro) public onlyOwner {\\n    require(address(_euro) != address(euroToken), \\\"Trying to change euro token to same address\\\");\\n    euroToken = _euro;\\n  }\\n\\n  function calculateDividendsForTimestamp(address _investor, uint _timestamp)\\n    public\\n    view\\n    returns (uint bfcl, uint euro)\\n  {\\n    Account storage account = accounts[_investor];\\n    uint withdrawingTimestamp = _findIntervalStart(account, _timestamp);\\n\\n    for (uint i = 0; i \\u003c deposits[_investor].length; i++) {\\n      (uint bfclDiv, uint euroDiv) = _calculateDividendForTimestamp(_investor, withdrawingTimestamp, i);\\n      bfcl = bfcl.add(bfclDiv);\\n      euro = euro.add(euroDiv);\\n    }\\n\\n    if (withdrawingTimestamp \\u003e= account.stopTime) {\\n      bfcl = bfcl.sub(account.vault.getBalance());\\n    }\\n  }\\n\\n  function calculateGroupDividendsForTimestamp(address[] memory _investors, uint _timestamp)\\n    public\\n    view\\n    returns (uint bfcl, uint euro)\\n  {\\n    for (uint i = 0; i \\u003c _investors.length; i++) {\\n      address investor = _investors[i];\\n      Account storage account = accounts[investor];\\n      uint withdrawingTimestamp = _findIntervalStart(account, _timestamp);\\n\\n      for (uint d = 0; d \\u003c deposits[investor].length; d++) {\\n        (uint bfclDiv, uint euroDiv) = _calculateDividendForTimestamp(investor, withdrawingTimestamp, d);\\n        bfcl = bfcl.add(bfclDiv);\\n        euro = euro.add(euroDiv);\\n      }\\n\\n      if (withdrawingTimestamp \\u003e= account.stopTime) {\\n        bfcl = bfcl.sub(account.vault.getBalance());\\n      }\\n    }\\n  }\\n\\n  function calculateDividendsWithDebtsForTimestamp(address _investor, uint _timestamp)\\n    public\\n    view\\n    returns (uint bfcl, uint euro)\\n  {\\n    (bfcl, euro) = calculateDividendsForTimestamp(_investor, _timestamp);\\n    for (uint d = 0; d \\u003c debts[_investor].length; d++) {\\n      Debt storage debt = debts[_investor][d];\\n      bfcl = bfcl.add(debt.bfcl);\\n      euro = euro.add(debt.euro);\\n    }\\n  }\\n\\n  function calculateGroupDividendsWithDebtsForTimestamp(address[] memory _investors, uint _timestamp)\\n    public\\n    view\\n    returns (uint bfcl, uint euro)\\n  {\\n    (bfcl, euro) = calculateGroupDividendsForTimestamp(_investors, _timestamp);\\n    for (uint i = 0; i \\u003c _investors.length; i++) {\\n      address investor = _investors[i];\\n      for (uint d = 0; d \\u003c debts[investor].length; d++) {\\n        Debt storage debt = debts[investor][d];\\n        bfcl = bfcl.add(debt.bfcl);\\n        euro = euro.add(debt.euro);\\n      }\\n    }\\n  }\\n\\n  function isInIntervals(uint _timestamp) public pure returns (bool) {\\n    uint8[4] memory months = [1, 4, 7, 10];\\n\\n    _DateTime memory dt = parseTimestamp(_timestamp);\\n    for (uint i = 0; i \\u003c months.length; i++) {\\n      if (dt.month == months[i]) {\\n        return 1 \\u003c= dt.day \\u0026\\u0026 dt.day \\u003c= 5;\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  function _getNextDate(uint _timestamp) internal pure returns (uint) {\\n    _DateTime memory dt = parseTimestamp(_timestamp);\\n\\n    uint16 year;\\n    uint8 month;\\n\\n    uint8[4] memory months = [1, 4, 7, 10];\\n    for (uint i = months.length; i \\u003e 0; --i) {\\n      if (dt.month \\u003e= months[i - 1]) {\\n        if (i == months.length) {\\n          year = dt.year + 1;\\n          month = months[0];\\n        } else {\\n          year = dt.year;\\n          month = months[i];\\n        }\\n        break;\\n      }\\n    }\\n\\n    return toTimestamp(year, month, 1);\\n  }\\n\\n  // implies that the timestamp is exactly in any of the intervals or after stopTime\\n  function _findIntervalStart(Account storage _account, uint _timestamp) internal view returns (uint) {\\n    if (_timestamp \\u003e= _account.stopTime) {\\n      return _account.stopTime;\\n    } else {\\n      _DateTime memory dt = parseTimestamp(_timestamp);\\n      return toTimestamp(dt.year, dt.month, 1);\\n    }\\n  }\\n\\n  function _getBalance(Currency _currency) internal view returns (uint) {\\n    IERC20 token = _currency == Currency.BFCL ? bfclToken : euroToken;\\n    uint balance = token.balanceOf(tokensWallet);\\n    uint allowance = token.allowance(tokensWallet, address(this));\\n    return balance \\u003c allowance ? balance : allowance;\\n  }\\n\\n  function _checkAndCloseAccount(address _investor) internal {\\n    bool isDepositWithdrawn = accounts[_investor].vault.getBalance() == 0;\\n    bool isDividendsWithdrawn = deposits[_investor].length == 0;\\n    bool isDebtsWithdrawn = debts[_investor].length == 0;\\n    if (isDepositWithdrawn \\u0026\\u0026 isDividendsWithdrawn \\u0026\\u0026 isDebtsWithdrawn) {\\n      delete accounts[_investor];\\n      emit CloseAccount(_investor);\\n    }\\n  }\\n\\n  function _withdrawOneDebt(address _investor, Currency _currency, uint _index) internal returns (bool) {\\n    Debt storage debt = debts[_investor][_index];\\n    return _send(_investor, debt.bfcl, debt.euro, _currency);\\n  }\\n\\n  function _deleteDebt(address _investor, uint _index) internal {\\n    uint lastIndex = debts[_investor].length - 1;\\n    if (_index == lastIndex) {\\n      delete debts[_investor][_index];\\n    } else {\\n      debts[_investor][_index] = debts[_investor][lastIndex];\\n      delete debts[_investor][lastIndex];\\n    }\\n    emit DeleteDebt(_investor, _index);\\n    debts[_investor].length--;\\n  }\\n\\n  function _checkAndReinvest(Deposit storage _deposit, uint _currentIntervalStart) internal {\\n    while (true) {\\n      uint nextDate = _getNextDate(_deposit.lastWithdrawTime);\\n      if (nextDate \\u003e= _currentIntervalStart) {\\n        return;\\n      }\\n\\n      uint periodSeconds = nextDate.sub(_deposit.lastWithdrawTime);\\n      (uint bfclDividends, uint euroDividends) = _calculateDividendForPeriod(_deposit, periodSeconds);\\n\\n      emit Reinvest(_deposit.bfcl, _deposit.euro, _deposit.lastWithdrawTime, bfclDividends, euroDividends, nextDate);\\n\\n      _deposit.bfcl = _deposit.bfcl.add(bfclDividends);\\n      _deposit.euro = _deposit.euro.add(euroDividends);\\n      _deposit.lastWithdrawTime = nextDate;\\n    }\\n  }\\n\\n  function _withdrawOneDividend(address _investor, Account storage _account, Currency _currency, uint _index)\\n    internal\\n    returns (bool result)\\n  {\\n    Deposit storage deposit = deposits[_investor][_index];\\n    uint intervalStart = _findIntervalStart(_account, now);\\n    if (deposit.lastWithdrawTime \\u003e intervalStart) {\\n      return false;\\n    }\\n    _checkAndReinvest(deposit, intervalStart);\\n    uint periodSeconds = intervalStart.sub(deposit.lastWithdrawTime);\\n    deposit.lastWithdrawTime = intervalStart;\\n    (uint bfclDividends, uint euroDividends) = _calculateDividendForPeriod(deposit, periodSeconds);\\n    result = _send(_investor, bfclDividends, euroDividends, _currency);\\n  }\\n\\n  function _deleteDeposit(address _investor, uint _index) internal {\\n    uint lastIndex = deposits[_investor].length - 1;\\n    if (_index == lastIndex) {\\n      delete deposits[_investor][_index];\\n    } else {\\n      deposits[_investor][_index] = deposits[_investor][lastIndex];\\n      delete deposits[_investor][lastIndex];\\n    }\\n    emit DeleteDeposit(_investor, _index);\\n    deposits[_investor].length--;\\n  }\\n\\n  function _calculateDividendForTimestamp(address _investor, uint _withdrawingTimestamp, uint _depositIndex)\\n    internal\\n    view\\n    returns (uint bfcl, uint euro)\\n  {\\n    Deposit storage deposit = deposits[_investor][_depositIndex];\\n    if (deposit.lastWithdrawTime \\u003e= _withdrawingTimestamp) {\\n      return (0, 0);\\n    }\\n\\n    Currency currency = address(euroToken) == address(0) ? Currency.BFCL : Currency.EURO;\\n\\n    uint b = deposit.bfcl;\\n    uint e = deposit.euro;\\n\\n    // check reinvestment\\n    uint lastWithdrawTime = deposit.lastWithdrawTime;\\n    while (true) {\\n      uint nextDate = _getNextDate(lastWithdrawTime);\\n      if (nextDate \\u003e= _withdrawingTimestamp) {\\n        break;\\n      }\\n\\n      uint periodSeconds = nextDate.sub(lastWithdrawTime);\\n      (uint bfclDividends, uint euroDividends) = _calculateDividendForPeriod(b, e, periodSeconds);\\n\\n      b = b.add(bfclDividends);\\n      e = e.add(euroDividends);\\n\\n      lastWithdrawTime = nextDate;\\n    }\\n\\n    // calculate dividends for last interval\\n    uint periodSeconds = _withdrawingTimestamp.sub(lastWithdrawTime);\\n    (bfcl, euro) = _calculateDividendForPeriod(b, e, periodSeconds);\\n    if (currency == Currency.BFCL) {\\n      euro = 0;\\n    } else if (_withdrawingTimestamp \\u003c accounts[_investor].stopTime) {\\n      bfcl = 0;\\n    }\\n\\n    if (_withdrawingTimestamp \\u003e= accounts[_investor].stopTime) {\\n      if (currency == Currency.BFCL) {\\n        bfcl = bfcl.add(b);\\n      } else {\\n        bfcl = b;\\n      }\\n    }\\n  }\\n\\n  function _calculateDividendForPeriod(Deposit storage _deposit, uint _periodSeconds)\\n    internal\\n    view\\n    returns (uint bfcl, uint euro)\\n  {\\n    (bfcl, euro) = _calculateDividendForPeriod(_deposit.bfcl, _deposit.euro, _periodSeconds);\\n  }\\n\\n  function _calculateDividendForPeriod(uint _bfcl, uint _euro, uint _periodSeconds)\\n    internal\\n    view\\n    returns (uint bfcl, uint euro)\\n  {\\n    bfcl = _bfcl.mul(_periodSeconds).mul(PERCENT_PER_YEAR).div(HUNDRED_PERCENTS).div(365 days);\\n    euro = _euro.mul(_periodSeconds).mul(PERCENT_PER_YEAR).div(HUNDRED_PERCENTS).div(365 days);\\n  }\\n\\n  function _send(address _investor, uint _bfclAmount, uint _euroAmount, Currency _currency) internal returns (bool) {\\n    if (_bfclAmount == 0 \\u0026\\u0026 _euroAmount == 0) {\\n      return false;\\n    }\\n\\n    uint balance = _getBalance(_currency);\\n    if (_currency == Currency.EURO) {\\n      balance = balance.mul(RATE_MULTIPLIER).div(10 ** euroToken.decimals());\\n    }\\n\\n    uint canPay;\\n\\n    if ((_currency == Currency.BFCL \\u0026\\u0026 balance \\u003e= _bfclAmount) || (_currency == Currency.EURO \\u0026\\u0026 balance \\u003e= _euroAmount)) {\\n      if (_currency == Currency.BFCL) {\\n        canPay = _bfclAmount;\\n      } else {\\n        canPay = _euroAmount;\\n      }\\n    } else {\\n      canPay = balance;\\n      uint bfclDebt;\\n      uint euroDebt;\\n      if (_currency == Currency.BFCL) {\\n        bfclDebt = _bfclAmount.sub(canPay);\\n        euroDebt = bfclDebt.mul(_euroAmount).div(_bfclAmount);\\n      } else {\\n        euroDebt = _euroAmount.sub(canPay);\\n        bfclDebt = euroDebt.mul(_bfclAmount).div(_euroAmount);\\n      }\\n\\n      debts[_investor].push(Debt(bfclDebt, euroDebt));\\n      emit AddDebt(_investor, bfclDebt, euroDebt);\\n    }\\n\\n    if (canPay == 0) {\\n      return true;\\n    }\\n\\n    uint toPay;\\n    IERC20 token;\\n    if (_currency == Currency.BFCL) {\\n      toPay = canPay;\\n      token = bfclToken;\\n    } else {\\n      toPay = canPay.mul(10 ** euroToken.decimals()).div(RATE_MULTIPLIER);\\n      token = euroToken;\\n    }\\n\\n    token.transferFrom(tokensWallet, _investor, toPay);\\n    return true;\\n  }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\n/**\\n * @title ERC20 interface without bool returns\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 {\\n  function transfer(address to, uint256 value) external;\\n\\n  function transferFrom(address from, address to, uint256 value) external;\\n\\n  function decimals() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     * @notice Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"PriceManagerRole.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\nimport \\\"./Roles.sol\\\";\\n\\ncontract PriceManagerRole {\\n  using Roles for Roles.Role;\\n\\n  event PriceManagerAdded(address indexed account);\\n  event PriceManagerRemoved(address indexed account);\\n\\n  Roles.Role private managers;\\n\\n  constructor() internal {\\n    _addPriceManager(msg.sender);\\n  }\\n\\n  modifier onlyPriceManager() {\\n    require(isPriceManager(msg.sender), \\\"Only for price manager\\\");\\n    _;\\n  }\\n\\n  function isPriceManager(address account) public view returns (bool) {\\n    return managers.has(account);\\n  }\\n\\n  function addPriceManager(address account) public onlyPriceManager {\\n    _addPriceManager(account);\\n  }\\n\\n  function renouncePriceManager() public {\\n    _removePriceManager(msg.sender);\\n  }\\n\\n  function _addPriceManager(address account) internal {\\n    managers.add(account);\\n    emit PriceManagerAdded(account);\\n  }\\n\\n  function _removePriceManager(address account) internal {\\n    managers.remove(account);\\n    emit PriceManagerRemoved(account);\\n  }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n/**\\n * @title Helps contracts guard against reentrancy attacks.\\n * @author Remco Bloemen \\u003cremco@2π.com\\u003e, Eenae \\u003calexey@mixbytes.io\\u003e\\n * @dev If you mark a function `nonReentrant`, you should also\\n * mark it `external`.\\n */\\ncontract ReentrancyGuard {\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    constructor () internal {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(localCounter == _guardCounter);\\n    }\\n}\\n\"},\"Roles.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address =\\u003e bool) bearer;\\n    }\\n\\n    /**\\n     * @dev give an account access to this role\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(account != address(0));\\n        require(!has(role, account));\\n\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev remove an account\\u0027s access to this role\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(account != address(0));\\n        require(has(role, account));\\n\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev check if an account has this role\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0));\\n        return role.bearer[account];\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two unsigned integers, reverts on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"},\"Vault.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract Vault is Ownable {\\n  using SafeMath for uint;\\n\\n  address public investor;\\n  IERC20 internal bfclToken;\\n\\n  constructor(address _investor, IERC20 _bfclToken) public {\\n    investor = _investor;\\n    bfclToken = _bfclToken;\\n  }\\n\\n  // reverts erc223 transfers\\n  function tokenFallback(address, uint, bytes calldata) external pure {\\n    revert(\\\"ERC223 tokens not allowed in Vault\\\");\\n  }\\n\\n  function withdrawToInvestor(uint _amount) external onlyOwner returns (bool) {\\n    bfclToken.transfer(investor, _amount);\\n    return true;\\n  }\\n\\n  function getBalance() public view returns (uint) {\\n    return bfclToken.balanceOf(address(this));\\n  }\\n}\\n\"},\"Whitelist.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\nimport \\\"./Roles.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract Whitelist is Ownable {\\n  using Roles for Roles.Role;\\n\\n  Roles.Role private whitelist;\\n\\n  event WhitelistedAddressAdded(address indexed _address);\\n\\n  function isWhitelisted(address _address) public view returns (bool) {\\n    return whitelist.has(_address);\\n  }\\n\\n  function addAddressToWhitelist(address _address) external onlyOwner {\\n    _addAddressToWhitelist(_address);\\n  }\\n\\n  function addAddressesToWhitelist(address[] calldata _addresses) external onlyOwner {\\n    for (uint i = 0; i \\u003c _addresses.length; i++) {\\n      _addAddressToWhitelist(_addresses[i]);\\n    }\\n  }\\n\\n  function _addAddressToWhitelist(address _address) internal {\\n    whitelist.add(_address);\\n    emit WhitelistedAddressAdded(_address);\\n  }\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferErc20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bfclToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_euro\",\"type\":\"address\"}],\"name\":\"switchToEuro\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bfclAmount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"euroToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferBfcl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"switchToBfcl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPriceManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePriceManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"firstDepositTimestamp\",\"type\":\"uint256\"},{\"name\":\"stopTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"debts\",\"outputs\":[{\"name\":\"bfcl\",\"type\":\"uint256\"},{\"name\":\"euro\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setBfclEuroRateFor72h\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"calculateGroupDividendsWithDebtsForTimestamp\",\"outputs\":[{\"name\":\"bfcl\",\"type\":\"uint256\"},{\"name\":\"euro\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"calculateDividendsForTimestamp\",\"outputs\":[{\"name\":\"bfcl\",\"type\":\"uint256\"},{\"name\":\"euro\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"isInIntervals\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPriceManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"calculateDividendsWithDebtsForTimestamp\",\"outputs\":[{\"name\":\"bfcl\",\"type\":\"uint256\"},{\"name\":\"euro\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"bfcl\",\"type\":\"uint256\"},{\"name\":\"euro\",\"type\":\"uint256\"},{\"name\":\"lastWithdrawTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"calculateGroupDividendsForTimestamp\",\"outputs\":[{\"name\":\"bfcl\",\"type\":\"uint256\"},{\"name\":\"euro\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bfclEuroRateFor72h\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdrawOneDividend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDebts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdrawOneDebt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bfclToken\",\"type\":\"address\"},{\"name\":\"_whitelist\",\"type\":\"address\"},{\"name\":\"_tokensWallet\",\"type\":\"address\"},{\"name\":\"_initialBfclEuroRateFor72h\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"AddInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"CloseAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bfclAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"euroAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"depositTime\",\"type\":\"uint256\"}],\"name\":\"InvestorDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldBfcl\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldEuro\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldLastWithdrawTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bfclDividends\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"euroDividends\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lastWithdrawTime\",\"type\":\"uint256\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DeleteDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DeleteDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bfclDebt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"euroDebt\",\"type\":\"uint256\"}],\"name\":\"AddDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PriceManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PriceManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DepositPlan","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c844c9632076bf10f0984151799eb974719cd6910000000000000000000000006f9c7680841906b42972e817b08373ed942727a4000000000000000000000000352e5513532f8b400062f5f50f70e1e9fca40f220000000000000000000000000000000000000000000000000f6b75ab2bc471c7","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://0b4726049ef0e6e4314dc830e5495e4bf5e998c456a6d8993853d303a67e0f8d"}]}