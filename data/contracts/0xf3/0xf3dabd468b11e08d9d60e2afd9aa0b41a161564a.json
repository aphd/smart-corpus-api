{"status":"1","message":"OK","result":[{"SourceCode":"// File: @ensdomains/buffer/contracts/Buffer.sol\r\n\r\npragma solidity >0.4.18;\r\n\r\n/**\r\n* @dev A library for working with mutable byte buffers in Solidity.\r\n*\r\n* Byte buffers are mutable and expandable, and provide a variety of primitives\r\n* for writing to them. At any time you can fetch a bytes object containing the\r\n* current contents of the buffer. The bytes object should not be stored between\r\n* operations, as it may change due to resizing of the buffer.\r\n*/\r\nlibrary Buffer {\r\n    /**\r\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\r\n    *      a capacity. The capacity may be longer than the current value, in\r\n    *      which case it can be extended without the need to allocate more memory.\r\n    */\r\n    struct buffer {\r\n        bytes buf;\r\n        uint capacity;\r\n    }\r\n\r\n    /**\r\n    * @dev Initializes a buffer with an initial capacity.\r\n    * @param buf The buffer to initialize.\r\n    * @param capacity The number of bytes of space to allocate the buffer.\r\n    * @return The buffer, for chaining.\r\n    */\r\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\r\n        if (capacity % 32 != 0) {\r\n            capacity += 32 - (capacity % 32);\r\n        }\r\n        // Allocate space for the buffer data\r\n        buf.capacity = capacity;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(buf, ptr)\r\n            mstore(ptr, 0)\r\n            mstore(0x40, add(32, add(ptr, capacity)))\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Initializes a new buffer from an existing bytes object.\r\n    *      Changes to the buffer may mutate the original value.\r\n    * @param b The bytes object to initialize the buffer with.\r\n    * @return A new buffer.\r\n    */\r\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\r\n        buffer memory buf;\r\n        buf.buf = b;\r\n        buf.capacity = b.length;\r\n        return buf;\r\n    }\r\n\r\n    function resize(buffer memory buf, uint capacity) private pure {\r\n        bytes memory oldbuf = buf.buf;\r\n        init(buf, capacity);\r\n        append(buf, oldbuf);\r\n    }\r\n\r\n    function max(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets buffer length to 0.\r\n    * @param buf The buffer to truncate.\r\n    * @return The original buffer, for chaining..\r\n    */\r\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\r\n        assembly {\r\n            let bufptr := mload(buf)\r\n            mstore(bufptr, 0)\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The start offset to write to.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to copy.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\r\n        require(len <= data.length);\r\n\r\n        if (off + len > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len + off) * 2);\r\n        }\r\n\r\n        uint dest;\r\n        uint src;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Start address = buffer address + offset + sizeof(buffer length)\r\n            dest := add(add(bufptr, 32), off)\r\n            // Update buffer length if we're extending it\r\n            if gt(add(len, off), buflen) {\r\n                mstore(bufptr, add(len, off))\r\n            }\r\n            src := add(data, 32)\r\n        }\r\n\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to copy.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, len);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, data.length);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write the byte at.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\r\n        if (off >= buf.capacity) {\r\n            resize(buf, buf.capacity * 2);\r\n        }\r\n\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Address = buffer address + sizeof(buffer length) + off\r\n            let dest := add(add(bufptr, off), 32)\r\n            mstore8(dest, data)\r\n            // Update buffer length if we extended it\r\n            if eq(off, buflen) {\r\n                mstore(bufptr, add(buflen, 1))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\r\n        return writeUint8(buf, buf.buf.length, data);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\r\n    *      exceed the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to write (left-aligned).\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\r\n        if (len + off > buf.capacity) {\r\n            resize(buf, (len + off) * 2);\r\n        }\r\n\r\n        uint mask = 256 ** len - 1;\r\n        // Right-align data\r\n        data = data >> (8 * (32 - len));\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Address = buffer address + sizeof(buffer length) + off + len\r\n            let dest := add(add(bufptr, off), len)\r\n            mstore(dest, or(and(mload(dest), not(mask)), data))\r\n            // Update buffer length if we extended it\r\n            if gt(add(off, len), mload(bufptr)) {\r\n                mstore(bufptr, add(off, len))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\r\n        return write(buf, off, bytes32(data), 20);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chhaining.\r\n    */\r\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, bytes32(data), 20);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, 32);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to write (right-aligned).\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\r\n        if (len + off > buf.capacity) {\r\n            resize(buf, (len + off) * 2);\r\n        }\r\n\r\n        uint mask = 256 ** len - 1;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Address = buffer address + off + sizeof(buffer length) + len\r\n            let dest := add(add(bufptr, off), len)\r\n            mstore(dest, or(and(mload(dest), not(mask)), data))\r\n            // Update buffer length if we extended it\r\n            if gt(add(off, len), mload(bufptr)) {\r\n                mstore(bufptr, add(off, len))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n     * exceed the capacity of the buffer.\r\n     * @param buf The buffer to append to.\r\n     * @param data The data to append.\r\n     * @return The original buffer.\r\n     */\r\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\r\n        return writeInt(buf, buf.buf.length, data, len);\r\n    }\r\n}\r\n\r\n// File: solidity-cborutils/contracts/CBOR.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\nlibrary CBOR {\r\n    using Buffer for Buffer.buffer;\r\n\r\n    uint8 private constant MAJOR_TYPE_INT = 0;\r\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\r\n    uint8 private constant MAJOR_TYPE_STRING = 3;\r\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n    uint8 private constant MAJOR_TYPE_MAP = 5;\r\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\r\n        if(value <= 23) {\r\n            buf.appendUint8(uint8((major << 5) | value));\r\n        } else if(value <= 0xFF) {\r\n            buf.appendUint8(uint8((major << 5) | 24));\r\n            buf.appendInt(value, 1);\r\n        } else if(value <= 0xFFFF) {\r\n            buf.appendUint8(uint8((major << 5) | 25));\r\n            buf.appendInt(value, 2);\r\n        } else if(value <= 0xFFFFFFFF) {\r\n            buf.appendUint8(uint8((major << 5) | 26));\r\n            buf.appendInt(value, 4);\r\n        } else if(value <= 0xFFFFFFFFFFFFFFFF) {\r\n            buf.appendUint8(uint8((major << 5) | 27));\r\n            buf.appendInt(value, 8);\r\n        }\r\n    }\r\n\r\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\r\n        buf.appendUint8(uint8((major << 5) | 31));\r\n    }\r\n\r\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\r\n        encodeType(buf, MAJOR_TYPE_INT, value);\r\n    }\r\n\r\n    function encodeInt(Buffer.buffer memory buf, int value) internal pure {\r\n        if(value >= 0) {\r\n            encodeType(buf, MAJOR_TYPE_INT, uint(value));\r\n        } else {\r\n            encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\r\n        }\r\n    }\r\n\r\n    function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\r\n        encodeType(buf, MAJOR_TYPE_BYTES, value.length);\r\n        buf.append(value);\r\n    }\r\n\r\n    function encodeString(Buffer.buffer memory buf, string value) internal pure {\r\n        encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\r\n        buf.append(bytes(value));\r\n    }\r\n\r\n    function startArray(Buffer.buffer memory buf) internal pure {\r\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\r\n    }\r\n\r\n    function startMap(Buffer.buffer memory buf) internal pure {\r\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\r\n    }\r\n\r\n    function endSequence(Buffer.buffer memory buf) internal pure {\r\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\r\n    }\r\n}\r\n\r\n// File: contracts/Chainlink.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title Library for common Chainlink functions\r\n * @dev Uses imported CBOR library for encoding to buffer\r\n */\r\nlibrary Chainlink {\r\n  uint256 internal constant defaultBufferSize = 256;\r\n\r\n  using CBOR for Buffer.buffer;\r\n\r\n  struct Request {\r\n    bytes32 id;\r\n    address callbackAddress;\r\n    bytes4 callbackFunctionId;\r\n    uint256 nonce;\r\n    Buffer.buffer buf;\r\n  }\r\n\r\n  /**\r\n   * @notice Initializes a Chainlink request\r\n   * @dev Sets the ID, callback address, and callback function signature on the request\r\n   * @param self The uninitialized request\r\n   * @param _id The Job Specification ID\r\n   * @param _callbackAddress The callback address\r\n   * @param _callbackFunction The callback function signature\r\n   * @return The initialized request\r\n   */\r\n  function initialize(\r\n    Request memory self,\r\n    bytes32 _id,\r\n    address _callbackAddress,\r\n    bytes4 _callbackFunction\r\n  ) internal pure returns (Chainlink.Request memory) {\r\n    Buffer.init(self.buf, defaultBufferSize);\r\n    self.id = _id;\r\n    self.callbackAddress = _callbackAddress;\r\n    self.callbackFunctionId = _callbackFunction;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\r\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\r\n   * @param self The initialized request\r\n   * @param _data The CBOR data\r\n   */\r\n  function setBuffer(Request memory self, bytes _data)\r\n    internal pure\r\n  {\r\n    Buffer.init(self.buf, _data.length);\r\n    Buffer.append(self.buf, _data);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a string value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _value The string value to add\r\n   */\r\n  function add(Request memory self, string _key, string _value)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.encodeString(_value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a bytes value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _value The bytes value to add\r\n   */\r\n  function addBytes(Request memory self, string _key, bytes _value)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.encodeBytes(_value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a int256 value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _value The int256 value to add\r\n   */\r\n  function addInt(Request memory self, string _key, int256 _value)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.encodeInt(_value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a uint256 value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _value The uint256 value to add\r\n   */\r\n  function addUint(Request memory self, string _key, uint256 _value)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.encodeUInt(_value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds an array of strings to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _values The array of string values to add\r\n   */\r\n  function addStringArray(Request memory self, string _key, string[] memory _values)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.startArray();\r\n    for (uint256 i = 0; i < _values.length; i++) {\r\n      self.buf.encodeString(_values[i]);\r\n    }\r\n    self.buf.endSequence();\r\n  }\r\n}\r\n\r\n// File: contracts/ENSResolver.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract ENSResolver {\r\n  function addr(bytes32 node) public view returns (address);\r\n}\r\n\r\n// File: contracts/interfaces/ENSInterface.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\ninterface ENSInterface {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/LinkTokenInterface.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external returns (bool success);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function balanceOf(address owner) external returns (uint256 balance);\r\n  function decimals() external returns (uint8 decimalPlaces);\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n  function name() external returns (string tokenName);\r\n  function symbol() external returns (string tokenSymbol);\r\n  function totalSupply() external returns (uint256 totalTokensIssued);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferAndCall(address to, uint256 value, bytes data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\n\r\n// File: contracts/interfaces/ChainlinkRequestInterface.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ninterface ChainlinkRequestInterface {\r\n  function oracleRequest(\r\n    address sender,\r\n    uint256 payment,\r\n    bytes32 id,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 version,\r\n    bytes data\r\n  ) external;\r\n\r\n  function cancelOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration\r\n  ) external;\r\n}\r\n\r\n// File: contracts/interfaces/PointerInterface.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ninterface PointerInterface {\r\n  function getAddress() external view returns (address);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/ChainlinkClient.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title The ChainlinkClient contract\r\n * @notice Contract writers can inherit this contract in order to create requests for the\r\n * Chainlink network\r\n */\r\ncontract ChainlinkClient {\r\n  using Chainlink for Chainlink.Request;\r\n  using SafeMath for uint256;\r\n\r\n  uint256 constant internal LINK = 10**18;\r\n  uint256 constant private AMOUNT_OVERRIDE = 0;\r\n  address constant private SENDER_OVERRIDE = 0x0;\r\n  uint256 constant private ARGS_VERSION = 1;\r\n  bytes32 constant private ENS_TOKEN_SUBNAME = keccak256(\"link\");\r\n  bytes32 constant private ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\r\n  address constant private LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\r\n\r\n  ENSInterface private ens;\r\n  bytes32 private ensNode;\r\n  LinkTokenInterface private link;\r\n  ChainlinkRequestInterface private oracle;\r\n  uint256 private requests = 1;\r\n  mapping(bytes32 => address) private pendingRequests;\r\n\r\n  event ChainlinkRequested(bytes32 indexed id);\r\n  event ChainlinkFulfilled(bytes32 indexed id);\r\n  event ChainlinkCancelled(bytes32 indexed id);\r\n\r\n  /**\r\n   * @notice Creates a request that can hold additional parameters\r\n   * @param _specId The Job Specification ID that the request will be created for\r\n   * @param _callbackAddress The callback address that the response will be sent to\r\n   * @param _callbackFunctionSignature The callback function signature to use for the callback address\r\n   * @return A Chainlink Request struct in memory\r\n   */\r\n  function buildChainlinkRequest(\r\n    bytes32 _specId,\r\n    address _callbackAddress,\r\n    bytes4 _callbackFunctionSignature\r\n  ) internal pure returns (Chainlink.Request memory) {\r\n    Chainlink.Request memory req;\r\n    return req.initialize(_specId, _callbackAddress, _callbackFunctionSignature);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the stored oracle address\r\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\r\n   * @param _req The initialized Chainlink Request\r\n   * @param _payment The amount of LINK to send for the request\r\n   * @return The request ID\r\n   */\r\n  function sendChainlinkRequest(Chainlink.Request memory _req, uint256 _payment)\r\n    internal\r\n    returns (bytes32)\r\n  {\r\n    return sendChainlinkRequestTo(oracle, _req, _payment);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the specified oracle address\r\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\r\n   * send LINK which creates a request on the target oracle contract.\r\n   * Emits ChainlinkRequested event.\r\n   * @param _oracle The address of the oracle for the request\r\n   * @param _req The initialized Chainlink Request\r\n   * @param _payment The amount of LINK to send for the request\r\n   * @return The request ID\r\n   */\r\n  function sendChainlinkRequestTo(address _oracle, Chainlink.Request memory _req, uint256 _payment)\r\n    internal\r\n    returns (bytes32 requestId)\r\n  {\r\n    requestId = keccak256(abi.encodePacked(this, requests));\r\n    _req.nonce = requests;\r\n    pendingRequests[requestId] = _oracle;\r\n    emit ChainlinkRequested(requestId);\r\n    require(link.transferAndCall(_oracle, _payment, encodeRequest(_req)), \"unable to transferAndCall to oracle\");\r\n    requests += 1;\r\n\r\n    return requestId;\r\n  }\r\n\r\n  /**\r\n   * @notice Allows a request to be cancelled if it has not been fulfilled\r\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\r\n   * Deletes the request from the `pendingRequests` mapping.\r\n   * Emits ChainlinkCancelled event.\r\n   * @param _requestId The request ID\r\n   * @param _payment The amount of LINK sent for the request\r\n   * @param _callbackFunc The callback function specified for the request\r\n   * @param _expiration The time of the expiration for the request\r\n   */\r\n  function cancelChainlinkRequest(\r\n    bytes32 _requestId,\r\n    uint256 _payment,\r\n    bytes4 _callbackFunc,\r\n    uint256 _expiration\r\n  )\r\n    internal\r\n  {\r\n    ChainlinkRequestInterface requested = ChainlinkRequestInterface(pendingRequests[_requestId]);\r\n    delete pendingRequests[_requestId];\r\n    emit ChainlinkCancelled(_requestId);\r\n    requested.cancelOracleRequest(_requestId, _payment, _callbackFunc, _expiration);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle address\r\n   * @param _oracle The address of the oracle contract\r\n   */\r\n  function setChainlinkOracle(address _oracle) internal {\r\n    oracle = ChainlinkRequestInterface(_oracle);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the LINK token address\r\n   * @param _link The address of the LINK token contract\r\n   */\r\n  function setChainlinkToken(address _link) internal {\r\n    link = LinkTokenInterface(_link);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the Chainlink token address for the public\r\n   * network as given by the Pointer contract\r\n   */\r\n  function setPublicChainlinkToken() internal {\r\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the stored address of the LINK token\r\n   * @return The address of the LINK token\r\n   */\r\n  function chainlinkTokenAddress()\r\n    internal\r\n    view\r\n    returns (address)\r\n  {\r\n    return address(link);\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the stored address of the oracle contract\r\n   * @return The address of the oracle contract\r\n   */\r\n  function chainlinkOracleAddress()\r\n    internal\r\n    view\r\n    returns (address)\r\n  {\r\n    return address(oracle);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows for a request which was created on another contract to be fulfilled\r\n   * on this contract\r\n   * @param _oracle The address of the oracle contract that will fulfill the request\r\n   * @param _requestId The request ID used for the response\r\n   */\r\n  function addChainlinkExternalRequest(address _oracle, bytes32 _requestId)\r\n    internal\r\n    notPendingRequest(_requestId)\r\n  {\r\n    pendingRequests[_requestId] = _oracle;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\r\n   * @dev Accounts for subnodes having different resolvers\r\n   * @param _ens The address of the ENS contract\r\n   * @param _node The ENS node hash\r\n   */\r\n  function useChainlinkWithENS(address _ens, bytes32 _node)\r\n    internal\r\n  {\r\n    ens = ENSInterface(_ens);\r\n    ensNode = _node;\r\n    bytes32 linkSubnode = keccak256(abi.encodePacked(ensNode, ENS_TOKEN_SUBNAME));\r\n    ENSResolver resolver = ENSResolver(ens.resolver(linkSubnode));\r\n    setChainlinkToken(resolver.addr(linkSubnode));\r\n    updateChainlinkOracleWithENS();\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle contract with the address resolved by ENS\r\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\r\n   */\r\n  function updateChainlinkOracleWithENS()\r\n    internal\r\n  {\r\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(ensNode, ENS_ORACLE_SUBNAME));\r\n    ENSResolver resolver = ENSResolver(ens.resolver(oracleSubnode));\r\n    setChainlinkOracle(resolver.addr(oracleSubnode));\r\n  }\r\n\r\n  /**\r\n   * @notice Encodes the request to be sent to the oracle contract\r\n   * @dev The Chainlink node expects values to be in order for the request to be picked up. Order of types\r\n   * will be validated in the oracle contract.\r\n   * @param _req The initialized Chainlink Request\r\n   * @return The bytes payload for the `transferAndCall` method\r\n   */\r\n  function encodeRequest(Chainlink.Request memory _req)\r\n    private\r\n    view\r\n    returns (bytes memory)\r\n  {\r\n    return abi.encodeWithSelector(\r\n      oracle.oracleRequest.selector,\r\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\r\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\r\n      _req.id,\r\n      _req.callbackAddress,\r\n      _req.callbackFunctionId,\r\n      _req.nonce,\r\n      ARGS_VERSION,\r\n      _req.buf.buf);\r\n  }\r\n\r\n  /**\r\n   * @notice Ensures that the fulfillment is valid for this contract\r\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\r\n   * @param _requestId The request ID for fulfillment\r\n   */\r\n  function validateChainlinkCallback(bytes32 _requestId)\r\n    internal\r\n    recordChainlinkFulfillment(_requestId)\r\n    // solium-disable-next-line no-empty-blocks\r\n  {}\r\n\r\n  /**\r\n   * @dev Reverts if the sender is not the oracle of the request.\r\n   * Emits ChainlinkFulfilled event.\r\n   * @param _requestId The request ID for fulfillment\r\n   */\r\n  modifier recordChainlinkFulfillment(bytes32 _requestId) {\r\n    require(msg.sender == pendingRequests[_requestId], \"Source must be the oracle of the request\");\r\n    delete pendingRequests[_requestId];\r\n    emit ChainlinkFulfilled(_requestId);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the request is already pending\r\n   * @param _requestId The request ID for fulfillment\r\n   */\r\n  modifier notPendingRequest(bytes32 _requestId) {\r\n    require(pendingRequests[_requestId] == address(0), \"Request is already pending\");\r\n    _;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: ../examples/testnet/TestnetConsumerBase.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\ncontract ATestnetConsumer is ChainlinkClient, Ownable {\r\n  uint256 constant private ORACLE_PAYMENT = 1 * LINK; // solium-disable-line zeppelin/no-arithmetic-operations\r\n\r\n  uint256 public currentPrice;\r\n  int256 public changeDay;\r\n  bytes32 public lastMarket;\r\n\r\n  event RequestEthereumPriceFulfilled(\r\n    bytes32 indexed requestId,\r\n    uint256 indexed price\r\n  );\r\n\r\n  event RequestEthereumChangeFulfilled(\r\n    bytes32 indexed requestId,\r\n    int256 indexed change\r\n  );\r\n\r\n  event RequestEthereumLastMarket(\r\n    bytes32 indexed requestId,\r\n    bytes32 indexed market\r\n  );\r\n\r\n  constructor() Ownable() public {\r\n    setPublicChainlinkToken();\r\n  }\r\n\r\n  function requestEthereumPrice(address _oracle, string _jobId)\r\n    public\r\n    onlyOwner\r\n  {\r\n    Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), this, this.fulfillEthereumPrice.selector);\r\n    req.add(\"get\", \"https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD\");\r\n    req.add(\"path\", \"USD\");\r\n    req.addInt(\"times\", 100);\r\n    sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);\r\n  }\r\n\r\n  function requestEthereumChange(address _oracle, string _jobId)\r\n    public\r\n    onlyOwner\r\n  {\r\n    Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), this, this.fulfillEthereumChange.selector);\r\n    req.add(\"get\", \"https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD\");\r\n    req.add(\"path\", \"RAW.ETH.USD.CHANGEPCTDAY\");\r\n    req.addInt(\"times\", 1000000000);\r\n    sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);\r\n  }\r\n\r\n  function requestEthereumLastMarket(address _oracle, string _jobId)\r\n    public\r\n    onlyOwner\r\n  {\r\n    Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), this, this.fulfillEthereumLastMarket.selector);\r\n    req.add(\"get\", \"https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD\");\r\n    string[] memory path = new string[](4);\r\n    path[0] = \"RAW\";\r\n    path[1] = \"ETH\";\r\n    path[2] = \"USD\";\r\n    path[3] = \"LASTMARKET\";\r\n    req.addStringArray(\"path\", path);\r\n    sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);\r\n  }\r\n\r\n  function fulfillEthereumPrice(bytes32 _requestId, uint256 _price)\r\n    public\r\n    recordChainlinkFulfillment(_requestId)\r\n  {\r\n    emit RequestEthereumPriceFulfilled(_requestId, _price);\r\n    currentPrice = _price;\r\n  }\r\n\r\n  function fulfillEthereumChange(bytes32 _requestId, int256 _change)\r\n    public\r\n    recordChainlinkFulfillment(_requestId)\r\n  {\r\n    emit RequestEthereumChangeFulfilled(_requestId, _change);\r\n    changeDay = _change;\r\n  }\r\n\r\n  function fulfillEthereumLastMarket(bytes32 _requestId, bytes32 _market)\r\n    public\r\n    recordChainlinkFulfillment(_requestId)\r\n  {\r\n    emit RequestEthereumLastMarket(_requestId, _market);\r\n    lastMarket = _market;\r\n  }\r\n\r\n  function getChainlinkToken() public view returns (address) {\r\n    return chainlinkTokenAddress();\r\n  }\r\n\r\n  function withdrawLink() public onlyOwner {\r\n    LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());\r\n    require(link.transfer(msg.sender, link.balanceOf(address(this))), \"Unable to transfer\");\r\n  }\r\n\r\n  function stringToBytes32(string memory source) private pure returns (bytes32 result) {\r\n    bytes memory tempEmptyStringTest = bytes(source);\r\n    if (tempEmptyStringTest.length == 0) {\r\n      return 0x0;\r\n    }\r\n\r\n    assembly {\r\n      result := mload(add(source, 32))\r\n    }\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getChainlinkToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"changeDay\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"name\":\"_market\",\"type\":\"bytes32\"}],\"name\":\"fulfillEthereumLastMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_jobId\",\"type\":\"string\"}],\"name\":\"requestEthereumChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawLink\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"fulfillEthereumPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"name\":\"_change\",\"type\":\"int256\"}],\"name\":\"fulfillEthereumChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_jobId\",\"type\":\"string\"}],\"name\":\"requestEthereumPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_jobId\",\"type\":\"string\"}],\"name\":\"requestEthereumLastMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"RequestEthereumPriceFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"change\",\"type\":\"int256\"}],\"name\":\"RequestEthereumChangeFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"market\",\"type\":\"bytes32\"}],\"name\":\"RequestEthereumLastMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkCancelled\",\"type\":\"event\"}]","ContractName":"ATestnetConsumer","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://42a30d781221f913fb47464b721e5cca92a9f51cb05655d572d4ee9d3dc29e14"}]}