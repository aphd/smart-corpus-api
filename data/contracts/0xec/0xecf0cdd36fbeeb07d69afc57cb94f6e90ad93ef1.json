{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-05-28\r\n*/\r\n\r\npragma solidity ^0.4.26;\r\n\r\n\r\n        /**\r\n         * @title SafeMath\r\n         * @dev Unsigned math operations with safety checks that revert on error\r\n         */\r\nlibrary SafeMath {\r\n        /**\r\n         * @dev Multiplies two unsigned integers, reverts on overflow.\r\n         */\r\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n                // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n                // benefit is lost if 'b' is also tested.\r\n                // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n                if (a == 0) {\r\n                    return 0;\r\n                }\r\n                uint256 c = a * b;\r\n                require(c / a == b);  \r\n                return c;\r\n        }\r\n\r\n        /**\r\n         * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n         */\r\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n                // Solidity only automatically asserts when dividing by 0\r\n                require(b > 0);\r\n                uint256 c = a / b;\r\n                // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n                return c;\r\n        }\r\n\r\n        /**\r\n         * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n         */\r\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n                require(b <= a);\r\n                uint256 c = a - b;\r\n\r\n                return c;\r\n        }\r\n\r\n        /**\r\n         * @dev Adds two unsigned integers, reverts on overflow.\r\n         */\r\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n                uint256 c = a + b;\r\n                require(c >= a);\r\n\r\n                return c;\r\n        }\r\n\r\n        /**\r\n         * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n         * reverts when dividing by zero.\r\n         */\r\n        function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n                require(b != 0);\r\n                return a % b;\r\n        }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n      function totalSupply() public view returns (uint256);\r\n      function balanceOf(address _who) public view returns (uint256);\r\n      function transfer(address _to, uint256 _value) public returns (bool);\r\n      function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n      function allowance(address _owner, address _spender) public view returns (uint256);\r\n      function approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n      event Transfer(address indexed from, address indexed to, uint256 value);\r\n      event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n}\r\n\r\n\r\ncontract StandardToken is ERC20 {\r\n        using SafeMath for uint256;\r\n\r\n        uint256 public totalSupply;\r\n        mapping(address => uint256) internal balances;\r\n        mapping(address => mapping (address => uint256)) internal allowed;\r\n\r\n        modifier validDestination( address _to )\r\n        {\r\n                require(_to != address(0x0), \"Invalid address.\");\r\n                require(_to != address(this), \"Invalid address.\");\r\n                _;\r\n        }\r\n\r\n        function totalSupply() public view returns (uint256) {\r\n                return totalSupply;\r\n        }\r\n\r\n        function balanceOf(address _owner) public view returns (uint256) {\r\n                return balances[_owner];\r\n        }\r\n\r\n        function transfer(address _to, uint256 _value)\r\n                public\r\n                validDestination(_to)\r\n                returns (bool)\r\n        {\r\n                balances[msg.sender] = balances[msg.sender].sub(_value);\r\n                balances[_to] = balances[_to].add(_value);\r\n                emit Transfer(msg.sender, _to, _value);\r\n                return true;\r\n        }\r\n\r\n        function transferFrom(address _from, address _to, uint256 _value)\r\n                public\r\n                validDestination(_to)\r\n                returns (bool)\r\n        {\r\n                require(_value <= allowed[_from][msg.sender],\"Exceed allowed.\");\r\n\r\n                balances[_from] = balances[_from].sub(_value);\r\n                balances[_to] = balances[_to].add(_value);\r\n\r\n                approve(msg.sender, allowed[_from][msg.sender].sub(_value));\r\n\r\n                emit Transfer(_from, _to, _value);\r\n                return true;\r\n        }\r\n\r\n        function burn(uint _value) public returns (bool)\r\n        {\r\n                balances[msg.sender] = balances[msg.sender].sub(_value);\r\n                totalSupply = totalSupply.sub(_value);\r\n                emit Transfer(msg.sender, address(0x0), _value);\r\n                return true;\r\n        }\r\n\r\n        function burnFrom(address _from, uint256 _value) public validDestination(_from) returns (bool)\r\n        {\r\n                balances[_from] = balances[_from].sub(_value);\r\n                totalSupply = totalSupply.sub(_value);\r\n                emit Transfer(_from, address(0x0), _value);\r\n\r\n                approve(msg.sender, allowed[_from][msg.sender].sub(_value));\r\n\r\n                return true;\r\n        }\r\n\r\n        function approve(address _spender, uint256 _value) public validDestination(_spender) returns (bool) {\r\n                require(_value <= 3 * 10 ** 11 * 10 ** 12);\r\n\r\n                allowed[msg.sender][_spender] = _value;\r\n                emit Approval(msg.sender, _spender, _value);\r\n                return true;\r\n        }\r\n\r\n        function allowance(address _owner, address _spender) public view returns (uint256)\r\n        {\r\n                return allowed[_owner][_spender];\r\n        }\r\n}\r\n\r\n\r\ncontract Ownable {\r\n        address public owner;\r\n\r\n        event OwnershipTransferred(\r\n                address indexed previousOwner,\r\n                address indexed newOwner\r\n        );\r\n\r\n        constructor() public {\r\n                owner = msg.sender;\r\n        }\r\n\r\n        modifier onlyOwner() {\r\n                require(msg.sender == owner);\r\n                _;\r\n        }\r\n\r\n        function transferOwnership(address _newOwner) public onlyOwner {\r\n                require(_newOwner != address(0x0));\r\n                emit OwnershipTransferred(owner, _newOwner);\r\n                owner = _newOwner;\r\n        }\r\n\r\n}\r\n\r\n\r\ncontract Pausable is Ownable {\r\n        event Pause();\r\n        event Unpause();\r\n\r\n        bool public paused = false;\r\n\r\n        modifier whenNotPaused() {\r\n                require(!paused);\r\n                _;\r\n        }\r\n\r\n        modifier whenPaused() {\r\n                require(paused);\r\n                _;\r\n        }\r\n\r\n        function pause() public onlyOwner whenNotPaused {\r\n                paused = true;\r\n                emit Pause();\r\n        }\r\n\r\n        function unpause() public onlyOwner whenPaused {\r\n                paused = false;\r\n                emit Unpause();\r\n        }\r\n}\r\n\r\n\r\ncontract Freezable is Ownable {\r\n        mapping (address => bool) public frozenAccount;\r\n\r\n        event Freeze(address indexed target, bool frozen);\r\n        event Unfreeze(address indexed target, bool frozen);\r\n\r\n        modifier isNotFrozen(address _target) {\r\n                require(!frozenAccount[_target]);\r\n                _;\r\n        }\r\n\r\n        modifier isFrozen(address _target) {\r\n                require(frozenAccount[_target]);\r\n                _;\r\n        }\r\n\r\n        function freeze(address _target) public onlyOwner isNotFrozen(_target) {\r\n                require(_target != address(0x0));\r\n\r\n                frozenAccount[_target] = true;\r\n                emit Freeze(_target, true);\r\n        }\r\n\r\n        function unfreeze(address _target) public onlyOwner isFrozen(_target) {\r\n                require(_target != address(0x0));\r\n\r\n                frozenAccount[_target] = false;\r\n                emit Unfreeze(_target, false);\r\n        }\r\n}\r\n\r\n        /**\r\n         * @title Pausable token\r\n         * @dev StandardToken modified with pausable transfers.\r\n         **/\r\ncontract PausableToken is StandardToken, Pausable, Freezable {\r\n\r\n        function transfer(address _to, uint256 _value)\r\n                public\r\n                whenNotPaused\r\n                isNotFrozen(msg.sender)\r\n                isNotFrozen(_to)\r\n                returns (bool)\r\n        {\r\n                return super.transfer(_to, _value);\r\n        }\r\n\r\n        function transferFrom(address _from, address _to, uint256 _value)\r\n                public\r\n                whenNotPaused\r\n                isNotFrozen(_from)\r\n                isNotFrozen(_to)\r\n                returns (bool)\r\n        {\r\n                return super.transferFrom(_from, _to, _value);\r\n        }\r\n\r\n        function burn(uint256 _value)\r\n                public\r\n                whenNotPaused\r\n                isNotFrozen(msg.sender)\r\n                returns (bool)\r\n        {\r\n                return super.burn(_value);\r\n        }\r\n\r\n        function burnFrom(address _to, uint256 _value)\r\n                public\r\n                whenNotPaused\r\n                isNotFrozen(_to)\r\n                returns (bool)\r\n        {\r\n                return super.burnFrom(_to, _value);\r\n        }\r\n\r\n        function approve(\r\n                address _spender,\r\n                uint256 _value\r\n        )\r\n                public\r\n                whenNotPaused\r\n                isNotFrozen(msg.sender)\r\n                isNotFrozen(_spender)\r\n                returns (bool)\r\n        {\r\n                return super.approve(_spender, _value);\r\n        }\r\n\r\n}\r\n\r\ncontract TimeLockable is Ownable {\r\n        using SafeMath for uint256;\r\n\r\n        uint256 private constant SECOND_IN_DAY = 86400;\r\n\r\n        mapping (address => uint256) internal lockedBaseQuantity;\r\n\r\n        event LockAccount(address indexed target, uint256 value);\r\n\r\n\r\n        function setTimeLockAccount(address _target, uint256 _value)\r\n                internal\r\n                onlyOwner\r\n                returns (bool)\r\n        {\r\n                require(_target != address(0));\r\n                require(_value != 0);\r\n                lockedBaseQuantity[_target] = lockedBaseQuantity[_target].add(_value);\r\n\r\n                emit LockAccount(_target, _value);\r\n                return true;\r\n        }\r\n\r\n        function lockedNow(address _target) internal view returns ( uint256 ) {\r\n                if (lockedBaseQuantity[_target] == 0) return 0;\r\n                return _getLockedRate(now) * lockedBaseQuantity[_target] / 100;\r\n        }\r\n\r\n        function _getLockedRate(uint256 _timeNow) private pure returns(uint256 lockedRate) {\r\n\r\n\r\n                if (_timeNow >= 1615334400) {           // 2021-03-10\r\n                        return 0;\r\n                } else if (_timeNow >= 1612915200) {    // 2021-02-10\r\n                        return 10;\r\n                } else if (_timeNow >= 1610236800) {    // 2021-01-10\r\n                        return 20;\r\n                } else if (_timeNow >= 1607558400) {    // 2020-12-10\r\n                        return 30;\r\n                } else if (_timeNow >= 1604966400) {    // 2020-11-10\r\n                        return 40;\r\n                } else if (_timeNow >= 1602288000) {    // 2020-10-10\r\n                        return 45;\r\n                } else if (_timeNow >= 1599696000) {    // 2020-09-10\r\n                        return 50;\r\n                } else if (_timeNow >= 1597017600) {    // 2020-08-10\r\n                        return 55;\r\n                } else if (_timeNow >= 1594339200) {    // 2020-07-10\r\n                        return 60;\r\n                } else if (_timeNow >= 1591747200) {    // 2020-06-10\r\n                        return 65;\r\n                } else if (_timeNow >= 1589068800) {    // 2020-05-10\r\n                        return 70;\r\n                } else if (_timeNow >= 1586476800) {    // 2020-04-10\r\n                        return 75;\r\n                } else if (_timeNow >= 1583798400) {    // 2020-03-10\r\n                        return 80;\r\n                } else if (_timeNow >= 1581292800) {    // 2020-02-10\r\n                        return 85;\r\n                } else if (_timeNow >= 1578614400) {    // 2020-01-10\r\n                        return 90;\r\n                } else if (_timeNow >= 1575936000) {    // 2019-12-10\r\n                        return 95;\r\n                } else {    // before 2019-12-10\r\n                        return 100;\r\n                }\r\n        }\r\n}\r\n\r\n        /**\r\n         * @title DKHAN Token\r\n         * @dev time lock(sequential unlock), puase, burn, freeze added.\r\n         **/\r\ncontract DKHAN is PausableToken, TimeLockable  {\r\n        using SafeMath for uint256;\r\n\r\n        string  public  name;\r\n        string  public  symbol;\r\n        uint256 public  constant decimals = 12;\r\n        uint256 public  totalSupply;\r\n\r\n        constructor(\r\n                uint256 initialSupply,\r\n                string memory tokenName,\r\n                string memory tokenSymbol\r\n        )\r\n                public\r\n        {\r\n                totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n                balances[msg.sender] = totalSupply;                     // Give the creator all initial tokens\r\n                name = tokenName;                                       // Set the name for display purposes\r\n                symbol = tokenSymbol;                                   // Set the symbol for display purposes\r\n        }\r\n\r\n        modifier canTransper(address _from, uint256 _value) {\r\n                require(_value <= balances[_from], \"Exceed balance\");\r\n                require(_value <= balanceAvailable(_from), \"Exceed unlocked balance\");\r\n                _;\r\n        }\r\n\r\n        function balanceAvailable(address _from) public view returns ( uint256 ) {\r\n                return balances[_from].sub(lockedNow(_from));\r\n        }\r\n\r\n        function lockedInfo(address _from) public view returns ( uint256 _lockedNow, uint256 _lockedAtFirst ) {\r\n                return (lockedNow(_from), lockedBaseQuantity[_from]);\r\n        }\r\n\r\n        function lockAndTransfer(address _to, uint256 _value)\r\n                public\r\n                onlyOwner\r\n                returns (bool)\r\n        {\r\n                setTimeLockAccount(_to, _value);\r\n                return super.transfer(_to, _value);\r\n        }\r\n\r\n        function transfer(address _to, uint _value)\r\n                public\r\n                canTransper(msg.sender, _value)\r\n                returns (bool)\r\n        {\r\n                return super.transfer(_to, _value);\r\n        }\r\n\r\n        function transferFrom(address _from, address _to, uint _value)\r\n                public\r\n                canTransper(_from, _value)\r\n                returns (bool)\r\n        {\r\n                return super.transferFrom(_from, _to, _value);\r\n        }\r\n\r\n        function burn(uint _value)                              // Cannot burn locked amount\r\n                public\r\n                canTransper(msg.sender, _value)\r\n                returns (bool)\r\n        {\r\n                return super.burn(_value);\r\n        }\r\n\r\n        function burnFrom(address _from, uint256 _value)        // Cannot burn locked amount\r\n                public\r\n                canTransper(_from, _value)\r\n                returns (bool)\r\n        {\r\n                return super.burnFrom(_from, _value);\r\n        }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"lockAndTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"balanceAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"lockedInfo\",\"outputs\":[{\"name\":\"_lockedNow\",\"type\":\"uint256\"},{\"name\":\"_lockedAtFirst\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LockAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"Unfreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"DKHAN","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000007d2b7500000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005444b48414e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003444b4e0000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://47c36b44bac7d9524bca4a3c69a3bdcaf1882b891844b7d26b4d5b4a6ffbab17"}]}