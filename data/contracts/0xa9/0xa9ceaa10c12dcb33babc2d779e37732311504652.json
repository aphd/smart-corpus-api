{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-07-16\r\n*/\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n        _addWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title WhitelistedRole\r\n * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\r\n * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\r\n * it), and not Whitelisteds themselves.\r\n */\r\ncontract WhitelistedRole is WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function renounceWhitelisted() public {\r\n        _removeWhitelisted(msg.sender);\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n}\r\n\r\n/**\r\n * @title RequestHashStorage\r\n * @notice This contract is the entry point to retrieve all the hashes of the request network system.\r\n  */\r\ncontract RequestHashStorage is WhitelistedRole {\r\n\r\n  // Event to declare a new hash\r\n  event NewHash(string hash, address hashSubmitter, bytes feesParameters);\r\n\r\n  /**\r\n   * @notice Declare a new hash\r\n   * @param _hash hash to store\r\n   * @param _feesParameters Parameters use to compute the fees. This is a bytes to stay generic, the structure is on the charge of the hashSubmitter contracts.\r\n   */\r\n  function declareNewHash(string calldata _hash, bytes calldata _feesParameters)\r\n    external\r\n    onlyWhitelisted\r\n  {\r\n    // Emit event for log\r\n    emit NewHash(_hash, msg.sender, _feesParameters);\r\n  }\r\n\r\n  // Fallback function returns funds to the sender\r\n  function()\r\n    external\r\n  {\r\n    revert(\"not payable fallback\");\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Bytes util library.\r\n * @notice Collection of utility functions to manipulate bytes for Request.\r\n */\r\nlibrary Bytes {\r\n  /**\r\n    * @notice Extract a bytes32 from a bytes.\r\n    * @param data bytes from where the bytes32 will be extract\r\n    * @param offset position of the first byte of the bytes32\r\n    * @return address\r\n    */\r\n  function extractBytes32(bytes memory data, uint offset)\r\n    internal\r\n    pure\r\n    returns (bytes32 bs)\r\n  {\r\n    require(offset >= 0 && offset + 32 <= data.length, \"offset value should be in the correct range\");\r\n\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n        bs := mload(add(data, add(32, offset)))\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @title StorageFeeCollector\r\n *\r\n * @notice StorageFeeCollector is a contract managing the fees\r\n */\r\ncontract StorageFeeCollector is WhitelistAdminRole {\r\n  using SafeMath for uint256;\r\n\r\n  /**\r\n   * Fee computation for storage are based on four parameters:\r\n   * minimumFee (wei) fee that will be applied for any size of storage\r\n   * rateFeesNumerator (wei) and rateFeesDenominator (byte) define the variable fee,\r\n   * for each <rateFeesDenominator> bytes above threshold, <rateFeesNumerator> wei will be charged\r\n   *\r\n   * Example:\r\n   * If the size to store is 50 bytes, the threshold is 100 bytes and the minimum fee is 300 wei,\r\n   * then 300 will be charged\r\n   *\r\n   * If rateFeesNumerator is 2 and rateFeesDenominator is 1 then 2 wei will be charged for every bytes above threshold,\r\n   * if the size to store is 150 bytes then the fee will be 300 + (150-100)*2 = 400 wei\r\n   */\r\n  uint256 public minimumFee;\r\n  uint256 public rateFeesNumerator;\r\n  uint256 public rateFeesDenominator;\r\n\r\n  // address of the contract that will burn req token\r\n  address payable public requestBurnerContract;\r\n\r\n  event UpdatedFeeParameters(uint256 minimumFee, uint256 rateFeesNumerator, uint256 rateFeesDenominator);\r\n  event UpdatedMinimumFeeThreshold(uint256 threshold);\r\n  event UpdatedBurnerContract(address burnerAddress);\r\n\r\n  /**\r\n   * @param _requestBurnerContract Address of the contract where to send the ether.\r\n   * This burner contract will have a function that can be called by anyone and will exchange ether to req via Kyber and burn the REQ\r\n   */\r\n  constructor(address payable _requestBurnerContract)\r\n    public\r\n  {\r\n    requestBurnerContract = _requestBurnerContract;\r\n  }\r\n\r\n  /**\r\n    * @notice Sets the fees rate and minimum fee.\r\n    * @dev if the _rateFeesDenominator is 0, it will be treated as 1. (in other words, the computation of the fees will not use it)\r\n    * @param _minimumFee minimum fixed fee\r\n    * @param _rateFeesNumerator numerator rate\r\n    * @param _rateFeesDenominator denominator rate\r\n    */\r\n  function setFeeParameters(uint256 _minimumFee, uint256 _rateFeesNumerator, uint256 _rateFeesDenominator)\r\n    external\r\n    onlyWhitelistAdmin\r\n  {\r\n    minimumFee = _minimumFee;\r\n    rateFeesNumerator = _rateFeesNumerator;\r\n    rateFeesDenominator = _rateFeesDenominator;\r\n    emit UpdatedFeeParameters(minimumFee, rateFeesNumerator, rateFeesDenominator);\r\n  }\r\n\r\n\r\n  /**\r\n    * @notice Set the request burner address.\r\n    * @param _requestBurnerContract address of the contract that will burn req token (probably through Kyber)\r\n    */\r\n  function setRequestBurnerContract(address payable _requestBurnerContract)\r\n    external\r\n    onlyWhitelistAdmin\r\n  {\r\n    requestBurnerContract = _requestBurnerContract;\r\n    emit UpdatedBurnerContract(requestBurnerContract);\r\n  }\r\n\r\n  /**\r\n    * @notice Computes the fees.\r\n    * @param _contentSize Size of the content of the block to be stored\r\n    * @return the expected amount of fees in wei\r\n    */\r\n  function getFeesAmount(uint256 _contentSize)\r\n    public\r\n    view\r\n    returns(uint256)\r\n  {\r\n    // Transactions fee\r\n    uint256 computedAllFee = _contentSize.mul(rateFeesNumerator);\r\n\r\n    if (rateFeesDenominator != 0) {\r\n      computedAllFee = computedAllFee.div(rateFeesDenominator);\r\n    }\r\n\r\n    if (computedAllFee <= minimumFee) {\r\n      return minimumFee;\r\n    } else {\r\n      return computedAllFee;\r\n    }\r\n  }\r\n\r\n  /**\r\n    * @notice Sends fees to the request burning address.\r\n    * @param _amount amount to send to the burning address\r\n    */\r\n  function collectForREQBurning(uint256 _amount)\r\n    internal\r\n  {\r\n    // .transfer throws on failure\r\n    requestBurnerContract.transfer(_amount);\r\n  }\r\n}\r\n\r\n/**\r\n * @title RequestOpenHashSubmitter\r\n * @notice Contract declares data hashes and collects the fees.\r\n * @notice The hash is declared to the whole request network system through the RequestHashStorage contract.\r\n * @notice Anyone can submit hashes.\r\n */\r\ncontract RequestOpenHashSubmitter is StorageFeeCollector {\r\n\r\n  RequestHashStorage public requestHashStorage;\r\n  \r\n  /**\r\n   * @param _addressRequestHashStorage contract address which manages the hashes declarations\r\n   * @param _addressBurner Burner address\r\n   */\r\n  constructor(address _addressRequestHashStorage, address payable _addressBurner)\r\n    StorageFeeCollector(_addressBurner)\r\n    public\r\n  {\r\n    requestHashStorage = RequestHashStorage(_addressRequestHashStorage);\r\n  }\r\n\r\n  /**\r\n   * @notice Submit a new hash to the blockchain.\r\n   *\r\n   * @param _hash Hash of the request to be stored\r\n   * @param _feesParameters fees parameters used to compute the fees. Here, it is the content size in an uint256\r\n   */\r\n  function submitHash(string calldata _hash, bytes calldata _feesParameters)\r\n    external\r\n    payable\r\n  {\r\n    // extract the contentSize from the _feesParameters\r\n    uint256 contentSize = uint256(Bytes.extractBytes32(_feesParameters, 0));\r\n\r\n    // Check fees are paid\r\n    require(getFeesAmount(contentSize) == msg.value, \"msg.value does not match the fees\");\r\n\r\n    // Send fees to burner, throws on failure\r\n    collectForREQBurning(msg.value);\r\n\r\n    // declare the hash to the whole system through to RequestHashStorage\r\n    requestHashStorage.declareNewHash(_hash, _feesParameters);\r\n  }\r\n\r\n  // Fallback function returns funds to the sender\r\n  function()\r\n    external\r\n    payable\r\n  {\r\n    revert(\"not payable fallback\");\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"minimumFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateFeesNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"string\"},{\"name\":\"_feesParameters\",\"type\":\"bytes\"}],\"name\":\"submitHash\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_requestBurnerContract\",\"type\":\"address\"}],\"name\":\"setRequestBurnerContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateFeesDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contentSize\",\"type\":\"uint256\"}],\"name\":\"getFeesAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minimumFee\",\"type\":\"uint256\"},{\"name\":\"_rateFeesNumerator\",\"type\":\"uint256\"},{\"name\":\"_rateFeesDenominator\",\"type\":\"uint256\"}],\"name\":\"setFeeParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestBurnerContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestHashStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addressRequestHashStorage\",\"type\":\"address\"},{\"name\":\"_addressBurner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"minimumFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rateFeesNumerator\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rateFeesDenominator\",\"type\":\"uint256\"}],\"name\":\"UpdatedFeeParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"UpdatedMinimumFeeThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"burnerAddress\",\"type\":\"address\"}],\"name\":\"UpdatedBurnerContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"}]","ContractName":"RequestOpenHashSubmitter","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000024a66afda3666fb0202f439708ece45c8121a9bb0000000000000000000000007b3c4d90e8af6030d66c07f8f815f9505e379d6f","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://cac196a65b33835bae4a2d5c12524ad94c6d0c66e9a035a1a6141cafb4ebe148"}]}