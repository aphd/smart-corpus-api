{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n\r\n// @title SafeMath: overflow/underflow checks\r\n// @notice Math operations with safety checks that throw on error\r\nlibrary SafeMath {\r\n\r\n  // @notice Multiplies two numbers, throws on overflow.\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  // @notice Integer division of two numbers, truncating the quotient.\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  // @notice Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  // @notice Adds two numbers, throws on overflow.\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  // @notice Returns fractional amount\r\n  function getFractionalAmount(uint256 _amount, uint256 _percentage)\r\n  internal\r\n  pure\r\n  returns (uint256) {\r\n    return div(mul(_amount, _percentage), 100);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/DBInterface.sol\r\n\r\n// Database interface\r\ninterface DBInterface {\r\n\r\n  function setContractManager(address _contractManager)\r\n  external;\r\n\r\n    // --------------------Set Functions------------------------\r\n\r\n    function setAddress(bytes32 _key, address _value)\r\n    external;\r\n\r\n    function setUint(bytes32 _key, uint _value)\r\n    external;\r\n\r\n    function setString(bytes32 _key, string _value)\r\n    external;\r\n\r\n    function setBytes(bytes32 _key, bytes _value)\r\n    external;\r\n\r\n    function setBytes32(bytes32 _key, bytes32 _value)\r\n    external;\r\n\r\n    function setBool(bytes32 _key, bool _value)\r\n    external;\r\n\r\n    function setInt(bytes32 _key, int _value)\r\n    external;\r\n\r\n\r\n     // -------------- Deletion Functions ------------------\r\n\r\n    function deleteAddress(bytes32 _key)\r\n    external;\r\n\r\n    function deleteUint(bytes32 _key)\r\n    external;\r\n\r\n    function deleteString(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBytes(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBytes32(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBool(bytes32 _key)\r\n    external;\r\n\r\n    function deleteInt(bytes32 _key)\r\n    external;\r\n\r\n    // ----------------Variable Getters---------------------\r\n\r\n    function uintStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (uint);\r\n\r\n    function stringStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (string);\r\n\r\n    function addressStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n    function bytesStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bytes);\r\n\r\n    function bytes32Storage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bytes32);\r\n\r\n    function boolStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n    function intStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n// File: contracts/database/Events.sol\r\n\r\ncontract Events {\r\n  DBInterface public database;\r\n\r\n  constructor(address _database) public{\r\n    database = DBInterface(_database);\r\n  }\r\n\r\n  function message(string _message)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogEvent(_message, keccak256(abi.encodePacked(_message)), tx.origin);\r\n  }\r\n\r\n  function transaction(string _message, address _from, address _to, uint _amount, address _token)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogTransaction(_message, keccak256(abi.encodePacked(_message)), _from, _to, _amount, _token, tx.origin);\r\n  }\r\n\r\n  function registration(string _message, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogAddress(_message, keccak256(abi.encodePacked(_message)), _account, tx.origin);\r\n  }\r\n\r\n  function contractChange(string _message, address _account, string _name)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogContractChange(_message, keccak256(abi.encodePacked(_message)), _account, _name, tx.origin);\r\n  }\r\n\r\n  function asset(string _message, string _uri, address _assetAddress, address _manager)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogAsset(_message, keccak256(abi.encodePacked(_message)), _uri, keccak256(abi.encodePacked(_uri)), _assetAddress, _manager, tx.origin);\r\n  }\r\n\r\n  function escrow(string _message, address _assetAddress, bytes32 _escrowID, address _manager, uint _amount)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogEscrow(_message, keccak256(abi.encodePacked(_message)), _assetAddress, _escrowID, _manager, _amount, tx.origin);\r\n  }\r\n\r\n  function order(string _message, bytes32 _orderID, uint _amount, uint _price)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogOrder(_message, keccak256(abi.encodePacked(_message)), _orderID, _amount, _price, tx.origin);\r\n  }\r\n\r\n  function exchange(string _message, bytes32 _orderID, address _assetAddress, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogExchange(_message, keccak256(abi.encodePacked(_message)), _orderID, _assetAddress, _account, tx.origin);\r\n  }\r\n\r\n  function operator(string _message, bytes32 _id, string _name, string _ipfs, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogOperator(_message, keccak256(abi.encodePacked(_message)), _id, _name, _ipfs, _account, tx.origin);\r\n  }\r\n\r\n  function consensus(string _message, bytes32 _executionID, bytes32 _votesID, uint _votes, uint _tokens, uint _quorum)\r\n  external\r\n  onlyApprovedContract {\r\n    emit LogConsensus(_message, keccak256(abi.encodePacked(_message)), _executionID, _votesID, _votes, _tokens, _quorum, tx.origin);\r\n  }\r\n\r\n  //Generalized events\r\n  event LogEvent(string message, bytes32 indexed messageID, address indexed origin);\r\n  event LogTransaction(string message, bytes32 indexed messageID, address indexed from, address indexed to, uint amount, address token, address origin); //amount and token will be empty on some events\r\n  event LogAddress(string message, bytes32 indexed messageID, address indexed account, address indexed origin);\r\n  event LogContractChange(string message, bytes32 indexed messageID, address indexed account, string name, address indexed origin);\r\n  event LogAsset(string message, bytes32 indexed messageID, string uri, bytes32 indexed assetID, address asset, address manager, address indexed origin);\r\n  event LogEscrow(string message, bytes32 indexed messageID, address asset, bytes32  escrowID, address indexed manager, uint amount, address indexed origin);\r\n  event LogOrder(string message, bytes32 indexed messageID, bytes32 indexed orderID, uint amount, uint price, address indexed origin);\r\n  event LogExchange(string message, bytes32 indexed messageID, bytes32 orderID, address indexed asset, address account, address indexed origin);\r\n  event LogOperator(string message, bytes32 indexed messageID, bytes32 id, string name, string ipfs, address indexed account, address indexed origin);\r\n  event LogConsensus(string message, bytes32 indexed messageID, bytes32 executionID, bytes32 votesID, uint votes, uint tokens, uint quorum, address indexed origin);\r\n\r\n\r\n  // --------------------------------------------------------------------------------------\r\n  // Caller must be registered as a contract through ContractManager.sol\r\n  // --------------------------------------------------------------------------------------\r\n  modifier onlyApprovedContract() {\r\n      require(database.boolStorage(keccak256(abi.encodePacked(\"contract\", msg.sender))));\r\n      _;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/KyberInterface.sol\r\n\r\n// @notice Trade via the Kyber Proxy Contract\r\ninterface KyberInterface {\r\n  function getExpectedRate(address src, address dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\r\n  function trade(address src, uint srcAmount, address dest, address destAddress, uint maxDestAmount,uint minConversionRate, address walletId) external payable returns(uint);\r\n}\r\n\r\n// File: contracts/interfaces/MinterInterface.sol\r\n\r\ninterface MinterInterface {\r\n  function cloneToken(string _uri, address _erc20Address) external returns (address asset);\r\n\r\n  function mintAssetTokens(address _assetAddress, address _receiver, uint256 _amount) external returns (bool);\r\n\r\n  function changeTokenController(address _assetAddress, address _newController) external returns (bool);\r\n}\r\n\r\n// File: contracts/crowdsale/CrowdsaleGeneratorERC20.sol\r\n\r\ninterface CrowdsaleGeneratorERC20_ERC20 {\r\n  function balanceOf(address _who) external view returns (uint256);\r\n  function approve(address _spender, uint256 _value) external returns (bool);\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\n// @title A crowdsale generator contract\r\n// @author Kyle Dewhurst & Peter Phillips, MyBit Foundation\r\n// @notice AssetManagers can initiate a crowdsale that accepts ERC20 tokens as payment here\r\ncontract CrowdsaleGeneratorERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  DBInterface private database;\r\n  Events private events;\r\n  KyberInterface private kyber;\r\n  MinterInterface private minter;\r\n  //CrowdsaleGeneratorERC20_ERC20Burner private burner;\r\n\r\n  //uint constant scalingFactor = 10**32;\r\n\r\n  // @notice This contract\r\n  // @param: The address for the database contract used by this platform\r\n  constructor(address _database, address _events, address _kyber)\r\n  public{\r\n      database = DBInterface(_database);\r\n      events = Events(_events);\r\n      kyber = KyberInterface(_kyber);\r\n      minter = MinterInterface(database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"Minter\"))));\r\n  }\r\n\r\n  // @notice AssetManagers can initiate a crowdfund for a new asset here\r\n  // @dev the crowdsaleERC20 contract is granted rights to mint asset-tokens as it receives funding\r\n  // @param (string) _assetURI = The location where information about the asset can be found\r\n  // @param (bytes32) _modelID = The modelID of the asset that will be used in the crowdsale\r\n  // @param (uint) _fundingLength = The number of seconds this crowdsale is to go on for until it fails\r\n  // @param (uint) _amountToRaise = The amount of tokens required to raise for the crowdsale to be a success\r\n  // @param (uint) _assetManagerPerc = The percentage of the total revenue which is to go to the AssetManager if asset is a success\r\n  // @param (address) _fundingToken = The ERC20 token to be used to fund the crowdsale (Operator must accept this token as payment)\r\n  function createAssetOrderERC20(string _assetURI, string _ipfs, bytes32 _modelID, uint _fundingLength, uint _amountToRaise, uint _assetManagerPerc, uint _escrow, address _fundingToken, address _paymentToken)\r\n  payable\r\n  external\r\n  {\r\n    if(_paymentToken == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)){\r\n      require(msg.value == _escrow);\r\n    } else {\r\n      require(msg.value == 0);\r\n    }\r\n    require(_amountToRaise >= 100, \"Crowdsale goal is too small\");\r\n    require((_assetManagerPerc + database.uintStorage(keccak256(abi.encodePacked(\"platform.percentage\")))) < 100, \"Manager percent need to be less than 100\");\r\n    require(database.addressStorage(keccak256(abi.encodePacked(\"model.operator\", _modelID))) != address(0), \"Model not set\");\r\n    require(!database.boolStorage(keccak256(abi.encodePacked(\"asset.uri\", _assetURI))), \"Asset URI is not unique\"); //Check that asset URI is unique\r\n    address assetAddress = minter.cloneToken(_assetURI, _fundingToken);\r\n    require(setCrowdsaleValues(assetAddress, _fundingLength, _amountToRaise));\r\n    require(setAssetValues(assetAddress, _assetURI, _ipfs, _modelID, msg.sender, _assetManagerPerc, _amountToRaise, _fundingToken));\r\n    uint minEscrow = calculateEscrowERC20(_amountToRaise, msg.sender, _modelID, _fundingToken);\r\n    require(lockEscrowERC20(msg.sender, assetAddress, _paymentToken, _fundingToken, _escrow, minEscrow));\r\n    events.asset('Asset funding started', _assetURI, assetAddress, msg.sender);\r\n    events.asset('New asset ipfs', _ipfs, assetAddress, msg.sender);\r\n  }\r\n\r\n  function updateIPFS(address _assetAddress, string _ipfs)\r\n  external {\r\n    require(msg.sender == database.addressStorage(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress))));\r\n    database.setString(keccak256(abi.encodePacked(\"asset.ipfs\", _assetAddress)), _ipfs);\r\n    events.asset('New asset ipfs', _ipfs, _assetAddress, msg.sender);\r\n  }\r\n\r\n  // @notice platform owners can destroy contract here\r\n  function destroy()\r\n  onlyOwner\r\n  external {\r\n    events.transaction('CrowdsaleGeneratorERC20 destroyed', address(this), msg.sender, address(this).balance, address(0));\r\n    selfdestruct(msg.sender);\r\n  }\r\n\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  //                                            Internal/ Private Functions\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n  function setCrowdsaleValues(address _assetAddress, uint _fundingLength, uint _amountToRaise)\r\n  private\r\n  returns (bool){\r\n    database.setUint(keccak256(abi.encodePacked(\"crowdsale.start\", _assetAddress)), now);\r\n    database.setUint(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress)), now.add(_fundingLength));\r\n    database.setUint(keccak256(abi.encodePacked(\"crowdsale.goal\", _assetAddress)), _amountToRaise);\r\n    database.setUint(keccak256(abi.encodePacked(\"crowdsale.remaining\", _assetAddress)), _amountToRaise.mul(uint(100).add(database.uintStorage(keccak256(abi.encodePacked(\"platform.fee\"))))).div(100));\r\n    return true;\r\n  }\r\n\r\n  function setAssetValues(address _assetAddress, string _assetURI, string _ipfs, bytes32 _modelID, address _assetManager, uint _assetManagerPerc, uint _amountToRaise, address _fundingToken)\r\n  private\r\n  returns (bool){\r\n    uint totalTokens = _amountToRaise.mul(100).div(uint(100).sub(_assetManagerPerc).sub(database.uintStorage(keccak256(abi.encodePacked(\"platform.percentage\")))));\r\n    //database.setUint(keccak256(abi.encodePacked(\"asset.managerTokens\", assetAddress)), _amountToRaise.mul(uint(100).mul(scalingFactor).div(uint(100).sub(_assetManagerPerc)).sub(scalingFactor)).div(scalingFactor));\r\n    database.setUint(keccak256(abi.encodePacked(\"asset.managerTokens\", _assetAddress)), totalTokens.getFractionalAmount(_assetManagerPerc));\r\n    database.setUint(keccak256(abi.encodePacked(\"asset.platformTokens\", _assetAddress)), totalTokens.getFractionalAmount(database.uintStorage(keccak256(abi.encodePacked(\"platform.percentage\")))));\r\n    database.setAddress(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress)), _assetManager);\r\n    database.setBytes32(keccak256(abi.encodePacked(\"asset.modelID\", _assetAddress)), _modelID);\r\n    database.setString(keccak256(abi.encodePacked(\"asset.ipfs\", _assetAddress)), _ipfs);\r\n    //database.setAddress(keccak256(abi.encodePacked(\"asset.operator\", _assetAddress)), database.addressStorage(keccak256(abi.encodePacked(\"asset.operator\", _modelID))));\r\n    /*\r\n    if(database.boolStorage(keccak256(abi.encodePacked(\"asset.acceptsToken\", _modelID, _fundingToken)))){\r\n      database.setAddress(keccak256(abi.encodePacked(\"asset.receiver\", _assetAddress)), database.addressStorage(keccak256(abi.encodePacked(\"model.operator\", _modelID))));\r\n    } else {\r\n      database.setAddress(keccak256(abi.encodePacked(\"asset.receiver\", _assetAddress)), _assetManager);\r\n    }\r\n    */\r\n    database.setBool(keccak256(abi.encodePacked(\"asset.uri\", _assetURI)), true); //Set to ensure a unique asset URI\r\n    return true;\r\n  }\r\n\r\n  function calculateEscrowERC20(uint _amount, address _manager, bytes32 _modelID, address _fundingToken)\r\n  private\r\n  view\r\n  returns (uint){\r\n    uint percent = database.uintStorage(keccak256(abi.encodePacked(\"collateral.base\"))).add(database.uintStorage(keccak256(abi.encodePacked(\"collateral.level\", database.uintStorage(keccak256(abi.encodePacked(\"manager.assets\", _manager)))))));\r\n    if(!database.boolStorage(keccak256(abi.encodePacked(\"model.payoutToken\", _modelID, _fundingToken)))){\r\n      percent = percent.mul(3);\r\n    }\r\n    if(!database.boolStorage(keccak256(abi.encodePacked(\"model.acceptsToken\", _modelID, _fundingToken)))){\r\n      percent = percent.add(100);\r\n    }\r\n    return _amount.getFractionalAmount(percent);\r\n  }\r\n\r\n  function lockEscrowERC20(address _assetManager, address _assetAddress, address _paymentTokenAddress, address _fundingTokenAddress, uint _amount, uint _min)\r\n  private\r\n  returns (bool) {\r\n    uint amount;\r\n    bytes32 assetManagerEscrowID = keccak256(abi.encodePacked(_assetAddress, _assetManager));\r\n    address platformTokenAddress = database.addressStorage(keccak256(abi.encodePacked(\"platform.token\")));\r\n    if(_paymentTokenAddress == _fundingTokenAddress){\r\n      require(_amount >= _min, \"Insufficient collateral for asset manager risk\");\r\n    } else {\r\n      //Get conversion rate, and make sure converted amount is >= _amount\r\n      (uint rate,) = kyber.getExpectedRate(_paymentTokenAddress, _fundingTokenAddress, _amount);\r\n      require(_amount.mul(rate).div(10**18) >= _min);\r\n    }\r\n    if(_paymentTokenAddress != platformTokenAddress){\r\n      //Convert the payment token into the platform token\r\n      if(_paymentTokenAddress == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)){\r\n        amount = kyber.trade.value(_amount)(_paymentTokenAddress, _amount, platformTokenAddress, address(this), 2**255, 0, 0); //Currently no minimum rate is set, so watch out for slippage!\r\n      } else {\r\n        CrowdsaleGeneratorERC20_ERC20 paymentToken = CrowdsaleGeneratorERC20_ERC20(_paymentTokenAddress);\r\n        require(paymentToken.transferFrom(_assetManager, address(this), _amount));\r\n        require(paymentToken.approve(address(kyber), _amount));\r\n        amount = kyber.trade(_paymentTokenAddress, _amount, platformTokenAddress, address(this), 2**255, 0, 0); //Currently no minimum rate is set, so watch out for slippage!\r\n      }\r\n      require(CrowdsaleGeneratorERC20_ERC20(platformTokenAddress).transfer(database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"EscrowReserve\"))), amount));\r\n    } else {\r\n      amount = _amount;\r\n      require(CrowdsaleGeneratorERC20_ERC20(platformTokenAddress).transferFrom(_assetManager, database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"EscrowReserve\"))), amount));\r\n    }\r\n    database.setUint(keccak256(abi.encodePacked(\"asset.escrow\", assetManagerEscrowID)), amount);\r\n    events.escrow('Escrow locked', _assetAddress, assetManagerEscrowID, _assetManager, amount);\r\n    return true;\r\n  }\r\n\r\n\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  //                                            Modifiers\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n  // @notice Sender must be a registered owner\r\n  modifier onlyOwner {\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\"owner\", msg.sender))), \"Not owner\");\r\n    _;\r\n  }\r\n\r\n  modifier checkRequirements {\r\n    _;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetURI\",\"type\":\"string\"},{\"name\":\"_ipfs\",\"type\":\"string\"},{\"name\":\"_modelID\",\"type\":\"bytes32\"},{\"name\":\"_fundingLength\",\"type\":\"uint256\"},{\"name\":\"_amountToRaise\",\"type\":\"uint256\"},{\"name\":\"_assetManagerPerc\",\"type\":\"uint256\"},{\"name\":\"_escrow\",\"type\":\"uint256\"},{\"name\":\"_fundingToken\",\"type\":\"address\"},{\"name\":\"_paymentToken\",\"type\":\"address\"}],\"name\":\"createAssetOrderERC20\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"},{\"name\":\"_ipfs\",\"type\":\"string\"}],\"name\":\"updateIPFS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_database\",\"type\":\"address\"},{\"name\":\"_events\",\"type\":\"address\"},{\"name\":\"_kyber\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"CrowdsaleGeneratorERC20","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005fcebeb70b88e86dd880352684e775b0f4d57c71000000000000000000000000eb6533f29a54c2c18bb2ce2a100de717692a518f000000000000000000000000818e6fecd516ecc3849daf6845e3ec868087b755","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://36636d95249eab5d3216fb67be047b5d06c83064a8862366c245d630cf1906ae"}]}