{"status":"1","message":"OK","result":[{"SourceCode":"// File: src/interfaces/compound/IComptroller.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface IComptroller {\r\n    /**\r\n     * @notice Marker function used for light validation when updating the comptroller of a market\r\n     * @dev Implementations should simply return true.\r\n     * @return true\r\n     */\r\n    function isComptroller() external view returns (bool);\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cToken) external returns (uint);\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n\r\n    function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint);\r\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external;\r\n\r\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint);\r\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\r\n\r\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint);\r\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) external;\r\n\r\n    function repayBorrowAllowed(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function repayBorrowVerify(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint borrowerIndex) external;\r\n\r\n    function liquidateBorrowAllowed(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function liquidateBorrowVerify(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint seizeTokens) external;\r\n\r\n    function seizeAllowed(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external returns (uint);\r\n    function seizeVerify(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external;\r\n\r\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint);\r\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) external;\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    function liquidateCalculateSeizeTokens(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        uint repayAmount) external view returns (uint, uint);\r\n}\r\n\r\n// File: src/interfaces/compound/ICEther.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract ICEther {\r\n    function mint() external payable;\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function repayBorrow() external payable;\r\n    function repayBorrowBehalf(address borrower) external payable;\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) external view returns (uint256);\r\n    function balanceOfUnderlying(address account) external returns (uint);\r\n    function balanceOf(address owner) external view returns (uint256);\r\n}\r\n\r\n// File: src/interfaces/compound/ICToken.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface ICToken {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) external view returns (uint256);\r\n    function balanceOfUnderlying(address account) external returns (uint);\r\n    \r\n    function underlying() external view returns (address);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function allowance(address, address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\n// File: src/interfaces/IERC20.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n}\r\n\r\n// File: src/lib/compound/CompoundBase.sol\r\n\r\n/*  Mostly functions from https://compound.finance/developers/ctokens\r\n    and https://compound.finance/developers/comptroller\r\n*/\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\ncontract CompoundBase {\r\n    address constant CompoundComptrollerAddress = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    address constant CEtherAddress = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"safe-math-sub-failed\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function _transferFromUnderlying(\r\n        address sender,\r\n        address recipient,\r\n        address cToken,\r\n        uint amount\r\n    ) internal {\r\n        address underlying = ICToken(cToken).underlying();\r\n        require(\r\n            IERC20(underlying).transferFrom(sender, recipient, amount),\r\n            \"cmpnd-mgr-transferFrom-underlying-failed\"\r\n        );\r\n    }\r\n\r\n    function _transferUnderlying(\r\n        address cToken,\r\n        address recipient,\r\n        uint amount\r\n    ) internal {\r\n        if (cToken == CEtherAddress) {\r\n            recipient.call.value(amount)(\"\");\r\n        } else {\r\n            require(\r\n                IERC20(ICToken(cToken).underlying()).transfer(recipient, amount),\r\n                \"cmpnd-mgr-transfer-underlying-failed\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function _transfer(\r\n        address token,\r\n        address recipient,\r\n        uint amount\r\n    ) internal {\r\n        require(\r\n            IERC20(token).transfer(recipient, amount),\r\n            \"cmpnd-mgr-transfer-failed\"\r\n        );\r\n    }\r\n\r\n    function enterMarkets(\r\n        address[] memory cTokens   // Address of the Compound derivation token (e.g. cDAI)\r\n    ) public {\r\n        // Enter the compound markets for all the specified tokens\r\n        uint[] memory errors = IComptroller(CompoundComptrollerAddress).enterMarkets(cTokens);\r\n\r\n        for (uint i = 0; i < errors.length; i++) {\r\n            require(errors[i] == 0, \"cmpnd-mgr-enter-markets-failed\");\r\n        }\r\n    }\r\n\r\n    function approveCToken(\r\n        address cToken,\r\n        uint amount\r\n    ) public {\r\n        // Approves CToken contract to call `transferFrom`\r\n        address underlying = ICToken(cToken).underlying();\r\n        require(\r\n            IERC20(underlying).approve(cToken, amount) == true,\r\n            \"cmpnd-mgr-ctoken-approved-failed\"\r\n        );\r\n    }\r\n\r\n    function approveCTokens(\r\n        address[] memory cTokens    // Tokens to approve\r\n    ) public {\r\n        for (uint i = 0; i < cTokens.length; i++) {\r\n            // Don't need to approve ICEther\r\n            if (cTokens[i] != CEtherAddress) {\r\n                approveCToken(cTokens[i], uint(-1));\r\n            }\r\n        }\r\n    }\r\n\r\n    function enterMarketsAndApproveCTokens(\r\n        address[] memory cTokens\r\n    ) public {\r\n        enterMarkets(cTokens);\r\n        approveCTokens(cTokens);\r\n    }\r\n\r\n    function supplyETH() public payable {\r\n        ICEther(CEtherAddress).mint.value(msg.value)();\r\n    }\r\n\r\n    function supply(address cToken, uint amount) public payable {\r\n        if (cToken == CEtherAddress) {\r\n            ICEther(CEtherAddress).mint.value(amount)();\r\n        } else {\r\n            // Approves CToken contract to call `transferFrom`\r\n            approveCToken(cToken, amount);\r\n\r\n            require(\r\n              ICToken(cToken).mint(amount) == 0,\r\n              \"cmpnd-mgr-ctoken-supply-failed\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function borrow(address cToken, uint borrowAmount) public {\r\n        require(ICToken(cToken).borrow(borrowAmount) == 0, \"cmpnd-mgr-ctoken-borrow-failed\");\r\n    }\r\n\r\n    function supplyAndBorrow(\r\n        address supplyCToken,\r\n        uint supplyAmount,\r\n        address borrowCToken,\r\n        uint borrowAmount\r\n    ) public payable {\r\n        supply(supplyCToken, supplyAmount);\r\n        borrow(borrowCToken, borrowAmount);\r\n    }\r\n\r\n    function supplyETHAndBorrow(\r\n        address cToken,\r\n        uint borrowAmount\r\n    ) public payable {\r\n        // Supply some Ether\r\n        supplyETH();\r\n\r\n        // Borrow some CTokens\r\n        borrow(cToken, borrowAmount);\r\n    }\r\n\r\n    function repayBorrow(address cToken, uint amount) public payable {\r\n        if (cToken == CEtherAddress) {\r\n            ICEther(cToken).repayBorrow.value(amount)();\r\n        } else {\r\n            approveCToken(cToken, amount);\r\n            require(ICToken(cToken).repayBorrow(amount) == 0, \"cmpnd-mgr-ctoken-repay-failed\");\r\n        }\r\n    }\r\n\r\n    function repayBorrowBehalf(address recipient, address cToken, uint amount) public payable {\r\n        if (cToken == CEtherAddress) {\r\n            ICEther(cToken).repayBorrowBehalf.value(amount)(recipient);\r\n        } else {\r\n            approveCToken(cToken, amount);\r\n            require(ICToken(cToken).repayBorrowBehalf(recipient, amount) == 0, \"cmpnd-mgr-ctoken-repaybehalf-failed\");\r\n        }\r\n    }\r\n\r\n    function redeem(address cToken, uint redeemTokens) public payable {\r\n        require(ICToken(cToken).redeem(redeemTokens) == 0, \"cmpnd-mgr-ctoken-redeem-failed\");\r\n    }\r\n\r\n    function redeemUnderlying(address cToken, uint redeemTokens) public payable {\r\n        require(ICToken(cToken).redeemUnderlying(redeemTokens) == 0, \"cmpnd-mgr-ctoken-redeem-underlying-failed\");\r\n    }\r\n\r\n    // -- Helper functions so proxy doesn't hold any funds, all funds borrowed\r\n    // or redeemed gets sent to user\r\n    // User needs to `approve(spender, amount)` before through proxy functions work\r\n\r\n    function supplyThroughProxy(\r\n        address cToken,\r\n        uint amount\r\n    ) public payable {\r\n        if (cToken != CEtherAddress) {\r\n            _transferFromUnderlying(msg.sender, address(this), cToken, amount);\r\n        }\r\n        supply(cToken, amount);\r\n    }\r\n\r\n    function repayBorrowThroughProxy(address cToken, uint amount) public payable {\r\n        if (cToken != CEtherAddress) {\r\n            _transferFromUnderlying(msg.sender, address(this), cToken, amount);\r\n        }\r\n        repayBorrow(cToken, amount);\r\n    }\r\n\r\n    function repayBorrowBehalfThroughProxy(address recipient, address cToken, uint amount) public payable {\r\n        if (cToken != CEtherAddress) {\r\n            _transferFromUnderlying(msg.sender, address(this), cToken, amount);\r\n        }\r\n        repayBorrowBehalf(recipient, cToken, amount);\r\n    }\r\n\r\n    function borrowThroughProxy(address cToken, uint amount) public {\r\n        borrow(cToken, amount);\r\n        _transferUnderlying(cToken, msg.sender, amount);\r\n    }\r\n\r\n    function redeemThroughProxy(\r\n        address cToken,\r\n        uint amount\r\n    ) public payable {\r\n        redeem(cToken, amount);\r\n        _transferUnderlying(cToken, msg.sender, amount);\r\n    }\r\n\r\n    function redeemUnderlyingThroughProxy(\r\n        address cToken,\r\n        uint amount\r\n    ) public payable {\r\n        redeemUnderlying(cToken, amount);\r\n        _transferUnderlying(cToken, msg.sender, amount);\r\n    }\r\n}\r\n\r\n// File: src/lib/dapphub/Auth.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (address(authority) == address(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\n// File: src/lib/dapphub/Guard.sol\r\n\r\n// guard.sol -- simple whitelist implementation of DSAuthority\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\ncontract DSGuardEvents {\r\n    event LogPermit(\r\n        bytes32 indexed src,\r\n        bytes32 indexed dst,\r\n        bytes32 indexed sig\r\n    );\r\n\r\n    event LogForbid(\r\n        bytes32 indexed src,\r\n        bytes32 indexed dst,\r\n        bytes32 indexed sig\r\n    );\r\n}\r\n\r\ncontract DSGuard is DSAuth, DSAuthority, DSGuardEvents {\r\n    bytes32 constant public ANY = bytes32(uint(-1));\r\n\r\n    mapping (bytes32 => mapping (bytes32 => mapping (bytes32 => bool))) acl;\r\n\r\n    function canCall(\r\n        address src_, address dst_, bytes4 sig\r\n    ) public view returns (bool) {\r\n        bytes32 src = bytes32(bytes20(src_));\r\n        bytes32 dst = bytes32(bytes20(dst_));\r\n\r\n        return acl[src][dst][sig]\r\n            || acl[src][dst][ANY]\r\n            || acl[src][ANY][sig]\r\n            || acl[src][ANY][ANY]\r\n            || acl[ANY][dst][sig]\r\n            || acl[ANY][dst][ANY]\r\n            || acl[ANY][ANY][sig]\r\n            || acl[ANY][ANY][ANY];\r\n    }\r\n\r\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public auth {\r\n        acl[src][dst][sig] = true;\r\n        emit LogPermit(src, dst, sig);\r\n    }\r\n\r\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public auth {\r\n        acl[src][dst][sig] = false;\r\n        emit LogForbid(src, dst, sig);\r\n    }\r\n\r\n    function permit(address src, address dst, bytes32 sig) public {\r\n        permit(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\r\n    }\r\n    function forbid(address src, address dst, bytes32 sig) public {\r\n        forbid(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\r\n    }\r\n\r\n}\r\n\r\ncontract DSGuardFactory {\r\n    mapping (address => bool)  public  isGuard;\r\n\r\n    function newGuard() public returns (DSGuard guard) {\r\n        guard = new DSGuard();\r\n        guard.setOwner(msg.sender);\r\n        isGuard[address(guard)] = true;\r\n    }\r\n}\r\n\r\n// File: src/interfaces/uniswap/IUniswapExchange.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract IUniswapExchange {\r\n    // Address of ERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n    // Provide Liquidity\r\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n    // Trade ETH to ERC20\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\r\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\r\n    // Trade ERC20 to ETH\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\r\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\r\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to ERC20\r\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\r\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to Custom Pool\r\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\r\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // ERC20 comaptibility for liquidity tokens\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public decimals;\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n}\r\n\r\n// File: src/interfaces/uniswap/IUniswapFactory.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract IUniswapFactory {\r\n    // Public Variables\r\n    address public exchangeTemplate;\r\n    uint256 public tokenCount;\r\n    // Create Exchange\r\n    function createExchange(address token) external returns (address exchange);\r\n    // Get Exchange and Token Info\r\n    function getExchange(address token) external view returns (address exchange);\r\n    function getToken(address exchange) external view returns (address token);\r\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\r\n    // Never use\r\n    function initializeFactory(address template) external;\r\n}\r\n\r\n// File: src/lib/uniswap/UniswapLiteBase.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\ncontract UniswapLiteBase {\r\n    // Uniswap Mainnet factory address\r\n    address constant UniswapFactoryAddress = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\r\n\r\n    function _getUniswapExchange(address tokenAddress) internal view returns (address) {\r\n        return IUniswapFactory(UniswapFactoryAddress).getExchange(tokenAddress);\r\n    }\r\n\r\n    function _ethToToken(address tokenAddress, uint ethAmount)\r\n        internal returns (uint) {\r\n        return _ethToToken(tokenAddress, ethAmount, uint(1));\r\n    }\r\n\r\n    function _ethToToken(address tokenAddress, uint ethAmount, uint minTokenAmount)\r\n        internal returns (uint) {\r\n        return IUniswapExchange(_getUniswapExchange(tokenAddress))\r\n            .ethToTokenSwapInput.value(ethAmount)(minTokenAmount, uint(now + 60));\r\n    }\r\n\r\n    function _tokenToEth(address tokenAddress, uint tokenAmount) internal returns (uint) {\r\n        return _tokenToEth(tokenAddress, tokenAmount, uint(1));\r\n    }\r\n\r\n    function _tokenToEth(address tokenAddress, uint tokenAmount, uint minEthAmount) internal returns (uint) {\r\n        address exchange = _getUniswapExchange(tokenAddress);\r\n\r\n        IERC20(tokenAddress).approve(exchange, tokenAmount);\r\n\r\n        return IUniswapExchange(exchange)\r\n            .tokenToEthSwapInput(tokenAmount, minEthAmount, uint(now + 60));\r\n    }\r\n\r\n    function _tokenToToken(address from, address to, uint tokenInAmount, uint minTokenOut) internal returns (uint) {\r\n        uint ethAmount = _tokenToEth(from, tokenInAmount);\r\n        return _ethToToken(to, ethAmount, minTokenOut);\r\n    }\r\n\r\n    function _tokenToToken(address from, address to, uint tokenAmount) internal returns (uint) {\r\n        return _tokenToToken(from, to, tokenAmount, uint(1));\r\n    }\r\n\r\n    function _getTokenToEthInput(address tokenAddress, uint tokenAmount) internal view returns (uint) {\r\n        return IUniswapExchange(_getUniswapExchange(tokenAddress)).getTokenToEthInputPrice(tokenAmount);\r\n    }\r\n\r\n    function _getEthToTokenInput(address tokenAddress, uint ethAmount) internal view returns (uint) {\r\n        return IUniswapExchange(_getUniswapExchange(tokenAddress)).getEthToTokenInputPrice(ethAmount);\r\n    }\r\n\r\n    function _getTokenToEthOutput(address tokenAddress, uint ethAmount) internal view returns (uint) {\r\n        return IUniswapExchange(_getUniswapExchange(tokenAddress)).getTokenToEthOutputPrice(ethAmount);\r\n    }\r\n\r\n    function _getEthToTokenOutput(address tokenAddress, uint tokenAmount) internal view returns (uint) {\r\n        return IUniswapExchange(_getUniswapExchange(tokenAddress)).getEthToTokenOutputPrice(tokenAmount);\r\n    }\r\n\r\n    function _getTokenToTokenInput(address from, address to, uint fromAmount) internal view returns (uint) {\r\n        uint ethAmount = _getTokenToEthInput(from, fromAmount);\r\n        return _getEthToTokenInput(to, ethAmount);\r\n    }\r\n}\r\n\r\n// File: src/interfaces/aave/ILendingPoolAddressesProvider.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/**\r\n@title ILendingPoolAddressesProvider interface\r\n@notice provides the interface to fetch the LendingPoolCore address\r\n */\r\n\r\ncontract ILendingPoolAddressesProvider {\r\n\r\n    function getLendingPool() public view returns (address);\r\n    function setLendingPoolImpl(address _pool) public;\r\n\r\n    function getLendingPoolCore() public view returns (address payable);\r\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public;\r\n\r\n    function getLendingPoolConfigurator() public view returns (address);\r\n    function setLendingPoolConfiguratorImpl(address _configurator) public;\r\n\r\n    function getLendingPoolDataProvider() public view returns (address);\r\n    function setLendingPoolDataProviderImpl(address _provider) public;\r\n\r\n    function getLendingPoolParametersProvider() public view returns (address);\r\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public;\r\n\r\n    function getTokenDistributor() public view returns (address);\r\n    function setTokenDistributor(address _tokenDistributor) public;\r\n\r\n    function getFeeProvider() public view returns (address);\r\n    function setFeeProviderImpl(address _feeProvider) public;\r\n\r\n    function getLendingPoolLiquidationManager() public view returns (address);\r\n    function setLendingPoolLiquidationManager(address _manager) public;\r\n\r\n    function getLendingPoolManager() public view returns (address);\r\n    function setLendingPoolManager(address _lendingPoolManager) public;\r\n\r\n    function getPriceOracle() public view returns (address);\r\n    function setPriceOracle(address _priceOracle) public;\r\n\r\n    function getLendingRateOracle() public view returns (address);\r\n    function setLendingRateOracle(address _lendingRateOracle) public;\r\n\r\n}\r\n\r\n// File: src/interfaces/aave/ILendingPool.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface ILendingPool {\r\n  function addressesProvider () external view returns ( address );\r\n  function deposit ( address _reserve, uint256 _amount, uint16 _referralCode ) external payable;\r\n  function redeemUnderlying ( address _reserve, address _user, uint256 _amount ) external;\r\n  function borrow ( address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode ) external;\r\n  function repay ( address _reserve, uint256 _amount, address _onBehalfOf ) external payable;\r\n  function swapBorrowRateMode ( address _reserve ) external;\r\n  function rebalanceFixedBorrowRate ( address _reserve, address _user ) external;\r\n  function setUserUseReserveAsCollateral ( address _reserve, bool _useAsCollateral ) external;\r\n  function liquidationCall ( address _collateral, address _reserve, address _user, uint256 _purchaseAmount, bool _receiveAToken ) external payable;\r\n  function flashLoan ( address _receiver, address _reserve, uint256 _amount, bytes calldata _params ) external;\r\n  function getReserveConfigurationData ( address _reserve ) external view returns ( uint256 ltv, uint256 liquidationThreshold, uint256 liquidationDiscount, address interestRateStrategyAddress, bool usageAsCollateralEnabled, bool borrowingEnabled, bool fixedBorrowRateEnabled, bool isActive );\r\n  function getReserveData ( address _reserve ) external view returns ( uint256 totalLiquidity, uint256 availableLiquidity, uint256 totalBorrowsFixed, uint256 totalBorrowsVariable, uint256 liquidityRate, uint256 variableBorrowRate, uint256 fixedBorrowRate, uint256 averageFixedBorrowRate, uint256 utilizationRate, uint256 liquidityIndex, uint256 variableBorrowIndex, address aTokenAddress, uint40 lastUpdateTimestamp );\r\n  function getUserAccountData ( address _user ) external view returns ( uint256 totalLiquidityETH, uint256 totalCollateralETH, uint256 totalBorrowsETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor );\r\n  function getUserReserveData ( address _reserve, address _user ) external view returns ( uint256 currentATokenBalance, uint256 currentUnderlyingBalance, uint256 currentBorrowBalance, uint256 principalBorrowBalance, uint256 borrowRateMode, uint256 borrowRate, uint256 liquidityRate, uint256 originationFee, uint256 variableBorrowIndex, uint256 lastUpdateTimestamp, bool usageAsCollateralEnabled );\r\n  function getReserves () external view;\r\n}\r\n\r\n// File: src/interfaces/aave/ILendingPoolParametersProvider.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/**\r\n@title ILendingPoolAddressesProvider interface\r\n@notice provides the interface to fetch the LendingPoolCore address\r\n */\r\n\r\ncontract ILendingPoolParametersProvider {\r\n    function getFlashLoanFeesInBips() public view returns (uint256, uint256);\r\n}\r\n\r\n// File: src/interfaces/compound/ICompoundPriceOracle.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract ICompoundPriceOracle {\r\n    function getUnderlyingPrice(address cToken) external view returns (uint256);\r\n}\r\n\r\n// File: src/registries/AddressRegistry.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract AddressRegistry {\r\n    // Aave\r\n    address public AaveLendingPoolAddressProviderAddress = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\r\n    address public AaveEthAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    // Uniswap\r\n    address public UniswapFactoryAddress = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\r\n\r\n    // Compound\r\n    address public CompoundPriceOracleAddress = 0x1D8aEdc9E924730DD3f9641CDb4D1B92B848b4bd;\r\n    address public CompoundComptrollerAddress = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    address public CEtherAddress = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n    address public CUSDCAddress = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\r\n    address public CDaiAddress = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\r\n    address public CSaiAddress = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\r\n\r\n    // Token(s)\r\n    address public DaiAddress = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    address public BatAddress = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF;\r\n    address public UsdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n\r\n    // MakerDAO\r\n    // https://changelog.makerdao.com/\r\n    // https://changelog.makerdao.com/releases/mainnet/1.0.4/contracts.json\r\n    address public EthJoinAddress = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;\r\n    address public UsdcJoinAddress = 0xA191e578a6736167326d05c119CE0c90849E84B7;\r\n    address public BatJoinAddress = 0x3D0B1912B66114d4096F48A8CEe3A56C231772cA;\r\n    address public DaiJoinAddress = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\r\n    address public JugAddress = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\r\n    address public DssProxyActionsAddress = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;\r\n    address public DssCdpManagerAddress = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\r\n}\r\n\r\n// File: src/lib/BytesLib.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n// https://github.com/GNSPS/solidity-bytes-utils/blob/b1b22d1e9c4de64defb811f4c65a391630f220d7/contracts/BytesLib.sol\r\n\r\ncontract BytesLibLite {\r\n    // A lite version of the ByteLib, containing only the \"slice\" function we need\r\n\r\n    function sliceToEnd(\r\n        bytes memory _bytes,\r\n        uint256 _start\r\n    ) internal pure returns (bytes memory) {\r\n        require(_start < _bytes.length, \"bytes-read-out-of-bounds\");\r\n\r\n        return slice(\r\n            _bytes,\r\n            _start,\r\n            _bytes.length - _start\r\n        );\r\n    }\r\n    \r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length), \"bytes-read-out-of-bounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function bytesToAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        require(_bytes.length >= (_start + 20), \"Read out of bounds\");\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: src/interfaces/ISafeERC20.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: src/interfaces/aave/IFlashLoanReceiver.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/**\r\n* @title IFlashLoanReceiver interface\r\n* @notice Interface for the Aave fee IFlashLoanReceiver.\r\n* @author Aave\r\n* @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\r\n**/\r\ninterface IFlashLoanReceiver {\r\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;\r\n}\r\n\r\n// File: src/lib/aave/FlashLoanReceiverBase.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\ncontract FlashLoanReceiverBase is IFlashLoanReceiver {\r\n    using SafeMath for uint256;\r\n\r\n    address constant ETHADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    ILendingPoolAddressesProvider public addressesProvider = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\r\n\r\n    function () external payable {    }\r\n\r\n    function transferFundsBackToPoolInternal(address _reserve, uint256 _amount) internal {\r\n        address payable core = addressesProvider.getLendingPoolCore();\r\n        transferInternal(core,_reserve, _amount);\r\n    }\r\n\r\n    function transferInternal(address payable _destination, address _reserve, uint256  _amount) internal {\r\n        if(_reserve == ETHADDRESS) {\r\n            //solium-disable-next-line\r\n            _destination.call.value(_amount)(\"\");\r\n            return;\r\n        }\r\n\r\n        IERC20(_reserve).transfer(_destination, _amount);\r\n    }\r\n\r\n    function getBalanceInternal(address _target, address _reserve) internal view returns(uint256) {\r\n        if(_reserve == ETHADDRESS) {\r\n\r\n            return _target.balance;\r\n        }\r\n\r\n        return IERC20(_reserve).balanceOf(_target);\r\n    }\r\n}\r\n\r\n// File: src/lib/dapphub/Note.sol\r\n\r\n/// note.sol -- the `note' modifier, for logging calls as events\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint256           wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        uint256 wad;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n            wad := callvalue\r\n        }\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n// File: src/lib/dapphub/Proxy.sol\r\n\r\n// proxy.sol - execute actions atomically through the proxy's identity\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\n\r\n// DSProxy\r\n// Allows code execution using a persistant identity This can be very\r\n// useful to execute a sequence of atomic actions. Since the owner of\r\n// the proxy can be changed, this allows for dynamic ownership models\r\n// i.e. a multisig\r\ncontract DSProxy is DSAuth, DSNote {\r\n    DSProxyCache public cache;  // global cache for contracts\r\n\r\n    constructor(address _cacheAddr) public {\r\n        setCache(_cacheAddr);\r\n    }\r\n\r\n    function() external payable {\r\n    }\r\n\r\n    // use the proxy to execute calldata _data on contract _code\r\n    function execute(bytes memory _code, bytes memory _data)\r\n        public\r\n        payable\r\n        returns (address target, bytes memory response)\r\n    {\r\n        target = cache.read(_code);\r\n        if (target == address(0)) {\r\n            // deploy contract & store its address in cache\r\n            target = cache.write(_code);\r\n        }\r\n\r\n        response = execute(target, _data);\r\n    }\r\n\r\n    function execute(address _target, bytes memory _data)\r\n        public\r\n        auth\r\n        note\r\n        payable\r\n        returns (bytes memory response)\r\n    {\r\n        require(_target != address(0), \"ds-proxy-target-address-required\");\r\n\r\n        // call contract in current context\r\n        assembly {\r\n            let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\r\n            let size := returndatasize\r\n\r\n            response := mload(0x40)\r\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\r\n            mstore(response, size)\r\n            returndatacopy(add(response, 0x20), 0, size)\r\n\r\n            switch iszero(succeeded)\r\n            case 1 {\r\n                // throw if delegatecall failed\r\n                revert(add(response, 0x20), size)\r\n            }\r\n        }\r\n    }\r\n\r\n    //set new cache\r\n    function setCache(address _cacheAddr)\r\n        public\r\n        auth\r\n        note\r\n        returns (bool)\r\n    {\r\n        require(_cacheAddr != address(0), \"ds-proxy-cache-address-required\");\r\n        cache = DSProxyCache(_cacheAddr);  // overwrite cache\r\n        return true;\r\n    }\r\n}\r\n\r\n// DSProxyFactory\r\n// This factory deploys new proxy instances through build()\r\n// Deployed proxy addresses are logged\r\ncontract DSProxyFactory {\r\n    event Created(address indexed sender, address indexed owner, address proxy, address cache);\r\n    mapping(address=>address) public proxies;\r\n    DSProxyCache public cache;\r\n\r\n    constructor() public {\r\n        cache = new DSProxyCache();\r\n    }\r\n\r\n    // deploys a new proxy instance\r\n    // sets owner of proxy to caller\r\n    function build() public returns (address payable proxy) {\r\n        proxy = build(msg.sender);\r\n    }\r\n\r\n    // deploys a new proxy instance\r\n    // sets custom owner of proxy\r\n    function build(address owner) public returns (address payable proxy) {\r\n        proxy = address(new DSProxy(address(cache)));\r\n        emit Created(msg.sender, owner, address(proxy), address(cache));\r\n        DSProxy(proxy).setOwner(owner);\r\n        proxies[owner] = proxy;\r\n    }\r\n}\r\n\r\n// DSProxyCache\r\n// This global cache stores addresses of contracts previously deployed\r\n// by a proxy. This saves gas from repeat deployment of the same\r\n// contracts and eliminates blockchain bloat.\r\n\r\n// By default, all proxies deployed from the same factory store\r\n// contracts in the same cache. The cache a proxy instance uses can be\r\n// changed.  The cache uses the sha3 hash of a contract's bytecode to\r\n// lookup the address\r\ncontract DSProxyCache {\r\n    mapping(bytes32 => address) cache;\r\n\r\n    function read(bytes memory _code) public view returns (address) {\r\n        bytes32 hash = keccak256(_code);\r\n        return cache[hash];\r\n    }\r\n\r\n    function write(bytes memory _code) public returns (address target) {\r\n        assembly {\r\n            target := create(0, add(_code, 0x20), mload(_code))\r\n            switch iszero(extcodesize(target))\r\n            case 1 {\r\n                // throw if contract failed to deploy\r\n                revert(0, 0)\r\n            }\r\n        }\r\n        bytes32 hash = keccak256(_code);\r\n        cache[hash] = target;\r\n    }\r\n}\r\n\r\n// File: src/proxies/DACProxy.sol\r\n\r\n/*\r\n    Main contract to handle Aave flashloans on Compound Finance.\r\n    (D)edge's (A)ave (C)ommon Proxy.\r\n*/\r\n\r\npragma solidity 0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\ncontract DACProxy is\r\n    DSProxy(address(1)),\r\n    FlashLoanReceiverBase,\r\n    BytesLibLite\r\n{\r\n    // TODO: Change this value\r\n    address payable constant protocolFeePayoutAddress1 = 0x773CCbFB422850617A5680D40B1260422d072f41;\r\n    address payable constant protocolFeePayoutAddress2 = 0xAbcCB8f0a3c206Bb0468C52CCc20f3b81077417B;\r\n\r\n    constructor(address _cacheAddr) public {\r\n        setCache(_cacheAddr);\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    // This is for Aave flashloans\r\n    function executeOperation(\r\n        address _reserve,\r\n        uint256 _amount,\r\n        uint256 _fee,\r\n        bytes calldata _params\r\n    ) external\r\n        auth\r\n    {\r\n        // Assumes that once the action(s) are performed\r\n        // we will have totalDebt would of _reserve to repay\r\n        // aave and the protocol\r\n        uint protocolFee = _fee.div(2);\r\n\r\n        // Re-encodes new data \r\n        // Function signature should conform to:\r\n        /* (\r\n                // Note: for address, as abiEncoder pads it to 32 bytes our starting position is 12\r\n                // due to addresses having 20 bytes in length\r\n                address     - Address to call        | start: 12;  (20 bytes)\r\n                bytes       - Function sig           | start: 32;  (4 bytes)\r\n                uint        - Data of _amount        | start: 36;  (32 bytes)\r\n                uint        - Data of _aaveFee       | start: 68;  (32 bytes)\r\n                uint        - Data of _protocolFee   | start: 100; (32 bytes)\r\n                bytes       - Data of _data          | start: 132; (dynamic length)\r\n            )\r\n\r\n            i.e.\r\n\r\n            function myFunction(\r\n                uint amount,\r\n                uint aaveFee,\r\n                uint protocolFee,\r\n                bytes memory _data\r\n            ) { ... }\r\n        */\r\n        address targetAddress = bytesToAddress(_params, 12);\r\n        bytes memory fSig     = slice(_params, 32, 4);\r\n        bytes memory data     = sliceToEnd(_params, 132);\r\n\r\n        // Re-encodes function signature and injects new\r\n        // _amount, _fee, and _protocolFee into _data\r\n        bytes memory newData = abi.encodePacked(\r\n            fSig,\r\n            abi.encode(_amount),\r\n            abi.encode(_fee),\r\n            abi.encode(protocolFee),\r\n            data\r\n        );\r\n\r\n        // Executes new target\r\n        execute(targetAddress, newData);\r\n\r\n        // Repays protocol fee\r\n        if (_reserve == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\r\n            protocolFeePayoutAddress1.call.value(protocolFee.div(2))(\"\");\r\n            protocolFeePayoutAddress2.call.value(protocolFee.div(2))(\"\");\r\n        } else {\r\n            IERC20(_reserve).transfer(protocolFeePayoutAddress1, protocolFee.div(2));\r\n            IERC20(_reserve).transfer(protocolFeePayoutAddress2, protocolFee.div(2));\r\n        }\r\n\r\n        // Repays aave\r\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\r\n    }\r\n}\r\n\r\n// File: src/managers/DedgeCompoundManager.sol\r\n\r\n/*\r\n    Dedge's Aave and Compound manager\r\n*/\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DedgeCompoundManager is UniswapLiteBase, CompoundBase {\r\n    using SafeMath for uint;\r\n\r\n    struct SwapOperationCalldata {\r\n        address addressRegistryAddress;\r\n        address oldCTokenAddress;\r\n        address newCTokenAddress;\r\n    }\r\n\r\n    function _proxyGuardPermit(address payable proxyAddress, address src) internal {\r\n        address g = address(DACProxy(proxyAddress).authority());\r\n\r\n        DSGuard(g).permit(\r\n            bytes32(bytes20(address(src))),\r\n            DSGuard(g).ANY(),\r\n            DSGuard(g).ANY()\r\n        );\r\n    }\r\n\r\n    function _proxyGuardForbid(address payable proxyAddress, address src) internal {\r\n        address g = address(DACProxy(proxyAddress).authority());\r\n\r\n        DSGuard(g).forbid(\r\n            bytes32(bytes20(address(src))),\r\n            DSGuard(g).ANY(),\r\n            DSGuard(g).ANY()\r\n        );\r\n    }\r\n\r\n    function swapDebtPostLoan(\r\n        uint _loanAmount,\r\n        uint _aaveFee,\r\n        uint _protocolFee,\r\n        bytes calldata _data\r\n    ) external {\r\n        SwapOperationCalldata memory soCalldata = abi.decode(_data, (SwapOperationCalldata));\r\n\r\n        AddressRegistry addressRegistry = AddressRegistry(soCalldata.addressRegistryAddress);\r\n\r\n        address oldCTokenAddress = soCalldata.oldCTokenAddress;\r\n        address newCTokenAddress = soCalldata.newCTokenAddress;\r\n\r\n        uint debtAmount = _loanAmount.add(_aaveFee).add(_protocolFee);\r\n\r\n        // Note: debtAmount = loanAmount + fees\r\n        // 1. Has ETH from Aave flashloan\r\n        // 2. Converts ETH to oldCToken underlying\r\n        // 3. Repays oldCToken underlying\r\n        // 4. Calculates new amount to borrow from new token to repay debtAmount\r\n        // 5. Borrows from new token\r\n        // 6. Convert new token to ETH\r\n\r\n        // Steps 2 + 3\r\n        // Converts ETH to oldCToken underlying and repay\r\n        // Unless old target underlying is already ether\r\n        if (oldCTokenAddress == addressRegistry.CEtherAddress()) {\r\n            repayBorrow(oldCTokenAddress, _loanAmount);\r\n        } else {\r\n            // Gets old token underlying and amount\r\n            address oldTokenUnderlying = ICToken(oldCTokenAddress).underlying();\r\n\r\n            uint oldTokenUnderlyingAmount = _ethToToken(\r\n                oldTokenUnderlying,\r\n                _loanAmount\r\n            );\r\n\r\n            // Approves CToken proxy and repays them\r\n            IERC20(oldTokenUnderlying)\r\n                .approve(oldCTokenAddress, oldTokenUnderlyingAmount);\r\n\r\n            // Repays CToken\r\n            repayBorrow(oldCTokenAddress, oldTokenUnderlyingAmount);\r\n        }\r\n\r\n        // Steps 4, 5, 6\r\n        // Calculates new debt amount to borrow\r\n        // Unless new target underlying is already ether\r\n        if (newCTokenAddress == addressRegistry.CEtherAddress()) {\r\n            borrow(newCTokenAddress, debtAmount);\r\n        } else {\r\n            // Gets new token underlying\r\n            address newTokenUnderlying = ICToken(newCTokenAddress).underlying();\r\n\r\n            // Calculates amount of old token underlying that needs to be borrowed\r\n            // to repay debts\r\n            uint newTokenUnderlyingAmount = _getTokenToEthOutput(\r\n                newTokenUnderlying,\r\n                debtAmount\r\n            );\r\n\r\n            // Borrows new debt\r\n            borrow(newCTokenAddress, newTokenUnderlyingAmount);\r\n\r\n            // Converts to ether\r\n            // Note this part is a bit more strict as we need to have\r\n            // enough ETH to repay Aave\r\n            _tokenToEth(newTokenUnderlying, newTokenUnderlyingAmount, debtAmount);\r\n        }\r\n    }\r\n\r\n    function swapCollateralPostLoan(\r\n        uint _loanAmount,\r\n        uint _aaveFee,\r\n        uint _protocolFee,\r\n        bytes calldata _data\r\n    ) external {\r\n        SwapOperationCalldata memory soCalldata = abi.decode(_data, (SwapOperationCalldata));\r\n\r\n        AddressRegistry addressRegistry = AddressRegistry(soCalldata.addressRegistryAddress);\r\n\r\n        address oldCTokenAddress = soCalldata.oldCTokenAddress;\r\n        address newCTokenAddress = soCalldata.newCTokenAddress;\r\n\r\n        // 1. Has ETH from Aave flashloan\r\n        // 2. Converts ETH into newCToken underlying\r\n        // 3. Supplies newCToken underlying\r\n        // 4. Redeems oldCToken underlying\r\n        // 5. Converts outCToken underlying to ETH\r\n        // 6. Borrow <fee> ETH to repay aave\r\n\r\n        // Steps 2 + 3\r\n        // Converts ETH to newCToken underlying and supply\r\n        // Unless old target underlying is already ether\r\n        uint repayAmount = _loanAmount.sub(_aaveFee).sub(_protocolFee);\r\n\r\n        if (newCTokenAddress == addressRegistry.CEtherAddress()) {\r\n            supply(newCTokenAddress, repayAmount);\r\n        } else {\r\n            // Gets new token underlying and converts ETH into newCToken underlying\r\n            address newTokenUnderlying = ICToken(newCTokenAddress).underlying();\r\n            uint newTokenUnderlyingAmount = _ethToToken(\r\n                newTokenUnderlying,\r\n                repayAmount\r\n            );\r\n\r\n            // Supplies new CTokens\r\n            supply(newCTokenAddress, newTokenUnderlyingAmount);\r\n        }\r\n\r\n        // Steps 4, 5\r\n        // Redeem CToken underlying\r\n        if (oldCTokenAddress == addressRegistry.CEtherAddress()) {\r\n            redeemUnderlying(oldCTokenAddress, _loanAmount);\r\n        } else {\r\n            // Gets old token underlying and amount to redeem (based on uniswap)\r\n            address oldTokenUnderlying = ICToken(oldCTokenAddress).underlying();\r\n            uint oldTokenUnderlyingAmount = _getTokenToEthOutput(oldTokenUnderlying, _loanAmount);\r\n\r\n            // Redeems them\r\n            redeemUnderlying(oldCTokenAddress, oldTokenUnderlyingAmount);\r\n\r\n            // Converts them into ETH\r\n            _tokenToEth(oldTokenUnderlying, oldTokenUnderlyingAmount, _loanAmount);\r\n        }\r\n    }\r\n\r\n    /*\r\n    Main entry point for swapping collateral / debt\r\n\r\n    @params:\r\n\r\n        dedgeCompoundManagerAddress: Dedge Compound Manager address\r\n        dacProxyAddress: User's proxy address\r\n        addressRegistryAddress: AddressRegistry's Address\r\n        oldCTokenAddress: oldCToken address\r\n        oldTokenUnderlyingDelta: Amount of tokens to swap from old c token's underlying\r\n        executeOperationCalldataParams:\r\n            Abi-encoded `data` used by User's proxy's `execute(address, <data>)` function.\r\n            Used to delegatecall to another contract (i.e. this contract) in the context\r\n            of the proxy. This allows us to decouple the logic of handling flashloans\r\n            from the proxy contract. In this specific case, it is expecting the results\r\n            from: (from JS)\r\n\r\n            ```\r\n                const IDedgeCompoundManager = ethers.utils.Interface(DedgeCompoundManager.abi)\r\n\r\n                const executeOperationCalldataParams = IDedgeCompoundManager\r\n                    .functions\r\n                    .swapDebt OR .swapCollateral\r\n                    .encode([\r\n                        <parameters>\r\n                    ])\r\n            ```\r\n    */\r\n    function swapOperation(\r\n        address dedgeCompoundManagerAddress,\r\n        address payable dacProxyAddress,\r\n        address addressRegistryAddress,\r\n        address oldCTokenAddress,            // Old CToken address for [debt|collateral]\r\n        uint oldTokenUnderlyingDelta,        // Amount of old tokens to swap to new tokens\r\n        bytes calldata executeOperationCalldataParams\r\n    ) external {\r\n        // Calling from dacProxy context (msg.sender is dacProxy)\r\n        // 1. Get amount of ETH obtained by selling that from Uniswap\r\n        // 2. Flashloans ETH to dacProxy\r\n\r\n        // Gets registries\r\n        AddressRegistry addressRegistry = AddressRegistry(addressRegistryAddress);\r\n\r\n        // 1. Get amount of ETH needed\r\n        // If the old target is ether than the ethDebtAmount is just the delta\r\n        uint ethDebtAmount;\r\n\r\n        if (oldCTokenAddress == addressRegistry.CEtherAddress()) {\r\n            ethDebtAmount = oldTokenUnderlyingDelta;\r\n        } else {\r\n            // Otherwise calculate it from the exchange\r\n            ethDebtAmount = _getEthToTokenOutput(\r\n                ICToken(oldCTokenAddress).underlying(),\r\n                oldTokenUnderlyingDelta\r\n            );\r\n        }\r\n\r\n        // Injects the target address into calldataParams\r\n        // so user proxy know which address it'll be calling `calldataParams` on\r\n        bytes memory addressAndExecuteOperationCalldataParams = abi.encodePacked(\r\n            abi.encode(dedgeCompoundManagerAddress),\r\n            executeOperationCalldataParams\r\n        );\r\n\r\n        ILendingPool lendingPool = ILendingPool(\r\n            ILendingPoolAddressesProvider(\r\n                addressRegistry.AaveLendingPoolAddressProviderAddress()\r\n            ).getLendingPool()\r\n        );\r\n\r\n        // Approve lendingPool to call proxy\r\n        _proxyGuardPermit(dacProxyAddress, address(lendingPool));\r\n\r\n        // 3. Flashloan ETH with relevant data\r\n        lendingPool.flashLoan(\r\n            dacProxyAddress,\r\n            addressRegistry.AaveEthAddress(),\r\n            ethDebtAmount,\r\n            addressAndExecuteOperationCalldataParams\r\n        );\r\n\r\n        // Forbids lendingPool to call proxy\r\n        _proxyGuardForbid(dacProxyAddress, address(lendingPool));\r\n    }\r\n\r\n    // Clears dust debt by swapping old debt into new debt\r\n    function clearDebtDust(\r\n        address addressRegistryAddress,\r\n        address oldCTokenAddress,\r\n        uint oldTokenUnderlyingDustAmount,\r\n        address newCTokenAddress\r\n    ) public payable {\r\n        // i.e. Has 0.1 ETH (oldCToken) debt 900 DAI (newCToken)\r\n        // wants to have it all in DAI\r\n\r\n        // 0. Calculates 0.1 ETH equilavent in DAI\r\n        // 1. Borrows out 0.1 ETH equilavent in DAI (~10 DAI as of march 2020)\r\n        // 2. Convert 10 DAI into 0.1 ETH\r\n        // 3. Repay 0.1 ETH\r\n\r\n        require(oldCTokenAddress != newCTokenAddress, \"clear-debt-same-address\");\r\n\r\n        AddressRegistry addressRegistry = AddressRegistry(addressRegistryAddress);\r\n\r\n        uint borrowAmount;\r\n        address oldTokenUnderlying;\r\n        address newTokenUnderlying;\r\n\r\n        if (oldCTokenAddress == addressRegistry.CEtherAddress()) {\r\n            // ETH -> Token\r\n            newTokenUnderlying = ICToken(newCTokenAddress).underlying();\r\n\r\n            // Calculates ETH equilavent in token\r\n            borrowAmount = _getTokenToEthOutput(newTokenUnderlying, oldTokenUnderlyingDustAmount);\r\n\r\n            // Borrows out equilavent token\r\n            borrow(newCTokenAddress, borrowAmount);\r\n\r\n            // Converts token to ETH\r\n            _tokenToEth(newTokenUnderlying, borrowAmount, oldTokenUnderlyingDustAmount);\r\n        } else if (newCTokenAddress == addressRegistry.CEtherAddress()) {\r\n            // Token -> ETH\r\n            oldTokenUnderlying = ICToken(oldCTokenAddress).underlying();\r\n\r\n            // Calculates token equilavent in ETH\r\n            borrowAmount = _getEthToTokenOutput(oldTokenUnderlying, oldTokenUnderlyingDustAmount);\r\n\r\n            // Borrows out equilavent ETH\r\n            borrow(newCTokenAddress, borrowAmount);\r\n\r\n            // Converts ETH to token\r\n            _ethToToken(oldTokenUnderlying, borrowAmount, oldTokenUnderlyingDustAmount);\r\n        } else {\r\n            // token -> token\r\n            oldTokenUnderlying = ICToken(oldCTokenAddress).underlying();\r\n            newTokenUnderlying = ICToken(newCTokenAddress).underlying();\r\n\r\n            // Calculates eth borrow amount\r\n            uint ethAmount = _getEthToTokenOutput(oldTokenUnderlying, oldTokenUnderlyingDustAmount);\r\n\r\n            // Calculates token borrow amount\r\n            borrowAmount = _getTokenToEthOutput(newTokenUnderlying, ethAmount);\r\n\r\n            // Borrows out equilavent token\r\n            borrow(newCTokenAddress, borrowAmount);\r\n\r\n            // Converts old token to target token\r\n            _tokenToEth(newTokenUnderlying, borrowAmount, ethAmount);\r\n            _ethToToken(oldTokenUnderlying, ethAmount, oldTokenUnderlyingDustAmount);\r\n        }\r\n\r\n        // Repays borrowed\r\n        repayBorrow(oldCTokenAddress, oldTokenUnderlyingDustAmount);\r\n    }\r\n\r\n    function clearCollateralDust(\r\n        address addressRegistryAddress,\r\n        address oldCTokenAddress,\r\n        uint oldTokenUnderlyingAmount,\r\n        address newCTokenAddress\r\n    ) public payable {\r\n        // i.e. Has 10 ETH collateral and 10 DAI collateral\r\n        // wants to have it all in ETH\r\n\r\n        // 1. Redeems 10 DAI collateral\r\n        // 2. Converts it to ETH\r\n        // 3. Puts it into ETH\r\n\r\n        // More abstractly,\r\n        // 1. Redeems tokens\r\n        // 2. Convert it to other token\r\n        // 3. Put other token in\r\n\r\n        require(oldCTokenAddress != newCTokenAddress, \"clear-collateral-same-address\");\r\n\r\n        uint supplyAmount;\r\n        AddressRegistry addressRegistry = AddressRegistry(addressRegistryAddress);\r\n\r\n        // Redeems collateral\r\n        redeemUnderlying(oldCTokenAddress, oldTokenUnderlyingAmount);\r\n\r\n        if (oldCTokenAddress == addressRegistry.CEtherAddress()) {\r\n            // ETH -> Token\r\n            supplyAmount = _ethToToken(\r\n                ICToken(newCTokenAddress).underlying(),\r\n                oldTokenUnderlyingAmount\r\n            );\r\n        } else if (newCTokenAddress == addressRegistry.CEtherAddress()) {\r\n            // Token -> ETH\r\n            supplyAmount = _tokenToEth(\r\n                ICToken(oldCTokenAddress).underlying(),\r\n                oldTokenUnderlyingAmount\r\n            );\r\n        } else {\r\n            // Token -> Token\r\n            supplyAmount = _tokenToToken(\r\n                ICToken(oldCTokenAddress).underlying(),\r\n                ICToken(newCTokenAddress).underlying(),\r\n                oldTokenUnderlyingAmount\r\n            );\r\n        }\r\n\r\n        // Supplies collateral\r\n        supply(newCTokenAddress, supplyAmount);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveCToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"}],\"name\":\"approveCTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"borrowThroughProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldCTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oldTokenUnderlyingAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newCTokenAddress\",\"type\":\"address\"}],\"name\":\"clearCollateralDust\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldCTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oldTokenUnderlyingDustAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newCTokenAddress\",\"type\":\"address\"}],\"name\":\"clearDebtDust\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"}],\"name\":\"enterMarkets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"}],\"name\":\"enterMarketsAndApproveCTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeemThroughProxy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlying\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlyingThroughProxy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayBorrow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayBorrowBehalf\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayBorrowBehalfThroughProxy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayBorrowThroughProxy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"supply\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"supplyCToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"supplyAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrowCToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"supplyAndBorrow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"supplyETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"supplyETHAndBorrow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"supplyThroughProxy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_aaveFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"swapCollateralPostLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_aaveFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"swapDebtPostLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dedgeCompoundManagerAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"dacProxyAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addressRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldCTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oldTokenUnderlyingDelta\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"executeOperationCalldataParams\",\"type\":\"bytes\"}],\"name\":\"swapOperation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DedgeCompoundManager","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://8ae895e7541e4d69281abf729bbfda1f8308d394605320a93823528931204e02"}]}