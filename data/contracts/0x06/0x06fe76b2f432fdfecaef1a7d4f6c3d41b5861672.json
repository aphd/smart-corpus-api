{"status":"1","message":"OK-Missing/Invalid API Key, rate limit of 1/3sec applied","result":[{"SourceCode":"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.6.5;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nstruct ProtocolBalance {\r\n    ProtocolMetadata metadata;\r\n    AdapterBalance[] adapterBalances;\r\n}\r\n\r\n\r\nstruct ProtocolMetadata {\r\n    string name;\r\n    string description;\r\n    string websiteURL;\r\n    string iconURL;\r\n    uint256 version;\r\n}\r\n\r\n\r\nstruct AdapterBalance {\r\n    AdapterMetadata metadata;\r\n    FullTokenBalance[] balances;\r\n}\r\n\r\n\r\nstruct AdapterMetadata {\r\n    address adapterAddress;\r\n    string adapterType;\r\n}\r\n\r\n\r\nstruct FullTokenBalance {\r\n    TokenBalance base;\r\n    TokenBalance[] underlying;\r\n}\r\n\r\n\r\nstruct TokenBalance {\r\n    TokenMetadata metadata;\r\n    uint256 amount;\r\n}\r\n\r\n\r\nstruct TokenMetadata {\r\n    address token;\r\n    string name;\r\n    string symbol;\r\n    uint8 decimals;\r\n}\r\n\r\n\r\nstruct Component {\r\n    address token;\r\n    string tokenType;\r\n    uint256 rate;\r\n}\r\n\r\n\r\n/**\r\n * @notice Library for strings.\r\n * @author Igor Sobolev <sobolev@zerion.io>\r\n */\r\nlibrary Strings {\r\n\r\n    function isEmpty(string memory s) internal pure returns (bool) {\r\n        return bytes(s).length == 0;\r\n    }\r\n\r\n    function isEqualTo(string memory s1, string memory s2) internal pure returns (bool) {\r\n        return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Token adapter interface.\r\n * @dev getMetadata() and getComponents() functions MUST be implemented.\r\n * @author Igor Sobolev <sobolev@zerion.io>\r\n */\r\ninterface TokenAdapter {\r\n\r\n    /**\r\n     * @dev MUST return TokenMetadata struct with ERC20-style token info.\r\n     * struct TokenMetadata {\r\n     *     address token;\r\n     *     string name;\r\n     *     string symbol;\r\n     *     uint8 decimals;\r\n     * }\r\n     */\r\n    function getMetadata(address token) external view returns (TokenMetadata memory);\r\n\r\n    /**\r\n    * @dev MUST return array of Component structs with underlying tokens rates for the given token.\r\n    * struct Component {\r\n    *     address token;    // Address of token contract\r\n    *     string tokenType; // Token type (\"ERC20\" by default)\r\n    *     uint256 rate;     // Price per share (1e18)\r\n    * }\r\n    */\r\n    function getComponents(address token) external view returns (Component[] memory);\r\n}\r\n\r\n\r\n/**\r\n * @title Protocol adapter interface.\r\n * @dev adapterType(), tokenType(), and getBalance() functions MUST be implemented.\r\n * @author Igor Sobolev <sobolev@zerion.io>\r\n */\r\ninterface ProtocolAdapter {\r\n\r\n    /**\r\n     * @dev MUST return \"Asset\" or \"Debt\".\r\n     * SHOULD be implemented by the public constant state variable.\r\n     */\r\n    function adapterType() external pure returns (string memory);\r\n\r\n    /**\r\n     * @dev MUST return token type (default is \"ERC20\").\r\n     * SHOULD be implemented by the public constant state variable.\r\n     */\r\n    function tokenType() external pure returns (string memory);\r\n\r\n    /**\r\n     * @dev MUST return amount of the given token locked on the protocol by the given account.\r\n     */\r\n    function getBalance(address token, address account) external view returns (uint256);\r\n}\r\n\r\n\r\nabstract contract Ownable {\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"O: onlyOwner function!\");\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @notice Initializes owner variable with msg.sender address.\r\n     */\r\n    constructor() internal {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership to the desired address.\r\n     * The function is callable only by the owner.\r\n     */\r\n    function transferOwnership(address _owner) external onlyOwner {\r\n        require(_owner != address(0), \"O: new owner is the zero address!\");\r\n        emit OwnershipTransferred(owner, _owner);\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title AdapterRegistry part responsible for token adapters management.\r\n * @dev Base contract for AdapterRegistry.\r\n * @author Igor Sobolev <sobolev@zerion.io>\r\n */\r\nabstract contract TokenAdapterManager is Ownable {\r\n\r\n    using Strings for string;\r\n\r\n    string internal constant INITIAL_NAME = \"Initial token name\";\r\n\r\n    // adapter name => next adapter name (linked list)\r\n    mapping (string => string) internal nextTokenAdapterName;\r\n    // adapter name => adapter info\r\n    mapping (string => address) internal tokenAdapter;\r\n\r\n    /**\r\n     * @notice Initializes contract storage.\r\n     */\r\n    constructor() internal {\r\n        nextTokenAdapterName[INITIAL_NAME] = INITIAL_NAME;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds new token adapters.\r\n     * The function is callable only by the owner.\r\n     * @param tokenAdapterNames Names of token adapters to be added.\r\n     * @param adapters Addresses of token adapters to be added.\r\n     */\r\n    function addTokenAdapters(\r\n        string[] memory tokenAdapterNames,\r\n        address[] memory adapters\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        uint256 length = tokenAdapterNames.length;\r\n        require(length == adapters.length, \"TAM: lengths differ!\");\r\n        require(length != 0, \"PM: empty!\");\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            addTokenAdapter(tokenAdapterNames[i], adapters[i]);\r\n        }\r\n    }\r\n    /**\r\n     * @notice Removes token adapters.\r\n     * The function is callable only by the owner.\r\n     * @param tokenAdapterNames Names of token adapters to be removed.\r\n     */\r\n    function removeTokenAdapters(\r\n        string[] memory tokenAdapterNames\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(tokenAdapterNames.length != 0, \"PM: empty!\");\r\n\r\n        for (uint256 i = 0; i < tokenAdapterNames.length; i++) {\r\n            removeTokenAdapter(tokenAdapterNames[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Updates token adapter.\r\n     * The function is callable only by the owner.\r\n     * @param tokenAdapterName Name of token adapter to be updated.\r\n     * @param adapter Address of token adapter to be added instead.\r\n     */\r\n    function updateTokenAdapter(\r\n        string memory tokenAdapterName,\r\n        address adapter\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(isValidTokenAdapter(tokenAdapterName), \"TAM: bad name!\");\r\n        require(adapter != address(0), \"TAM: zero!\");\r\n\r\n        tokenAdapter[tokenAdapterName] = adapter;\r\n    }\r\n\r\n    /**\r\n     * @return Array of token adapter names.\r\n     */\r\n    function getTokenAdapterNames()\r\n        public\r\n        view\r\n        returns (string[] memory)\r\n    {\r\n        uint256 counter = 0;\r\n        string memory currentTokenAdapterName = nextTokenAdapterName[INITIAL_NAME];\r\n\r\n        while (!currentTokenAdapterName.isEqualTo(INITIAL_NAME)) {\r\n            currentTokenAdapterName = nextTokenAdapterName[currentTokenAdapterName];\r\n            counter++;\r\n        }\r\n\r\n        string[] memory tokenAdapters = new string[](counter);\r\n        counter = 0;\r\n        currentTokenAdapterName = nextTokenAdapterName[INITIAL_NAME];\r\n\r\n        while (!currentTokenAdapterName.isEqualTo(INITIAL_NAME)) {\r\n            tokenAdapters[counter] = currentTokenAdapterName;\r\n            currentTokenAdapterName = nextTokenAdapterName[currentTokenAdapterName];\r\n            counter++;\r\n        }\r\n\r\n        return tokenAdapters;\r\n    }\r\n\r\n    /**\r\n     * @param tokenAdapterName Name of token adapter.\r\n     * @return Address of token adapter.\r\n     */\r\n    function getTokenAdapter(\r\n        string memory tokenAdapterName\r\n    )\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return tokenAdapter[tokenAdapterName];\r\n    }\r\n\r\n    /**\r\n     * @param tokenAdapterName Name of token adapter.\r\n     * @return Whether token adapter is valid.\r\n     */\r\n    function isValidTokenAdapter(\r\n        string memory tokenAdapterName\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return !nextTokenAdapterName[tokenAdapterName].isEmpty() && !tokenAdapterName.isEqualTo(INITIAL_NAME);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds new token adapter.\r\n     * The function is callable only by the owner.\r\n     * @param tokenAdapterName Name of token adapter to be added.\r\n     * @param adapter Address of token adapter to be added.\r\n     */\r\n    function addTokenAdapter(\r\n        string memory tokenAdapterName,\r\n        address adapter\r\n    )\r\n        internal\r\n    {\r\n        require(!tokenAdapterName.isEqualTo(INITIAL_NAME), \"TAM: initial name!\");\r\n        require(!tokenAdapterName.isEmpty(), \"TAM: empty name!\");\r\n        require(nextTokenAdapterName[tokenAdapterName].isEmpty(), \"TAM: name exists!\");\r\n        require(adapter != address(0), \"TAM: zero!\");\r\n\r\n        nextTokenAdapterName[tokenAdapterName] = nextTokenAdapterName[INITIAL_NAME];\r\n        nextTokenAdapterName[INITIAL_NAME] = tokenAdapterName;\r\n\r\n        tokenAdapter[tokenAdapterName] = adapter;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes one of token adapters.\r\n     * @param tokenAdapterName Name of token adapter to be removed.\r\n     */\r\n    function removeTokenAdapter(\r\n        string memory tokenAdapterName\r\n    )\r\n        internal\r\n    {\r\n        require(isValidTokenAdapter(tokenAdapterName), \"TAM: bad name!\");\r\n\r\n        string memory prevTokenAdapterName;\r\n        string memory currentTokenAdapterName = nextTokenAdapterName[tokenAdapterName];\r\n        while (!currentTokenAdapterName.isEqualTo(tokenAdapterName)) {\r\n            prevTokenAdapterName = currentTokenAdapterName;\r\n            currentTokenAdapterName = nextTokenAdapterName[currentTokenAdapterName];\r\n        }\r\n\r\n        nextTokenAdapterName[prevTokenAdapterName] = nextTokenAdapterName[tokenAdapterName];\r\n        delete nextTokenAdapterName[tokenAdapterName];\r\n\r\n        delete tokenAdapter[tokenAdapterName];\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title AdapterRegistry part responsible for protocols and adapters management.\r\n * @dev Base contract for AdapterRegistry.\r\n * @author Igor Sobolev <sobolev@zerion.io>\r\n */\r\nabstract contract ProtocolManager is Ownable {\r\n\r\n    using Strings for string;\r\n\r\n    string internal constant INITIAL_PROTOCOL_NAME = \"Initial protocol name\";\r\n\r\n    // protocol name => next protocol name (linked list)\r\n    mapping (string => string) internal nextProtocolName;\r\n    // protocol name => protocol struct with info and adapters\r\n    mapping (string => ProtocolMetadata) internal protocolMetadata;\r\n    // protocol name => array of protocol adapters\r\n    mapping (string => address[]) internal protocolAdapters;\r\n    // protocol adapter => array of supported tokens\r\n    mapping (address => address[]) internal supportedTokens;\r\n\r\n    /**\r\n     * @notice Initializes contract storage.\r\n     */\r\n    constructor() internal {\r\n        nextProtocolName[INITIAL_PROTOCOL_NAME] = INITIAL_PROTOCOL_NAME;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds new protocols.\r\n     * The function is callable only by the owner.\r\n     * @param protocolNames Names of the protocols to be added.\r\n     * @param metadata Array with new protocols metadata.\r\n     * @param adapters Nested arrays with new protocols' adapters.\r\n     * @param tokens Nested arrays with adapters' supported tokens.\r\n     */\r\n    function addProtocols(\r\n        string[] memory protocolNames,\r\n        ProtocolMetadata[] memory metadata,\r\n        address[][] memory adapters,\r\n        address[][][] memory tokens\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(protocolNames.length == metadata.length, \"PM: protocolNames & metadata differ!\");\r\n        require(protocolNames.length == adapters.length, \"PM: protocolNames & adapters differ!\");\r\n        require(protocolNames.length == tokens.length, \"PM: protocolNames & tokens differ!\");\r\n        require(protocolNames.length != 0, \"PM: empty!\");\r\n\r\n        for (uint256 i = 0; i < protocolNames.length; i++) {\r\n            addProtocol(protocolNames[i], metadata[i], adapters[i], tokens[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Removes protocols.\r\n     * The function is callable only by the owner.\r\n     * @param protocolNames Names of the protocols to be removed.\r\n     */\r\n    function removeProtocols(\r\n        string[] memory protocolNames\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(protocolNames.length != 0, \"PM: empty!\");\r\n\r\n        for (uint256 i = 0; i < protocolNames.length; i++) {\r\n            removeProtocol(protocolNames[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Updates a protocol info.\r\n     * The function is callable only by the owner.\r\n     * @param protocolName Name of the protocol to be updated.\r\n     * @param name Name of the protocol to be added instead.\r\n     * @param description Description of the protocol to be added instead.\r\n     * @param websiteURL URL of the protocol website to be added instead.\r\n     * @param iconURL URL of the protocol icon to be added instead.\r\n     */\r\n    function updateProtocolMetadata(\r\n        string memory protocolName,\r\n        string memory name,\r\n        string memory description,\r\n        string memory websiteURL,\r\n        string memory iconURL\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(isValidProtocol(protocolName), \"PM: bad name!\");\r\n        require(abi.encodePacked(name, description, websiteURL, iconURL).length != 0, \"PM: empty!\");\r\n\r\n        ProtocolMetadata storage metadata = protocolMetadata[protocolName];\r\n\r\n        if (!name.isEmpty()) {\r\n            metadata.name = name;\r\n        }\r\n\r\n        if (!description.isEmpty()) {\r\n            metadata.description = description;\r\n        }\r\n\r\n        if (!websiteURL.isEmpty()) {\r\n            metadata.websiteURL = websiteURL;\r\n        }\r\n\r\n        if (!iconURL.isEmpty()) {\r\n            metadata.iconURL = iconURL;\r\n        }\r\n\r\n        metadata.version++;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds protocol adapters.\r\n     * The function is callable only by the owner.\r\n     * @param protocolName Name of the protocol to be updated.\r\n     * @param adapters Array of new adapters to be added.\r\n     * @param tokens Array of new adapters' supported tokens.\r\n     */\r\n    function addProtocolAdapters(\r\n        string memory protocolName,\r\n        address[] memory adapters,\r\n        address[][] memory tokens\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(isValidProtocol(protocolName), \"PM: bad name!\");\r\n        require(adapters.length != 0, \"PM: empty!\");\r\n\r\n        for (uint256 i = 0; i < adapters.length; i++) {\r\n            addProtocolAdapter(protocolName, adapters[i], tokens[i]);\r\n        }\r\n\r\n        protocolMetadata[protocolName].version++;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes protocol adapters.\r\n     * The function is callable only by the owner.\r\n     * @param protocolName Name of the protocol to be updated.\r\n     * @param adapterIndices Array of adapter indexes to be removed.\r\n     * @dev NOTE: indexes will change during execution of this function!!!\r\n     */\r\n    function removeProtocolAdapters(\r\n        string memory protocolName,\r\n        uint256[] memory adapterIndices\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(isValidProtocol(protocolName), \"PM: bad name!\");\r\n        require(adapterIndices.length != 0, \"PM: empty!\");\r\n\r\n        for (uint256 i = 0; i < adapterIndices.length; i++) {\r\n            removeProtocolAdapter(protocolName, adapterIndices[i]);\r\n        }\r\n\r\n        protocolMetadata[protocolName].version++;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates a protocol adapter.\r\n     * The function is callable only by the owner.\r\n     * @param protocolName Name of the protocol to be updated.\r\n     * @param index Index of the adapter to be updated.\r\n     * @param newAdapterAddress New adapter address to be added instead.\r\n     * @param newSupportedTokens New supported tokens to be added instead.\r\n     */\r\n    function updateProtocolAdapter(\r\n        string memory protocolName,\r\n        uint256 index,\r\n        address newAdapterAddress,\r\n        address[] memory newSupportedTokens\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(isValidProtocol(protocolName), \"PM: bad name!\");\r\n        require(index < protocolAdapters[protocolName].length, \"PM: bad index!\");\r\n        require(newAdapterAddress != address(0), \"PM: empty!\");\r\n\r\n        address adapterAddress = protocolAdapters[protocolName][index];\r\n\r\n        if (newAdapterAddress == adapterAddress) {\r\n            supportedTokens[adapterAddress] = newSupportedTokens;\r\n        } else {\r\n            protocolAdapters[protocolName][index] = newAdapterAddress;\r\n            supportedTokens[newAdapterAddress] = newSupportedTokens;\r\n            delete supportedTokens[adapterAddress];\r\n        }\r\n\r\n        protocolMetadata[protocolName].version++;\r\n    }\r\n\r\n    /**\r\n     * @return Array of protocol names.\r\n     */\r\n    function getProtocolNames()\r\n        public\r\n        view\r\n        returns (string[] memory)\r\n    {\r\n        uint256 counter = 0;\r\n        string memory currentProtocolName = nextProtocolName[INITIAL_PROTOCOL_NAME];\r\n\r\n        while (!currentProtocolName.isEqualTo(INITIAL_PROTOCOL_NAME)) {\r\n            currentProtocolName = nextProtocolName[currentProtocolName];\r\n            counter++;\r\n        }\r\n\r\n        string[] memory protocols = new string[](counter);\r\n        counter = 0;\r\n        currentProtocolName = nextProtocolName[INITIAL_PROTOCOL_NAME];\r\n\r\n        while (!currentProtocolName.isEqualTo(INITIAL_PROTOCOL_NAME)) {\r\n            protocols[counter] = currentProtocolName;\r\n            currentProtocolName = nextProtocolName[currentProtocolName];\r\n            counter++;\r\n        }\r\n\r\n        return protocols;\r\n    }\r\n\r\n    /**\r\n     * @param protocolName Name of the protocol.\r\n     * @return Metadata of the protocol.\r\n     */\r\n    function getProtocolMetadata(\r\n        string memory protocolName\r\n    )\r\n        public\r\n        view\r\n        returns (ProtocolMetadata memory)\r\n    {\r\n        return (protocolMetadata[protocolName]);\r\n    }\r\n\r\n    /**\r\n     * @param protocolName Name of the protocol.\r\n     * @return Array of protocol adapters.\r\n     */\r\n    function getProtocolAdapters(\r\n        string memory protocolName\r\n    )\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return protocolAdapters[protocolName];\r\n    }\r\n\r\n    /**\r\n     * @param adapter Address of the protocol adapter.\r\n     * @return Array of supported tokens.\r\n     */\r\n    function getSupportedTokens(\r\n        address adapter\r\n    )\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return supportedTokens[adapter];\r\n    }\r\n\r\n    /**\r\n     * @param protocolName Name of the protocol.\r\n     * @return Whether the protocol name is valid.\r\n     */\r\n    function isValidProtocol(\r\n        string memory protocolName\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return !nextProtocolName[protocolName].isEmpty() && !protocolName.isEqualTo(INITIAL_PROTOCOL_NAME);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new protocol.\r\n     * The function is callable only by the owner.\r\n     * @param protocolName Name of the protocol to be added.\r\n     * @param metadata Info about new protocol.\r\n     * @param adapters Addresses of new protocol's adapters.\r\n     * @param tokens Addresses of new protocol's adapters' supported tokens.\r\n     */\r\n    function addProtocol(\r\n        string memory protocolName,\r\n        ProtocolMetadata memory metadata,\r\n        address[] memory adapters,\r\n        address[][] memory tokens\r\n    )\r\n        internal\r\n    {\r\n        require(!protocolName.isEqualTo(INITIAL_PROTOCOL_NAME), \"PM: initial name!\");\r\n        require(!protocolName.isEmpty(), \"PM: empty name!\");\r\n        require(nextProtocolName[protocolName].isEmpty(), \"PM: name exists!\");\r\n        require(adapters.length == tokens.length, \"PM: adapters & tokens differ!\");\r\n\r\n        nextProtocolName[protocolName] = nextProtocolName[INITIAL_PROTOCOL_NAME];\r\n        nextProtocolName[INITIAL_PROTOCOL_NAME] = protocolName;\r\n\r\n        protocolMetadata[protocolName] = ProtocolMetadata({\r\n            name: metadata.name,\r\n            description: metadata.description,\r\n            websiteURL: metadata.websiteURL,\r\n            iconURL: metadata.iconURL,\r\n            version: metadata.version\r\n        });\r\n\r\n        for (uint256 i = 0; i < adapters.length; i++) {\r\n            addProtocolAdapter(protocolName, adapters[i], tokens[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Removes one of the protocols.\r\n     * @param protocolName Name of the protocol to be removed.\r\n     */\r\n    function removeProtocol(\r\n        string memory protocolName\r\n    )\r\n        internal\r\n    {\r\n        require(isValidProtocol(protocolName), \"PM: bad name!\");\r\n\r\n        string memory prevProtocolName;\r\n        string memory currentProtocolName = nextProtocolName[protocolName];\r\n        while (!currentProtocolName.isEqualTo(protocolName)) {\r\n            prevProtocolName = currentProtocolName;\r\n            currentProtocolName = nextProtocolName[currentProtocolName];\r\n        }\r\n\r\n        delete protocolMetadata[protocolName];\r\n\r\n        nextProtocolName[prevProtocolName] = nextProtocolName[protocolName];\r\n        delete nextProtocolName[protocolName];\r\n\r\n        uint256 length = protocolAdapters[protocolName].length;\r\n        for (uint256 i = length - 1; i < length; i--) {\r\n            removeProtocolAdapter(protocolName, i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a protocol adapter.\r\n     * The function is callable only by the owner.\r\n     * @param protocolName Name of the protocol to be updated.\r\n     * @param adapter New adapter to be added.\r\n     * @param tokens New adapter's supported tokens.\r\n     */\r\n    function addProtocolAdapter(\r\n        string memory protocolName,\r\n        address adapter,\r\n        address[] memory tokens\r\n    )\r\n        internal\r\n    {\r\n        require(adapter != address(0), \"PM: zero!\");\r\n        require(supportedTokens[adapter].length == 0, \"PM: exists!\");\r\n\r\n        protocolAdapters[protocolName].push(adapter);\r\n        supportedTokens[adapter] = tokens;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes a protocol adapter.\r\n     * The function is callable only by the owner.\r\n     * @param protocolName Name of the protocol to be updated.\r\n     * @param index Adapter index to be removed.\r\n     */\r\n    function removeProtocolAdapter(\r\n        string memory protocolName,\r\n        uint256 index\r\n    )\r\n        internal\r\n    {\r\n        uint256 length = protocolAdapters[protocolName].length;\r\n        require(index < length, \"PM: bad index!\");\r\n\r\n        delete supportedTokens[protocolAdapters[protocolName][index]];\r\n\r\n        if (index != length - 1) {\r\n            protocolAdapters[protocolName][index] = protocolAdapters[protocolName][length - 1];\r\n        }\r\n\r\n        protocolAdapters[protocolName].pop();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Registry for protocols, adapters, and token adapters.\r\n * @notice getBalances() function implements the main functionality.\r\n * @author Igor Sobolev <sobolev@zerion.io>\r\n */\r\ncontract AdapterRegistry is Ownable, ProtocolManager, TokenAdapterManager {\r\n\r\n    using Strings for string;\r\n\r\n    /**\r\n     * @param tokenType String with type of the token.\r\n     * @param token Address of the token.\r\n     * @return Full token balance by token type and token address.\r\n     */\r\n    function getFullTokenBalance(\r\n        string calldata tokenType,\r\n        address token\r\n    )\r\n        external\r\n        view\r\n        returns (FullTokenBalance memory)\r\n    {\r\n        Component[] memory components = getComponents(tokenType, token, 1e18);\r\n        return getFullTokenBalance(tokenType, token, 1e18, components);\r\n    }\r\n\r\n    /**\r\n     * @param tokenType String with type of the token.\r\n     * @param token Address of the token.\r\n     * @return Final full token balance by token type and token address.\r\n     */\r\n    function getFinalFullTokenBalance(\r\n        string calldata tokenType,\r\n        address token\r\n    )\r\n        external\r\n        view\r\n        returns (FullTokenBalance memory)\r\n    {\r\n        Component[] memory finalComponents = getFinalComponents(tokenType, token, 1e18);\r\n        return getFullTokenBalance(tokenType, token, 1e18, finalComponents);\r\n    }\r\n\r\n    /**\r\n     * @param account Address of the account.\r\n     * @return ProtocolBalance array by the given account.\r\n     */\r\n    function getBalances(\r\n        address account\r\n    )\r\n        external\r\n        view\r\n        returns (ProtocolBalance[] memory)\r\n    {\r\n        string[] memory protocolNames = getProtocolNames();\r\n\r\n        return getProtocolBalances(account, protocolNames);\r\n    }\r\n\r\n    /**\r\n     * @param account Address of the account.\r\n     * @param protocolNames Array of the protocols' names.\r\n     * @return ProtocolBalance array by the given account and names of protocols.\r\n     */\r\n    function getProtocolBalances(\r\n        address account,\r\n        string[] memory protocolNames\r\n    )\r\n        public\r\n        view\r\n        returns (ProtocolBalance[] memory)\r\n    {\r\n        ProtocolBalance[] memory protocolBalances = new ProtocolBalance[](protocolNames.length);\r\n        uint256 counter = 0;\r\n\r\n        for (uint256 i = 0; i < protocolNames.length; i++) {\r\n            protocolBalances[i] = ProtocolBalance({\r\n                metadata: protocolMetadata[protocolNames[i]],\r\n                adapterBalances: getAdapterBalances(account, protocolAdapters[protocolNames[i]])\r\n            });\r\n            if (protocolBalances[i].adapterBalances.length > 0) {\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        ProtocolBalance[] memory nonZeroProtocolBalances = new ProtocolBalance[](counter);\r\n        counter = 0;\r\n\r\n        for (uint256 i = 0; i < protocolNames.length; i++) {\r\n            if (protocolBalances[i].adapterBalances.length > 0) {\r\n                nonZeroProtocolBalances[counter] = protocolBalances[i];\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        return nonZeroProtocolBalances;\r\n    }\r\n\r\n    /**\r\n     * @param account Address of the account.\r\n     * @param adapters Array of the protocol adapters' addresses.\r\n     * @return AdapterBalance array by the given parameters.\r\n     */\r\n    function getAdapterBalances(\r\n        address account,\r\n        address[] memory adapters\r\n    )\r\n        public\r\n        view\r\n        returns (AdapterBalance[] memory)\r\n    {\r\n        AdapterBalance[] memory adapterBalances = new AdapterBalance[](adapters.length);\r\n        uint256 counter = 0;\r\n\r\n        for (uint256 i = 0; i < adapterBalances.length; i++) {\r\n            adapterBalances[i] = getAdapterBalance(\r\n                account,\r\n                adapters[i],\r\n                supportedTokens[adapters[i]]\r\n            );\r\n            if (adapterBalances[i].balances.length > 0) {\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        AdapterBalance[] memory nonZeroAdapterBalances = new AdapterBalance[](counter);\r\n        counter = 0;\r\n\r\n        for (uint256 i = 0; i < adapterBalances.length; i++) {\r\n            if (adapterBalances[i].balances.length > 0) {\r\n                nonZeroAdapterBalances[counter] = adapterBalances[i];\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        return nonZeroAdapterBalances;\r\n    }\r\n\r\n    /**\r\n     * @param account Address of the account.\r\n     * @param adapter Address of the protocol adapter.\r\n     * @param tokens Array with tokens' addresses.\r\n     * @return AdapterBalance array by the given parameters.\r\n     */\r\n    function getAdapterBalance(\r\n        address account,\r\n        address adapter,\r\n        address[] memory tokens\r\n    )\r\n        public\r\n        view\r\n        returns (AdapterBalance memory)\r\n    {\r\n        string memory tokenType = ProtocolAdapter(adapter).tokenType();\r\n        uint256[] memory amounts = new uint256[](tokens.length);\r\n        uint256 counter;\r\n\r\n        for (uint256 i = 0; i < amounts.length; i++) {\r\n            try ProtocolAdapter(adapter).getBalance(tokens[i], account) returns (uint256 result) {\r\n                amounts[i] = result;\r\n            } catch {\r\n                amounts[i] = 0;\r\n            }\r\n            if (amounts[i] > 0) {\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        FullTokenBalance[] memory finalFullTokenBalances = new FullTokenBalance[](counter);\r\n        counter = 0;\r\n\r\n        for (uint256 i = 0; i < amounts.length; i++) {\r\n            if (amounts[i] > 0) {\r\n                finalFullTokenBalances[counter] = getFullTokenBalance(\r\n                    tokenType,\r\n                    tokens[i],\r\n                    amounts[i],\r\n                    getFinalComponents(tokenType, tokens[i], amounts[i])\r\n                );\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        return AdapterBalance({\r\n            metadata: AdapterMetadata({\r\n                adapterAddress: adapter,\r\n                adapterType: ProtocolAdapter(adapter).adapterType()\r\n            }),\r\n            balances: finalFullTokenBalances\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param tokenType Type of the base token.\r\n     * @param token Address of the base token.\r\n     * @param amount Amount of the base token.\r\n     * @param components Components of the base token.\r\n     * @return FullTokenBalance struct by the given components.\r\n     */\r\n    function getFullTokenBalance(\r\n        string memory tokenType,\r\n        address token,\r\n        uint256 amount,\r\n        Component[] memory components\r\n    )\r\n        internal\r\n        view\r\n        returns (FullTokenBalance memory)\r\n    {\r\n        TokenBalance[] memory componentTokenBalances = new TokenBalance[](components.length);\r\n\r\n        for (uint256 i = 0; i < components.length; i++) {\r\n            componentTokenBalances[i] = getTokenBalance(\r\n                components[i].tokenType,\r\n                components[i].token,\r\n                components[i].rate\r\n            );\r\n        }\r\n\r\n        return FullTokenBalance({\r\n            base: getTokenBalance(tokenType, token, amount),\r\n            underlying: componentTokenBalances\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param tokenType String with type of the token.\r\n     * @param token Address of the token.\r\n     * @param amount Amount of the token.\r\n     * @return Final components by token type and token address.\r\n     */\r\n    function getFinalComponents(\r\n        string memory tokenType,\r\n        address token,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        view\r\n        returns (Component[] memory)\r\n    {\r\n        uint256 totalLength = getFinalComponentsNumber(tokenType, token, true);\r\n        Component[] memory finalTokens = new Component[](totalLength);\r\n        uint256 length;\r\n        uint256 init = 0;\r\n\r\n        Component[] memory components = getComponents(tokenType, token, amount);\r\n        Component[] memory finalComponents;\r\n\r\n        for (uint256 i = 0; i < components.length; i++) {\r\n            finalComponents = getFinalComponents(\r\n                components[i].tokenType,\r\n                components[i].token,\r\n                components[i].rate\r\n            );\r\n\r\n            length = finalComponents.length;\r\n\r\n            if (length == 0) {\r\n                finalTokens[init] = components[i];\r\n                init = init + 1;\r\n            } else {\r\n                for (uint256 j = 0; j < length; j++) {\r\n                    finalTokens[init + j] = finalComponents[j];\r\n                }\r\n\r\n                init = init + length;\r\n            }\r\n        }\r\n\r\n        return finalTokens;\r\n    }\r\n\r\n    /**\r\n     * @param tokenType String with type of the token.\r\n     * @param token Address of the token.\r\n     * @param initial Whether the function call is initial or recursive.\r\n     * @return Final tokens number by token type and token.\r\n     */\r\n    function getFinalComponentsNumber(\r\n        string memory tokenType,\r\n        address token,\r\n        bool initial\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 totalLength = 0;\r\n        Component[] memory components = getComponents(tokenType, token, 1e18);\r\n\r\n        if (components.length == 0) {\r\n            return initial ? uint256(0) : uint256(1);\r\n        }\r\n\r\n        for (uint256 i = 0; i < components.length; i++) {\r\n            totalLength = totalLength + getFinalComponentsNumber(\r\n                components[i].tokenType,\r\n                components[i].token,\r\n                false\r\n            );\r\n        }\r\n\r\n        return totalLength;\r\n    }\r\n\r\n    /**\r\n     * @param tokenType String with type of the token.\r\n     * @param token Address of the token.\r\n     * @param amount Amount of the token.\r\n     * @return Components by token type and token address.\r\n     */\r\n    function getComponents(\r\n        string memory tokenType,\r\n        address token,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        view\r\n        returns (Component[] memory)\r\n    {\r\n        TokenAdapter adapter = TokenAdapter(tokenAdapter[tokenType]);\r\n        Component[] memory components;\r\n\r\n        if (address(adapter) != address(0)) {\r\n            try adapter.getComponents(token) returns (Component[] memory result) {\r\n                components = result;\r\n            } catch {\r\n                components = new Component[](0);\r\n            }\r\n        } else {\r\n            components = new Component[](0);\r\n        }\r\n\r\n        for (uint256 i = 0; i < components.length; i++) {\r\n            components[i].rate = components[i].rate * amount / 1e18;\r\n        }\r\n\r\n        return components;\r\n    }\r\n\r\n    /**\r\n     * @notice Fulfills TokenBalance struct using type, address, and balance of the token.\r\n     * @param tokenType String with type of the token.\r\n     * @param token Address of the token.\r\n     * @param amount Amount of tokens.\r\n     * @return TokenBalance struct with token info and balance.\r\n     */\r\n    function getTokenBalance(\r\n        string memory tokenType,\r\n        address token,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        view\r\n        returns (TokenBalance memory)\r\n    {\r\n        TokenAdapter adapter = TokenAdapter(tokenAdapter[tokenType]);\r\n        TokenBalance memory tokenBalance;\r\n        tokenBalance.amount = amount;\r\n\r\n        if (address(adapter) != address(0)) {\r\n            try adapter.getMetadata(token) returns (TokenMetadata memory result) {\r\n                tokenBalance.metadata = result;\r\n            } catch {\r\n                tokenBalance.metadata = TokenMetadata({\r\n                    token: token,\r\n                    name: \"Not available\",\r\n                    symbol: \"N/A\",\r\n                    decimals: 0\r\n                });\r\n            }\r\n        } else {\r\n            tokenBalance.metadata = TokenMetadata({\r\n                token: token,\r\n                name: \"Not available\",\r\n                symbol: \"N/A\",\r\n                decimals: 0\r\n            });\r\n        }\r\n\r\n        return tokenBalance;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocolName\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"adapters\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"tokens\",\"type\":\"address[][]\"}],\"name\":\"addProtocolAdapters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"protocolNames\",\"type\":\"string[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"websiteURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"iconURL\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"internalType\":\"struct ProtocolMetadata[]\",\"name\":\"metadata\",\"type\":\"tuple[]\"},{\"internalType\":\"address[][]\",\"name\":\"adapters\",\"type\":\"address[][]\"},{\"internalType\":\"address[][][]\",\"name\":\"tokens\",\"type\":\"address[][][]\"}],\"name\":\"addProtocols\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"tokenAdapterNames\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"adapters\",\"type\":\"address[]\"}],\"name\":\"addTokenAdapters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getAdapterBalance\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"adapterAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"adapterType\",\"type\":\"string\"}],\"internalType\":\"struct AdapterMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance\",\"name\":\"base\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance[]\",\"name\":\"underlying\",\"type\":\"tuple[]\"}],\"internalType\":\"struct FullTokenBalance[]\",\"name\":\"balances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct AdapterBalance\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"adapters\",\"type\":\"address[]\"}],\"name\":\"getAdapterBalances\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"adapterAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"adapterType\",\"type\":\"string\"}],\"internalType\":\"struct AdapterMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance\",\"name\":\"base\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance[]\",\"name\":\"underlying\",\"type\":\"tuple[]\"}],\"internalType\":\"struct FullTokenBalance[]\",\"name\":\"balances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct AdapterBalance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBalances\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"websiteURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"iconURL\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"internalType\":\"struct ProtocolMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"adapterAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"adapterType\",\"type\":\"string\"}],\"internalType\":\"struct AdapterMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance\",\"name\":\"base\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance[]\",\"name\":\"underlying\",\"type\":\"tuple[]\"}],\"internalType\":\"struct FullTokenBalance[]\",\"name\":\"balances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct AdapterBalance[]\",\"name\":\"adapterBalances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ProtocolBalance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenType\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getFinalFullTokenBalance\",\"outputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance\",\"name\":\"base\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance[]\",\"name\":\"underlying\",\"type\":\"tuple[]\"}],\"internalType\":\"struct FullTokenBalance\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenType\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getFullTokenBalance\",\"outputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance\",\"name\":\"base\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance[]\",\"name\":\"underlying\",\"type\":\"tuple[]\"}],\"internalType\":\"struct FullTokenBalance\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocolName\",\"type\":\"string\"}],\"name\":\"getProtocolAdapters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"protocolNames\",\"type\":\"string[]\"}],\"name\":\"getProtocolBalances\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"websiteURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"iconURL\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"internalType\":\"struct ProtocolMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"adapterAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"adapterType\",\"type\":\"string\"}],\"internalType\":\"struct AdapterMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance\",\"name\":\"base\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance[]\",\"name\":\"underlying\",\"type\":\"tuple[]\"}],\"internalType\":\"struct FullTokenBalance[]\",\"name\":\"balances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct AdapterBalance[]\",\"name\":\"adapterBalances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ProtocolBalance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocolName\",\"type\":\"string\"}],\"name\":\"getProtocolMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"websiteURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"iconURL\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"internalType\":\"struct ProtocolMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolNames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"getSupportedTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenAdapterName\",\"type\":\"string\"}],\"name\":\"getTokenAdapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenAdapterNames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocolName\",\"type\":\"string\"}],\"name\":\"isValidProtocol\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenAdapterName\",\"type\":\"string\"}],\"name\":\"isValidTokenAdapter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocolName\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"adapterIndices\",\"type\":\"uint256[]\"}],\"name\":\"removeProtocolAdapters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"protocolNames\",\"type\":\"string[]\"}],\"name\":\"removeProtocols\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"tokenAdapterNames\",\"type\":\"string[]\"}],\"name\":\"removeTokenAdapters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocolName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newAdapterAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"newSupportedTokens\",\"type\":\"address[]\"}],\"name\":\"updateProtocolAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"protocolName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"websiteURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"iconURL\",\"type\":\"string\"}],\"name\":\"updateProtocolMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenAdapterName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"updateTokenAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AdapterRegistry","CompilerVersion":"v0.6.5+commit.f956cc89","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"ipfs://dc5ef9c040192a8395dfdae3099215469cf36fd77b7322dc5fab4b2ea6b807fb"}]}