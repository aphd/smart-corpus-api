{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/interfaces/IMultiSigWalletWithDailyLimit.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\ninterface IMultiSigWalletWithDailyLimit {\r\n\r\n    function transactions(uint256 id) external view returns (address,uint,bytes,bool);\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n        external\r\n        returns (uint transactionId);\r\n\r\n    /// @dev Allows to change the daily limit. Transaction has to be sent by wallet.\r\n    /// @param _dailyLimit Amount in wei.\r\n    function changeDailyLimit(uint _dailyLimit) external;\r\n}\r\n\r\n// File: contracts/interfaces/IMultiSigWalletWithDailyLimitFactory.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\ninterface IMultiSigWalletWithDailyLimitFactory {\r\n\r\n    /// @dev Allows verified creation of multisignature wallet.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    /// @param _dailyLimit Amount in wei, which can be withdrawn without confirmations on a daily basis.\r\n    /// @return Returns wallet address.\r\n    function create(address[] _owners, uint _required, uint _dailyLimit)\r\n        external\r\n        returns (address wallet);\r\n}\r\n\r\n// File: contracts/interfaces/IFeePool.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\ninterface IFeePool {\r\n    /**\r\n     * @notice Check if a particular address is able to claim fees right now\r\n     * @param account The address you want to query for\r\n     */\r\n    function isFeesClaimable(address account) external view returns (bool);\r\n\r\n    /**\r\n     * @notice The fees available to be withdrawn by a specific account, priced in sUSD\r\n     * @dev Returns two amounts, one for fees and one for SNX rewards\r\n     */\r\n    function feesAvailable(address account) external view returns (uint, uint);\r\n\r\n    /**\r\n     * @notice Delegated claimFees(). Call from the delegated address\r\n     * and the fees will be sent to the claimingForAddress.\r\n     * approveClaimOnBehalf() must be called first to approve the delegate address\r\n     * @param claimingForAddress The account you are claiming fees for\r\n     */\r\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IDelegateApprovals.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\ninterface IDelegateApprovals {\r\n\r\n    function canClaimFor(address authoriser, address delegate) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract ERC20 is IERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) private _balances;\r\n\r\n  mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param owner The address to query the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return _balances[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   */\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param from address The address which you want to send tokens from\r\n   * @param to address The address which you want to transfer to\r\n   * @param value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(value <= _allowed[from][msg.sender]);\r\n\r\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n    _transfer(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseAllowance(\r\n    address spender,\r\n    uint256 addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n      _allowed[msg.sender][spender].add(addedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseAllowance(\r\n    address spender,\r\n    uint256 subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n      _allowed[msg.sender][spender].sub(subtractedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified addresses\r\n  * @param from The address to transfer from.\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n    require(value <= _balances[from]);\r\n    require(to != address(0));\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that mints an amount of the token and assigns it to\r\n   * an account. This encapsulates the modification of balances such that the\r\n   * proper events are emitted.\r\n   * @param account The account that will receive the created tokens.\r\n   * @param value The amount that will be created.\r\n   */\r\n  function _mint(address account, uint256 value) internal {\r\n    require(account != 0);\r\n    _totalSupply = _totalSupply.add(value);\r\n    _balances[account] = _balances[account].add(value);\r\n    emit Transfer(address(0), account, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n  function _burn(address account, uint256 value) internal {\r\n    require(account != 0);\r\n    require(value <= _balances[account]);\r\n\r\n    _totalSupply = _totalSupply.sub(value);\r\n    _balances[account] = _balances[account].sub(value);\r\n    emit Transfer(account, address(0), value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account, deducting from the sender's allowance for said account. Uses the\r\n   * internal burn function.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n  function _burnFrom(address account, uint256 value) internal {\r\n    require(value <= _allowed[account][msg.sender]);\r\n\r\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n    // this function needs to emit an event with the updated approval.\r\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\r\n      value);\r\n    _burn(account, value);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    // safeApprove should only be called when setting an initial allowance, \r\n    // or when resetting it to zero. To increase and decrease it, use \r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n    require(token.approve(spender, value));\r\n  }\r\n\r\n  function safeIncreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n    require(token.approve(spender, newAllowance));\r\n  }\r\n\r\n  function safeDecreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n    require(token.approve(spender, newAllowance));\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/Ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev counter to allow mutex lock with only one SSTORE operation\r\n  uint256 private _guardCounter;\r\n\r\n  constructor() internal {\r\n    // The counter starts at one to prevent changing it from zero to a non-zero\r\n    // value, which is a more expensive operation.\r\n    _guardCounter = 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * Calling a `nonReentrant` function from another `nonReentrant`\r\n   * function is not supported. It is possible to prevent this from happening\r\n   * by making the `nonReentrant` function external, and make it call a\r\n   * `private` function that does the actual work.\r\n   */\r\n  modifier nonReentrant() {\r\n    _guardCounter += 1;\r\n    uint256 localCounter = _guardCounter;\r\n    _;\r\n    require(localCounter == _guardCounter);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/utils/Withdrawable.sol\r\n\r\npragma solidity >=0.4.24;\r\n\r\n\r\n\r\n\r\n\r\ncontract Withdrawable is Ownable, ReentrancyGuard {\r\n    using SafeERC20 for ERC20;\r\n    address constant ETHER = address(0);\r\n\r\n    event LogWithdrawAsset(\r\n        address indexed _from,\r\n        address indexed _asset,\r\n        uint amount\r\n    );\r\n\r\n    /**\r\n     * @dev Withdraw asset.\r\n     * @param _assetAddress Asset to be withdrawn.\r\n     * @return bool.\r\n     */\r\n    function withdrawAsset(address _assetAddress) public nonReentrant onlyOwner {\r\n        uint assetBalance;\r\n        if (_assetAddress == ETHER) {\r\n            address self = address(this); // workaround for a possible solidity bug\r\n            assetBalance = self.balance;\r\n            require(msg.sender.call.value(assetBalance)(''), 'Transfer failed');\r\n        } else {\r\n            assetBalance = ERC20(_assetAddress).balanceOf(address(this));\r\n            ERC20(_assetAddress).safeTransfer(msg.sender, assetBalance);\r\n        }\r\n        emit LogWithdrawAsset(msg.sender, _assetAddress, assetBalance);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/SNXLinkV1.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SNXLinkV1 is Withdrawable, IFeePool, IDelegateApprovals {\r\n    using SafeMath for uint256;\r\n\r\n    /// Storage\r\n\r\n    // @notice Mapping user max gas price settings\r\n    mapping(address => uint256) public userMaxGasPrices;\r\n    // @notice Mapping user max fee per claim\r\n    mapping(address => uint256) public userMaxFeePerClaim;\r\n    // @notice Mapping user fee wallets\r\n    mapping(address => IMultiSigWalletWithDailyLimit) public userFeeWallets;\r\n    // @notice Mapping user auto-claim activation status\r\n    mapping(address => bool) public userAutoClaimDisabled;\r\n\r\n    // @notice Gnosis Wallet Factory\r\n    IMultiSigWalletWithDailyLimitFactory public userFeeWalletFactory;\r\n    // @notice Synthetix FeePool\r\n    IFeePool public snxFeePool;\r\n    // @notice Synthetix DelegateApprovals\r\n    IDelegateApprovals public snxDelegateApprovals;\r\n\r\n    // @notice Platform fee wallet\r\n    address public feeCollector;\r\n    // @notice Platform fee\r\n    uint256 public platformFee;\r\n    // @notice Claimer fee\r\n    uint256 public claimerFee;\r\n\r\n    // @notice Gas correction offset\r\n    uint256 public gasOffsetCorrection;\r\n\r\n    // @notice Registered users\r\n    address[] public registeredUsers;\r\n\r\n    // @notice Count of total users registered\r\n    uint256 public registeredUsersCount;\r\n\r\n    // @notice Count of total users disabled\r\n    uint256 public disabledUsersCount;\r\n\r\n    // @notice Total fees claimed;\r\n    uint256 public totalFeesClaimed;\r\n\r\n    // @notice Total rewards claimed;\r\n    uint256 public totalRewardsClaimed;\r\n\r\n\r\n    /// Events\r\n\r\n    // @notice Emits when fee sent to the claimer.\r\n    event PayFeeToClaimer(\r\n        address indexed claimer,\r\n        uint256 amount\r\n    );\r\n\r\n    // @notice Emits when fee sent to the platform.\r\n    event PayFeeToPlatform();\r\n\r\n    // @notice Emits when claimer claims on behalf of user.\r\n    event Claim(\r\n        address indexed user,\r\n        address indexed claimer,\r\n        uint256 availableFees,\r\n        uint256 availableRewards\r\n    );\r\n\r\n    // @notice Emits when the user register.\r\n    event Register(address indexed user);\r\n\r\n    // @notice Emits when the user change settings.\r\n    event ChangeSettings(\r\n        address indexed user,\r\n        uint256 maxGasPrice,\r\n        uint256 maxFeePerClaim,\r\n        uint256 enabled\r\n    );\r\n\r\n\r\n    /// Modifiers\r\n\r\n    // @dev Throws if the user does not exists\r\n    modifier onlyRegisteredUser(address user) {\r\n        require(isRegistered(user), 'Auch! User is not registered');\r\n        _;\r\n    }\r\n\r\n    // @dev Throws if the gasPrice is invalid\r\n    modifier validMaxGasPrice(uint256 maxGasPrice) {\r\n        require(maxGasPrice != 0, 'Max Gas Price should be greater than 0');\r\n        _;\r\n    }\r\n\r\n    // @dev Throws if the gasPrice is invalid\r\n    modifier validMaxFeePerClaim(uint256 maxFeePerClaim) {\r\n        require(maxFeePerClaim != 0, 'Max Fee per Claim should be greater than 0');\r\n        _;\r\n    }\r\n\r\n    /// Logic\r\n\r\n    constructor(\r\n        address _userFeeWalletFactory,\r\n        address _snxFeePool,\r\n        address _snxDelegateApprovals,\r\n        address _feeCollector,\r\n        uint256 _platformFee,\r\n        uint256 _claimerFee,\r\n        uint256 _gasOffsetCorrection\r\n    ) public {\r\n        userFeeWalletFactory = IMultiSigWalletWithDailyLimitFactory(_userFeeWalletFactory);\r\n\r\n        snxFeePool = IFeePool(_snxFeePool);\r\n        snxDelegateApprovals = IDelegateApprovals(_snxDelegateApprovals);\r\n\r\n        feeCollector = _feeCollector;\r\n        platformFee = _platformFee;\r\n        claimerFee = _claimerFee;\r\n\r\n        gasOffsetCorrection = _gasOffsetCorrection;\r\n    }\r\n\r\n    function isRegistered(address user) public view returns (bool) {\r\n        return address(userFeeWallets[user]) != address(0);\r\n    }\r\n\r\n    function register(uint256 _maxGasPrice, uint256 _maxFeePerClaim)\r\n        validMaxGasPrice(_maxGasPrice)\r\n        validMaxFeePerClaim(_maxFeePerClaim)\r\n        external payable returns (address) {\r\n        require(!isRegistered(msg.sender), 'User already registered');\r\n\r\n        address[] memory owners = new address[](2);\r\n        owners[0] = msg.sender;\r\n        owners[1] = address(this);\r\n\r\n        address userWallet = userFeeWalletFactory.create(\r\n            owners,\r\n            1,\r\n            0\r\n        );\r\n\r\n        userFeeWallets[msg.sender] = IMultiSigWalletWithDailyLimit(userWallet);\r\n\r\n        require(userWallet.call.value(msg.value)(''), 'Transfer failed');\r\n\r\n        userMaxGasPrices[msg.sender] = _maxGasPrice;\r\n        userMaxFeePerClaim[msg.sender] = _maxFeePerClaim;\r\n\r\n        registeredUsersCount++;\r\n        registeredUsers.push(msg.sender);\r\n        emit Register(msg.sender);\r\n\r\n        return userWallet;\r\n    }\r\n\r\n    function setMaxGasPrice(uint256 _maxGasPrice)\r\n        validMaxGasPrice(_maxGasPrice)\r\n        onlyRegisteredUser(msg.sender)\r\n        external {\r\n        require(userMaxGasPrices[msg.sender] != _maxGasPrice, 'Same setting');\r\n\r\n        userMaxGasPrices[msg.sender] = _maxGasPrice;\r\n        emit ChangeSettings(msg.sender, _maxGasPrice, 0, 0);\r\n    }\r\n\r\n    function setMaxFeePerClaim(uint256 _maxFeePerClaim)\r\n        validMaxFeePerClaim(_maxFeePerClaim)\r\n        onlyRegisteredUser(msg.sender)\r\n        external {\r\n        require(userMaxFeePerClaim[msg.sender] != _maxFeePerClaim, 'Same setting');\r\n\r\n        userMaxFeePerClaim[msg.sender] = _maxFeePerClaim;\r\n        emit ChangeSettings(msg.sender, 0, _maxFeePerClaim, 0);\r\n    }\r\n\r\n    function enable()\r\n        onlyRegisteredUser(msg.sender)\r\n        external {\r\n        require(userAutoClaimDisabled[msg.sender], 'Already enabled');\r\n\r\n        userAutoClaimDisabled[msg.sender] = false;\r\n        disabledUsersCount--;\r\n        emit ChangeSettings(msg.sender, 0, 0, 1);\r\n    }\r\n\r\n    function disable()\r\n        onlyRegisteredUser(msg.sender)\r\n        external {\r\n        require(!userAutoClaimDisabled[msg.sender], 'Already disabled');\r\n\r\n        userAutoClaimDisabled[msg.sender] = true;\r\n        disabledUsersCount++;\r\n        emit ChangeSettings(msg.sender, 0, 0, 2);\r\n    }\r\n\r\n    function applySettings(\r\n        uint256 _maxGasPrice,\r\n        uint256 _maxFeePerClaim,\r\n        bool _enabled\r\n    )   validMaxGasPrice(_maxGasPrice)\r\n        validMaxFeePerClaim(_maxFeePerClaim)\r\n        onlyRegisteredUser(msg.sender)\r\n        external {\r\n\r\n        uint256 maxGasPrice;\r\n        uint256 maxFeePerClaim;\r\n        uint256 enabled;\r\n\r\n        bool changed;\r\n\r\n        if (userMaxGasPrices[msg.sender] != _maxGasPrice) {\r\n            userMaxGasPrices[msg.sender] = _maxGasPrice;\r\n            maxGasPrice = _maxGasPrice;\r\n            changed = true;\r\n        }\r\n\r\n        if (userMaxFeePerClaim[msg.sender] != _maxFeePerClaim) {\r\n            userMaxFeePerClaim[msg.sender] = _maxFeePerClaim;\r\n            maxFeePerClaim = _maxFeePerClaim;\r\n            changed = true;\r\n        }\r\n\r\n        if (userAutoClaimDisabled[msg.sender] == _enabled) {\r\n            if (_enabled) {\r\n                userAutoClaimDisabled[msg.sender] = false;\r\n                disabledUsersCount--;\r\n                enabled = 1;\r\n            } else {\r\n                userAutoClaimDisabled[msg.sender] = true;\r\n                disabledUsersCount++;\r\n                enabled = 2;\r\n            }\r\n\r\n            changed = true;\r\n        }\r\n\r\n        require(changed, 'Nothing changed');\r\n\r\n        emit ChangeSettings(\r\n            msg.sender,\r\n            maxGasPrice,\r\n            maxFeePerClaim,\r\n            enabled\r\n        );\r\n    }\r\n\r\n    function topUp()\r\n        onlyRegisteredUser(msg.sender)\r\n        external payable {\r\n        require(address(userFeeWallets[msg.sender]).call.value(msg.value)(''), 'Transfer failed');\r\n    }\r\n\r\n    function withdraw(uint256 value)\r\n        onlyRegisteredUser(msg.sender)\r\n        nonReentrant\r\n        external {\r\n        IMultiSigWalletWithDailyLimit userFeeWallet = userFeeWallets[msg.sender];\r\n\r\n        uint256 txid = userFeeWallet.submitTransaction(msg.sender, value, '');\r\n\r\n        (,,,bool executed) = userFeeWallet.transactions(txid);\r\n        require(executed, 'Unable to withdraw from user wallet!');\r\n    }\r\n\r\n    function canClaimFor(address authoriser, address /* delegate */)\r\n        external view returns (bool) {\r\n        return snxDelegateApprovals.canClaimFor(authoriser, address (this));\r\n    }\r\n\r\n    function isFeesClaimable(address account)\r\n        public view returns (bool) {\r\n        return snxFeePool.isFeesClaimable(account);\r\n    }\r\n\r\n    function feesAvailable(address account)\r\n        public view returns (uint, uint) {\r\n        return snxFeePool.feesAvailable(account);\r\n    }\r\n\r\n    function canClaim(address user) public view returns (bool) {\r\n        (uint256 availableFees, uint256 availableRewards) = snxFeePool.feesAvailable(user);\r\n\r\n        return\r\n            isRegistered(user) &&\r\n            !userAutoClaimDisabled[user] &&\r\n            (availableFees > 0 && availableRewards > 0) &&\r\n            snxFeePool.isFeesClaimable(user) &&\r\n            snxDelegateApprovals.canClaimFor(user, address(this));\r\n    }\r\n\r\n    function claimOnBehalf(address user)\r\n        nonReentrant\r\n        public returns(bool) {\r\n\r\n        // Start gas counting\r\n        uint256 startGas = gasleft();\r\n\r\n        require(isRegistered(user), 'User is not registered');\r\n\r\n        require(!userAutoClaimDisabled[user], 'User disabled auto-claim');\r\n\r\n        require(tx.gasprice <= userMaxGasPrices[user], 'Gas Price higher than user configured');\r\n\r\n        (uint256 availableFees, uint256 availableRewards) = snxFeePool.feesAvailable(user);\r\n\r\n        require(snxFeePool.claimOnBehalf(user), 'Failed to ClaimOnBehalf');\r\n\r\n        totalFeesClaimed = totalFeesClaimed.add(availableFees);\r\n        totalRewardsClaimed = totalRewardsClaimed.add(availableRewards);\r\n        emit Claim(user, msg.sender, availableFees, availableRewards);\r\n\r\n        uint256 gasUsed = startGas - gasleft();\r\n\r\n        // End gas counting\r\n\r\n        uint256 totalRefundForClaimer =\r\n            ((gasUsed.add(gasOffsetCorrection)).mul(tx.gasprice)).add(claimerFee);\r\n\r\n        uint256 totalToWithdraw = totalRefundForClaimer.add(platformFee);\r\n        require(totalToWithdraw <= userMaxFeePerClaim[user], 'Total cost higher than user configured');\r\n\r\n        IMultiSigWalletWithDailyLimit userFeeWallet = userFeeWallets[user];\r\n        uint256 txid = userFeeWallet.submitTransaction(address(this), totalToWithdraw, '');\r\n\r\n        (,,,bool executed) = userFeeWallet.transactions(txid);\r\n        require(executed, 'Unable to withdraw from user wallet!');\r\n\r\n        require(msg.sender.call.value(totalRefundForClaimer)(''), 'Transfer to claimer failed');\r\n        emit PayFeeToClaimer(msg.sender, totalRefundForClaimer);\r\n\r\n        require(feeCollector.call.value(platformFee)(''), 'Transfer to feeCollector failed');\r\n        emit PayFeeToPlatform();\r\n\r\n        return true;\r\n    }\r\n\r\n    function () payable {}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"withdrawAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"snxFeePool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"feesAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userMaxFeePerClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"authoriser\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"canClaimFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platformFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userMaxGasPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isFeesClaimable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimOnBehalf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"snxDelegateApprovals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userAutoClaimDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRewardsClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registeredUsersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxGasPrice\",\"type\":\"uint256\"},{\"name\":\"_maxFeePerClaim\",\"type\":\"uint256\"},{\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"applySettings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"canClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxFeePerClaim\",\"type\":\"uint256\"}],\"name\":\"setMaxFeePerClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxGasPrice\",\"type\":\"uint256\"}],\"name\":\"setMaxGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFeesClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxGasPrice\",\"type\":\"uint256\"},{\"name\":\"_maxFeePerClaim\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"topUp\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"userFeeWalletFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userFeeWallets\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"disabledUsersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasOffsetCorrection\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_userFeeWalletFactory\",\"type\":\"address\"},{\"name\":\"_snxFeePool\",\"type\":\"address\"},{\"name\":\"_snxDelegateApprovals\",\"type\":\"address\"},{\"name\":\"_feeCollector\",\"type\":\"address\"},{\"name\":\"_platformFee\",\"type\":\"uint256\"},{\"name\":\"_claimerFee\",\"type\":\"uint256\"},{\"name\":\"_gasOffsetCorrection\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayFeeToClaimer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PayFeeToPlatform\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"availableFees\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"availableRewards\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"maxGasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxFeePerClaim\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"enabled\",\"type\":\"uint256\"}],\"name\":\"ChangeSettings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SNXLinkV1","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006e95c8e8557abc08b46f3c347ba06f8dc012763f000000000000000000000000b440dd674e1243644791a4adfe3a2abb0a92d30900000000000000000000000015fd6e554874b9e70f832ed37f231ac5e142362f00000000000000000000000071bff5119a67fc976b4b4ca9ade942e04dccbaac0000000000000000000000000000000000000000000000000001c6bf5263400000000000000000000000000000000000000000000000000000038d7ea4c680000000000000000000000000000000000000000000000000000000000000035b60","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://fcf0701d98e3e9cff557c348b7c3ee366780d0f3ad5454f06e3b04da951bfc40"}]}