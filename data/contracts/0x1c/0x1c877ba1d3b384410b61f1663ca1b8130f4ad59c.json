{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/interface/MarketDepositsInterface.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract MarketDepositsInterface {\r\n    function approve(address _sender, uint256 _value) external;\r\n    function spend(address _depositor, address _to, uint256 _value) external;\r\n    function withdraw(address _to, uint256 _value) external;\r\n}\r\n\r\n// File: contracts/MarketDeposits.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\ncontract MarketDeposits is MarketDepositsInterface {\r\n\r\n    address public token;\r\n    address public poolOwners;\r\n\r\n    mapping(address => mapping(address => uint256)) public approvals;\r\n    mapping(address => uint256) public deposits;\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event Deposit(address indexed depositor, uint256 value);\r\n    event Spend(address indexed depositor, address indexed to, uint256 value);\r\n    event Withdraw(address indexed depositor, address indexed to, uint256 value);\r\n    event Approval(address indexed depositor, address indexed spender, uint256 value);\r\n    event Disapproval(address indexed depositor, address indexed spender, uint256 value);\r\n\r\n    constructor(address _token, address _poolOwners) public {\r\n        token = _token;\r\n        poolOwners = _poolOwners;\r\n    }\r\n\r\n    function onTokenTransfer(address, uint256 _value, bytes _data) external {\r\n        require(msg.sender == address(token), \"Only internal token transfers can execute this method\");\r\n\r\n        address dataSender = _bytesToAddress(_data);\r\n        require(dataSender != address(0), \"Empty depositor address in the token transfer\");\r\n        deposits[dataSender] = deposits[dataSender].add(_value);\r\n\r\n        emit Deposit(dataSender, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) external {\r\n        require(_value != 0, \"Cannot approve zero\");\r\n        require(deposits[msg.sender] >= _value, \"Insufficient balance\");\r\n        approvals[msg.sender][_spender] = approvals[msg.sender][_spender].add(_value);\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    function disapprove(address _spender, uint256 _value) external {\r\n        require(_value != 0, \"Cannot disapprove zero\");\r\n        require(approvals[msg.sender][_spender] >= _value, \"Insufficient approved\");\r\n        approvals[msg.sender][_spender] = approvals[msg.sender][_spender].sub(_value);\r\n\r\n        emit Disapproval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    function spend(address _depositor, address _to, uint256 _value) external {\r\n        require(_value != 0, \"Cannot spend zero\");\r\n        require(approvals[_depositor][msg.sender] >= _value, \"Address isn't an authorised spender\");\r\n        require(deposits[_depositor] >= _value, \"Depositor has an insufficient balance\");\r\n\r\n        approvals[_depositor][msg.sender] = approvals[_depositor][msg.sender].sub(_value);\r\n        deposits[_depositor] = deposits[_depositor].sub(_value);\r\n        if (_to == address(0)) {\r\n            ERC20(token).transfer(poolOwners, _value);\r\n            emit Spend(_depositor, poolOwners, _value);\r\n        } else {\r\n            ERC20(token).transfer(_to, _value);\r\n            emit Spend(_depositor, _to, _value);\r\n        }\r\n    }\r\n\r\n    function withdraw(address _to, uint256 _value) external {\r\n        require(_value != 0, \"Cannot withdraw zero\");\r\n        require(deposits[msg.sender] >= _value, \"Insufficient balance\");\r\n\r\n        deposits[msg.sender] = deposits[msg.sender].sub(_value);\r\n        ERC20(token).transfer(_to, _value);\r\n        emit Withdraw(msg.sender, _to, _value);\r\n    }\r\n\r\n    function _bytesToAddress(bytes bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys,20))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_depositor\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"spend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"disapprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_poolOwners\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Spend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Disapproval\",\"type\":\"event\"}]","ContractName":"MarketDeposits","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca000000000000000000000000182d4990bb0ff595b308b3efcb93313abad575e7","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://ea9001ef61066109278ed2a27930997812aa00010ab582ff50bfef0c92b30c11"}]}