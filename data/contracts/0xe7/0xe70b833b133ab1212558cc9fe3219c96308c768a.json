{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.4;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Eternal Storage for the Reserve Token\r\n *\r\n * @dev Eternal Storage facilitates future upgrades.\r\n *\r\n * If Reserve chooses to release an upgraded contract for the Reserve  in the future, Reserve\r\n * will have the option of reusing the deployed version of this data contract to simplify migration.\r\n *\r\n * The use of this contract does not imply that Reserve will choose to do a future upgrade, nor that\r\n * any future upgrades will necessarily re-use this storage. It merely provides option value.\r\n */\r\ncontract ReserveEternalStorage {\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n\r\n    // ===== auth =====\r\n\r\n    address public owner;\r\n    address public escapeHatch;\r\n\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n    event EscapeHatchTransferred(address indexed oldEscapeHatch, address indexed newEscapeHatch);\r\n\r\n    /// On construction, set auth fields.\r\n    constructor(address escapeHatchAddress) public {\r\n        owner = msg.sender;\r\n        escapeHatch = escapeHatchAddress;\r\n    }\r\n\r\n    /// Only run modified function if sent by `owner`.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"onlyOwner\");\r\n        _;\r\n    }\r\n\r\n    /// Set `owner`.\r\n    function transferOwnership(address newOwner) external {\r\n        require(msg.sender == owner || msg.sender == escapeHatch, \"not authorized\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /// Set `escape hatch`.\r\n    function transferEscapeHatch(address newEscapeHatch) external {\r\n        require(msg.sender == escapeHatch, \"not authorized\");\r\n        emit EscapeHatchTransferred(escapeHatch, newEscapeHatch);\r\n        escapeHatch = newEscapeHatch;\r\n    }\r\n\r\n\r\n\r\n    // ===== balance =====\r\n\r\n    mapping(address => uint256) public balance;\r\n\r\n    /// Add `value` to `balance[key]`, unless this causes integer overflow.\r\n    ///\r\n    /// @dev This is a slight divergence from the strict Eternal Storage pattern, but it reduces the gas\r\n    /// for the by-far most common token usage, it's a *very simple* divergence, and `setBalance` is\r\n    /// available anyway.\r\n    function addBalance(address key, uint256 value) external onlyOwner {\r\n        balance[key] = balance[key].add(value);\r\n    }\r\n\r\n    /// Subtract `value` from `balance[key]`, unless this causes integer underflow.\r\n    function subBalance(address key, uint256 value) external onlyOwner {\r\n        balance[key] = balance[key].sub(value);\r\n    }\r\n\r\n    /// Set `balance[key]` to `value`.\r\n    function setBalance(address key, uint256 value) external onlyOwner {\r\n        balance[key] = value;\r\n    }\r\n\r\n\r\n\r\n    // ===== allowed =====\r\n\r\n    mapping(address => mapping(address => uint256)) public allowed;\r\n\r\n    /// Set `to`'s allowance of `from`'s tokens to `value`.\r\n    function setAllowed(address from, address to, uint256 value) external onlyOwner {\r\n        allowed[from][to] = value;\r\n    }\r\n\r\n\r\n\r\n    // ===== frozenTime =====\r\n\r\n    /// @dev When `frozenTime[addr] == 0`, `addr` is not frozen. This is the normal state.\r\n    /// When `frozenTime[addr] == t` and `t > 0`, `addr` was last frozen at timestamp `t`.\r\n    /// So, to unfreeze an address `addr`, set `frozenTime[addr] = 0`.\r\n    mapping(address => uint256) public frozenTime;\r\n\r\n    /// Set `frozenTime[who]` to `time`.\r\n    function setFrozenTime(address who, uint256 time) external onlyOwner {\r\n        frozenTime[who] = time;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatch\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"addBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newEscapeHatch\",\"type\":\"address\"}],\"name\":\"transferEscapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setFrozenTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"subBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"escapeHatchAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldEscapeHatch\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newEscapeHatch\",\"type\":\"address\"}],\"name\":\"EscapeHatchTransferred\",\"type\":\"event\"}]","ContractName":"ReserveEternalStorage","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"0000000000000000000000004c664c88304156470c05357708253d8d122d88e9","Library":"","LicenseType":"Unlicense","SwarmSource":"bzzr://d6530ad21e43247255ce5c6488a991b7905d2c68bb772d109067b2e0d16ba58b"}]}