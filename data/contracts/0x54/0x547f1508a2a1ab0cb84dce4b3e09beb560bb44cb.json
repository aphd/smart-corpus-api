{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\ninterface CTokenInterface {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); // For ERC20\r\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) external returns (uint);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n    function repayBorrowBehalf(address borrower) external payable;\r\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n}\r\n\r\ninterface TokenInterface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cTokenAddress) external returns (uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n}\r\n\r\ninterface InstaMapping {\r\n    function cTokenMapping(address) external view returns (address);\r\n}\r\n\r\ninterface MemoryInterface {\r\n    function getUint(uint _id) external returns (uint _num);\r\n    function setUint(uint _id, uint _val) external;\r\n}\r\n\r\ninterface EventInterface {\r\n    function emitEvent(uint _connectorType, uint _connectorID, bytes32 _eventCode, bytes calldata _eventData) external;\r\n}\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helpers is DSMath {\r\n    /**\r\n     * @dev Return ethereum address\r\n     */\r\n    function getAddressETH() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return Memory Variable Address\r\n     */\r\n    function getMemoryAddr() internal pure returns (address) {\r\n        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaEvent Address.\r\n     */\r\n    function getEventAddr() internal pure returns (address) {\r\n        return 0x2af7ea6Cb911035f3eb1ED895Cb6692C39ecbA97; // InstaEvent Address\r\n    }\r\n\r\n    /**\r\n     * @dev Get Uint value from InstaMemory Contract.\r\n    */\r\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\r\n        returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\r\n    }\r\n\r\n    /**\r\n     * @dev Set Uint value in InstaMemory Contract.\r\n    */\r\n    function setUint(uint setId, uint val) internal {\r\n        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\r\n    }\r\n\r\n    /**\r\n     * @dev Connector Details\r\n    */\r\n    function connectorID() public pure returns(uint _type, uint _id) {\r\n        (_type, _id) = (1, 3);\r\n    }\r\n}\r\n\r\n\r\ncontract CompoundHelpers is Helpers {\r\n    /**\r\n     * @dev Return Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() internal pure returns (address) {\r\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaDApp Mapping Addresses\r\n     */\r\n    function getMappingAddr() internal pure returns (address) {\r\n        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88; // InstaMapping Address\r\n    }\r\n\r\n    /**\r\n     * @dev enter compound market\r\n     */\r\n    function enterMarket(address cToken) internal {\r\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\r\n        address[] memory markets = troller.getAssetsIn(address(this));\r\n        bool isEntered = false;\r\n        for (uint i = 0; i < markets.length; i++) {\r\n            if (markets[i] == cToken) {\r\n                isEntered = true;\r\n            }\r\n        }\r\n        if (!isEntered) {\r\n            address[] memory toEnter = new address[](1);\r\n            toEnter[0] = cToken;\r\n            troller.enterMarkets(toEnter);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract BasicResolver is CompoundHelpers {\r\n    event LogDeposit(address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogWithdraw(address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogBorrow(address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogPayback(address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n\r\n    /**\r\n     * @dev Deposit ETH/ERC20_Token.\r\n     * @param token token address to deposit.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to deposit.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function deposit(address token, uint amt, uint getId, uint setId) external payable{\r\n        uint _amt = getUint(getId, amt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        enterMarket(cToken);\r\n        if (token == getAddressETH()) {\r\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\r\n            CETHInterface(cToken).mint.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\r\n            tokenContract.approve(cToken, _amt);\r\n            require(CTokenInterface(cToken).mint(_amt) == 0, \"borrow-failed\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogDeposit(token, cToken, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogDeposit(address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(token, cToken, _amt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw ETH/ERC20_Token.\r\n     * @param token token address to withdraw.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to withdraw.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function withdraw(address token, uint amt, uint getId, uint setId) external payable{\r\n        uint _amt = getUint(getId, amt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\r\n        if (_amt == uint(-1)) {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            uint initialBal = token == getAddressETH() ? address(this).balance : tokenContract.balanceOf(address(this));\r\n            require(cTokenContract.redeem(cTokenContract.balanceOf(address(this))) == 0, \"full-withdraw-failed\");\r\n            uint finalBal = token == getAddressETH() ? address(this).balance : tokenContract.balanceOf(address(this));\r\n            _amt = finalBal - initialBal;\r\n        } else {\r\n            require(cTokenContract.redeemUnderlying(_amt) == 0, \"withdraw-failed\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogWithdraw(token, cToken, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogWithdraw(address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(token, cToken, _amt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Borrow ETH/ERC20_Token.\r\n     * @param token token address to borrow.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to borrow.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function borrow(address token, uint amt, uint getId, uint setId) external payable {\r\n        uint _amt = getUint(getId, amt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        enterMarket(cToken);\r\n        require(CTokenInterface(cToken).borrow(_amt) == 0, \"borrow-failed\");\r\n        setUint(setId, _amt);\r\n\r\n        emit LogBorrow(token, cToken, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogBorrow(address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(token, cToken, _amt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Payback borrowed ETH/ERC20_Token.\r\n     * @param token token address to payback.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to payback.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function payback(address token, uint amt, uint getId, uint setId) external payable {\r\n        uint _amt = getUint(getId, amt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\r\n        _amt = _amt == uint(-1) ? cTokenContract.borrowBalanceCurrent(address(this)) : _amt;\r\n\r\n        if (token == getAddressETH()) {\r\n            require(address(this).balance >= _amt, \"not-enough-eth\");\r\n            CETHInterface(cToken).repayBorrow.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            require(tokenContract.balanceOf(address(this)) >= _amt, \"not-enough-token\");\r\n            tokenContract.approve(cToken, _amt);\r\n            require(cTokenContract.repayBorrow(_amt) == 0, \"repay-failed.\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogPayback(token, cToken, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogPayback(address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(token, cToken, _amt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n}\r\n\r\ncontract ExtraResolver is BasicResolver {\r\n    event LogPaybackBehalf(address indexed borrower, address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogDepositCToken(address indexed token, address cToken, uint256 tokenAmt, uint256 cTokenAmt,uint256 getId, uint256 setId);\r\n    event LogWithdrawCToken(address indexed token, address cToken, uint256 cTokenAmt, uint256 getId, uint256 setId);\r\n    event LogLiquidate(\r\n        address indexed borrower,\r\n        address indexed tokenToPay,\r\n        address indexed tokenInReturn,\r\n        uint256 tokenAmt,\r\n        uint256 getId,\r\n        uint256 setId\r\n    );\r\n\r\n    /**\r\n     * @dev Deposit ETH/ERC20_Token.\r\n     * @param token token address to depositCToken.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to depositCToken.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set ctoken amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function depositCToken(address token, uint amt, uint getId, uint setId) external payable{\r\n        uint _amt = getUint(getId, amt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        enterMarket(cToken);\r\n\r\n        CTokenInterface ctokenContract = CTokenInterface(cToken);\r\n        uint initialBal = ctokenContract.balanceOf(address(this));\r\n\r\n        if (token == getAddressETH()) {\r\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\r\n            CETHInterface(cToken).mint.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\r\n            tokenContract.approve(cToken, _amt);\r\n            require(ctokenContract.mint(_amt) == 0, \"deposit-ctoken-failed.\");\r\n        }\r\n\r\n        uint finalBal = ctokenContract.balanceOf(address(this));\r\n        uint _cAmt = finalBal - initialBal;\r\n        setUint(setId, _cAmt);\r\n\r\n        emit LogDepositCToken(token, cToken, _amt, _cAmt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogDepositCToken(address,address,uint256,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(token, cToken, _amt, _cAmt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw CETH/CERC20_Token using cToken Amt.\r\n     * @param token token address to withdraw CToken.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param cTokenAmt ctoken amount to withdrawCToken.\r\n     * @param getId Get ctoken amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set ctoken amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function withdrawCToken(address token, uint cTokenAmt, uint getId, uint setId) external payable {\r\n        uint _amt = getUint(getId, cTokenAmt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\r\n        _amt = _amt == uint(-1) ? cTokenContract.balanceOf(address(this)) : _amt;\r\n        require(cTokenContract.redeem(_amt) == 0, \"redeem-failed\");\r\n        setUint(setId, _amt);\r\n\r\n        emit LogWithdrawCToken(token, cToken, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogWithdrawCToken(address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(token, cToken, _amt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Payback on Behalf of user's borrowed ETH/ERC20_Token.\r\n     * @param borrower Borrower's Address.\r\n     * @param token token address to payback.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to payback.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function paybackBehalf(\r\n        address borrower,\r\n        address token,\r\n        uint amt,\r\n        uint getId,\r\n        uint setId\r\n    ) external payable\r\n    {\r\n        uint _amt = getUint(getId, amt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\r\n        uint borrows = cTokenContract.borrowBalanceCurrent(borrower);\r\n        _amt = _amt == uint(-1) ? borrows : _amt;\r\n        if (token == getAddressETH()) {\r\n            require(address(this).balance >= _amt, \"not-enough-eth\");\r\n            CETHInterface(cToken).repayBorrowBehalf.value(_amt)(borrower);\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            require(tokenContract.balanceOf(address(this)) >= _amt, \"Not-enough-token\");\r\n            tokenContract.approve(cToken, _amt);\r\n            require(cTokenContract.repayBorrowBehalf(borrower, _amt) == 0, \"repay-failed\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogPaybackBehalf(address(this), token, cToken, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogPaybackBehalf(address,address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(address(this), token, cToken, _amt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Liquidate a position.\r\n     * @param borrower Borrower's Address.\r\n     * @param tokenToPay token address to pay for liquidation.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param tokenInReturn token address to return for liquidation.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to pay for liquidation.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function liquidate(\r\n        address borrower,\r\n        address tokenToPay,\r\n        address tokenInReturn,\r\n        uint amt,\r\n        uint getId,\r\n        uint setId\r\n    ) external payable\r\n    {\r\n        uint _amt = getUint(getId, amt);\r\n        address cTokenPay = InstaMapping(getMappingAddr()).cTokenMapping(tokenToPay);\r\n        address cTokenColl = InstaMapping(getMappingAddr()).cTokenMapping(tokenInReturn);\r\n        CTokenInterface cTokenContract = CTokenInterface(cTokenPay);\r\n\r\n        (,, uint shortfal) = ComptrollerInterface(getComptrollerAddress()).getAccountLiquidity(borrower);\r\n        require(shortfal != 0, \"account-cannot-be-liquidated\");\r\n\r\n        _amt = _amt == uint(-1) ? cTokenContract.borrowBalanceCurrent(borrower) : _amt;\r\n        if (tokenToPay == getAddressETH()) {\r\n            require(address(this).balance >= _amt, \"not-enought-eth\");\r\n            CETHInterface(cTokenPay).liquidateBorrow.value(_amt)(borrower, cTokenColl);\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(tokenToPay);\r\n            require(tokenContract.balanceOf(address(this)) >= _amt, \"not-enough-token\");\r\n            tokenContract.approve(cTokenPay, _amt);\r\n            require(cTokenContract.liquidateBorrow(borrower, _amt, cTokenColl) == 0, \"liquidate-failed\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogLiquidate(\r\n            address(this),\r\n            tokenToPay,\r\n            tokenInReturn,\r\n            _amt,\r\n            getId,\r\n            setId\r\n        );\r\n        bytes32 _eventCode = keccak256(\"LogLiquidate(address,address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(\r\n            address(this),\r\n            tokenToPay,\r\n            tokenInReturn,\r\n            _amt,\r\n            getId,\r\n            setId\r\n        );\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n\r\n    }\r\n}\r\n\r\n\r\ncontract ConnectCompound is ExtraResolver {\r\n    string public name = \"Compound-v1\";\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cTokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogDepositCToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenToPay\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenInReturn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogLiquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogPayback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogPaybackBehalf\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cTokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawCToken\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectorID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"depositCToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenToPay\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenInReturn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"liquidate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"payback\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"paybackBehalf\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cTokenAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"withdrawCToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"ConnectCompound","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"ipfs://738b01d3a9404928d7427ab90c609e03ed33b1831409cbed6038d4124457105a"}]}