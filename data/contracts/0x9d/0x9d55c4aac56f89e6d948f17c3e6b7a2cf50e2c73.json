{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *  @authors: [@mtsalenc]\r\n *  @reviewers: []\r\n *  @auditors: []\r\n *  @bounties: []\r\n *  @deployments: []\r\n */\r\n \r\n \r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\ncontract AddressListInterface {\r\n    \r\n    enum AddressStatus {\r\n        Absent, // The address is not in the registry.\r\n        Registered, // The address is in the registry.\r\n        RegistrationRequested, // The address has a request to be added to the registry.\r\n        ClearingRequested // The address has a request to be removed from the registry.\r\n    }\r\n    \r\n    enum Party {\r\n        None,      // Party per default when there is no challenger or requester. Also used for unconclusive ruling.\r\n        Requester, // Party that made the request to change an address status.\r\n        Challenger // Party that challenges the request to change an address status.\r\n    }\r\n    \r\n    struct Address {\r\n        AddressStatus status; // The status of the address.\r\n        Request[] requests; // List of status change requests made for the address.\r\n    }\r\n    \r\n    struct Request {\r\n        bool disputed; // True if a dispute was raised.\r\n        uint disputeID; // ID of the dispute, if any.\r\n        uint submissionTime; // Time when the request was made. Used to track when the challenge period ends.\r\n        bool resolved; // True if the request was executed and/or any disputes raised were resolved.\r\n        address[3] parties; // Address of requester and challenger, if any.\r\n        Round[] rounds; // Tracks each round of a dispute.\r\n        Party ruling; // The final ruling given, if any.\r\n        address arbitrator; // The arbitrator trusted to solve disputes for this request.\r\n        bytes arbitratorExtraData; // The extra data for the trusted arbitrator of this request.\r\n    }\r\n    \r\n    struct Round {\r\n        uint[3] paidFees; // Tracks the fees paid by each side on this round.\r\n        bool[3] hasPaid; // True when the side has fully paid its fee. False otherwise.\r\n        uint feeRewards; // Sum of reimbursable fees and stake rewards available to the parties that made contributions to the side that ultimately wins a dispute.\r\n        mapping(address => uint[3]) contributions; // Maps contributors to their contributions for each side.\r\n    }\r\n    \r\n    /** @dev Return the values of the addresses the query finds. This function is O(n), where n is the number of addresses. This could exceed the gas limit, therefore this function should only be used for interface display and not by other contracts.\r\n     *  @param _cursor The address from which to start iterating. To start from either the oldest or newest item.\r\n     *  @param _count The number of addresses to return.\r\n     *  @param _filter The filter to use. Each element of the array in sequence means:\r\n     *  - Include absent addresses in result.\r\n     *  - Include registered addresses in result.\r\n     *  - Include addresses with registration requests that are not disputed in result.\r\n     *  - Include addresses with clearing requests that are not disputed in result.\r\n     *  - Include disputed addresses with registration requests in result.\r\n     *  - Include disputed addresses with clearing requests in result.\r\n     *  - Include addresses submitted by the caller.\r\n     *  - Include addresses challenged by the caller.\r\n     *  @param _oldestFirst Whether to sort from oldest to the newest item.\r\n     *  @return The values of the addresses found and whether there are more addresses for the current filter and sort.\r\n     */\r\n    function queryAddresses(address _cursor, uint _count, bool[8] calldata _filter, bool _oldestFirst) external view returns (address[] memory values, bool hasMore);\r\n    \r\n    /** @dev Return the numbers of addresses that were submitted. Includes addresses that never made it to the list or were later removed.\r\n     *  @return count The numbers of addresses in the list.\r\n     */\r\n    function addressCount() external view returns (uint count);\r\n    \r\n    /** @dev Get the address at a given position of the addresses array.\r\n     *  @param _index The position of the address to fetch.\r\n     *  @return The address.\r\n     */\r\n    function addressList(uint _index) external view returns (address);\r\n    \r\n    /** @dev Returns address information. Includes length of requests array.\r\n     *  @param _address The queried address.\r\n     *  @return The address information.\r\n     */\r\n    function getAddressInfo(address _address)\r\n        external\r\n        view\r\n        returns (\r\n            AddressStatus status,\r\n            uint numberOfRequests\r\n        );\r\n    \r\n    /** @dev Gets information on a request made for an address.\r\n     *  @param _address The queried address.\r\n     *  @param _request The request to be queried.\r\n     *  @return The request information.\r\n     */\r\n    function getRequestInfo(address _address, uint _request)\r\n        external\r\n        view\r\n        returns (\r\n            bool disputed,\r\n            uint disputeID,\r\n            uint submissionTime,\r\n            bool resolved,\r\n            address[3] memory parties,\r\n            uint numberOfRounds,\r\n            Party ruling,\r\n            address arbitrator,\r\n            bytes memory arbitratorExtraData\r\n        );\r\n}\r\n\r\n/** @title AddressCount\r\n *  Utility view contract for AddressListInterface\r\n */\r\ncontract AddressCount {\r\n    \r\n    /** @dev Return the number of items in the address TCR for the provided filter.\r\n     *  @param _tcr The address of the TCR to query.\r\n     *  @param _cursor The address from where to start counting, or zero to start from the beggining.\r\n     *  @param _filter The filter to use. Each element of the array in sequence means:\r\n     *  - Include absent addresses in result.\r\n     *  - Include registered addresses in result.\r\n     *  - Include addresses with registration requests that are not disputed in result.\r\n     *  - Include addresses with clearing requests that are not disputed in result.\r\n     *  - Include disputed addresses with registration requests in result.\r\n     *  - Include disputed addresses with clearing requests in result.\r\n     *  - Include addresses submitted by the caller.\r\n     *  - Include addresses challenged by the caller.\r\n     *  @param _count The number of addresses to search.\r\n     */\r\n    function countByStatus(address _tcr, address _cursor, bool[8] calldata _filter, uint _count) external view returns (uint count, bool hasMore, address lastAddress) {\r\n        uint cursorIndex;\r\n        uint index = 0;\r\n        bool oldestFirst = true;\r\n        AddressListInterface addressTCR = AddressListInterface(_tcr);\r\n        uint addressListLength = addressTCR.addressCount();\r\n\r\n        if (_cursor == 0x0000000000000000000000000000000000000000)\r\n            cursorIndex = 0;\r\n        else {\r\n            for (uint j = 0; j < addressTCR.addressCount(); j++) {\r\n                if (addressTCR.addressList(j) == _cursor) {\r\n                    cursorIndex = j;\r\n                    break;\r\n                }\r\n            }\r\n            require(cursorIndex != 0, \"The cursor is invalid.\");\r\n        }\r\n\r\n        for (\r\n                uint i = cursorIndex == 0 ? (oldestFirst ? 0 : 1) : (oldestFirst ? cursorIndex + 1 : addressListLength - cursorIndex + 1);\r\n                oldestFirst ? i < addressListLength : i <= addressListLength;\r\n                i++\r\n            ) { // Oldest or newest first.\r\n            address addr = addressTCR.addressList(oldestFirst ? i : addressListLength - i);\r\n            (AddressListInterface.AddressStatus status, uint numberOfRequests) = addressTCR.getAddressInfo(addr);\r\n            (bool disputed,,,,,,,,) = addressTCR.getRequestInfo(addr, numberOfRequests-1);\r\n            if (\r\n                /* solium-disable operator-whitespace */\r\n                (_filter[0] && status == AddressListInterface.AddressStatus.Absent) ||\r\n                (_filter[1] && status == AddressListInterface.AddressStatus.Registered) ||\r\n                (_filter[2] && status == AddressListInterface.AddressStatus.RegistrationRequested && !disputed) ||\r\n                (_filter[3] && status == AddressListInterface.AddressStatus.ClearingRequested && !disputed) ||\r\n                (_filter[4] && status == AddressListInterface.AddressStatus.RegistrationRequested && disputed) ||\r\n                (_filter[5] && status == AddressListInterface.AddressStatus.ClearingRequested && disputed)\r\n                /* solium-enable operator-whitespace */\r\n            ) {\r\n                if (index < _count) {\r\n                    count++;\r\n                    index++;\r\n                } else {\r\n                    hasMore = true;\r\n                    lastAddress = addressTCR.addressList(oldestFirst ? i : addressListLength - i);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_tcr\",\"type\":\"address\"},{\"name\":\"_cursor\",\"type\":\"address\"},{\"name\":\"_filter\",\"type\":\"bool[8]\"},{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"countByStatus\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"hasMore\",\"type\":\"bool\"},{\"name\":\"lastAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AddressCount","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://f60d53042c273557ac9cd1175f64523eaa9fabd92eeb818e5b9068766cd409ec"}]}