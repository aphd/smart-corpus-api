{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n\r\n// @title SafeMath: overflow/underflow checks\r\n// @notice Math operations with safety checks that throw on error\r\nlibrary SafeMath {\r\n\r\n  // @notice Multiplies two numbers, throws on overflow.\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  // @notice Integer division of two numbers, truncating the quotient.\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  // @notice Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  // @notice Adds two numbers, throws on overflow.\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  // @notice Returns fractional amount\r\n  function getFractionalAmount(uint256 _amount, uint256 _percentage)\r\n  internal\r\n  pure\r\n  returns (uint256) {\r\n    return div(mul(_amount, _percentage), 100);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/DBInterface.sol\r\n\r\n// Database interface\r\ninterface DBInterface {\r\n\r\n  function setContractManager(address _contractManager)\r\n  external;\r\n\r\n    // --------------------Set Functions------------------------\r\n\r\n    function setAddress(bytes32 _key, address _value)\r\n    external;\r\n\r\n    function setUint(bytes32 _key, uint _value)\r\n    external;\r\n\r\n    function setString(bytes32 _key, string _value)\r\n    external;\r\n\r\n    function setBytes(bytes32 _key, bytes _value)\r\n    external;\r\n\r\n    function setBytes32(bytes32 _key, bytes32 _value)\r\n    external;\r\n\r\n    function setBool(bytes32 _key, bool _value)\r\n    external;\r\n\r\n    function setInt(bytes32 _key, int _value)\r\n    external;\r\n\r\n\r\n     // -------------- Deletion Functions ------------------\r\n\r\n    function deleteAddress(bytes32 _key)\r\n    external;\r\n\r\n    function deleteUint(bytes32 _key)\r\n    external;\r\n\r\n    function deleteString(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBytes(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBytes32(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBool(bytes32 _key)\r\n    external;\r\n\r\n    function deleteInt(bytes32 _key)\r\n    external;\r\n\r\n    // ----------------Variable Getters---------------------\r\n\r\n    function uintStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (uint);\r\n\r\n    function stringStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (string);\r\n\r\n    function addressStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n    function bytesStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bytes);\r\n\r\n    function bytes32Storage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bytes32);\r\n\r\n    function boolStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n    function intStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n// File: contracts/database/Events.sol\r\n\r\ncontract Events {\r\n  DBInterface public database;\r\n\r\n  constructor(address _database) public{\r\n    database = DBInterface(_database);\r\n  }\r\n\r\n  function message(string _message)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogEvent(_message, keccak256(abi.encodePacked(_message)), tx.origin);\r\n  }\r\n\r\n  function transaction(string _message, address _from, address _to, uint _amount, address _token)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogTransaction(_message, keccak256(abi.encodePacked(_message)), _from, _to, _amount, _token, tx.origin);\r\n  }\r\n\r\n  function registration(string _message, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogAddress(_message, keccak256(abi.encodePacked(_message)), _account, tx.origin);\r\n  }\r\n\r\n  function contractChange(string _message, address _account, string _name)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogContractChange(_message, keccak256(abi.encodePacked(_message)), _account, _name, tx.origin);\r\n  }\r\n\r\n  function asset(string _message, string _uri, address _assetAddress, address _manager)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogAsset(_message, keccak256(abi.encodePacked(_message)), _uri, keccak256(abi.encodePacked(_uri)), _assetAddress, _manager, tx.origin);\r\n  }\r\n\r\n  function escrow(string _message, address _assetAddress, bytes32 _escrowID, address _manager, uint _amount)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogEscrow(_message, keccak256(abi.encodePacked(_message)), _assetAddress, _escrowID, _manager, _amount, tx.origin);\r\n  }\r\n\r\n  function order(string _message, bytes32 _orderID, uint _amount, uint _price)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogOrder(_message, keccak256(abi.encodePacked(_message)), _orderID, _amount, _price, tx.origin);\r\n  }\r\n\r\n  function exchange(string _message, bytes32 _orderID, address _assetAddress, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogExchange(_message, keccak256(abi.encodePacked(_message)), _orderID, _assetAddress, _account, tx.origin);\r\n  }\r\n\r\n  function operator(string _message, bytes32 _id, string _name, string _ipfs, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogOperator(_message, keccak256(abi.encodePacked(_message)), _id, _name, _ipfs, _account, tx.origin);\r\n  }\r\n\r\n  function consensus(string _message, bytes32 _executionID, bytes32 _votesID, uint _votes, uint _tokens, uint _quorum)\r\n  external\r\n  onlyApprovedContract {\r\n    emit LogConsensus(_message, keccak256(abi.encodePacked(_message)), _executionID, _votesID, _votes, _tokens, _quorum, tx.origin);\r\n  }\r\n\r\n  //Generalized events\r\n  event LogEvent(string message, bytes32 indexed messageID, address indexed origin);\r\n  event LogTransaction(string message, bytes32 indexed messageID, address indexed from, address indexed to, uint amount, address token, address origin); //amount and token will be empty on some events\r\n  event LogAddress(string message, bytes32 indexed messageID, address indexed account, address indexed origin);\r\n  event LogContractChange(string message, bytes32 indexed messageID, address indexed account, string name, address indexed origin);\r\n  event LogAsset(string message, bytes32 indexed messageID, string uri, bytes32 indexed assetID, address asset, address manager, address indexed origin);\r\n  event LogEscrow(string message, bytes32 indexed messageID, address asset, bytes32  escrowID, address indexed manager, uint amount, address indexed origin);\r\n  event LogOrder(string message, bytes32 indexed messageID, bytes32 indexed orderID, uint amount, uint price, address indexed origin);\r\n  event LogExchange(string message, bytes32 indexed messageID, bytes32 orderID, address indexed asset, address account, address indexed origin);\r\n  event LogOperator(string message, bytes32 indexed messageID, bytes32 id, string name, string ipfs, address indexed account, address indexed origin);\r\n  event LogConsensus(string message, bytes32 indexed messageID, bytes32 executionID, bytes32 votesID, uint votes, uint tokens, uint quorum, address indexed origin);\r\n\r\n\r\n  // --------------------------------------------------------------------------------------\r\n  // Caller must be registered as a contract through ContractManager.sol\r\n  // --------------------------------------------------------------------------------------\r\n  modifier onlyApprovedContract() {\r\n      require(database.boolStorage(keccak256(abi.encodePacked(\"contract\", msg.sender))));\r\n      _;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/PullPayment.sol\r\n\r\n// @notice allows contract to call a basic withdraw() function taking no parameters on another contract\r\ninterface PullPayment {\r\n\r\n\tfunction withdraw()\texternal returns(bool);\r\n\r\n}\r\n\r\n// File: contracts/tokens/distribution/StandardDistribution.sol\r\n\r\n// @title Non-Transferable ERC20 token contract with shared revenue distribution functionality.\r\n// @notice This token contract can receive payments in the fallback function and token owners can withdraw their share\r\n// @author Kyle Dewhurst, MyBitFoundation\r\n// Credit goes to Nick Johnson for the dividend token https://medium.com/@weka/dividend-bearing-tokens-on-ethereum-42d01c710657\r\ncontract StandardDistribution{\r\n  using SafeMath for uint;\r\n\r\n\r\n  uint public supply;\r\n  mapping (address => uint) internal balances;\r\n\r\n  string public tokenURI;                 // A reference to a URI containing further token information\r\n\r\n\r\n  // @notice Token Income Information\r\n  uint constant scalingFactor = 1e32;\r\n  uint public assetIncome;\r\n  uint public valuePerToken;\r\n\r\n  mapping (address => uint) public claimableIncome;\r\n  mapping (address => uint) public previousValuePerToken;\r\n\r\n\r\n  // @notice Updates claimableIncome, sends all wei to the token holder\r\n  function withdraw()\r\n  public\r\n  updateclaimableIncome(msg.sender)\r\n  returns (uint _amount) {\r\n      _amount = claimableIncome[msg.sender].div(scalingFactor);\r\n      delete claimableIncome[msg.sender];\r\n      msg.sender.transfer(_amount);\r\n      emit LogIncomeCollected(now, msg.sender, _amount);\r\n  }\r\n/*\r\n  // @notice allows beneficiaries to withdraw from contracts at different locations to be re-distributed here\r\n  // @dev can call withdraw() on any address if there are no parameters required. Fallback function will be triggered\r\n  // @param (address) _contractAddress = The address to call withdraw() on.\r\n  function getFunds(address _contractAddress)\r\n  external\r\n  returns (bool) {\r\n    PullPayment(_contractAddress).withdraw();\r\n    return true;\r\n  }\r\n\r\n*/\r\n  function issueDividends()\r\n  payable\r\n  public {\r\n      valuePerToken = valuePerToken.add(msg.value.mul(scalingFactor).div(supply));\r\n      assetIncome = assetIncome.add(msg.value);\r\n      emit LogIncomeReceived(msg.sender, msg.value);\r\n  }\r\n\r\n    // Fallback function: Accepts Ether and updates ledger (issues dividends)\r\n  function ()\r\n    payable\r\n    public {\r\n      valuePerToken = valuePerToken.add(msg.value.mul(scalingFactor).div(supply));\r\n      assetIncome = assetIncome.add(msg.value);\r\n      emit LogIncomeReceived(msg.sender, msg.value);\r\n  }\r\n\r\n  // ------------------------------------------------------------------------------------------------\r\n  //                                   View Functions\r\n  // ------------------------------------------------------------------------------------------------\r\n\r\n  // @notice Calculates how much value _user holds\r\n  function getTokenValue(address _user)\r\n  public\r\n  view\r\n  returns (uint) {\r\n      uint valuePerTokenDifference = valuePerToken.sub(previousValuePerToken[_user]);\r\n      return valuePerTokenDifference.mul(balances[_user]);\r\n  }\r\n\r\n  // @notice Calculates how much wei user is owed. (new income + claimableIncome) / 10**32\r\n  function getUnclaimedAmount(address _user)\r\n  public\r\n  view\r\n  returns (uint) {\r\n      return (getTokenValue(_user).add(claimableIncome[_user]).div(scalingFactor));\r\n  }\r\n\r\n  function totalSupply() public view returns (uint256) {\r\n    return supply;\r\n  }\r\n\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  // ------------------------------------------------------------------------------------------------\r\n  //                                   Modifiers\r\n  // ------------------------------------------------------------------------------------------------\r\n\r\n  // Updates the amount owed to user while holding tokenSupply\r\n  // @dev must be called before transfering tokens\r\n  modifier updateclaimableIncome(address _user) {\r\n      claimableIncome[_user] = claimableIncome[_user].add(getTokenValue(_user));\r\n      previousValuePerToken[_user] = valuePerToken;\r\n      _;\r\n  }\r\n\r\n\r\n  // ------------------------------------------------------------------------------------------------\r\n  //                                     Events\r\n  // ------------------------------------------------------------------------------------------------\r\n\r\n  event LogIncomeReceived(address indexed _sender, uint _paymentAmount);\r\n  event LogIncomeCollected(uint _block, address _address, uint _amount);\r\n\r\n}\r\n\r\n// File: contracts/tokens/distribution/FixedDistribution.sol\r\n\r\n// @title Non-Transferable ERC20 token contract with shared revenue distribution functionality.\r\n// @notice This token contract can receive payments in the fallback function and token owners can withdraw their share\r\n// @author Kyle Dewhurst, MyBit Foundation\r\n// Credit goes to Nick Johnson for the dividend token https://medium.com/@weka/dividend-bearing-tokens-on-ethereum-42d01c710657\r\ncontract FixedDistribution is StandardDistribution {\r\n  using SafeMath for uint;\r\n\r\n  // @notice constructor: initialized\r\n  constructor(string _tokenURI, address[] _tokenHolders, uint[] _amount)\r\n  public {\r\n    require(_tokenHolders.length < 200 && _tokenHolders.length == _amount.length);\r\n    uint _totalSupply;\r\n    tokenURI = _tokenURI;\r\n    for (uint8 i = 0; i < _tokenHolders.length; i++) {\r\n      _totalSupply = _totalSupply.add(_amount[i]);\r\n      balances[_tokenHolders[i]] = balances[_tokenHolders[i]].add(_amount[i]);\r\n    }\r\n    supply = _totalSupply;\r\n  }\r\n}\r\n\r\n// File: contracts/interfaces/MinterInterface.sol\r\n\r\ninterface MinterInterface {\r\n  function cloneToken(string _uri, address _erc20Address) external returns (address asset);\r\n\r\n  function mintAssetTokens(address _assetAddress, address _receiver, uint256 _amount) external returns (bool);\r\n\r\n  function changeTokenController(address _assetAddress, address _newController) external returns (bool);\r\n}\r\n\r\n// File: contracts/ecosystem/AssetGenerator.sol\r\n\r\n// import \"../access/ERC20Burner.sol\";\r\n\r\n\r\n\r\n// @title An asset generator contract for onboarding existing real-world assets\r\n// @notice This contract creates ERC20 dividend tokens and give sthem to the _tokenHolders provided\r\n// @author Kyle Dewhurst, MyBit Foundation\r\ncontract AssetGenerator {\r\n  using SafeMath for uint256;\r\n\r\n  DBInterface private database;\r\n  Events private events;\r\n  MinterInterface private minter;\r\n\r\n\r\n  // @notice This contract\r\n  // @param: The address for the database contract used by this platform\r\n  constructor(address _database, address _events)\r\n  public{\r\n      database = DBInterface(_database);\r\n      events = Events(_events);\r\n      minter = MinterInterface(database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"Minter\"))));\r\n  }\r\n\r\n\r\n  // @notice users can on-board non-tradeable assets here\r\n  // @dev creates an ERC20 dividend token (tradeable) or distribution token (not-tradeable)\r\n  function createAsset(string _tokenURI, address[] _tokenHolders, uint[] _amount)\r\n  external\r\n  // burnRequired\r\n  returns (bool) {\r\n    require (_tokenHolders.length == _amount.length && _tokenHolders.length <= 100);\r\n    FixedDistribution assetInstance = new FixedDistribution(_tokenURI, _tokenHolders, _amount);\r\n    database.setAddress(keccak256(abi.encodePacked(\"asset.manager\", address(assetInstance))), msg.sender);\r\n    events.asset('Asset created', _tokenURI, address(assetInstance), msg.sender);\r\n    return true;\r\n  }\r\n\r\n  // @notice users can on-board tradeable assets here\r\n  // @dev creates an ERC20 dividend token (tradeable) or\r\n  function createTradeableAsset(string _tokenURI, address[] _tokenHolders, uint[] _amount)\r\n  external\r\n  // burnRequired\r\n  returns (bool) {\r\n    require (_tokenHolders.length == _amount.length && _tokenHolders.length <= uint8(100));\r\n    address assetAddress = minter.cloneToken(_tokenURI, address(0));\r\n    for (uint8 i = 0; i < _tokenHolders.length; i++) {\r\n      minter.mintAssetTokens(assetAddress, _tokenHolders[i], _amount[i]);\r\n    }\r\n    database.setAddress(keccak256(abi.encodePacked(\"asset.manager\", assetAddress)), msg.sender);\r\n    events.asset('Asset created', _tokenURI, assetAddress, msg.sender);\r\n    return true;\r\n  }\r\n\r\n  // @notice platform owners can destroy contract here\r\n  function destroy()\r\n  onlyOwner\r\n  external {\r\n    events.transaction('AssetGenerator destroyed', address(this), msg.sender, address(this).balance, address(0));\r\n    selfdestruct(msg.sender);\r\n  }\r\n\r\n  // @notice reverts if user hasn't approved burner to burn platform token\r\n  // modifier burnRequired {\r\n  //   ERC20Burner burner = ERC20Burner(database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"ERC20Burner\"))));\r\n  //   require(burner.burn(msg.sender, database.uintStorage(keccak256(abi.encodePacked(msg.sig, address(this))))));\r\n  //   _;\r\n  // }\r\n\r\n  // @notice Sender must be a registered owner\r\n  modifier onlyOwner {\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\"owner\", msg.sender))), \"Not owner\");\r\n    _;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenURI\",\"type\":\"string\"},{\"name\":\"_tokenHolders\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"createTradeableAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenURI\",\"type\":\"string\"},{\"name\":\"_tokenHolders\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"createAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_database\",\"type\":\"address\"},{\"name\":\"_events\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"AssetGenerator","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005fcebeb70b88e86dd880352684e775b0f4d57c71000000000000000000000000eb6533f29a54c2c18bb2ce2a100de717692a518f","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://f7345af1c4de06d240ebbbfdf22a3792adbc05f2bc48a286e38b115b8e19622b"}]}