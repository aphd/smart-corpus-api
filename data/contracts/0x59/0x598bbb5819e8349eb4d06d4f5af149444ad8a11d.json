{"status":"1","message":"OK-Missing/Invalid API Key, rate limit of 1/3sec applied","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/* This is the Revolution smart contract from the culottes project.\r\nIts copyrights (2019) belong to its authors including Jean Millerat (siggg at akasig dot org).\r\nIt is distributed under the GNU Affero General Public License version 3 or later (AGPL v.3 or later). You can find a copy of this license with the full source code of this project at\r\nhttps://github.com/siggg/culottes\r\n*/\r\n\r\ncontract RevolutionFactory {\r\n\r\n  address public owner = msg.sender;\r\n\r\n  string [] public hashtags;\r\n\r\n  mapping(string => Revolution) revolutions;\r\n\r\n\r\n  function createRevolution(string memory _criteria, string memory _hashtag, uint _distributionBlockPeriod, uint _distributionAmount, bool _testingMode) public {\r\n    // check that we don't already have a revolution with this hashtag\r\n    if (address(revolutions[_hashtag]) == address(0)) {\r\n      revolutions[_hashtag] = new Revolution(msg.sender, _criteria, _hashtag, _distributionBlockPeriod, _distributionAmount, _testingMode);\r\n      hashtags.push(_hashtag);\r\n    }\r\n  }\r\n\r\n\r\n  function getRevolution(string memory _hashtag) public view returns (Revolution) {\r\n    return revolutions[_hashtag];\r\n  }\r\n\r\n\r\n  function lockRevolution(string memory _hashtag) public {\r\n    // will irreversibly lock a Revolution given by its hashtag\r\n\r\n    // only factory contract owner can make it lock a revolution\r\n    require(msg.sender == owner);\r\n    revolutions[_hashtag].lock();\r\n  }\r\n}\r\n\r\n\r\ncontract Revolution {\r\n\r\n  address public owner;\r\n  address public factory;\r\n  \r\n  // Criteria the citizen should match to win votes\r\n  // e.g. : \"a sans-culotte\"\r\n  string public criteria;\r\n  \r\n  // Hashtag to be used for discussing this contract\r\n  // e.g. : \"#SansCulottesRevolution\"\r\n  string public hashtag;\r\n\r\n  // Minimum number of blocks before next cake distribution from the Revolution\r\n  uint public distributionBlockPeriod;\r\n\r\n  // Amount of WEI to be distributed to each citizen matching criteria\r\n  uint public distributionAmount;\r\n\r\n  // Number of the block at last distribution\r\n  uint public lastDistributionBlockNumber;\r\n\r\n  // Are we running in testing mode ?\r\n  bool public testingMode;\r\n  \r\n  // Is this Revolution irreversibly locked (end of life) ?\r\n  \r\n  bool public locked;\r\n\r\n  // For a given citizen, let's put all positive (or negative) votes\r\n  // received into a positive (or negative) justice scale.\r\n  struct JusticeScale {\r\n    address payable [] voters;\r\n    mapping (address => uint) votes;\r\n    uint amount;\r\n  }\r\n\r\n  // This is the revolutionary trial for a given citizen\r\n  struct Trial {\r\n    address payable citizen;\r\n    JusticeScale sansculotteScale;\r\n    JusticeScale privilegedScale;\r\n    uint lastLotteryBlock;\r\n    bool opened;\r\n    bool matchesCriteria;\r\n  }\r\n\r\n  // Citizens known at this Revolution\r\n  address payable [] public citizens;\r\n\r\n  // Names of these citizens at this Revolution\r\n  mapping (address => string) public names;\r\n\r\n  // Trials known at this Revolution\r\n  mapping (address => Trial) private trials;\r\n\r\n  // This is the amount of cakes in the Bastille\r\n  uint public bastilleBalance;\r\n\r\n  // Creation of the revolution\r\n  event RevolutionCreated(string indexed _hashtag);\r\n  // Start of new trial for a given citizen\r\n  event TrialOpened(string indexed _eventName, address indexed _citizen);\r\n  // End of trial for a given citizen\r\n  event TrialClosed(string indexed _eventName, address indexed _citizen, bool _matchesCriteria);\r\n  // New cake-vote received for a given citizen\r\n  event VoteReceived(string indexed _eventName, address indexed _from, address indexed _citizen, bool _vote, uint _amount);\r\n  // \r\n  event Distribution(string indexed _eventName, address indexed _citizen, uint _distributionAmount);\r\n\r\n\r\n  constructor(address _owner, string memory _criteria, string memory _hashtag, uint _distributionBlockPeriod, uint _distributionAmount, bool _testingMode) public {\r\n    factory = msg.sender;\r\n    owner = _owner;\r\n    criteria = _criteria;\r\n    hashtag = _hashtag;\r\n    distributionBlockPeriod = _distributionBlockPeriod;\r\n    distributionAmount = _distributionAmount;\r\n    lastDistributionBlockNumber = block.number;\r\n    testingMode = _testingMode;\r\n    locked = false;\r\n    emit RevolutionCreated(hashtag);\r\n  }\r\n\r\n\r\n  function lock() public {\r\n    // will irreversibly lock this Revolution\r\n\r\n    // only contract owner or factory can lock\r\n    require(msg.sender == owner || msg.sender == factory);\r\n    locked = true;\r\n\r\n  }\r\n\r\n\r\n  function vote(bool _vote, address payable _citizen) public payable {\r\n\r\n    // can't vote on a locked revolution with an empty bastille\r\n    require(locked == false || bastilleBalance > 0);\r\n    // can't vote with less than distributionAmount / 10\r\n    require(msg.value >= distributionAmount / 10);\r\n\r\n    Trial storage trial = trials[_citizen];\r\n    // open the trial if the vote is not the same as the verdict\r\n    if (_vote != trial.matchesCriteria) {\r\n      trial.opened = true;\r\n    }\r\n    if (trial.citizen == address(0x0) ) {\r\n      // this is a new trial, emit an event\r\n      emit TrialOpened('TrialOpened', _citizen);\r\n      citizens.push(_citizen);\r\n      trial.citizen = _citizen;\r\n      trial.lastLotteryBlock = block.number;\r\n    }\r\n\r\n    // select the target scale\r\n    JusticeScale storage scale = trial.sansculotteScale;\r\n    if (_vote == false) {\r\n      scale = trial.privilegedScale;\r\n    }\r\n    // record the vote\r\n    scale.voters.push(msg.sender);\r\n    scale.votes[msg.sender] += msg.value;\r\n    scale.amount+= msg.value;\r\n\r\n    emit VoteReceived('VoteReceived', msg.sender, _citizen, _vote, msg.value);\r\n\r\n    if(testingMode == false) {\r\n      closeTrial(_citizen);\r\n      distribute();\r\n    }\r\n\r\n  }\r\n\r\n\r\n  function closeTrial(address payable _citizen) public {\r\n    \r\n    // check the closing  lottery\r\n    bool shouldClose = trialLottery(_citizen);\r\n    if(shouldClose == false) {\r\n      // no luck this time, won't close yet, retry later\r\n      return;\r\n    }\r\n  \r\n    // let's close the trial now\r\n    Trial storage trial = trials[_citizen];\r\n    trial.opened = false;\r\n    // Issue a verdict : is this citizen a sans-culotte or a privileged ?\r\n    // By default, citizens are seen as privileged...\r\n    JusticeScale storage winnerScale = trial.privilegedScale;\r\n    JusticeScale storage loserScale = trial.sansculotteScale;\r\n    trial.matchesCriteria = false;\r\n    // .. unless they get more votes on their sans-culotte scale than on their privileged scale.\r\n    if (trial.sansculotteScale.amount > trial.privilegedScale.amount) {\r\n      winnerScale = trial.sansculotteScale;\r\n      loserScale = trial.privilegedScale;\r\n      trial.matchesCriteria = true;\r\n    }\r\n    emit TrialClosed('TrialClosed', _citizen, trial.matchesCriteria);\r\n\r\n    // Compute Bastille virtual vote\r\n    uint bastilleVote = winnerScale.amount - loserScale.amount;\r\n\r\n    // Distribute cakes to winners as rewards\r\n    // Side note : the reward scheme slightly differs from the culottes board game rules\r\n    // regarding the way decimal fractions of cakes to be given as rewards to winners are managed.\r\n    // The board game stipulates that fractions are rounded to the nearest integer and reward cakes\r\n    // are given in the descending order of winners (bigger winners first). But the code below\r\n    // states that only the integer part of reward cakes is taken into account. And the remaining\r\n    // reward cakes are put back into the Bastille. This slightly lessens the number of cakes\r\n    // rewarded to winners and slightly increases the number of cakes given to the Bastille.\r\n    // The main advantage is that it simplifies the algorithm a bit.\r\n    // But this rounding difference should not matter when dealing with Weis instead of real cakes.\r\n    uint remainingRewardCakes = loserScale.amount;\r\n    for (uint i = 0; i < winnerScale.voters.length; i++) {\r\n      address payable voter = winnerScale.voters[i];\r\n      // First distribute cakes from the winner scale, also known as winning cakes\r\n      // How many cakes did this voter put on the winnerScale ?\r\n      uint winningCakes = winnerScale.votes[voter];\r\n      // Send them back\r\n      winnerScale.votes[voter]=0;\r\n      // FIXME : handle the case of failure to send winningCakes\r\n      voter.send(winningCakes);\r\n      // How many cakes from the loser scale are to be rewarded to this winner citizen ?\r\n      // Rewards should be a share of the lost cakes that is proportionate to the fraction of\r\n      // winning cakes that were voted by this voting citizen, pretending that the Bastille\r\n      // itself took part in the vote.\r\n      uint rewardCakes = loserScale.amount * winningCakes / ( winnerScale.amount + bastilleVote );\r\n      // Send their fair share of lost cakes as reward.\r\n      // FIXME : handle the failure of sending rewardCakes\r\n      voter.send(rewardCakes);\r\n      remainingRewardCakes -= rewardCakes;\r\n    }\r\n   \r\n    // distribute cakes to the Bastille\r\n    bastilleBalance += remainingRewardCakes;\r\n\r\n    // Empty the winner scale\r\n    winnerScale.amount = 0;\r\n\r\n    // Empty the loser scale\r\n    for (uint i = 0; i < loserScale.voters.length; i++) {\r\n      address payable voter = loserScale.voters[i];\r\n      loserScale.votes[voter]=0;\r\n    }\r\n    loserScale.amount = 0;\r\n\r\n  }\r\n\r\n\r\n  function pseudoRandomNumber(uint _max) private view returns (uint) {\r\n    // returns pseudo random integer number between 0 and _max - 1\r\n    // random integer between 0 and 1 million\r\n    uint randomHash = uint(keccak256(abi.encodePacked(block.difficulty,block.timestamp)));\r\n    return randomHash % _max;\r\n  }\r\n\r\n  function trialLottery(address payable _citizen) private returns (bool) {\r\n\r\n    if (testingMode == true) {\r\n      // always return true when testing\r\n      return true;\r\n    }\r\n    // returns true with a 50% probability per distribution period.\r\n    // We will weight by the time spent during that this distribution period since the last lottery call\r\n    // so that there is a 50% probability the trial will close over a full distribution period no\r\n    // matter how often the trial lottery is called.\r\n    // returns false otherwise\r\n    uint probabilityPercent = 50;\r\n    uint million = 1000000;\r\n    uint threshold = million * probabilityPercent / 100;\r\n    Trial storage trial = trials[_citizen];\r\n    uint blocksSince = block.number - trial.lastLotteryBlock;\r\n    if (blocksSince < distributionBlockPeriod) {\r\n      threshold *= blocksSince / distributionBlockPeriod;\r\n      // threshold is now between 0 and probabilityPercent% of 1 million\r\n    }\r\n    // remember current block\r\n    trial.lastLotteryBlock = block.number;\r\n    if(pseudoRandomNumber(million) < threshold) {\r\n      return true;\r\n    }\r\n    return false;\r\n\r\n  }\r\n\r\n\r\n  function distribute() public {\r\n\r\n    // Did the last distribution happen long enough ago ?\r\n    if  (block.number - lastDistributionBlockNumber < distributionBlockPeriod) {\r\n      return;\r\n    }\r\n    // For each citizen trial, starting at random first citizen in the list\r\n    uint firstCitizen = pseudoRandomNumber(citizens.length);\r\n    for (uint i = 0; i < citizens.length; i++) {\r\n      uint citizenIndex = firstCitizen + i;\r\n      if (citizenIndex >= citizens.length) {\r\n        citizenIndex = citizenIndex - citizens.length;\r\n      }\r\n      address payable citizen = citizens[citizenIndex];\r\n      Trial memory trial = trials[citizen];\r\n      // Is the trial closed ?\r\n      // and Was the verdict \"sans-culotte\" (citizen does match criteria according to winners) ?\r\n      // and Does the Bastille have more cakes left than the amount to be distributed ?\r\n      if (trial.opened == false &&\r\n          trial.matchesCriteria == true ) {\r\n        uint distributed = 0;\r\n        if (bastilleBalance >= distributionAmount) {\r\n          distributed = distributionAmount;\r\n        } else {\r\n          if (locked == true) {\r\n            distributed = bastilleBalance;\r\n          }\r\n        }\r\n        // Then send this sans-culotte its fair share of Bastille cakes.\r\n        if (distributed > 0) {\r\n          if (citizen.send(distributed)) {\r\n            bastilleBalance -= distributed;\r\n            emit Distribution('Distribution', citizen, distributed);\r\n          } else {\r\n            // sending failed, maybe citizen is a smart contract with an expensive fallback function ?\r\n            emit Distribution('Distribution', citizen, 0);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Remember when this distribution happened.\r\n    lastDistributionBlockNumber = block.number;\r\n\r\n  }\r\n\r\n\r\n  function getScaleAmount(bool _vote, address _citizen) public view returns (uint) {\r\n\r\n    Trial storage trial = trials[_citizen]; \r\n    if (_vote == true)\r\n      return trial.sansculotteScale.amount;\r\n    else\r\n      return trial.privilegedScale.amount;\r\n\r\n  }\r\n\r\n\r\n  function trialStatus(address _citizen) public view returns(bool opened, bool matchesCriteria, uint sansculotteScale, uint privilegedScale, string memory name) {\r\n  \r\n    Trial memory trial = trials[_citizen];\r\n    return (trial.opened, trial.matchesCriteria, trial.sansculotteScale.amount, trial.privilegedScale.amount, names[_citizen]);\r\n\r\n  }\r\n\r\n\r\n  function getName(address payable _citizen) public view returns (string memory name) {\r\n    return names[_citizen];\r\n  }\r\n\r\n\r\n  function setName(address payable _citizen, string memory _name) public {\r\n    require(msg.sender == _citizen);\r\n    names[_citizen] = _name;\r\n  }\r\n\r\n\r\n  function voteAndSetName(bool _vote, address payable _citizen, string memory _name) public payable {\r\n    vote(_vote, _citizen);\r\n    setName(_citizen, _name);\r\n  }\r\n\r\n  function() payable external {\r\n\r\n    require(locked == false);\r\n    bastilleBalance += msg.value;\r\n\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_criteria\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_hashtag\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_distributionBlockPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_distributionAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_testingMode\",\"type\":\"bool\"}],\"name\":\"createRevolution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_hashtag\",\"type\":\"string\"}],\"name\":\"getRevolution\",\"outputs\":[{\"internalType\":\"contract Revolution\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hashtags\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_hashtag\",\"type\":\"string\"}],\"name\":\"lockRevolution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RevolutionFactory","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://9f7c6a5c9d52b3e89636f59e75cb1b197f89fcbe3bc24bb541f763b94d5bb0ca"}]}