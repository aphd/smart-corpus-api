{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n ENS Contanthash resolver (EIP-1577) which may be updated with signatures from contenthash-signer-ens\r\n\r\n\r\n Copyright (c) Ulf Bartel\r\n\r\n Public repository:\r\n https://github.com/berlincode/contenthash-signer-ens\r\n\r\n License: MIT\r\n\r\n Contact:\r\n elastic.code@gmail.com\r\n\r\n Version 4.1.0\r\n\r\n This contract acts as a ens resolver. It always serves only one contenthash (for all nodes).\r\n Implements contenthash field for ENS (EIP 1577) (https://eips.ethereum.org/EIPS/eip-1577).\r\n*/\r\n\r\npragma solidity 0.5.10;\r\npragma experimental ABIEncoderV2;\r\n\r\n/*\r\ninterface ENS {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n}\r\n*/\r\n\r\n\r\ncontract ResolverContenthashSignerENS {\r\n\r\n    /* public constant contractVersion */\r\n    uint64 public constant CONTRACT_VERSION = (\r\n        (4 << 32) + /* major */\r\n        (1 << 16) + /* minor */\r\n        0 /* bugfix */\r\n    );\r\n\r\n    bytes4 constant CONTENTHASH_INTERFACE_ID = 0xbc1c58d1;\r\n\r\n    event ContenthashChanged(bytes hash);\r\n\r\n    struct Signature {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    struct Record {\r\n        uint64 version;\r\n        bytes contenthash;\r\n    }\r\n\r\n    address signer; /* signer address */\r\n\r\n    Record record;\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param signerAddr The signer address.\r\n     */\r\n    constructor(address signerAddr) public {\r\n        signer = signerAddr;\r\n    }\r\n\r\n    /**\r\n     * Sets the contenthash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param hash The contenthash to set\r\n     */\r\n    /*\r\n    function setContenthash(bytes32 node, bytes calldata hash) external {\r\n        require(\r\n            false,\r\n            \"Function call not supported\"\r\n        );\r\n    }\r\n    */\r\n\r\n    /**\r\n     * Returns the contenthash associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function contenthash(bytes32 node) external view returns (bytes memory) {\r\n        return record.contenthash;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the resolver implements the interface specified by the provided hash.\r\n     * @param interfaceID The ID of the interface to check for.\r\n     * @return True if the contract implements the requested interface.\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n        return interfaceID == CONTENTHASH_INTERFACE_ID;\r\n    }\r\n\r\n    /**\r\n     * Sets the contenthash associated with an ENS node using a prebuild signature.\r\n     * May be called by anyone with a valid signature.\r\n     * @param hash The contenthash to set\r\n     * @param version The version (which is part of the signature)\r\n     * @param signature The signature over the keccak256(hash, version)\r\n     */\r\n    function setContenthashBySignature (\r\n        bytes memory hash,\r\n        uint64 version,\r\n        Signature memory signature\r\n    ) public\r\n    {\r\n        require(\r\n            signer == verify(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        hash,\r\n                        version\r\n                    )\r\n                ),\r\n                signature\r\n            ),\r\n            \"Invalid signature\"\r\n        );\r\n\r\n        // update only if new version is higher than current version\r\n        if (version > record.version) {\r\n            record.contenthash = hash;\r\n            record.version = version;\r\n            emit ContenthashChanged(hash);\r\n        }\r\n    }\r\n\r\n    /* internal functions */\r\n\r\n    function verify(\r\n        bytes32 _message,\r\n        Signature memory signature\r\n    ) internal pure returns (address)\r\n    {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHash = keccak256(\r\n            abi.encodePacked(\r\n                prefix,\r\n                _message\r\n            )\r\n        );\r\n        return ecrecover(\r\n            prefixedHash,\r\n            signature.v,\r\n            signature.r,\r\n            signature.s\r\n        );\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes\"},{\"name\":\"version\",\"type\":\"uint64\"},{\"components\":[{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"setContenthashBySignature\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"contenthash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"signerAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"ContenthashChanged\",\"type\":\"event\"}]","ContractName":"ResolverContenthashSignerENS","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000004c912071643adba7d26ffbf95abe8c423e89594","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://98d7d55d11da7e54ecf0eca14c732eaaa01819764c38fd9cc97bf9134dde1a23"}]}