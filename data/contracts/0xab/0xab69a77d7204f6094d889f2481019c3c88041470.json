{"status":"1","message":"OK","result":[{"SourceCode":"{\"EmalBounty.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n\\ncontract EmalToken {\\n    // add function prototypes of only those used here\\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\\n    \\n    function getBountyAmount() public view returns(uint256);\\n}\\n\\n\\ncontract EmalBounty is Ownable {\\n\\n    using SafeMath for uint256;\\n\\n    // The token being sold\\n    EmalToken public token;\\n\\n    // Bounty contract state Data structures\\n    enum State {\\n        Active,\\n        Closed\\n    }\\n\\n    // contains current state of bounty contract\\n    State public state;\\n\\n    // Bounty limit in EMAL tokens\\n    uint256 public bountyLimit;\\n\\n    // Count of total number of EML tokens that have been currently allocated to bounty users\\n    uint256 public totalTokensAllocated = 0;\\n\\n    // Count of allocated tokens (not issued only allocated) for each bounty user\\n    mapping(address =\\u003e uint256) public allocatedTokens;\\n\\n    // Count of allocated tokens issued to each bounty user.\\n    mapping(address =\\u003e uint256) public amountOfAllocatedTokensGivenOut;\\n\\n\\n    /** @dev Event fired when tokens are allocated to a bounty user account\\n      * @param beneficiary Address that is allocated tokens\\n      * @param tokenCount The amount of tokens that were allocated\\n      */\\n    event TokensAllocated(address indexed beneficiary, uint256 tokenCount);\\n    event TokensDeallocated(address indexed beneficiary, uint256 tokenCount);\\n\\n    /**\\n     * @dev Event fired when EML tokens are sent to a bounty user\\n     * @param beneficiary Address where the allocated tokens were sent\\n     * @param tokenCount The amount of tokens that were sent\\n     */\\n    event IssuedAllocatedTokens(address indexed beneficiary, uint256 tokenCount);\\n\\n\\n\\n    /** @param _token Address of the token that will be rewarded for the investors\\n      */\\n    constructor(address _token) public {\\n        require(_token != address(0));\\n        owner = msg.sender;\\n        token = EmalToken(_token);\\n        state = State.Active;\\n        bountyLimit = token.getBountyAmount();\\n    }\\n\\n    /* Do not accept ETH */\\n    function() external payable {\\n        revert();\\n    }\\n\\n    function closeBounty() public onlyOwner returns(bool){\\n        require( state!=State.Closed );\\n        state = State.Closed;\\n        return true;\\n    }\\n\\n    /** @dev Public function to check if bounty isActive or not\\n      * @return True if Bounty event has ended\\n      */\\n    function isBountyActive() public view returns(bool) {\\n        if (state==State.Active \\u0026\\u0026 totalTokensAllocated\\u003cbountyLimit){\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /** @dev Allocates tokens to a bounty user\\n      * @param beneficiary The address of the bounty user\\n      * @param tokenCount The number of tokens to be allocated to this address\\n      */\\n    function allocateTokens(address beneficiary, uint256 tokenCount) public onlyOwner returns(bool success) {\\n        require(beneficiary != address(0));\\n        require(validAllocation(tokenCount));\\n\\n        uint256 tokens = tokenCount;\\n\\n        /* Allocate only the remaining tokens if final contribution exceeds hard cap */\\n        if (totalTokensAllocated.add(tokens) \\u003e bountyLimit) {\\n            tokens = bountyLimit.sub(totalTokensAllocated);\\n        }\\n\\n        /* Update state and balances */\\n        allocatedTokens[beneficiary] = allocatedTokens[beneficiary].add(tokens);\\n        totalTokensAllocated = totalTokensAllocated.add(tokens);\\n        emit TokensAllocated(beneficiary, tokens);\\n\\n        return true;\\n    }\\n\\n    function validAllocation( uint256 tokenCount ) internal view returns(bool) {\\n        bool isActive = state==State.Active;\\n        bool positiveAllocation = tokenCount\\u003e0;\\n        bool bountyLimitNotReached = totalTokensAllocated\\u003cbountyLimit;\\n        return isActive \\u0026\\u0026 positiveAllocation \\u0026\\u0026 bountyLimitNotReached;\\n    }\\n\\n    /** @dev Remove tokens from a bounty user\\u0027s allocation.\\n      * @dev Used in game based bounty allocation, automatically called from the Sails app\\n      * @param beneficiary The address of the bounty user\\n      * @param tokenCount The number of tokens to be deallocated to this address\\n      */\\n    function deductAllocatedTokens(address beneficiary, uint256 tokenCount) public onlyOwner returns(bool success) {\\n        require(beneficiary != address(0));\\n        require(tokenCount\\u003e0 \\u0026\\u0026 tokenCount\\u003c=allocatedTokens[beneficiary]);\\n\\n        allocatedTokens[beneficiary] = allocatedTokens[beneficiary].sub(tokenCount);\\n        totalTokensAllocated = totalTokensAllocated.sub(tokenCount);\\n        emit TokensDeallocated(beneficiary, tokenCount);\\n\\n        return true;\\n    }\\n\\n    /** @dev Getter function to check the amount of allocated tokens\\n      * @param beneficiary address of the investor or the bounty user\\n      */\\n    function getAllocatedTokens(address beneficiary) public view returns(uint256 tokenCount) {\\n        require(beneficiary != address(0));\\n        return allocatedTokens[beneficiary];\\n    }\\n\\n    /** @dev Bounty users will be issued EML Tokens by the sails api,\\n      * @dev after the Bounty has ended to their address\\n      * @param beneficiary address of the bounty user\\n      */\\n    function issueTokensToAllocatedUsers(address beneficiary) public onlyOwner returns(bool success) {\\n        require(beneficiary!=address(0));\\n        require(allocatedTokens[beneficiary]\\u003e0);\\n\\n        uint256 tokensToSend = allocatedTokens[beneficiary];\\n        allocatedTokens[beneficiary] = 0;\\n        amountOfAllocatedTokensGivenOut[beneficiary] = amountOfAllocatedTokensGivenOut[beneficiary].add(tokensToSend);\\n        assert(token.transferFrom(owner, beneficiary, tokensToSend));\\n\\n        emit IssuedAllocatedTokens(beneficiary, tokensToSend);\\n        return true;\\n    }\\n}\\n\"},\"EmalCrowdsale.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\n\\ncontract EmalToken {\\n    // add function prototypes of only those used here\\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\\n    function getCrowdsaleAmount() public view returns(uint256);\\n    function setStartTimeForTokenTransfers(uint256 _startTime) external;\\n}\\n\\ncontract EmalWhitelist {\\n    // add function prototypes of only those used here\\n    function isWhitelisted(address investorAddr) public view returns(bool whitelisted);\\n}\\n\\n\\ncontract EmalCrowdsale is Ownable, Pausable {\\n\\n    using SafeMath for uint256;\\n\\n    // Start and end timestamps\\n    uint256 public startTime;\\n    uint256 public endTime;\\n\\n    // The token being sold\\n    EmalToken public token;\\n\\n    // Whitelist contract used to store whitelisted addresses\\n    EmalWhitelist public list;\\n\\n    // Address where funds are collected\\n    address public multisigWallet;\\n\\n    // Switched to true once token contract is notified of when to enable token transfers\\n    bool private isStartTimeSetForTokenTransfers = false;\\n\\n    // Hard cap in EMAL tokens\\n    uint256 public hardCap;\\n\\n    // Soft cap in EMAL tokens\\n    uint256 constant public soft_cap = 50000000 * (10 ** 18);\\n\\n    // Amount of tokens that were sold to ether investors plus tokens allocated to investors for fiat and btc investments.\\n    uint256 public totalTokensSoldandAllocated = 0;\\n\\n\\n\\n    // Investor contributions made in ether\\n    mapping(address =\\u003e uint256) public etherInvestments;\\n\\n    // Tokens given to investors who sent ether investments\\n    mapping(address =\\u003e uint256) public tokensSoldForEther;\\n\\n    // Total ether raised by the Crowdsale\\n    uint256 public totalEtherRaisedByCrowdsale = 0;\\n\\n    // Total number of tokens sold to investors who made payments in ether\\n    uint256 public totalTokensSoldByEtherInvestments = 0;\\n\\n    // Count of allocated tokens  for each investor or bounty user\\n    mapping(address =\\u003e uint256) public allocatedTokens;\\n\\n    // Count of total number of EML tokens that have been currently allocated to Crowdsale investors\\n    uint256 public totalTokensAllocated = 0;\\n\\n\\n\\n   /** @dev Event for EML token purchase using ether\\n     * @param investorAddr Address that paid and got the tokens\\n     * @param paidAmount The amount that was paid (in wei)\\n     * @param tokenCount The amount of tokens that were bought\\n     */\\n    event TokenPurchasedUsingEther(address indexed investorAddr, uint256 paidAmount, uint256 tokenCount);\\n\\n    /**\\n     * @dev Event for refund logging\\n     * @param receiver The address that received the refund\\n     * @param amount The amount that is being refunded (in wei)\\n     */\\n    event Refund(address indexed receiver, uint256 amount);\\n\\n    /** @dev Event fired when EML tokens are allocated to an investor account\\n      * @param beneficiary Address that is allocated tokens\\n      * @param tokenCount The amount of tokens that were allocated\\n      */\\n    event TokensAllocated(address indexed beneficiary, uint256 tokenCount);\\n    event TokensDeallocated(address indexed beneficiary, uint256 tokenCount);\\n\\n\\n    /** @dev variables and functions which determine conversion rate from ETH to EML\\n      * based on bonuses and current timestamp.\\n      */\\n    uint256 priceOfEthInUSD = 450;\\n    uint256 bonusPercent1 = 25;\\n    uint256 bonusPercent2 = 15;\\n    uint256 bonusPercent3 = 0;\\n    uint256 priceOfEMLTokenInUSDPenny = 60;\\n    uint256 overridenBonusValue = 0;\\n\\n    function setExchangeRate(uint256 overridenValue) public onlyOwner returns(bool) {\\n        require( overridenValue \\u003e 0 );\\n        require( overridenValue != priceOfEthInUSD);\\n        priceOfEthInUSD = overridenValue;\\n        return true;\\n    }\\n\\n    function getExchangeRate() public view returns(uint256){\\n        return priceOfEthInUSD;\\n    }\\n\\n    function setOverrideBonus(uint256 overridenValue) public onlyOwner returns(bool) {\\n        require( overridenValue \\u003e 0 );\\n        require( overridenValue != overridenBonusValue);\\n        overridenBonusValue = overridenValue;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev public function that is used to determine the current rate for token / ETH conversion\\n     * @dev there exists a case where rate cant be set to 0, which is fine.\\n     * @return The current token rate\\n     */\\n    function getRate() public view returns(uint256) {\\n        require( priceOfEMLTokenInUSDPenny !=0 );\\n        require( priceOfEthInUSD !=0 );\\n        uint256 rate;\\n\\n        if(overridenBonusValue \\u003e 0){\\n            rate = priceOfEthInUSD.mul(100).div(priceOfEMLTokenInUSDPenny).mul(overridenBonusValue.add(100)).div(100);\\n        } else {\\n            if (now \\u003c= (startTime + 1 days)) {\\n                rate = priceOfEthInUSD.mul(100).div(priceOfEMLTokenInUSDPenny).mul(bonusPercent1.add(100)).div(100);\\n            } if (now \\u003e (startTime + 1 days) \\u0026\\u0026 now \\u003c= (startTime + 2 days)) {\\n                rate = priceOfEthInUSD.mul(100).div(priceOfEMLTokenInUSDPenny).mul(bonusPercent2.add(100)).div(100);\\n            } else {\\n                rate = priceOfEthInUSD.mul(100).div(priceOfEMLTokenInUSDPenny).mul(bonusPercent3.add(100)).div(100);\\n            }\\n        }\\n        return rate;\\n    }\\n\\n\\n    /** @dev Initialise the Crowdsale contract.\\n      * (can be removed for testing) _startTime Unix timestamp for the start of the token sale\\n      * (can be removed for testing) _endTime Unix timestamp for the end of the token sale\\n      * @param _multisigWallet Ethereum address to which the invested funds are forwarded\\n      * @param _token Address of the token that will be rewarded for the investors\\n      * @param _list contains a list of investors who completed KYC procedures.\\n      */\\n    constructor(uint256 _startTime, uint256 _endTime, address _multisigWallet, address _token, address _list) public {\\n        require(_startTime \\u003e= now);\\n        require(_endTime \\u003e= _startTime);\\n        require(_multisigWallet != address(0));\\n        require(_token != address(0));\\n        require(_list != address(0));\\n\\n        startTime = _startTime;\\n        endTime = _endTime;\\n        multisigWallet = _multisigWallet;\\n        owner = msg.sender;\\n        token = EmalToken(_token);\\n        list = EmalWhitelist(_list);\\n        hardCap = token.getCrowdsaleAmount();\\n    }\\n\\n    /** @dev Fallback function that can be used to buy EML tokens. Or in\\n      * case of the owner, return ether to allow refunds in case crowdsale\\n      * ended or paused and didnt reach soft_cap.\\n      */\\n    function() external payable {\\n        if (msg.sender == multisigWallet) {\\n            require( (!isCrowdsaleActive()) \\u0026\\u0026 totalTokensSoldandAllocated\\u003csoft_cap);\\n        } else {\\n            if (list.isWhitelisted(msg.sender)) {\\n                buyTokensUsingEther(msg.sender);\\n            } else {\\n                revert();\\n            }\\n        }\\n    }\\n\\n    /** @dev Function for buying EML tokens using ether\\n      * @param _investorAddr The address that should receive bought tokens\\n      */\\n    function buyTokensUsingEther(address _investorAddr) internal whenNotPaused {\\n        require(_investorAddr != address(0));\\n        require(validPurchase());\\n\\n        uint256 weiAmount = msg.value;\\n        uint256 returnToSender = 0;\\n\\n        // final rate after including rate value and bonus amount.\\n        uint256 finalConversionRate = getRate();\\n\\n        // Calculate EML token amount to be transferred\\n        uint256 tokens = weiAmount.mul(finalConversionRate);\\n\\n        // Distribute only the remaining tokens if final contribution exceeds hard cap\\n        if (totalTokensSoldandAllocated.add(tokens) \\u003e hardCap) {\\n            tokens = hardCap.sub(totalTokensSoldandAllocated);\\n            weiAmount = tokens.div(finalConversionRate);\\n            returnToSender = msg.value.sub(weiAmount);\\n        }\\n\\n        // update state and balances\\n        etherInvestments[_investorAddr] = etherInvestments[_investorAddr].add(weiAmount);\\n        tokensSoldForEther[_investorAddr] = tokensSoldForEther[_investorAddr].add(tokens);\\n        totalTokensSoldByEtherInvestments = totalTokensSoldByEtherInvestments.add(tokens);\\n        totalEtherRaisedByCrowdsale = totalEtherRaisedByCrowdsale.add(weiAmount);\\n        totalTokensSoldandAllocated = totalTokensSoldandAllocated.add(tokens);\\n\\n\\n        // assert implies it should never fail\\n        assert(token.transferFrom(owner, _investorAddr, tokens));\\n        emit TokenPurchasedUsingEther(_investorAddr, weiAmount, tokens);\\n\\n        // Forward funds\\n        multisigWallet.transfer(weiAmount);\\n\\n        // Update token contract.\\n        _postValidationUpdateTokenContract();\\n\\n        // Return funds that are over hard cap\\n        if (returnToSender \\u003e 0) {\\n            msg.sender.transfer(returnToSender);\\n        }\\n    }\\n\\n    function _postValidationUpdateTokenContract() internal {\\n       /** @dev If hard cap is reachde allow token transfers after two weeks\\n         * @dev Allow users to transfer tokens only after hardCap is reached\\n         * @dev Notiy token contract about startTime to start transfers\\n         */\\n        if (totalTokensSoldandAllocated == hardCap) {\\n            token.setStartTimeForTokenTransfers(now + 2 weeks);\\n        }\\n\\n       /** @dev If its the first token sold or allocated then set s, allow after 2 weeks\\n         * @dev Allow users to transfer tokens only after ICO crowdsale ends.\\n         * @dev Notify token contract about sale end time\\n         */\\n        if (!isStartTimeSetForTokenTransfers) {\\n            isStartTimeSetForTokenTransfers = true;\\n            token.setStartTimeForTokenTransfers(endTime + 2 weeks);\\n        }\\n    }\\n\\n    /** @dev Internal function that is used to check if the incoming purchase should be accepted.\\n      * @return True if the transaction can buy tokens\\n      */\\n    function validPurchase() internal view returns(bool) {\\n        bool withinPeriod = now \\u003e= startTime \\u0026\\u0026 now \\u003c= endTime;\\n        bool minimumPurchase = msg.value \\u003e= 1*(10**18);\\n        bool hardCapNotReached = totalTokensSoldandAllocated \\u003c hardCap;\\n        return withinPeriod \\u0026\\u0026 hardCapNotReached \\u0026\\u0026 minimumPurchase;\\n    }\\n\\n    /** @dev Public function to check if Crowdsale isActive or not\\n      * @return True if Crowdsale event has ended\\n      */\\n    function isCrowdsaleActive() public view returns(bool) {\\n        if (!paused \\u0026\\u0026 now\\u003estartTime \\u0026\\u0026 now\\u003cendTime \\u0026\\u0026 totalTokensSoldandAllocated\\u003c=hardCap){\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /** @dev Gets the balance of the specified address.\\n      * @param _owner The address to query the the balance of.\\n      * @return An uint256 representing the amount owned by the passed address.\\n      */\\n    function balanceOfEtherInvestor(address _owner) external view returns(uint256 balance) {\\n        require(_owner != address(0));\\n        return etherInvestments[_owner];\\n    }\\n\\n    function getTokensSoldToEtherInvestor(address _owner) public view returns(uint256 balance) {\\n        require(_owner != address(0));\\n        return tokensSoldForEther[_owner];\\n    }\\n\\n    /** @dev Returns ether to token holders in case soft cap is not reached.\\n      */\\n    function claimRefund() public whenNotPaused onlyOwner {\\n        require(now\\u003eendTime);\\n        require(totalTokensSoldandAllocated\\u003csoft_cap);\\n        uint256 amount = etherInvestments[msg.sender];\\n\\n        if (address(this).balance \\u003e= amount) {\\n            etherInvestments[msg.sender] = 0;\\n            if (amount \\u003e 0) {\\n                msg.sender.transfer(amount);\\n                emit Refund(msg.sender, amount);\\n            }\\n        }\\n      }\\n\\n\\n\\n\\n    /** @dev BELOW ARE FUNCTIONS THAT HANDLE INVESTMENTS IN FIAT AND BTC.\\n      * functions are automatically called by ICO Sails.js app.\\n      */\\n\\n\\n    /** @dev Allocates EML tokens to an investor address called automatically\\n      * after receiving fiat or btc investments from KYC whitelisted investors.\\n      * @param beneficiary The address of the investor\\n      * @param tokenCount The number of tokens to be allocated to this address\\n      */\\n    function allocateTokens(address beneficiary, uint256 tokenCount) public onlyOwner returns(bool success) {\\n        require(beneficiary != address(0));\\n        require(validAllocation(tokenCount));\\n\\n        uint256 tokens = tokenCount;\\n\\n        /* Allocate only the remaining tokens if final contribution exceeds hard cap */\\n        if (totalTokensSoldandAllocated.add(tokens) \\u003e hardCap) {\\n            tokens = hardCap.sub(totalTokensSoldandAllocated);\\n        }\\n\\n        /* Update state and balances */\\n        allocatedTokens[beneficiary] = allocatedTokens[beneficiary].add(tokens);\\n        totalTokensSoldandAllocated = totalTokensSoldandAllocated.add(tokens);\\n        totalTokensAllocated = totalTokensAllocated.add(tokens);\\n\\n        // assert implies it should never fail\\n        assert(token.transferFrom(owner, beneficiary, tokens));\\n        emit TokensAllocated(beneficiary, tokens);\\n\\n        /* Update token contract. */\\n        _postValidationUpdateTokenContract();\\n        return true;\\n    }\\n\\n    function validAllocation( uint256 tokenCount ) internal view returns(bool) {\\n        bool withinPeriod = now \\u003e= startTime \\u0026\\u0026 now \\u003c= endTime;\\n        bool positiveAllocation = tokenCount \\u003e 0;\\n        bool hardCapNotReached = totalTokensSoldandAllocated \\u003c hardCap;\\n        return withinPeriod \\u0026\\u0026 positiveAllocation \\u0026\\u0026 hardCapNotReached;\\n    }\\n\\n\\n    /** @dev Getter function to check the amount of allocated tokens\\n      * @param beneficiary address of the investor\\n      */\\n    function getAllocatedTokens(address beneficiary) public view returns(uint256 tokenCount) {\\n        require(beneficiary != address(0));\\n        return allocatedTokens[beneficiary];\\n    }\\n\\n    function getSoldandAllocatedTokens(address _addr) public view returns (uint256) {\\n        require(_addr != address(0));\\n        uint256 totalTokenCount = getAllocatedTokens(_addr).add(getTokensSoldToEtherInvestor(_addr));\\n        return totalTokenCount;\\n    }\\n\\n}\\n\"},\"EmalPresale.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\n\\ncontract EmalToken {\\n    // add function prototypes of only those used here\\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\\n    function getPresaleAmount() public view returns(uint256);\\n}\\n\\ncontract EmalWhitelist {\\n    // add function prototypes of only those used here\\n    function isWhitelisted(address investorAddr) public view returns(bool whitelisted);\\n}\\n\\n\\ncontract EmalPresale is Ownable, Pausable {\\n\\n    using SafeMath for uint256;\\n\\n    // Start and end timestamps\\n    uint256 public startTime;\\n    uint256 public endTime;\\n\\n    // The token being sold\\n    EmalToken public token;\\n\\n    // Whitelist contract used to store whitelisted addresses\\n    EmalWhitelist public list;\\n\\n    // Address where funds are collected\\n    address public multisigWallet;\\n\\n    // Hard cap in EMAL tokens\\n    uint256 public hardCap;\\n\\n    // Amount of tokens that were sold to ether investors plus tokens allocated to investors for fiat and btc investments.\\n    uint256 public totalTokensSoldandAllocated = 0;\\n\\n\\n\\n    // Investor contributions made in ether\\n    mapping(address =\\u003e uint256) public etherInvestments;\\n\\n    // Tokens given to investors who sent ether investments\\n    mapping(address =\\u003e uint256) public tokensSoldForEther;\\n\\n    // Total ether raised by the Presale\\n    uint256 public totalEtherRaisedByPresale = 0;\\n\\n    // Total number of tokens sold to investors who made payments in ether\\n    uint256 public totalTokensSoldByEtherInvestments = 0;\\n\\n    // Count of allocated tokens  for each investor or bounty user\\n    mapping(address =\\u003e uint256) public allocatedTokens;\\n\\n    // Count of total number of EML tokens that have been currently allocated to Presale investors\\n    uint256 public totalTokensAllocated = 0;\\n\\n\\n\\n   /** @dev Event for EML token purchase using ether\\n     * @param investorAddr Address that paid and got the tokens\\n     * @param paidAmount The amount that was paid (in wei)\\n     * @param tokenCount The amount of tokens that were bought\\n     */\\n    event TokenPurchasedUsingEther(address indexed investorAddr, uint256 paidAmount, uint256 tokenCount);\\n\\n    /** @dev Event fired when EML tokens are allocated to an investor account\\n      * @param beneficiary Address that is allocated tokens\\n      * @param tokenCount The amount of tokens that were allocated\\n      */\\n    event TokensAllocated(address indexed beneficiary, uint256 tokenCount);\\n    event TokensDeallocated(address indexed beneficiary, uint256 tokenCount);\\n\\n\\n    /** @dev variables and functions which determine conversion rate from ETH to EML\\n      * based on bonuses and current timestamp.\\n      */\\n    uint256 priceOfEthInUSD = 450;\\n    uint256 bonusPercent1 = 35;\\n    uint256 priceOfEMLTokenInUSDPenny = 60;\\n    uint256 overridenBonusValue = 0;\\n\\n    function setExchangeRate(uint256 overridenValue) public onlyOwner returns(bool) {\\n        require( overridenValue \\u003e 0 );\\n        require( overridenValue != priceOfEthInUSD);\\n        priceOfEthInUSD = overridenValue;\\n        return true;\\n    }\\n\\n    function getExchangeRate() public view returns(uint256){\\n        return priceOfEthInUSD;\\n    }\\n\\n    function setOverrideBonus(uint256 overridenValue) public onlyOwner returns(bool) {\\n        require( overridenValue \\u003e 0 );\\n        require( overridenValue != overridenBonusValue);\\n        overridenBonusValue = overridenValue;\\n        return true;\\n    }\\n\\n    /** @dev public function that is used to determine the current rate for ETH to EML conversion\\n      * @return The current token rate\\n      */\\n    function getRate() public view returns(uint256) {\\n        require(priceOfEMLTokenInUSDPenny \\u003e 0 );\\n        require(priceOfEthInUSD \\u003e 0 );\\n        uint256 rate;\\n\\n        if(overridenBonusValue \\u003e 0){\\n            rate = priceOfEthInUSD.mul(100).div(priceOfEMLTokenInUSDPenny).mul(overridenBonusValue.add(100)).div(100);\\n        } else {\\n            rate = priceOfEthInUSD.mul(100).div(priceOfEMLTokenInUSDPenny).mul(bonusPercent1.add(100)).div(100);\\n        }\\n        return rate;\\n    }\\n\\n\\n    /** @dev Initialise the Presale contract.\\n      * (can be removed for testing) _startTime Unix timestamp for the start of the token sale\\n      * (can be removed for testing) _endTime Unix timestamp for the end of the token sale\\n      * @param _multisigWallet Ethereum address to which the invested funds are forwarded\\n      * @param _token Address of the token that will be rewarded for the investors\\n      * @param _list contains a list of investors who completed KYC procedures.\\n      */\\n    constructor(uint256 _startTime, uint256 _endTime, address _multisigWallet, address _token, address _list) public {\\n        require(_startTime \\u003e= now);\\n        require(_endTime \\u003e= _startTime);\\n        require(_multisigWallet != address(0));\\n        require(_token != address(0));\\n        require(_list != address(0));\\n\\n        startTime = _startTime;\\n        endTime = _endTime;\\n        multisigWallet = _multisigWallet;\\n        owner = msg.sender;\\n        token = EmalToken(_token);\\n        list = EmalWhitelist(_list);\\n        hardCap = token.getPresaleAmount();\\n    }\\n\\n    /** @dev Fallback function that can be used to buy tokens.\\n      */\\n    function() external payable {\\n        if (list.isWhitelisted(msg.sender)) {\\n            buyTokensUsingEther(msg.sender);\\n        } else {\\n            /* Do not accept ETH */\\n            revert();\\n        }\\n    }\\n\\n    /** @dev Function for buying EML tokens using ether\\n      * @param _investorAddr The address that should receive bought tokens\\n      */\\n    function buyTokensUsingEther(address _investorAddr) internal whenNotPaused {\\n        require(_investorAddr != address(0));\\n        require(validPurchase());\\n\\n        uint256 weiAmount = msg.value;\\n        uint256 returnToSender = 0;\\n\\n        // final rate after including rate value and bonus amount.\\n        uint256 finalConversionRate = getRate();\\n\\n        // Calculate EML token amount to be transferred\\n        uint256 tokens = weiAmount.mul(finalConversionRate);\\n\\n        // Distribute only the remaining tokens if final contribution exceeds hard cap\\n        if (totalTokensSoldandAllocated.add(tokens) \\u003e hardCap) {\\n            tokens = hardCap.sub(totalTokensSoldandAllocated);\\n            weiAmount = tokens.div(finalConversionRate);\\n            returnToSender = msg.value.sub(weiAmount);\\n        }\\n\\n        // update state and balances\\n        etherInvestments[_investorAddr] = etherInvestments[_investorAddr].add(weiAmount);\\n        tokensSoldForEther[_investorAddr] = tokensSoldForEther[_investorAddr].add(tokens);\\n        totalTokensSoldByEtherInvestments = totalTokensSoldByEtherInvestments.add(tokens);\\n        totalEtherRaisedByPresale = totalEtherRaisedByPresale.add(weiAmount);\\n        totalTokensSoldandAllocated = totalTokensSoldandAllocated.add(tokens);\\n\\n\\n        // assert implies it should never fail\\n        assert(token.transferFrom(owner, _investorAddr, tokens));\\n        emit TokenPurchasedUsingEther(_investorAddr, weiAmount, tokens);\\n\\n        // Forward funds\\n        multisigWallet.transfer(weiAmount);\\n\\n        // Return funds that are over hard cap\\n        if (returnToSender \\u003e 0) {\\n            msg.sender.transfer(returnToSender);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that is used to check if the incoming purchase should be accepted.\\n     * @return True if the transaction can buy tokens\\n     */\\n    function validPurchase() internal view returns(bool) {\\n        bool withinPeriod = now \\u003e= startTime \\u0026\\u0026 now \\u003c= endTime;\\n        bool minimumPurchase = msg.value \\u003e= 1*(10**18);\\n        bool hardCapNotReached = totalTokensSoldandAllocated \\u003c hardCap;\\n        return withinPeriod \\u0026\\u0026 hardCapNotReached \\u0026\\u0026 minimumPurchase;\\n    }\\n\\n    /** @dev Public function to check if Presale isActive or not\\n      * @return True if Presale event has ended\\n      */\\n    function isPresaleActive() public view returns(bool) {\\n        if (!paused \\u0026\\u0026 now\\u003estartTime \\u0026\\u0026 now\\u003cendTime \\u0026\\u0026 totalTokensSoldandAllocated\\u003c=hardCap){\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /** @dev Gets the balance of the specified address.\\n      * @param _owner The address to query the the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOfEtherInvestor(address _owner) external view returns(uint256 balance) {\\n        require(_owner != address(0));\\n        return etherInvestments[_owner];\\n    }\\n\\n    function getTokensSoldToEtherInvestor(address _owner) public view returns(uint256 balance) {\\n        require(_owner != address(0));\\n        return tokensSoldForEther[_owner];\\n    }\\n\\n\\n\\n\\n    /** @dev BELOW ARE FUNCTIONS THAT HANDLE INVESTMENTS IN FIAT AND BTC.\\n      * functions are automatically called by ICO Sails.js app.\\n      */\\n\\n\\n    /** @dev Allocates EML tokens to an investor address called automatically\\n      * after receiving fiat or btc investments from KYC whitelisted investors.\\n      * @param beneficiary The address of the investor\\n      * @param tokenCount The number of tokens to be allocated to this address\\n      */\\n    function allocateTokens(address beneficiary, uint256 tokenCount) public onlyOwner returns(bool success) {\\n        require(beneficiary != address(0));\\n        require(validAllocation(tokenCount));\\n\\n        uint256 tokens = tokenCount;\\n\\n        /* Allocate only the remaining tokens if final contribution exceeds hard cap */\\n        if (totalTokensSoldandAllocated.add(tokens) \\u003e hardCap) {\\n            tokens = hardCap.sub(totalTokensSoldandAllocated);\\n        }\\n\\n        /* Update state and balances */\\n        allocatedTokens[beneficiary] = allocatedTokens[beneficiary].add(tokens);\\n        totalTokensSoldandAllocated = totalTokensSoldandAllocated.add(tokens);\\n        totalTokensAllocated = totalTokensAllocated.add(tokens);\\n\\n        // assert implies it should never fail\\n        assert(token.transferFrom(owner, beneficiary, tokens));\\n        emit TokensAllocated(beneficiary, tokens);\\n\\n        return true;\\n    }\\n\\n    function validAllocation( uint256 tokenCount ) internal view returns(bool) {\\n        bool withinPeriod = now \\u003e= startTime \\u0026\\u0026 now \\u003c= endTime;\\n        bool positiveAllocation = tokenCount \\u003e 0;\\n        bool hardCapNotReached = totalTokensSoldandAllocated \\u003c hardCap;\\n        return withinPeriod \\u0026\\u0026 positiveAllocation \\u0026\\u0026 hardCapNotReached;\\n    }\\n\\n\\n    /** @dev Getter function to check the amount of allocated tokens\\n      * @param beneficiary address of the investor\\n      */\\n    function getAllocatedTokens(address beneficiary) public view returns(uint256 tokenCount) {\\n        require(beneficiary != address(0));\\n        return allocatedTokens[beneficiary];\\n    }\\n\\n    function getSoldandAllocatedTokens(address _addr) public view returns (uint256) {\\n        require(_addr != address(0));\\n        uint256 totalTokenCount = getAllocatedTokens(_addr).add(getTokensSoldToEtherInvestor(_addr));\\n        return totalTokenCount;\\n    }\\n\\n}\\n\"},\"EmalToken.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\u0027./StandardToken.sol\\u0027;\\nimport \\u0027./Ownable.sol\\u0027;\\n\\ncontract EmalToken is StandardToken, Ownable {\\n\\n    using SafeMath for uint256;\\n\\n    string public constant symbol = \\\"EML\\\";\\n    string public constant name = \\\"e-Mal Token\\\";\\n    uint8 public constant decimals = 18;\\n\\n    // Total Number of tokens ever goint to be minted. 1 BILLION EML tokens.\\n    uint256 private constant minting_capped_amount = 1000000000 * 10 ** uint256(decimals);\\n\\n    // 24% of initial supply\\n    uint256 constant presale_amount = 120000000 * 10 ** uint256(decimals);\\n    // 60% of inital supply\\n    uint256 constant crowdsale_amount = 300000000 * 10 ** uint256(decimals);\\n    // 8% of inital supply.\\n    uint256  constant vesting_amount = 40000000 * 10 ** uint256(decimals);\\n    // 8% of inital supply.\\n    uint256 constant bounty_amount = 40000000 * 10 ** uint256(decimals);\\n    \\n    uint256 private initialSupply = minting_capped_amount;\\n\\n    address public presaleAddress;\\n    address public crowdsaleAddress;\\n    address public vestingAddress;\\n    address public bountyAddress;\\n\\n\\n\\n    /** @dev Defines the start time after which transferring of EML tokens\\n      * will be allowed done so as to prevent early buyers from clearing out\\n      * of their EML balance during the presale and publicsale.\\n      */\\n    uint256 public startTimeForTransfers;\\n\\n    /** @dev to cap the total number of tokens that will ever be newly minted\\n      * owner has to stop the minting by setting this variable to true.\\n      */\\n    bool public mintingFinished = false;\\n\\n    /** @dev Miniting Essentials functions as per OpenZeppelin standards\\n      */\\n    modifier canMint() {\\n      require(!mintingFinished);\\n      _;\\n    }\\n    modifier hasMintPermission() {\\n      require(msg.sender == owner);\\n      _;\\n    }\\n\\n    /** @dev to prevent malicious use of EML tokens and to comply with Anti\\n      * Money laundering regulations EML tokens can be frozen.\\n      */\\n    mapping (address =\\u003e bool) public frozenAccount;\\n\\n    /** @dev This generates a public event on the blockchain that will notify clients\\n      */\\n    event FrozenFunds(address target, bool frozen);\\n    event Mint(address indexed to, uint256 amount);\\n    event MintFinished();\\n    event Burn(address indexed burner, uint256 value);\\n\\n\\n    constructor() public {\\n        startTimeForTransfers = now - 210 days;\\n\\n        _totalSupply = initialSupply;\\n        owner = msg.sender;\\n        balances[owner] = _totalSupply;\\n        emit Transfer(address(0), owner, balances[owner]);\\n    }\\n\\n    /* Do not accept ETH */\\n    function() public payable {\\n        revert();\\n    }\\n\\n\\n    /** @dev Basic setters and getters to allocate tokens for vesting factory, presale\\n      * crowdsale and bounty this is done so that no need of actually transferring EML\\n      * tokens to sale contracts and hence preventing EML tokens from the risk of being\\n      * locked out in future inside the subcontracts.\\n      */\\n    function setPresaleAddress(address _presaleAddress) external onlyOwner {\\n        presaleAddress = _presaleAddress;\\n        assert(approve(presaleAddress, presale_amount));\\n    }\\n    function setCrowdsaleAddress(address _crowdsaleAddress) external onlyOwner {\\n        crowdsaleAddress = _crowdsaleAddress;\\n        assert(approve(crowdsaleAddress, crowdsale_amount));\\n    }\\n    function setVestingAddress(address _vestingAddress) external onlyOwner {\\n        vestingAddress = _vestingAddress;\\n        assert(approve(vestingAddress, vesting_amount));\\n    }\\n    function setBountyAddress(address _bountyAddress) external onlyOwner {\\n        bountyAddress = _bountyAddress;\\n        assert(approve(bountyAddress, bounty_amount));\\n    }\\n    \\n\\n\\n    function getPresaleAmount()  internal pure returns(uint256) {\\n        return presale_amount;\\n    }\\n    function getCrowdsaleAmount() internal pure  returns(uint256) {\\n        return crowdsale_amount;\\n    }\\n    function getVestingAmount() internal pure  returns(uint256) {\\n        return vesting_amount;\\n    }\\n    function getBountyAmount() internal pure  returns(uint256) {\\n        return bounty_amount;\\n    }\\n\\n    /** @dev Sets the start time after which transferring of EML tokens\\n      * will be allowed done so as to prevent early buyers from clearing out\\n      * of their EML balance during the presale and publicsale.\\n      */\\n    function setStartTimeForTokenTransfers(uint256 _startTimeForTransfers) external {\\n        require(msg.sender == crowdsaleAddress);\\n        if (_startTimeForTransfers \\u003c startTimeForTransfers) {\\n            startTimeForTransfers = _startTimeForTransfers;\\n        }\\n    }\\n\\n\\n    /** @dev Transfer possible only after ICO ends and Frozen accounts\\n      * wont be able to transfer funds to other any other account and viz.\\n      * @notice added safeTransfer functionality\\n      */\\n    function transfer(address _to, uint256 _value) public returns(bool) {\\n        require(now \\u003e= startTimeForTransfers);\\n        require(!frozenAccount[msg.sender]);\\n        require(!frozenAccount[_to]);\\n\\n        require(super.transfer(_to, _value));\\n        return true;\\n    }\\n\\n    /** @dev Only owner\\u0027s tokens can be transferred before Crowdsale ends.\\n      * beacuse the inital supply of EML is allocated to owners acc and later\\n      * distributed to various subcontracts.\\n      * @notice added safeTransferFrom functionality\\n      */\\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {\\n        require(!frozenAccount[_from]);\\n        require(!frozenAccount[_to]);\\n        require(!frozenAccount[msg.sender]);\\n\\n        if (now \\u003c startTimeForTransfers) {\\n            require(_from == owner);\\n        }\\n\\n        require(super.transferFrom(_from, _to, _value));\\n        return true;\\n    }\\n\\n    /** @notice added safeApprove functionality\\n      */\\n    function approve(address spender, uint256 tokens) public returns (bool){\\n        require(super.approve(spender, tokens));\\n        return true;\\n    }\\n\\n   /** @notice `freeze? Prevent | Allow` `target` from sending \\u0026 receiving tokens\\n     * @param target Address to be frozen\\n     * @param freeze either to freeze it or not\\n     */\\n    function freezeAccount(address target, bool freeze) public onlyOwner {\\n        require(frozenAccount[target] != freeze);\\n\\n        frozenAccount[target] = freeze;\\n        emit FrozenFunds(target, freeze);\\n    }\\n\\n\\n    /** @dev Function to mint tokens\\n      * @param _to The address that will receive the minted tokens.\\n      * @param _amount The amount of tokens to mint.\\n      * @return A boolean that indicates if the operation was successful.\\n      */\\n    function mint(address _to, uint256 _amount) public hasMintPermission canMint returns (bool) {\\n      require(_totalSupply.add(_amount) \\u003c= minting_capped_amount);\\n\\n      _totalSupply = _totalSupply.add(_amount);\\n      balances[_to] = balances[_to].add(_amount);\\n      emit Mint(_to, _amount);\\n      emit Transfer(address(0), _to, _amount);\\n      return true;\\n    }\\n\\n   /** @dev Function to stop minting new tokens.\\n     * @return True if the operation was successful.\\n     */\\n    function finishMinting() public onlyOwner canMint returns (bool) {\\n      mintingFinished = true;\\n      emit MintFinished();\\n      return true;\\n    }\\n\\n    /** @dev Burns a specific amount of tokens.\\n      * @param _value The amount of token to be burned.\\n      */\\n     function burn(uint256 _value) public {\\n       _burn(msg.sender, _value);\\n     }\\n\\n     function _burn(address _who, uint256 _value) internal {\\n       require(_value \\u003c= balances[_who]);\\n       // no need to require value \\u003c= totalSupply, since that would imply the\\n       // sender\\u0027s balance is greater than the totalSupply, which *should* be an assertion failure\\n\\n       balances[_who] = balances[_who].sub(_value);\\n       _totalSupply = _totalSupply.sub(_value);\\n       emit Burn(_who, _value);\\n       emit Transfer(_who, address(0), _value);\\n     }\\n}\\n\"},\"EmalTokenVestingFactory.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./EmalToken.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n/** @title StandardTokenVesting\\n  * @dev A token holder contract that can release its token balance gradually like a\\n  * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the owner.\\n  */\\ncontract StandardTokenVesting is Ownable {\\n  using SafeMath for uint256;\\n\\n  event Released(uint256 amount);\\n  event Revoked();\\n\\n  // beneficiary of tokens after they are released\\n  address public beneficiary;\\n\\n  uint256 public cliff;\\n  uint256 public start;\\n  uint256 public duration;\\n\\n  bool public revocable;\\n\\n  mapping (address =\\u003e uint256) public released;\\n  mapping (address =\\u003e bool) public revoked;\\n\\n\\n  /** @dev Creates a vesting contract that vests its balance of any ERC20 token to the\\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\\n   * of the balance will have vested.\\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\\n   * @param _start the time (as Unix time) at which point vesting starts\\n   * @param _duration duration in seconds of the period in which the tokens will vest\\n   * @param _revocable whether the vesting is revocable or not\\n   */\\n  constructor(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {\\n    require(_beneficiary != address(0));\\n    require(_cliff \\u003c= _duration);\\n\\n    beneficiary = _beneficiary;\\n    revocable = _revocable;\\n    duration = _duration;\\n    owner = msg.sender;\\n    cliff = _start.add(_cliff);\\n    start = _start;\\n  }\\n\\n  /** @notice Transfers vested tokens to beneficiary.\\n    * @param token ERC20 token which is being vested\\n    */\\n  function release(EmalToken token) public returns (bool){\\n    uint256 unreleased = releasableAmount(token);\\n    require(unreleased \\u003e 0);\\n    released[token] = released[token].add(unreleased);\\n\\n    token.transfer(beneficiary, unreleased);\\n    emit Released(unreleased);\\n    return true;\\n  }\\n\\n  /** @notice Allows the owner to revoke the vesting. Tokens already vested\\n    * remain in the contract, the rest are returned to the owner.\\n    * @param token ERC20 token which is being vested\\n    */\\n  function revoke(EmalToken token) public onlyOwner returns(bool) {\\n    require(revocable);\\n    require(!revoked[token]);\\n    uint256 balance = token.balanceOf(this);\\n    uint256 unreleased = releasableAmount(token);\\n    uint256 refund = balance.sub(unreleased);\\n\\n    revoked[token] = true;\\n    token.transfer(owner, refund);\\n    emit Revoked();\\n\\n    return true;\\n  }\\n\\n  /** @dev Calculates the amount that has already vested but hasn\\u0027t been released yet.\\n    * @param token ERC20 token which is being vested\\n    */\\n  function releasableAmount(EmalToken token) public view returns (uint256) {\\n    return vestedAmount(token).sub(released[token]);\\n  }\\n\\n  /** @dev Calculates the amount that has already vested.\\n    * @param token Emal token which is being vested\\n    */\\n  function vestedAmount(EmalToken token) public view returns (uint256) {\\n    uint256 currentBalance = token.balanceOf(this);\\n    uint256 totalBalance = currentBalance.add(released[token]);\\n\\n    if (block.timestamp \\u003c cliff) {\\n      return 0;\\n    } else if (block.timestamp \\u003e= start.add(duration) || revoked[token]) {\\n      return totalBalance;\\n    } else {\\n      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\\n    }\\n  }\\n}\\n\"},\"EmalWhitelist.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\u0027./Ownable.sol\\u0027;\\n\\n/** @notice This contract provides support for whitelisting addresses.\\n * only whitelisted addresses are allowed to send ether and buy tokens\\n * during preSale and Pulic crowdsale.\\n * @dev after deploying contract, deploy Presale / Crowdsale contract using\\n * EmalWhitelist address. To allow claim refund functionality and allow wallet\\n * owner efatoora to send ether to Crowdsale contract for refunds add wallet\\n * address to whitelist.\\n */\\ncontract EmalWhitelist is Ownable {\\n\\n    mapping(address =\\u003e bool) whitelist;\\n\\n    event AddToWhitelist(address investorAddr);\\n    event RemoveFromWhitelist(address investorAddr);\\n\\n\\n    /** @dev Throws if operator is not whitelisted.\\n     */\\n    modifier onlyIfWhitelisted(address investorAddr) {\\n        require(whitelist[investorAddr]);\\n        _;\\n    }\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    /** @dev Returns if an address is whitelisted or not\\n     */\\n    function isWhitelisted(address investorAddr) public view returns(bool whitelisted) {\\n        return whitelist[investorAddr];\\n    }\\n\\n    /**\\n     * @dev Adds an investor to whitelist\\n     * @param investorAddr The address to user to be added to the whitelist, signifies that the user completed KYC requirements.\\n     */\\n    function addToWhitelist(address investorAddr) public onlyOwner returns(bool success) {\\n        require(investorAddr!= address(0));\\n        whitelist[investorAddr] = true;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Removes an investor\\u0027s address from whitelist\\n     * @param investorAddr The address to user to be added to the whitelist, signifies that the user completed KYC requirements.\\n     */\\n    function removeFromWhitelist(address investorAddr) public onlyOwner returns(bool success) {\\n        require(investorAddr!= address(0));\\n        whitelist[investorAddr] = false;\\n        return true;\\n    }\\n\\n\\n}\\n\"},\"ERC20Token.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\ncontract ERC20Token {\\n  function totalSupply() public constant returns (uint);\\n  function balanceOf(address tokenOwner) public constant returns (uint balance);\\n  function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\\n  function transfer(address to, uint256 tokens) public returns (bool success);\\n  function approve(address spender, uint256 tokens) public returns (bool success);\\n  function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\\n\\n  event Transfer(address indexed from, address indexed to, uint tokens);\\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n}\\n\"},\"Pausable.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/* Pausable contract */\\ncontract Pausable is Ownable {\\n\\n    event Pause();\\n    event Unpause();\\n\\n    bool public paused = false;\\n\\n    /** @dev Modifier to make a function callable only when the contract is not paused.\\n      */\\n    modifier whenNotPaused() {\\n        require(!paused);\\n        _;\\n    }\\n\\n    /** @dev Modifier to make a function callable only when the contract is paused.\\n      */\\n    modifier whenPaused() {\\n        require(paused);\\n        _;\\n    }\\n\\n    /** @dev called by the owner to pause, triggers stopped state\\n      */\\n    function pause() onlyOwner whenNotPaused public {\\n        paused = true;\\n        emit Pause();\\n    }\\n\\n    /** @dev called by the owner to unpause, returns to normal state\\n      */\\n    function unpause() onlyOwner whenPaused public {\\n        paused = false;\\n        emit Unpause();\\n    }\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n\"},\"StandardToken.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\u0027./ERC20Token.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\ncontract StandardToken is ERC20Token {\\n\\n  using SafeMath for uint256;\\n\\n  // Global variable to store total number of tokens passed from EmalToken.sol\\n  uint256 _totalSupply;\\n\\n  mapping(address =\\u003e uint256) balances;\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) allowed;\\n\\n\\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address tokenOwner) public view returns (uint256){\\n        return balances[tokenOwner];\\n  }\\n\\n\\n\\n  function transfer(address to, uint256 tokens) public returns (bool){\\n      require(to != address(0));\\n      require(tokens \\u003e 0 \\u0026\\u0026 tokens \\u003c= balances[msg.sender]);\\n\\n      balances[msg.sender] = balances[msg.sender].sub(tokens);\\n      balances[to] = balances[to].add(tokens);\\n      emit Transfer(msg.sender, to, tokens);\\n      return true;\\n  }\\n\\n  // Transfer tokens from one address to another\\n  function transferFrom(address from, address to, uint256 tokens) public returns (bool success){\\n      require(to != address(0));\\n      require(tokens \\u003e 0 \\u0026\\u0026 tokens \\u003c= balances[from]);\\n      require(tokens \\u003c= allowed[from][msg.sender]);\\n\\n      balances[from] = balances[from].sub(tokens);\\n      balances[to] = balances[to].add(tokens);\\n      allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\\n      emit Transfer(from, to, tokens);\\n\\n      return true;\\n  }\\n\\n  // Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n  function approve(address spender, uint256 tokens) public returns (bool success){\\n      allowed[msg.sender][spender] = tokens;\\n      emit Approval(msg.sender, spender, tokens);\\n      return true;\\n  }\\n\\n  // Function to check the amount of tokens that an owner allowed to a spender.\\n  function allowance(address tokenOwner, address spender) public view returns (uint256 remaining){\\n      return allowed[tokenOwner][spender];\\n  }\\n\\n  // Increase the amount of tokens that an owner allowed to a spender.\\n  // approve should be called when allowed[spender] == 0.\\n  // To increment allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\\n  function increaseApproval(address spender, uint256 addedValue) public returns (bool) {\\n    allowed[msg.sender][spender] = (allowed[msg.sender][spender].add(addedValue));\\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  // Decrease the amount of tokens that an owner allowed to a spender.\\n  // approve should be called when allowed[spender] == 0.\\n  // To decrement allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\\n  function decreaseApproval(address spender, uint256 subtractedValue ) public returns (bool){\\n    uint256 oldValue = allowed[msg.sender][spender];\\n    if (subtractedValue \\u003e= oldValue) {\\n      allowed[msg.sender][spender] = 0;\\n    } else {\\n      allowed[msg.sender][spender] = oldValue.sub(subtractedValue);\\n    }\\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n}\\n\"},\"StandardTokenVesting.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./EmalToken.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n/** @title StandardTokenVesting\\n  * @dev A token holder contract that can release its token balance gradually like a\\n  * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the owner.\\n  */\\ncontract StandardTokenVesting is Ownable {\\n  using SafeMath for uint256;\\n\\n  event Released(uint256 amount);\\n  event Revoked();\\n\\n  // beneficiary of tokens after they are released\\n  address public beneficiary;\\n\\n  uint256 public cliff;\\n  uint256 public start;\\n  uint256 public duration;\\n\\n  bool public revocable;\\n\\n  mapping (address =\\u003e uint256) public released;\\n  mapping (address =\\u003e bool) public revoked;\\n\\n\\n  /** @dev Creates a vesting contract that vests its balance of any ERC20 token to the\\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\\n   * of the balance will have vested.\\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\\n   * @param _start the time (as Unix time) at which point vesting starts\\n   * @param _duration duration in seconds of the period in which the tokens will vest\\n   * @param _revocable whether the vesting is revocable or not\\n   */\\n  constructor(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {\\n    require(_beneficiary != address(0));\\n    require(_cliff \\u003c= _duration);\\n\\n    beneficiary = _beneficiary;\\n    revocable = _revocable;\\n    duration = _duration;\\n    owner = msg.sender;\\n    cliff = _start.add(_cliff);\\n    start = _start;\\n  }\\n\\n  /** @notice Transfers vested tokens to beneficiary.\\n    * @param token ERC20 token which is being vested\\n    */\\n  function release(EmalToken token) public returns (bool){\\n    uint256 unreleased = releasableAmount(token);\\n    require(unreleased \\u003e 0);\\n    released[token] = released[token].add(unreleased);\\n\\n    token.transfer(beneficiary, unreleased);\\n    emit Released(unreleased);\\n    return true;\\n  }\\n\\n  /** @notice Allows the owner to revoke the vesting. Tokens already vested\\n    * remain in the contract, the rest are returned to the owner.\\n    * @param token ERC20 token which is being vested\\n    */\\n  function revoke(EmalToken token) public onlyOwner returns(bool) {\\n    require(revocable);\\n    require(!revoked[token]);\\n    uint256 balance = token.balanceOf(this);\\n    uint256 unreleased = releasableAmount(token);\\n    uint256 refund = balance.sub(unreleased);\\n\\n    revoked[token] = true;\\n    token.transfer(owner, refund);\\n    emit Revoked();\\n\\n    return true;\\n  }\\n\\n  /** @dev Calculates the amount that has already vested but hasn\\u0027t been released yet.\\n    * @param token ERC20 token which is being vested\\n    */\\n  function releasableAmount(EmalToken token) public view returns (uint256) {\\n    return vestedAmount(token).sub(released[token]);\\n  }\\n\\n  /** @dev Calculates the amount that has already vested.\\n    * @param token Emal token which is being vested\\n    */\\n  function vestedAmount(EmalToken token) public view returns (uint256) {\\n    uint256 currentBalance = token.balanceOf(this);\\n    uint256 totalBalance = currentBalance.add(released[token]);\\n\\n    if (block.timestamp \\u003c cliff) {\\n      return 0;\\n    } else if (block.timestamp \\u003e= start.add(duration) || revoked[token]) {\\n      return totalBalance;\\n    } else {\\n      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\\n    }\\n  }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsaleAddress\",\"type\":\"address\"}],\"name\":\"setCrowdsaleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTimeForTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTimeForTransfers\",\"type\":\"uint256\"}],\"name\":\"setStartTimeForTokenTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleAddress\",\"type\":\"address\"}],\"name\":\"setPresaleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bountyAddress\",\"type\":\"address\"}],\"name\":\"setBountyAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vestingAddress\",\"type\":\"address\"}],\"name\":\"setVestingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"EmalToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://ed5a77861101fe5ba91c2ec79dde5bdfeb5fb4059c01d9332fb99a5aa6b073ca"}]}