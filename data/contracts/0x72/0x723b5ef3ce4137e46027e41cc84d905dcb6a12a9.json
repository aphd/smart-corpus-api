{"status":"1","message":"OK","result":[{"SourceCode":"{\"ABIResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\n\\ncontract ABIResolver is ResolverBase {\\n    bytes4 constant private ABI_INTERFACE_ID = 0x2203ab56;\\n\\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\\n\\n    mapping(bytes32=\\u003emapping(uint256=\\u003ebytes)) abis;\\n\\n    /**\\n     * Sets the ABI associated with an ENS node.\\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\\n     * the empty string.\\n     * @param node The node to update.\\n     * @param contentType The content type of the ABI\\n     * @param data The ABI data.\\n     */\\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external authorised(node) {\\n        // Content types must be powers of 2\\n        require(((contentType - 1) \\u0026 contentType) == 0);\\n\\n        abis[node][contentType] = data;\\n        emit ABIChanged(node, contentType);\\n    }\\n\\n    /**\\n     * Returns the ABI associated with an ENS node.\\n     * Defined in EIP205.\\n     * @param node The ENS node to query\\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\n     * @return contentType The content type of the return value\\n     * @return data The ABI data\\n     */\\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory) {\\n        mapping(uint256=\\u003ebytes) storage abiset = abis[node];\\n\\n        for (uint256 contentType = 1; contentType \\u003c= contentTypes; contentType \\u003c\\u003c= 1) {\\n            if ((contentType \\u0026 contentTypes) != 0 \\u0026\\u0026 abiset[contentType].length \\u003e 0) {\\n                return (contentType, abiset[contentType]);\\n            }\\n        }\\n\\n        return (0, bytes(\\\"\\\"));\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == ABI_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Collection of functions related to the address type,\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * \\u003e It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n}\\n\"},\"AddrResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\n\\ncontract AddrResolver is ResolverBase {\\n    bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de;\\n\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    mapping(bytes32=\\u003eaddress) addresses;\\n\\n    /**\\n     * Sets the address associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param addr The address to set.\\n     */\\n    function setAddr(bytes32 node, address addr) external authorised(node) {\\n        addresses[node] = addr;\\n        emit AddrChanged(node, addr);\\n    }\\n\\n    /**\\n     * Returns the address associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node) public view returns (address) {\\n        return addresses[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == ADDR_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"bytesUtils.sol\":{\"content\":\"/**\\n *  BytesUtils - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/// @title BytesUtils provides basic byte slicing and casting functionality.\\nlibrary BytesUtils {\\n\\n    using SafeMath for uint256;\\n\\n    /// @dev This function converts to an address\\n    /// @param _bts bytes\\n    /// @param _from start position\\n    function _bytesToAddress(bytes memory _bts, uint _from) internal pure returns (address) {\\n\\n        require(_bts.length \\u003e= _from.add(20), \\\"slicing out of range\\\");\\n\\n        bytes20 convertedAddress;\\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\\n\\n        assembly {\\n            convertedAddress := mload(add(_bts, startByte))\\n        }\\n\\n        return address(convertedAddress);\\n    }\\n\\n    /// @dev This function slices bytes into bytes4\\n    /// @param _bts some bytes\\n    /// @param _from start position\\n    function _bytesToBytes4(bytes memory _bts, uint _from) internal pure returns (bytes4) {\\n        require(_bts.length \\u003e= _from.add(4), \\\"slicing out of range\\\");\\n\\n        bytes4 slicedBytes4;\\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\\n\\n        assembly {\\n            slicedBytes4 := mload(add(_bts, startByte))\\n        }\\n\\n        return slicedBytes4;\\n\\n    }\\n\\n    /// @dev This function slices a uint\\n    /// @param _bts some bytes\\n    /// @param _from start position\\n    // credit to https://ethereum.stackexchange.com/questions/51229/how-to-convert-bytes-to-uint-in-solidity\\n    // and Nick Johnson https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity/4177#4177\\n    function _bytesToUint256(bytes memory _bts, uint _from) internal pure returns (uint) {\\n        require(_bts.length \\u003e= _from.add(32), \\\"slicing out of range\\\");\\n\\n        uint convertedUint256;\\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\\n        \\n        assembly {\\n            convertedUint256 := mload(add(_bts, startByte))\\n        }\\n\\n        return convertedUint256;\\n    }\\n}\\n\"},\"ContentHashResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\n\\ncontract ContentHashResolver is ResolverBase {\\n    bytes4 constant private CONTENT_HASH_INTERFACE_ID = 0xbc1c58d1;\\n\\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\\n\\n    mapping(bytes32=\\u003ebytes) hashes;\\n\\n    /**\\n     * Sets the contenthash associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param hash The contenthash to set\\n     */\\n    function setContenthash(bytes32 node, bytes calldata hash) external authorised(node) {\\n        hashes[node] = hash;\\n        emit ContenthashChanged(node, hash);\\n    }\\n\\n    /**\\n     * Returns the contenthash associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function contenthash(bytes32 node) external view returns (bytes memory) {\\n        return hashes[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == CONTENT_HASH_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"controllable.sol\":{\"content\":\"/**\\n *  Controllable - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./controller.sol\\\";\\nimport \\\"./ensResolvable.sol\\\";\\n\\n\\n/// @title Controllable implements access control functionality of the Controller found via ENS.\\ncontract Controllable is ENSResolvable {\\n    /// @dev Is the registered ENS node identifying the controller contract.\\n    bytes32 private _controllerNode;\\n\\n    /// @notice Constructor initializes the controller contract object.\\n    /// @param _controllerNode_ is the ENS node of the Controller.\\n    constructor(bytes32 _controllerNode_) internal {\\n        _controllerNode = _controllerNode_;\\n    }\\n\\n    /// @notice Checks if message sender is a controller.\\n    modifier onlyController() {\\n        require(_isController(msg.sender), \\\"sender is not a controller\\\");\\n        _;\\n    }\\n\\n    /// @notice Checks if message sender is an admin.\\n    modifier onlyAdmin() {\\n        require(_isAdmin(msg.sender), \\\"sender is not an admin\\\");\\n        _;\\n    }\\n\\n    /// @return the controller node registered in ENS.\\n    function controllerNode() external view returns (bytes32) {\\n        return _controllerNode;\\n    }\\n\\n    /// @return true if the provided account is a controller.\\n    function _isController(address _account) internal view returns (bool) {\\n        return IController(_ensResolve(_controllerNode)).isController(_account);\\n    }\\n\\n    /// @return true if the provided account is an admin.\\n    function _isAdmin(address _account) internal view returns (bool) {\\n        return IController(_ensResolve(_controllerNode)).isAdmin(_account);\\n    }\\n\\n}\\n\"},\"controller.sol\":{\"content\":\"/**\\n *  Controller - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./ownable.sol\\\";\\nimport \\\"./transferrable.sol\\\";\\n\\n/// @title The IController interface provides access to the isController and isAdmin checks.\\ninterface IController {\\n    function isController(address) external view returns (bool);\\n    function isAdmin(address) external view returns (bool);\\n}\\n\\n\\n/// @title Controller stores a list of controller addresses that can be used for authentication in other contracts.\\n/// @notice The Controller implements a hierarchy of concepts, Owner, Admin, and the Controllers.\\n/// @dev Owner can change the Admins\\n/// @dev Admins and can the Controllers\\n/// @dev Controllers are used by the application.\\ncontract Controller is IController, Ownable, Transferrable {\\n\\n    event AddedController(address _sender, address _controller);\\n    event RemovedController(address _sender, address _controller);\\n\\n    event AddedAdmin(address _sender, address _admin);\\n    event RemovedAdmin(address _sender, address _admin);\\n\\n    event Claimed(address _to, address _asset, uint _amount);\\n\\n    event Stopped(address _sender);\\n    event Started(address _sender);\\n\\n    mapping (address =\\u003e bool) private _isAdmin;\\n    uint private _adminCount;\\n\\n    mapping (address =\\u003e bool) private _isController;\\n    uint private _controllerCount;\\n\\n    bool private _stopped;\\n\\n    /// @notice Constructor initializes the owner with the provided address.\\n    /// @param _ownerAddress_ address of the owner.\\n    constructor(address payable _ownerAddress_) Ownable(_ownerAddress_, false) public {}\\n\\n    /// @notice Checks if message sender is an admin.\\n    modifier onlyAdmin() {\\n        require(isAdmin(msg.sender), \\\"sender is not an admin\\\");\\n        _;\\n    }\\n\\n    /// @notice Check if Owner or Admin\\n    modifier onlyAdminOrOwner() {\\n        require(_isOwner(msg.sender) || isAdmin(msg.sender), \\\"sender is not an admin\\\");\\n        _;\\n    }\\n\\n    /// @notice Check if controller is stopped\\n    modifier notStopped() {\\n        require(!isStopped(), \\\"controller is stopped\\\");\\n        _;\\n    }\\n\\n    /// @notice Add a new admin to the list of admins.\\n    /// @param _account address to add to the list of admins.\\n    function addAdmin(address _account) external onlyOwner notStopped {\\n        _addAdmin(_account);\\n    }\\n\\n    /// @notice Remove a admin from the list of admins.\\n    /// @param _account address to remove from the list of admins.\\n    function removeAdmin(address _account) external onlyOwner {\\n        _removeAdmin(_account);\\n    }\\n\\n    /// @return the current number of admins.\\n    function adminCount() external view returns (uint) {\\n        return _adminCount;\\n    }\\n\\n    /// @notice Add a new controller to the list of controllers.\\n    /// @param _account address to add to the list of controllers.\\n    function addController(address _account) external onlyAdminOrOwner notStopped {\\n        _addController(_account);\\n    }\\n\\n    /// @notice Remove a controller from the list of controllers.\\n    /// @param _account address to remove from the list of controllers.\\n    function removeController(address _account) external onlyAdminOrOwner {\\n        _removeController(_account);\\n    }\\n\\n    /// @notice count the Controllers\\n    /// @return the current number of controllers.\\n    function controllerCount() external view returns (uint) {\\n        return _controllerCount;\\n    }\\n\\n    /// @notice is an address an Admin?\\n    /// @return true if the provided account is an admin.\\n    function isAdmin(address _account) public view notStopped returns (bool) {\\n        return _isAdmin[_account];\\n    }\\n\\n    /// @notice is an address a Controller?\\n    /// @return true if the provided account is a controller.\\n    function isController(address _account) public view notStopped returns (bool) {\\n        return _isController[_account];\\n    }\\n\\n    /// @notice this function can be used to see if the controller has been stopped\\n    /// @return true is the Controller has been stopped\\n    function isStopped() public view returns (bool) {\\n        return _stopped;\\n    }\\n\\n    /// @notice Internal-only function that adds a new admin.\\n    function _addAdmin(address _account) private {\\n        require(!_isAdmin[_account], \\\"provided account is already an admin\\\");\\n        require(!_isController[_account], \\\"provided account is already a controller\\\");\\n        require(!_isOwner(_account), \\\"provided account is already the owner\\\");\\n        require(_account != address(0), \\\"provided account is the zero address\\\");\\n        _isAdmin[_account] = true;\\n        _adminCount++;\\n        emit AddedAdmin(msg.sender, _account);\\n    }\\n\\n    /// @notice Internal-only function that removes an existing admin.\\n    function _removeAdmin(address _account) private {\\n        require(_isAdmin[_account], \\\"provided account is not an admin\\\");\\n        _isAdmin[_account] = false;\\n        _adminCount--;\\n        emit RemovedAdmin(msg.sender, _account);\\n    }\\n\\n    /// @notice Internal-only function that adds a new controller.\\n    function _addController(address _account) private {\\n        require(!_isAdmin[_account], \\\"provided account is already an admin\\\");\\n        require(!_isController[_account], \\\"provided account is already a controller\\\");\\n        require(!_isOwner(_account), \\\"provided account is already the owner\\\");\\n        require(_account != address(0), \\\"provided account is the zero address\\\");\\n        _isController[_account] = true;\\n        _controllerCount++;\\n        emit AddedController(msg.sender, _account);\\n    }\\n\\n    /// @notice Internal-only function that removes an existing controller.\\n    function _removeController(address _account) private {\\n        require(_isController[_account], \\\"provided account is not a controller\\\");\\n        _isController[_account] = false;\\n        _controllerCount--;\\n        emit RemovedController(msg.sender, _account);\\n    }\\n\\n    /// @notice stop our controllers and admins from being useable\\n    function stop() external onlyAdminOrOwner {\\n        _stopped = true;\\n        emit Stopped(msg.sender);\\n    }\\n\\n    /// @notice start our controller again\\n    function start() external onlyOwner {\\n        _stopped = false;\\n        emit Started(msg.sender);\\n    }\\n\\n    //// @notice Withdraw tokens from the smart contract to the specified account.\\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin notStopped {\\n        _safeTransfer(_to, _asset, _amount);\\n        emit Claimed(_to, _asset, _amount);\\n    }\\n}\\n\"},\"ENS.sol\":{\"content\":\"/**\\n * BSD 2-Clause License\\n *\\n * Copyright (c) 2018, True Names Limited\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n*/\\npragma solidity ^0.5.0;\\n\\ninterface ENS {\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\\n    function setResolver(bytes32 node, address resolver) external;\\n    function setOwner(bytes32 node, address owner) external;\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n    function owner(bytes32 node) external view returns (address);\\n    function resolver(bytes32 node) external view returns (address);\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n}\\n\"},\"ensResolvable.sol\":{\"content\":\"/**\\n *  ENSResolvable - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./ENS.sol\\\";\\nimport \\\"./PublicResolver.sol\\\";\\n\\n\\n///@title ENSResolvable - Ethereum Name Service Resolver\\n///@notice contract should be used to get an address for an ENS node\\ncontract ENSResolvable {\\n    /// @notice _ens is an instance of ENS\\n    ENS private _ens;\\n\\n    /// @notice _ensRegistry points to the ENS registry smart contract.\\n    address private _ensRegistry;\\n\\n    /// @param _ensReg_ is the ENS registry used\\n    constructor(address _ensReg_) internal {\\n        _ensRegistry = _ensReg_;\\n        _ens = ENS(_ensRegistry);\\n    }\\n\\n    /// @notice this is used to that one can observe which ENS registry is being used\\n    function ensRegistry() external view returns (address) {\\n        return _ensRegistry;\\n    }\\n\\n    /// @notice helper function used to get the address of a node\\n    /// @param _node of the ENS entry that needs resolving\\n    /// @return the address of the said node\\n    function _ensResolve(bytes32 _node) internal view returns (address) {\\n        return PublicResolver(_ens.resolver(_node)).addr(_node);\\n    }\\n\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n/// @title ERC20 interface is a subset of the ERC20 specification.\\n/// @notice see https://github.com/ethereum/EIPs/issues/20\\ninterface ERC20 {\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n    function balanceOf(address _who) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n}\\n\"},\"InterfaceResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\nimport \\\"./AddrResolver.sol\\\";\\n\\ncontract InterfaceResolver is ResolverBase, AddrResolver {\\n    bytes4 constant private INTERFACE_INTERFACE_ID = bytes4(keccak256(\\\"interfaceImplementer(bytes32,bytes4)\\\"));\\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\\n\\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\\n\\n    mapping(bytes32=\\u003emapping(bytes4=\\u003eaddress)) interfaces;\\n\\n    /**\\n     * Sets an interface associated with a name.\\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\\n     * @param node The node to update.\\n     * @param interfaceID The EIP 168 interface ID.\\n     * @param implementer The address of a contract that implements this interface for this node.\\n     */\\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external authorised(node) {\\n        interfaces[node][interfaceID] = implementer;\\n        emit InterfaceChanged(node, interfaceID, implementer);\\n    }\\n\\n    /**\\n     * Returns the address of a contract that implements the specified interface for this name.\\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\\n     * contract implements EIP168 and returns `true` for the specified interfaceID, its address\\n     * will be returned.\\n     * @param node The ENS node to query.\\n     * @param interfaceID The EIP 168 interface ID to check for.\\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\\n     */\\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address) {\\n        address implementer = interfaces[node][interfaceID];\\n        if(implementer != address(0)) {\\n            return implementer;\\n        }\\n\\n        address a = addr(node);\\n        if(a == address(0)) {\\n            return address(0);\\n        }\\n\\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\\\"supportsInterface(bytes4)\\\", INTERFACE_META_ID));\\n        if(!success || returnData.length \\u003c 32 || returnData[31] == 0) {\\n            // EIP 168 not supported by target\\n            return address(0);\\n        }\\n\\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\\\"supportsInterface(bytes4)\\\", interfaceID));\\n        if(!success || returnData.length \\u003c 32 || returnData[31] == 0) {\\n            // Specified interface not supported by target\\n            return address(0);\\n        }\\n\\n        return a;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == INTERFACE_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"NameResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\n\\ncontract NameResolver is ResolverBase {\\n    bytes4 constant private NAME_INTERFACE_ID = 0x691f3431;\\n\\n    event NameChanged(bytes32 indexed node, string name);\\n\\n    mapping(bytes32=\\u003estring) names;\\n\\n    /**\\n     * Sets the name associated with an ENS node, for reverse records.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param name The name to set.\\n     */\\n    function setName(bytes32 node, string calldata name) external authorised(node) {\\n        names[node] = name;\\n        emit NameChanged(node, name);\\n    }\\n\\n    /**\\n     * Returns the name associated with an ENS node, for reverse records.\\n     * Defined in EIP181.\\n     * @param node The ENS node to query.\\n     * @return The associated name.\\n     */\\n    function name(bytes32 node) external view returns (string memory) {\\n        return names[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == NAME_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"ownable.sol\":{\"content\":\"/**\\n *  Ownable - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\n\\n/// @title Ownable has an owner address and provides basic authorization control functions.\\n/// This contract is modified version of the MIT OpenZepplin Ownable contract\\n/// This contract allows for the transferOwnership operation to be made impossible\\n/// https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\\ncontract Ownable {\\n    event TransferredOwnership(address _from, address _to);\\n    event LockedOwnership(address _locked);\\n\\n    address payable private _owner;\\n    bool private _isTransferable;\\n\\n    /// @notice Constructor sets the original owner of the contract and whether or not it is one time transferable.\\n    constructor(address payable _account_, bool _transferable_) internal {\\n        _owner = _account_;\\n        _isTransferable = _transferable_;\\n        // Emit the LockedOwnership event if no longer transferable.\\n        if (!_isTransferable) {\\n            emit LockedOwnership(_account_);\\n        }\\n        emit TransferredOwnership(address(0), _account_);\\n    }\\n\\n    /// @notice Reverts if called by any account other than the owner.\\n    modifier onlyOwner() {\\n        require(_isOwner(msg.sender), \\\"sender is not an owner\\\");\\n        _;\\n    }\\n\\n    /// @notice Allows the current owner to transfer control of the contract to a new address.\\n    /// @param _account address to transfer ownership to.\\n    /// @param _transferable indicates whether to keep the ownership transferable.\\n    function transferOwnership(address payable _account, bool _transferable) external onlyOwner {\\n        // Require that the ownership is transferable.\\n        require(_isTransferable, \\\"ownership is not transferable\\\");\\n        // Require that the new owner is not the zero address.\\n        require(_account != address(0), \\\"owner cannot be set to zero address\\\");\\n        // Set the transferable flag to the value _transferable passed in.\\n        _isTransferable = _transferable;\\n        // Emit the LockedOwnership event if no longer transferable.\\n        if (!_transferable) {\\n            emit LockedOwnership(_account);\\n        }\\n        // Emit the ownership transfer event.\\n        emit TransferredOwnership(_owner, _account);\\n        // Set the owner to the provided address.\\n        _owner = _account;\\n    }\\n\\n    /// @notice check if the ownership is transferable.\\n    /// @return true if the ownership is transferable.\\n    function isTransferable() external view returns (bool) {\\n        return _isTransferable;\\n    }\\n\\n    /// @notice Allows the current owner to relinquish control of the contract.\\n    /// @dev Renouncing to ownership will leave the contract without an owner and unusable.\\n    /// @dev It will not be possible to call the functions with the `onlyOwner` modifier anymore.\\n    function renounceOwnership() external onlyOwner {\\n        // Require that the ownership is transferable.\\n        require(_isTransferable, \\\"ownership is not transferable\\\");\\n        // note that this could be terminal\\n        _owner = address(0);\\n\\n        emit TransferredOwnership(_owner, address(0));\\n    }\\n\\n    /// @notice Find out owner address\\n    /// @return address of the owner.\\n    function owner() public view returns (address payable) {\\n        return _owner;\\n    }\\n\\n    /// @notice Check if owner address\\n    /// @return true if sender is the owner of the contract.\\n    function _isOwner(address _address) internal view returns (bool) {\\n        return _address == _owner;\\n    }\\n}\\n\"},\"PubkeyResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\n\\ncontract PubkeyResolver is ResolverBase {\\n    bytes4 constant private PUBKEY_INTERFACE_ID = 0xc8690233;\\n\\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\\n\\n    struct PublicKey {\\n        bytes32 x;\\n        bytes32 y;\\n    }\\n\\n    mapping(bytes32=\\u003ePublicKey) pubkeys;\\n\\n    /**\\n     * Sets the SECP256k1 public key associated with an ENS node.\\n     * @param node The ENS node to query\\n     * @param x the X coordinate of the curve point for the public key.\\n     * @param y the Y coordinate of the curve point for the public key.\\n     */\\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external authorised(node) {\\n        pubkeys[node] = PublicKey(x, y);\\n        emit PubkeyChanged(node, x, y);\\n    }\\n\\n    /**\\n     * Returns the SECP256k1 public key associated with an ENS node.\\n     * Defined in EIP 619.\\n     * @param node The ENS node to query\\n     * @return x, y the X and Y coordinates of the curve point for the public key.\\n     */\\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y) {\\n        return (pubkeys[node].x, pubkeys[node].y);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == PUBKEY_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"PublicResolver.sol\":{\"content\":\"/**\\n * BSD 2-Clause License\\n *\\n * Copyright (c) 2018, True Names Limited\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n*/\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./ENS.sol\\\";\\nimport \\\"./ABIResolver.sol\\\";\\nimport \\\"./AddrResolver.sol\\\";\\nimport \\\"./ContentHashResolver.sol\\\";\\nimport \\\"./InterfaceResolver.sol\\\";\\nimport \\\"./NameResolver.sol\\\";\\nimport \\\"./PubkeyResolver.sol\\\";\\nimport \\\"./TextResolver.sol\\\";\\n\\n/**\\n * A simple resolver anyone can use; only allows the owner of a node to set its\\n * address.\\n */\\ncontract PublicResolver is ABIResolver, AddrResolver, ContentHashResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\\n    ENS ens;\\n\\n    /**\\n     * A mapping of authorisations. An address that is authorised for a name\\n     * may make any changes to the name that the owner could, but may not update\\n     * the set of authorisations.\\n     * (node, owner, caller) =\\u003e isAuthorised\\n     */\\n    mapping(bytes32=\\u003emapping(address=\\u003emapping(address=\\u003ebool))) public authorisations;\\n\\n    event AuthorisationChanged(bytes32 indexed node, address indexed owner, address indexed target, bool isAuthorised);\\n\\n    constructor(ENS _ens) public {\\n        ens = _ens;\\n    }\\n\\n    /**\\n     * @dev Sets or clears an authorisation.\\n     * Authorisations are specific to the caller. Any account can set an authorisation\\n     * for any name, but the authorisation that is checked will be that of the\\n     * current owner of a name. Thus, transferring a name effectively clears any\\n     * existing authorisations, and new authorisations can be set in advance of\\n     * an ownership transfer if desired.\\n     *\\n     * @param node The name to change the authorisation on.\\n     * @param target The address that is to be authorised or deauthorised.\\n     * @param isAuthorised True if the address should be authorised, or false if it should be deauthorised.\\n     */\\n    function setAuthorisation(bytes32 node, address target, bool isAuthorised) external {\\n        authorisations[node][msg.sender][target] = isAuthorised;\\n        emit AuthorisationChanged(node, msg.sender, target, isAuthorised);\\n    }\\n\\n    function isAuthorised(bytes32 node) internal view returns(bool) {\\n        address owner = ens.owner(node);\\n        return owner == msg.sender || authorisations[node][owner][msg.sender];\\n    }\\n}\\n\"},\"ResolverBase.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ncontract ResolverBase {\\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == INTERFACE_META_ID;\\n    }\\n\\n    function isAuthorised(bytes32 node) internal view returns(bool);\\n\\n    modifier authorised(bytes32 node) {\\n        require(isAuthorised(node));\\n        _;\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"/**\\n * The MIT License (MIT)\\n *\\n * Copyright (c) 2016-2019 zOS Global Limited\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining\\n * a copy of this software and associated documentation files (the\\n * \\\"Software\\\"), to deal in the Software without restriction, including\\n * without limitation the rights to use, copy, modify, merge, publish,\\n * distribute, sublicense, and/or sell copies of the Software, and to\\n * permit persons to whom the Software is furnished to do so, subject to\\n * the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included\\n * in all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(ERC20 token, bytes memory data) internal {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length \\u003e 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"},\"strings.sol\":{\"content\":\"/*\\n * Copyright 2016 Nick Johnson\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n/*\\n * @title String \\u0026 slice utility library for Solidity contracts.\\n * @author Nick Johnson \\u003carachnid@notdot.net\\u003e\\n *\\n * @dev Functionality in this library is largely implemented using an\\n *      abstraction called a \\u0027slice\\u0027. A slice represents a part of a string -\\n *      anything from the entire string to a single character, or even no\\n *      characters at all (a 0-length slice). Since a slice only has to specify\\n *      an offset and a length, copying and manipulating slices is a lot less\\n *      expensive than copying and manipulating the strings they reference.\\n *\\n *      To further reduce gas costs, most functions on slice that need to return\\n *      a slice modify the original one instead of allocating a new one; for\\n *      instance, `s.split(\\\".\\\")` will return the text up to the first \\u0027.\\u0027,\\n *      modifying s to only contain the remainder of the string after the \\u0027.\\u0027.\\n *      In situations where you do not want to modify the original slice, you\\n *      can make a copy first with `.copy()`, for example:\\n *      `s.copy().split(\\\".\\\")`. Try and avoid using this idiom in loops; since\\n *      Solidity has no memory management, it will result in allocating many\\n *      short-lived slices that are later discarded.\\n *\\n *      Functions that return two slices come in two versions: a non-allocating\\n *      version that takes the second slice as an argument, modifying it in\\n *      place, and an allocating version that allocates and returns the second\\n *      slice; see `nextRune` for example.\\n *\\n *      Functions that have to copy string data will return strings rather than\\n *      slices; these can be cast back to slices for further processing if\\n *      required.\\n *\\n *      For convenience, some functions are provided with non-modifying\\n *      variants that create a new slice and return both; for instance,\\n *      `s.splitNew(\\u0027.\\u0027)` leaves s unmodified, and returns two values\\n *      corresponding to the left and right parts of the string.\\n */\\n\\npragma solidity ^0.5.0;\\n\\nlibrary strings {\\n    struct slice {\\n        uint _len;\\n        uint _ptr;\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for(; len \\u003e= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire string.\\n     * @param self The string to make a slice from.\\n     * @return A newly allocated slice containing the entire string.\\n     */\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns the length of a null-terminated bytes32 string.\\n     * @param self The value to find the length of.\\n     * @return The length of the string, from 0 to 32.\\n     */\\n    function len(bytes32 self) internal pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (uint(self) \\u0026 0xffffffffffffffffffffffffffffffff == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (uint(self) \\u0026 0xffffffffffffffff == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (uint(self) \\u0026 0xffffffff == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (uint(self) \\u0026 0xffff == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (uint(self) \\u0026 0xff == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\\n     *      null-terminated utf-8 string.\\n     * @param self The bytes32 value to convert to a slice.\\n     * @return A new slice containing the value of the input argument up to the\\n     *         first null.\\n     */\\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\\n        // Allocate space for `self` in memory, copy it there, and point ret at it\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(0x40, add(ptr, 0x20))\\n            mstore(ptr, self)\\n            mstore(add(ret, 0x20), ptr)\\n        }\\n        ret._len = len(self);\\n    }\\n\\n    /*\\n     * @dev Returns a new slice containing the same data as the current slice.\\n     * @param self The slice to copy.\\n     * @return A new slice containing the same data as `self`.\\n     */\\n    function copy(slice memory self) internal pure returns (slice memory) {\\n        return slice(self._len, self._ptr);\\n    }\\n\\n    /*\\n     * @dev Copies a slice to a new string.\\n     * @param self The slice to copy.\\n     * @return A newly allocated string containing the slice\\u0027s text.\\n     */\\n    function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the length in runes of the slice. Note that this operation\\n     *      takes time proportional to the length of the slice; avoid using it\\n     *      in loops, and call `slice.empty()` if you only need to know whether\\n     *      the slice is empty or not.\\n     * @param self The slice to operate on.\\n     * @return The length of the slice in runes.\\n     */\\n    function len(slice memory self) internal pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr \\u003c end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b \\u003c 0x80) {\\n                ptr += 1;\\n            } else if (b \\u003c 0xE0) {\\n                ptr += 2;\\n            } else if (b \\u003c 0xF0) {\\n                ptr += 3;\\n            } else if (b \\u003c 0xF8) {\\n                ptr += 4;\\n            } else if (b \\u003c 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns true if the slice is empty (has a length of 0).\\n     * @param self The slice to operate on.\\n     * @return True if the slice is empty, False otherwise.\\n     */\\n    function empty(slice memory self) internal pure returns (bool) {\\n        return self._len == 0;\\n    }\\n\\n    /*\\n     * @dev Returns a positive number if `other` comes lexicographically after\\n     *      `self`, a negative number if it comes before, or zero if the\\n     *      contents of the two slices are equal. Comparison is done per-rune,\\n     *      on unicode codepoints.\\n     * @param self The first slice to compare.\\n     * @param other The second slice to compare.\\n     * @return The result of the comparison.\\n     */\\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\\n        uint shortest = self._len;\\n        if (other._len \\u003c self._len)\\n            shortest = other._len;\\n\\n        uint selfptr = self._ptr;\\n        uint otherptr = other._ptr;\\n        for (uint idx = 0; idx \\u003c shortest; idx += 32) {\\n            uint a;\\n            uint b;\\n            assembly {\\n                a := mload(selfptr)\\n                b := mload(otherptr)\\n            }\\n            if (a != b) {\\n                // Mask out irrelevant bytes and check again\\n                uint256 mask = uint256(-1); // 0xffff...\\n                if (shortest \\u003c 32) {\\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\\n                }\\n                uint256 diff = (a \\u0026 mask) - (b \\u0026 mask);\\n                if (diff != 0)\\n                    return int(diff);\\n            }\\n            selfptr += 32;\\n            otherptr += 32;\\n        }\\n        return int(self._len) - int(other._len);\\n    }\\n\\n    /*\\n     * @dev Returns true if the two slices contain the same text.\\n     * @param self The first slice to compare.\\n     * @param self The second slice to compare.\\n     * @return True if the slices are equal, false otherwise.\\n     */\\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\\n        return compare(self, other) == 0;\\n    }\\n\\n    /*\\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\\n     *      slice to point to the next rune and returning `self`.\\n     * @param self The slice to operate on.\\n     * @param rune The slice that will contain the first rune.\\n     * @return `rune`.\\n     */\\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\\n        rune._ptr = self._ptr;\\n\\n        if (self._len == 0) {\\n            rune._len = 0;\\n            return rune;\\n        }\\n\\n        uint l;\\n        uint b;\\n        // Load the first byte of the rune into the LSBs of b\\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\\n        if (b \\u003c 0x80) {\\n            l = 1;\\n        } else if (b \\u003c 0xE0) {\\n            l = 2;\\n        } else if (b \\u003c 0xF0) {\\n            l = 3;\\n        } else {\\n            l = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (l \\u003e self._len) {\\n            rune._len = self._len;\\n            self._ptr += self._len;\\n            self._len = 0;\\n            return rune;\\n        }\\n\\n        self._ptr += l;\\n        self._len -= l;\\n        rune._len = l;\\n        return rune;\\n    }\\n\\n    /*\\n     * @dev Returns the first rune in the slice, advancing the slice to point\\n     *      to the next rune.\\n     * @param self The slice to operate on.\\n     * @return A slice containing only the first rune from `self`.\\n     */\\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\\n        nextRune(self, ret);\\n    }\\n\\n    /*\\n     * @dev Returns the number of the first codepoint in the slice.\\n     * @param self The slice to operate on.\\n     * @return The number of the first codepoint in the slice.\\n     */\\n    function ord(slice memory self) internal pure returns (uint ret) {\\n        if (self._len == 0) {\\n            return 0;\\n        }\\n\\n        uint word;\\n        uint length;\\n        uint divisor = 2 ** 248;\\n\\n        // Load the rune into the MSBs of b\\n        assembly { word:= mload(mload(add(self, 32))) }\\n        uint b = word / divisor;\\n        if (b \\u003c 0x80) {\\n            ret = b;\\n            length = 1;\\n        } else if (b \\u003c 0xE0) {\\n            ret = b \\u0026 0x1F;\\n            length = 2;\\n        } else if (b \\u003c 0xF0) {\\n            ret = b \\u0026 0x0F;\\n            length = 3;\\n        } else {\\n            ret = b \\u0026 0x07;\\n            length = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (length \\u003e self._len) {\\n            return 0;\\n        }\\n\\n        for (uint i = 1; i \\u003c length; i++) {\\n            divisor = divisor / 256;\\n            b = (word / divisor) \\u0026 0xFF;\\n            if (b \\u0026 0xC0 != 0x80) {\\n                // Invalid UTF-8 sequence\\n                return 0;\\n            }\\n            ret = (ret * 64) | (b \\u0026 0x3F);\\n        }\\n\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the keccak-256 hash of the slice.\\n     * @param self The slice to hash.\\n     * @return The hash of the slice.\\n     */\\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\\n        assembly {\\n            ret := keccak256(mload(add(self, 32)), mload(self))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns true if `self` starts with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\\n        if (self._len \\u003c needle._len) {\\n            return false;\\n        }\\n\\n        if (self._ptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let selfptr := mload(add(self, 0x20))\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` starts with `needle`, `needle` is removed from the\\n     *      beginning of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        if (self._len \\u003c needle._len) {\\n            return self;\\n        }\\n\\n        bool equal = true;\\n        if (self._ptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let selfptr := mload(add(self, 0x20))\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n            self._ptr += needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Returns true if the slice ends with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\\n        if (self._len \\u003c needle._len) {\\n            return false;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n\\n        if (selfptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` ends with `needle`, `needle` is removed from the\\n     *      end of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        if (self._len \\u003c needle._len) {\\n            return self;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n        bool equal = true;\\n        if (selfptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    // Returns the memory address of the first byte of the first occurrence of\\n    // `needle` in `self`, or the first byte after `self` if not found.\\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr = selfptr;\\n        uint idx;\\n\\n        if (needlelen \\u003c= selflen) {\\n            if (needlelen \\u003c= 32) {\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly { needledata := and(mload(needleptr), mask) }\\n\\n                uint end = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly { ptrdata := and(mload(ptr), mask) }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr \\u003e= end)\\n                        return selfptr + selflen;\\n                    ptr++;\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\n                }\\n                return ptr;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly { hash := keccak256(needleptr, needlelen) }\\n\\n                for (idx = 0; idx \\u003c= selflen - needlelen; idx++) {\\n                    bytes32 testHash;\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\n                    if (hash == testHash)\\n                        return ptr;\\n                    ptr += 1;\\n                }\\n            }\\n        }\\n        return selfptr + selflen;\\n    }\\n\\n    // Returns the memory address of the first byte after the last occurrence of\\n    // `needle` in `self`, or the address of `self` if not found.\\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr;\\n\\n        if (needlelen \\u003c= selflen) {\\n            if (needlelen \\u003c= 32) {\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly { needledata := and(mload(needleptr), mask) }\\n\\n                ptr = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly { ptrdata := and(mload(ptr), mask) }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr \\u003c= selfptr)\\n                        return selfptr;\\n                    ptr--;\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\n                }\\n                return ptr + needlelen;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly { hash := keccak256(needleptr, needlelen) }\\n                ptr = selfptr + (selflen - needlelen);\\n                while (ptr \\u003e= selfptr) {\\n                    bytes32 testHash;\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\n                    if (hash == testHash)\\n                        return ptr + needlelen;\\n                    ptr -= 1;\\n                }\\n            }\\n        }\\n        return selfptr;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain everything from the first occurrence of\\n     *      `needle` to the end of the slice. `self` is set to the empty slice\\n     *      if `needle` is not found.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len -= ptr - self._ptr;\\n        self._ptr = ptr;\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain the part of the string from the start of\\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\\n     *      is not found, `self` is set to the empty slice.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len = ptr - self._ptr;\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and `token` to everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = self._ptr;\\n        token._len = ptr - self._ptr;\\n        if (ptr == self._ptr + self._len) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n            self._ptr = ptr + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and returning everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` up to the first occurrence of `delim`.\\n     */\\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\n        split(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything before the last\\n     *      occurrence of `needle`, and `token` to everything after it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = ptr;\\n        token._len = self._len - (ptr - self._ptr);\\n        if (ptr == self._ptr) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything before the last\\n     *      occurrence of `needle`, and returning everything after it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` after the last occurrence of `delim`.\\n     */\\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\n        rsplit(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return The number of occurrences of `needle` found in `self`.\\n     */\\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\\n        while (ptr \\u003c= self._ptr + self._len) {\\n            cnt++;\\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns True if `self` contains `needle`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return True if `needle` is found in `self`, false otherwise.\\n     */\\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\\n    }\\n\\n    /*\\n     * @dev Returns a newly allocated string containing the concatenation of\\n     *      `self` and `other`.\\n     * @param self The first slice to concatenate.\\n     * @param other The second slice to concatenate.\\n     * @return The concatenation of the two strings.\\n     */\\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\\n        string memory ret = new string(self._len + other._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n        memcpy(retptr, self._ptr, self._len);\\n        memcpy(retptr + self._len, other._ptr, other._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\\n     *      newly allocated string.\\n     * @param self The delimiter to use.\\n     * @param parts A list of slices to join.\\n     * @return A newly allocated string containing all the slices in `parts`,\\n     *         joined with `self`.\\n     */\\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\\n        if (parts.length == 0)\\n            return \\\"\\\";\\n\\n        uint length = self._len * (parts.length - 1);\\n        for (uint i = 0; i \\u003c parts.length; i++) {\\n            length += parts[i]._len;\\n        }\\n\\n        string memory ret = new string(length);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        for (uint i = 0; i \\u003c parts.length; i++) {\\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\\n            retptr += parts[i]._len;\\n            if (i \\u003c parts.length - 1) {\\n                memcpy(retptr, self._ptr, self._len);\\n                retptr += self._len;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n}\\n\"},\"TextResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\n\\ncontract TextResolver is ResolverBase {\\n    bytes4 constant private TEXT_INTERFACE_ID = 0x59d1d43c;\\n\\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\\n\\n    mapping(bytes32=\\u003emapping(string=\\u003estring)) texts;\\n\\n    /**\\n     * Sets the text data associated with an ENS node and key.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param key The key to set.\\n     * @param value The text data value to set.\\n     */\\n    function setText(bytes32 node, string calldata key, string calldata value) external authorised(node) {\\n        texts[node][key] = value;\\n        emit TextChanged(node, key, key);\\n    }\\n\\n    /**\\n     * Returns the text data associated with an ENS node and key.\\n     * @param node The ENS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(bytes32 node, string calldata key) external view returns (string memory) {\\n        return texts[node][key];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == TEXT_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"tokenWhitelist.sol\":{\"content\":\"/**\\n *  TokenWhitelist - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./controllable.sol\\\";\\nimport \\\"./transferrable.sol\\\";\\nimport \\\"./bytesUtils.sol\\\";\\nimport \\\"./strings.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/// @title The ITokenWhitelist interface provides access to a whitelist of tokens.\\ninterface ITokenWhitelist {\\n    function getTokenInfo(address) external view returns (string memory, uint256, uint256, bool, bool, bool, uint256);\\n    function getStablecoinInfo() external view returns (string memory, uint256, uint256, bool, bool, bool, uint256);\\n    function tokenAddressArray() external view returns (address[] memory);\\n    function redeemableTokens() external view returns (address[] memory);\\n    function methodIdWhitelist(bytes4) external view returns (bool);\\n    function getERC20RecipientAndAmount(address, bytes calldata) external view returns (address, uint);\\n    function stablecoin() external view returns (address);\\n    function updateTokenRate(address, uint, uint) external;\\n}\\n\\n\\n/// @title TokenWhitelist stores a list of tokens used by the Consumer Contract Wallet, the Oracle, the TKN Holder and the TKN Licence Contract\\ncontract TokenWhitelist is ENSResolvable, Controllable, Transferrable {\\n    using strings for *;\\n    using SafeMath for uint256;\\n    using BytesUtils for bytes;\\n\\n    event UpdatedTokenRate(address _sender, address _token, uint _rate);\\n\\n    event UpdatedTokenLoadable(address _sender, address _token, bool _loadable);\\n    event UpdatedTokenRedeemable(address _sender, address _token, bool _redeemable);\\n\\n    event AddedToken(address _sender, address _token, string _symbol, uint _magnitude, bool _loadable, bool _redeemable);\\n    event RemovedToken(address _sender, address _token);\\n\\n    event AddedMethodId(bytes4 _methodId);\\n    event RemovedMethodId(bytes4 _methodId);\\n    event AddedExclusiveMethod(address _token, bytes4 _methodId);\\n    event RemovedExclusiveMethod(address _token, bytes4 _methodId);\\n\\n    event Claimed(address _to, address _asset, uint _amount);\\n\\n    /// @dev these are the methods whitelisted by default in executeTransaction() for protected tokens\\n    bytes4 private constant _APPROVE = 0x095ea7b3; // keccak256(approve(address,uint256)) =\\u003e 0x095ea7b3\\n    bytes4 private constant _BURN = 0x42966c68; // keccak256(burn(uint256)) =\\u003e 0x42966c68\\n    bytes4 private constant _TRANSFER= 0xa9059cbb; // keccak256(transfer(address,uint256)) =\\u003e 0xa9059cbb\\n    bytes4 private constant _TRANSFER_FROM = 0x23b872dd; // keccak256(transferFrom(address,address,uint256)) =\\u003e 0x23b872dd\\n\\n    struct Token {\\n        string symbol;    // Token symbol\\n        uint magnitude;   // 10^decimals\\n        uint rate;        // Token exchange rate in wei\\n        bool available;   // Flags if the token is available or not\\n        bool loadable;    // Flags if token is loadable to the TokenCard\\n        bool redeemable;    // Flags if token is redeemable in the TKN Holder contract\\n        uint lastUpdate;  // Time of the last rate update\\n    }\\n\\n    mapping(address =\\u003e Token) private _tokenInfoMap;\\n\\n    // @notice specifies whitelisted methodIds for protected tokens in wallet\\u0027s excuteTranaction() e.g. keccak256(transfer(address,uint256)) =\\u003e 0xa9059cbb\\n    mapping(bytes4 =\\u003e bool) private _methodIdWhitelist;\\n\\n    address[] private _tokenAddressArray;\\n\\n    /// @notice keeping track of how many redeemable tokens are in the tokenWhitelist\\n    uint private _redeemableCounter;\\n\\n    /// @notice Address of the stablecoin.\\n    address private _stablecoin;\\n\\n    /// @notice is registered ENS node identifying the oracle contract.\\n    bytes32 private _oracleNode;\\n\\n    /// @notice Constructor initializes ENSResolvable, and Controllable.\\n    /// @param _ens_ is the ENS registry address.\\n    /// @param _oracleNode_ is the ENS node of the Oracle.\\n    /// @param _controllerNode_ is our Controllers node.\\n    /// @param _stablecoinAddress_ is the address of the stablecoint used by the wallet for the card load limit.\\n    constructor(address _ens_, bytes32 _oracleNode_, bytes32 _controllerNode_, address _stablecoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNode_) public {\\n        _oracleNode = _oracleNode_;\\n        _stablecoin = _stablecoinAddress_;\\n        //a priori ERC20 whitelisted methods\\n        _methodIdWhitelist[_APPROVE] = true;\\n        _methodIdWhitelist[_BURN] = true;\\n        _methodIdWhitelist[_TRANSFER] = true;\\n        _methodIdWhitelist[_TRANSFER_FROM] = true;\\n    }\\n\\n    modifier onlyAdminOrOracle() {\\n        address oracleAddress = _ensResolve(_oracleNode);\\n        require (_isAdmin(msg.sender) || msg.sender == oracleAddress, \\\"either oracle or admin\\\");\\n        _;\\n    }\\n\\n    /// @notice Add ERC20 tokens to the list of whitelisted tokens.\\n    /// @param _tokens ERC20 token contract addresses.\\n    /// @param _symbols ERC20 token names.\\n    /// @param _magnitude 10 to the power of number of decimal places used by each ERC20 token.\\n    /// @param _loadable is a bool that states whether or not a token is loadable to the TokenCard.\\n    /// @param _redeemable is a bool that states whether or not a token is redeemable in the TKN Holder Contract.\\n    /// @param _lastUpdate is a unit representing an ISO datetime e.g. 20180913153211.\\n    function addTokens(address[] calldata _tokens, bytes32[] calldata _symbols, uint[] calldata _magnitude, bool[] calldata _loadable, bool[] calldata _redeemable, uint _lastUpdate) external onlyAdmin {\\n        // Require that all parameters have the same length.\\n        require(_tokens.length == _symbols.length \\u0026\\u0026 _tokens.length == _magnitude.length \\u0026\\u0026 _tokens.length == _loadable.length \\u0026\\u0026 _tokens.length == _loadable.length, \\\"parameter lengths do not match\\\");\\n        // Add each token to the list of supported tokens.\\n        for (uint i = 0; i \\u003c _tokens.length; i++) {\\n            // Require that the token isn\\u0027t already available.\\n            require(!_tokenInfoMap[_tokens[i]].available, \\\"token already available\\\");\\n            // Store the intermediate values.\\n            string memory symbol = _symbols[i].toSliceB32().toString();\\n            // Add the token to the token list.\\n            _tokenInfoMap[_tokens[i]] = Token({\\n                symbol : symbol,\\n                magnitude : _magnitude[i],\\n                rate : 0,\\n                available : true,\\n                loadable : _loadable[i],\\n                redeemable: _redeemable[i],\\n                lastUpdate : _lastUpdate\\n                });\\n            // Add the token address to the address list.\\n            _tokenAddressArray.push(_tokens[i]);\\n            //if the token is redeemable increase the redeemableCounter\\n            if (_redeemable[i]){\\n                _redeemableCounter = _redeemableCounter.add(1);\\n            }\\n            // Emit token addition event.\\n            emit AddedToken(msg.sender, _tokens[i], symbol, _magnitude[i], _loadable[i], _redeemable[i]);\\n        }\\n    }\\n\\n    /// @notice Remove ERC20 tokens from the whitelist of tokens.\\n    /// @param _tokens ERC20 token contract addresses.\\n    function removeTokens(address[] calldata _tokens) external onlyAdmin {\\n        // Delete each token object from the list of supported tokens based on the addresses provided.\\n        for (uint i = 0; i \\u003c _tokens.length; i++) {\\n            // Store the token address.\\n            address token = _tokens[i];\\n            //token must be available, reverts on duplicates as well\\n            require(_tokenInfoMap[token].available, \\\"token is not available\\\");\\n            //if the token is redeemable decrease the redeemableCounter\\n            if (_tokenInfoMap[token].redeemable){\\n                _redeemableCounter = _redeemableCounter.sub(1);\\n            }\\n            // Delete the token object.\\n            delete _tokenInfoMap[token];\\n            // Remove the token address from the address list.\\n            for (uint j = 0; j \\u003c _tokenAddressArray.length.sub(1); j++) {\\n                if (_tokenAddressArray[j] == token) {\\n                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\\n                    break;\\n                }\\n            }\\n            _tokenAddressArray.length--;\\n            // Emit token removal event.\\n            emit RemovedToken(msg.sender, token);\\n        }\\n    }\\n\\n    /// @notice based on the method it returns the recipient address and amount/value, ERC20 specific.\\n    /// @param _data is the transaction payload.\\n    function getERC20RecipientAndAmount(address _token, bytes calldata _data) external view returns (address, uint) {\\n        // Require that there exist enough bytes for encoding at least a method signature + data in the transaction payload:\\n        // 4 (signature)  + 32(address or uint256)\\n        require(_data.length \\u003e= 4 + 32, \\\"not enough method-encoding bytes\\\");\\n        // Get the method signature\\n        bytes4 signature = _data._bytesToBytes4(0);\\n        // Check if method Id is supported\\n        require(isERC20MethodSupported(_token, signature), \\\"unsupported method\\\");\\n        // returns the recipient\\u0027s address and amount is the value to be transferred\\n        if (signature == _BURN) {\\n            // 4 (signature) + 32(uint256)\\n            return (_token, _data._bytesToUint256(4));\\n        } else if (signature == _TRANSFER_FROM) {\\n            // 4 (signature) + 32(address) + 32(address) + 32(uint256)\\n            require(_data.length \\u003e= 4 + 32 + 32 + 32, \\\"not enough data for transferFrom\\\");\\n            return ( _data._bytesToAddress(4 + 32 + 12), _data._bytesToUint256(4 + 32 + 32));\\n        } else { //transfer or approve\\n            // 4 (signature) + 32(address) + 32(uint)\\n            require(_data.length \\u003e= 4 + 32 + 32, \\\"not enough data for transfer/appprove\\\");\\n            return (_data._bytesToAddress(4 + 12), _data._bytesToUint256(4 + 32));\\n        }\\n    }\\n\\n    /// @notice Toggles whether or not a token is loadable or not.\\n    function setTokenLoadable(address _token, bool _loadable) external onlyAdmin {\\n        // Require that the token exists.\\n        require(_tokenInfoMap[_token].available, \\\"token is not available\\\");\\n\\n        // this sets the loadable flag to the value passed in\\n        _tokenInfoMap[_token].loadable = _loadable;\\n\\n        emit UpdatedTokenLoadable(msg.sender, _token, _loadable);\\n    }\\n\\n    /// @notice Toggles whether or not a token is redeemable or not.\\n    function setTokenRedeemable(address _token, bool _redeemable) external onlyAdmin {\\n        // Require that the token exists.\\n        require(_tokenInfoMap[_token].available, \\\"token is not available\\\");\\n\\n        // this sets the redeemable flag to the value passed in\\n        _tokenInfoMap[_token].redeemable = _redeemable;\\n\\n        emit UpdatedTokenRedeemable(msg.sender, _token, _redeemable);\\n    }\\n\\n    /// @notice Update ERC20 token exchange rate.\\n    /// @param _token ERC20 token contract address.\\n    /// @param _rate ERC20 token exchange rate in wei.\\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\\n    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyAdminOrOracle {\\n        // Require that the token exists.\\n        require(_tokenInfoMap[_token].available, \\\"token is not available\\\");\\n        // Update the token\\u0027s rate.\\n        _tokenInfoMap[_token].rate = _rate;\\n        // Update the token\\u0027s last update timestamp.\\n        _tokenInfoMap[_token].lastUpdate = _updateDate;\\n        // Emit the rate update event.\\n        emit UpdatedTokenRate(msg.sender, _token, _rate);\\n    }\\n\\n    //// @notice Withdraw tokens from the smart contract to the specified account.\\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin {\\n        _safeTransfer(_to, _asset, _amount);\\n        emit Claimed(_to, _asset, _amount);\\n    }\\n\\n    /// @notice This returns all of the fields for a given token.\\n    /// @param _a is the address of a given token.\\n    /// @return string of the token\\u0027s symbol.\\n    /// @return uint of the token\\u0027s magnitude.\\n    /// @return uint of the token\\u0027s exchange rate to ETH.\\n    /// @return bool whether the token is available.\\n    /// @return bool whether the token is loadable to the TokenCard.\\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\\n    /// @return uint of the lastUpdated time of the token\\u0027s exchange rate.\\n    function getTokenInfo(address _a) external view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\\n        Token storage tokenInfo = _tokenInfoMap[_a];\\n        return (tokenInfo.symbol, tokenInfo.magnitude, tokenInfo.rate, tokenInfo.available, tokenInfo.loadable, tokenInfo.redeemable, tokenInfo.lastUpdate);\\n    }\\n\\n    /// @notice This returns all of the fields for our StableCoin.\\n    /// @return string of the token\\u0027s symbol.\\n    /// @return uint of the token\\u0027s magnitude.\\n    /// @return uint of the token\\u0027s exchange rate to ETH.\\n    /// @return bool whether the token is available.\\n    /// @return bool whether the token is loadable to the TokenCard.\\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\\n    /// @return uint of the lastUpdated time of the token\\u0027s exchange rate.\\n    function getStablecoinInfo() external view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\\n        Token storage stablecoinInfo = _tokenInfoMap[_stablecoin];\\n        return (stablecoinInfo.symbol, stablecoinInfo.magnitude, stablecoinInfo.rate, stablecoinInfo.available, stablecoinInfo.loadable, stablecoinInfo.redeemable, stablecoinInfo.lastUpdate);\\n    }\\n\\n    /// @notice This returns an array of all whitelisted token addresses.\\n    /// @return address[] of whitelisted tokens.\\n    function tokenAddressArray() external view returns (address[] memory) {\\n        return _tokenAddressArray;\\n    }\\n\\n    /// @notice This returns an array of all redeemable token addresses.\\n    /// @return address[] of redeemable tokens.\\n    function redeemableTokens() external view returns (address[] memory) {\\n        address[] memory redeemableAddresses = new address[](_redeemableCounter);\\n        uint redeemableIndex = 0;\\n        for (uint i = 0; i \\u003c _tokenAddressArray.length; i++) {\\n            address token = _tokenAddressArray[i];\\n            if (_tokenInfoMap[token].redeemable){\\n                redeemableAddresses[redeemableIndex] = token;\\n                redeemableIndex += 1;\\n            }\\n        }\\n        return redeemableAddresses;\\n    }\\n\\n\\n    /// @notice This returns true if a method Id is supported for the specific token.\\n    /// @return true if _methodId is supported in general or just for the specific token.\\n    function isERC20MethodSupported(address _token, bytes4 _methodId) public view returns (bool) {\\n        require(_tokenInfoMap[_token].available, \\\"non-existing token\\\");\\n        return (_methodIdWhitelist[_methodId]);\\n    }\\n\\n    /// @notice This returns true if the method is supported for all protected tokens.\\n    /// @return true if _methodId is in the method whitelist.\\n    function isERC20MethodWhitelisted(bytes4 _methodId) external view returns (bool) {\\n        return (_methodIdWhitelist[_methodId]);\\n    }\\n\\n    /// @notice This returns the number of redeemable tokens.\\n    /// @return current # of redeemables.\\n    function redeemableCounter() external view returns (uint) {\\n        return _redeemableCounter;\\n    }\\n\\n    /// @notice This returns the address of our stablecoin of choice.\\n    /// @return the address of the stablecoin contract.\\n    function stablecoin() external view returns (address) {\\n        return _stablecoin;\\n    }\\n\\n    /// @notice this returns the node hash of our Oracle.\\n    /// @return the oracle node registered in ENS.\\n    function oracleNode() external view returns (bytes32) {\\n        return _oracleNode;\\n    }\\n}\\n\"},\"transferrable.sol\":{\"content\":\"/**\\n *  Transferrable - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\n\\n/// @title SafeTransfer, allowing contract to withdraw tokens accidentally sent to itself\\ncontract Transferrable {\\n\\n    using SafeERC20 for ERC20;\\n\\n\\n    /// @dev This function is used to move tokens sent accidentally to this contract method.\\n    /// @dev The owner can chose the new destination address\\n    /// @param _to is the recipient\\u0027s address.\\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\\n    /// @param _amount is the amount to be transferred in base units.\\n    function _safeTransfer(address payable _to, address _asset, uint _amount) internal {\\n        // address(0) is used to denote ETH\\n        if (_asset == address(0)) {\\n            _to.transfer(_amount);\\n        } else {\\n            ERC20(_asset).safeTransfer(_to, _amount);\\n        }\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"redeemableCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_methodId\",\"type\":\"bytes4\"}],\"name\":\"isERC20MethodWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"getTokenInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_symbols\",\"type\":\"bytes32[]\"},{\"name\":\"_magnitude\",\"type\":\"uint256[]\"},{\"name\":\"_loadable\",\"type\":\"bool[]\"},{\"name\":\"_redeemable\",\"type\":\"bool[]\"},{\"name\":\"_lastUpdate\",\"type\":\"uint256\"}],\"name\":\"addTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStablecoinInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddressArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"redeemableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_redeemable\",\"type\":\"bool\"}],\"name\":\"setTokenRedeemable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_methodId\",\"type\":\"bytes4\"}],\"name\":\"isERC20MethodSupported\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"removeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ensRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_loadable\",\"type\":\"bool\"}],\"name\":\"setTokenLoadable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_asset\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"getERC20RecipientAndAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_updateDate\",\"type\":\"uint256\"}],\"name\":\"updateTokenRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllerNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stablecoin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ens_\",\"type\":\"address\"},{\"name\":\"_oracleNode_\",\"type\":\"bytes32\"},{\"name\":\"_controllerNode_\",\"type\":\"bytes32\"},{\"name\":\"_stablecoinAddress_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"UpdatedTokenRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_loadable\",\"type\":\"bool\"}],\"name\":\"UpdatedTokenLoadable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_redeemable\",\"type\":\"bool\"}],\"name\":\"UpdatedTokenRedeemable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_symbol\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_magnitude\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_loadable\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_redeemable\",\"type\":\"bool\"}],\"name\":\"AddedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"RemovedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_methodId\",\"type\":\"bytes4\"}],\"name\":\"AddedMethodId\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_methodId\",\"type\":\"bytes4\"}],\"name\":\"RemovedMethodId\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_methodId\",\"type\":\"bytes4\"}],\"name\":\"AddedExclusiveMethod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_methodId\",\"type\":\"bytes4\"}],\"name\":\"RemovedExclusiveMethod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"}]","ContractName":"TokenWhitelist","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b3e6619339eb0a070dc69fcbd6cad36c338032c0c9750e26b8b76ab1ec06aa3d87f2ce995617d2816b426c5c8698c5ec2952f7a34bb10f38326f74933d5893697000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://b9d0cff30fd06ec46b310e69c7459f33f14b7e95655e2e7621c17dae70fc5754"}]}