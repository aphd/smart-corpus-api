{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Claimable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() public onlyPendingOwner {\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20Basic compatible tokens\r\n   * @param _token ERC20Basic The address of the token contract\r\n   */\r\n  function reclaimToken(ERC20Basic _token) external onlyOwner {\r\n    uint256 balance = _token.balanceOf(this);\r\n    _token.safeTransfer(owner, balance);\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/HasNoEther.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should not own Ether\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\r\n * in the contract, it will allow the owner to reclaim this Ether.\r\n * @notice Ether can still be sent to this contract by:\r\n * calling functions labeled `payable`\r\n * `selfdestruct(contract_address)`\r\n * mining directly to the contract address\r\n */\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  constructor() public payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by setting a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    owner.transfer(address(this).balance);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/HasNoTokens.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should not own Tokens\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.\r\n * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\r\n * owner to reclaim the tokens.\r\n */\r\ncontract HasNoTokens is CanReclaimToken {\r\n\r\n /**\r\n  * @dev Reject all ERC223 compatible tokens\r\n  * @param _from address The address that is transferring the tokens\r\n  * @param _value uint256 the amount of the specified token\r\n  * @param _data Bytes The data passed from the caller.\r\n  */\r\n  function tokenFallback(\r\n    address _from,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    external\r\n    pure\r\n  {\r\n    _from;\r\n    _value;\r\n    _data;\r\n    revert();\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/HasNoContracts.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should not own Contracts\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\r\n * of this contract to reclaim ownership of the contracts.\r\n */\r\ncontract HasNoContracts is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim ownership of Ownable contracts\r\n   * @param _contractAddr The address of the Ownable to be reclaimed.\r\n   */\r\n  function reclaimContract(address _contractAddr) external onlyOwner {\r\n    Ownable contractInst = Ownable(_contractAddr);\r\n    contractInst.transferOwnership(owner);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/NoOwner.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Base contract for contracts that should not own things.\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or\r\n * Owned contracts. See respective base contracts for details.\r\n */\r\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Destructible.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Destructible\r\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\r\n */\r\ncontract Destructible is Ownable {\r\n  /**\r\n   * @dev Transfers the current balance to the owner and terminates the contract.\r\n   */\r\n  function destroy() public onlyOwner {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function destroyAndSend(address _recipient) public onlyOwner {\r\n    selfdestruct(_recipient);\r\n  }\r\n}\r\n\r\n// File: contracts/IERC20.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/TokenStorageLib.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/** @title TokenStorageLib\r\n * @dev Implementation of an[external storage for tokens.\r\n */\r\nlibrary TokenStorageLib {\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct TokenStorage {\r\n        mapping (address => uint) balances;\r\n        mapping (address => mapping (address => uint)) allowed;\r\n        uint totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Increases balance of an address.\r\n     * @param self Token storage to operate on.\r\n     * @param to Address to increase.\r\n     * @param amount Number of units to add.\r\n     */\r\n    function addBalance(TokenStorage storage self, address to, uint amount)\r\n        external\r\n    {\r\n        self.totalSupply = self.totalSupply.add(amount);\r\n        self.balances[to] = self.balances[to].add(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Decreases balance of an address.\r\n     * @param self Token storage to operate on.\r\n     * @param from Address to decrease.\r\n     * @param amount Number of units to subtract.\r\n     */\r\n    function subBalance(TokenStorage storage self, address from, uint amount)\r\n        external\r\n    {\r\n        self.totalSupply = self.totalSupply.sub(amount);\r\n        self.balances[from] = self.balances[from].sub(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the allowance for a spender.\r\n     * @param self Token storage to operate on.\r\n     * @param owner Address of the owner of the tokens to spend.\r\n     * @param spender Address of the spender.\r\n     * @param amount Qunatity of allowance.\r\n     */\r\n    function setAllowed(TokenStorage storage self, address owner, address spender, uint amount)\r\n        external\r\n    {\r\n        self.allowed[owner][spender] = amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the supply of tokens.\r\n     * @param self Token storage to operate on.\r\n     * @return Total supply.\r\n     */\r\n    function getSupply(TokenStorage storage self)\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return self.totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the balance of an address.\r\n     * @param self Token storage to operate on.\r\n     * @param who Address to lookup.\r\n     * @return Number of units.\r\n     */\r\n    function getBalance(TokenStorage storage self, address who)\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return self.balances[who];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the allowance for a spender.\r\n     * @param self Token storage to operate on.\r\n     * @param owner Address of the owner of the tokens to spend.\r\n     * @param spender Address of the spender.\r\n     * @return Number of units.\r\n     */\r\n    function getAllowed(TokenStorage storage self, address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return self.allowed[owner][spender];\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/TokenStorage.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenStorage\r\n * @dev External storage for tokens.\r\n * The storage is implemented in a separate contract to maintain state\r\n * between token upgrades.\r\n */\r\ncontract TokenStorage is Claimable, CanReclaimToken, NoOwner {\r\n\r\n    using TokenStorageLib for TokenStorageLib.TokenStorage;\r\n\r\n    TokenStorageLib.TokenStorage internal tokenStorage;\r\n\r\n    /**\r\n     * @dev Increases balance of an address.\r\n     * @param to Address to increase.\r\n     * @param amount Number of units to add.\r\n     */\r\n    function addBalance(address to, uint amount) external onlyOwner {\r\n        tokenStorage.addBalance(to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Decreases balance of an address.\r\n     * @param from Address to decrease.\r\n     * @param amount Number of units to subtract.\r\n     */\r\n    function subBalance(address from, uint amount) external onlyOwner {\r\n        tokenStorage.subBalance(from, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the allowance for a spender.\r\n     * @param owner Address of the owner of the tokens to spend.\r\n     * @param spender Address of the spender.\r\n     * @param amount Qunatity of allowance.\r\n     */\r\n    function setAllowed(address owner, address spender, uint amount) external onlyOwner {\r\n        tokenStorage.setAllowed(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the supply of tokens.\r\n     * @return Total supply.\r\n     */\r\n    function getSupply() external view returns (uint) {\r\n        return tokenStorage.getSupply();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the balance of an address.\r\n     * @param who Address to lookup.\r\n     * @return Number of units.\r\n     */\r\n    function getBalance(address who) external view returns (uint) {\r\n        return tokenStorage.getBalance(who);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the allowance for a spender.\r\n     * @param owner Address of the owner of the tokens to spend.\r\n     * @param spender Address of the spender.\r\n     * @return Number of units.\r\n     */\r\n    function getAllowed(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return tokenStorage.getAllowed(owner, spender);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/ERC20Lib.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Lib\r\n * @dev Standard ERC20 token functionality.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n */\r\nlibrary ERC20Lib {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     * @dev Transfers tokens [ERC20].\r\n     * @param db Token storage to operate on.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens to transfer.\r\n     */\r\n    function transfer(TokenStorage db, address caller, address to, uint amount)\r\n        external\r\n        returns (bool success)\r\n    {\r\n        db.subBalance(caller, amount);\r\n        db.addBalance(to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from a specific address [ERC20].\r\n     * The address owner has to approve the spender beforehand.\r\n     * @param db Token storage to operate on.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param from Address to debet the tokens from.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens to transfer.\r\n     */\r\n    function transferFrom(\r\n        TokenStorage db,\r\n        address caller,\r\n        address from,\r\n        address to,\r\n        uint amount\r\n    )\r\n        external\r\n        returns (bool success)\r\n    {\r\n        uint allowance = db.getAllowed(from, caller);\r\n        db.subBalance(from, amount);\r\n        db.addBalance(to, amount);\r\n        db.setAllowed(from, caller, allowance.sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves a spender [ERC20].\r\n     * Note that using the approve/transferFrom presents a possible\r\n     * security vulnerability described in:\r\n     * https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.quou09mcbpzw\r\n     * Use transferAndCall to mitigate.\r\n     * @param db Token storage to operate on.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param spender The address of the future spender.\r\n     * @param amount The allowance of the spender.\r\n     */\r\n    function approve(TokenStorage db, address caller, address spender, uint amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        db.setAllowed(caller, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number tokens associated with an address.\r\n     * @param db Token storage to operate on.\r\n     * @param who Address to lookup.\r\n     * @return Balance of address.\r\n     */\r\n    function balanceOf(TokenStorage db, address who)\r\n        external\r\n        view\r\n        returns (uint balance)\r\n    {\r\n        return db.getBalance(who);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the allowance for a spender\r\n     * @param db Token storage to operate on.\r\n     * @param owner The address of the owner of the tokens.\r\n     * @param spender The address of the spender.\r\n     * @return Number of tokens the spender is allowed to spend.\r\n     */\r\n    function allowance(TokenStorage db, address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint remaining)\r\n    {\r\n        return db.getAllowed(owner, spender);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/MintableTokenLib.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\n\r\nlibrary MintableTokenLib {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     * @dev Mints new tokens.\r\n     * @param db Token storage to operate on.\r\n     * @param to The address that will recieve the minted tokens.\r\n     * @param amount The amount of tokens to mint.\r\n     */\r\n    function mint(\r\n        TokenStorage db,\r\n        address to,\r\n        uint amount\r\n    )\r\n        external\r\n        returns (bool)\r\n    {\r\n        db.addBalance(to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Burns tokens.\r\n     * @param db Token storage to operate on.\r\n     * @param from The address holding tokens.\r\n     * @param amount The amount of tokens to burn.\r\n     */\r\n    function burn(\r\n        TokenStorage db,\r\n        address from,\r\n        uint amount\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        db.subBalance(from, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Burns tokens from a specific address.\r\n     * To burn the tokens the caller needs to provide a signature\r\n     * proving that the caller is authorized by the token owner to do so.\r\n     * @param db Token storage to operate on.\r\n     * @param from The address holding tokens.\r\n     * @param amount The amount of tokens to burn.\r\n     * @param h Hash which the token owner signed.\r\n     * @param v Signature component.\r\n     * @param r Signature component.\r\n     * @param s Sigature component.\r\n     */\r\n    function burn(\r\n        TokenStorage db,\r\n        address from,\r\n        uint amount,\r\n        bytes32 h,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        returns (bool)\r\n    {\r\n        require(\r\n            ecrecover(h, v, r, s) == from,\r\n            \"signature/hash does not match\"\r\n        );\r\n        return burn(db, from, amount);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/IValidator.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @title IValidator\r\n * @dev Contracts implementing this interface validate token transfers.\r\n */\r\ninterface IValidator {\r\n\r\n    /**\r\n     * @dev Emitted when a validator makes a decision.\r\n     * @param from Sender address.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens.\r\n     * @param valid True if transfer approved, false if rejected.\r\n     */\r\n    event Decision(address indexed from, address indexed to, uint amount, bool valid);\r\n\r\n    /**\r\n     * @dev Validates token transfer.\r\n     * If the sender is on the blacklist the transfer is denied.\r\n     * @param from Sender address.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens.\r\n     */\r\n    function validate(address from, address to, uint amount) external returns (bool valid);\r\n\r\n}\r\n\r\n// File: contracts/SmartTokenLib.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SmartTokenLib\r\n * @dev This library provides functionality which is required from a regulatory perspective.\r\n */\r\nlibrary SmartTokenLib {\r\n\r\n    using ERC20Lib for TokenStorage;\r\n    using MintableTokenLib for TokenStorage;\r\n\r\n    struct SmartStorage {\r\n        IValidator validator;\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when the contract owner recovers tokens.\r\n     * @param from Sender address.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens.\r\n     */\r\n    event Recovered(address indexed from, address indexed to, uint amount);\r\n\r\n    /**\r\n     * @dev Emitted when updating the validator.\r\n     * @param old Address of the old validator.\r\n     * @param current Address of the new validator.\r\n     */\r\n    event Validator(address indexed old, address indexed current);\r\n\r\n    /**\r\n     * @dev Sets a new validator.\r\n     * @param self Smart storage to operate on.\r\n     * @param validator Address of validator.\r\n     */\r\n    function setValidator(SmartStorage storage self, address validator)\r\n        external\r\n    {\r\n        emit Validator(self.validator, validator);\r\n        self.validator = IValidator(validator);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Approves or rejects a transfer request.\r\n     * The request is forwarded to a validator which implements\r\n     * the actual business logic.\r\n     * @param self Smart storage to operate on.\r\n     * @param from Sender address.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens.\r\n     */\r\n    function validate(SmartStorage storage self, address from, address to, uint amount)\r\n        external\r\n        returns (bool valid)\r\n    {\r\n        return self.validator.validate(from, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Recovers tokens from an address and reissues them to another address.\r\n     * In case a user loses its private key the tokens can be recovered by burning\r\n     * the tokens from that address and reissuing to a new address.\r\n     * To recover tokens the contract owner needs to provide a signature\r\n     * proving that the token owner has authorized the owner to do so.\r\n     * @param from Address to burn tokens from.\r\n     * @param to Address to mint tokens to.\r\n     * @param h Hash which the token owner signed.\r\n     * @param v Signature component.\r\n     * @param r Signature component.\r\n     * @param s Sigature component.\r\n     * @return Amount recovered.\r\n     */\r\n    function recover(\r\n        TokenStorage token,\r\n        address from,\r\n        address to,\r\n        bytes32 h,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        returns (uint)\r\n    {\r\n        require(\r\n            ecrecover(h, v, r, s) == from,\r\n            \"signature/hash does not recover from address\"\r\n        );\r\n        uint amount = token.balanceOf(from);\r\n        token.burn(from, amount);\r\n        token.mint(to, amount);\r\n        emit Recovered(from, to, amount);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the current validator.\r\n     * @param self Smart storage to operate on.\r\n     * @return Address of validator.\r\n     */\r\n    function getValidator(SmartStorage storage self)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return address(self.validator);\r\n    }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param _addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address _addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(_addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/IERC677Recipient.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @title IERC677Recipient\r\n * @dev Contracts implementing this interface can participate in [ERC677].\r\n */\r\ninterface IERC677Recipient {\r\n\r\n    /**\r\n     * @dev Receives notification from [ERC677] transferAndCall.\r\n     * @param from Sender address.\r\n     * @param amount Number of tokens.\r\n     * @param data Additional data.\r\n     */\r\n    function onTokenTransfer(address from, uint256 amount, bytes data) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/ERC677Lib.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC677\r\n * @dev ERC677 token functionality.\r\n * https://github.com/ethereum/EIPs/issues/677\r\n */\r\nlibrary ERC677Lib {\r\n\r\n    using ERC20Lib for TokenStorage;\r\n    using AddressUtils for address;\r\n\r\n    /**\r\n     * @dev Transfers tokens and subsequently calls a method on the recipient [ERC677].\r\n     * If the recipient is a non-contract address this method behaves just like transfer.\r\n     * @notice db.transfer either returns true or reverts.\r\n     * @param db Token storage to operate on.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens to transfer.\r\n     * @param data Additional data passed to the recipient's tokenFallback method.\r\n     */\r\n    function transferAndCall(\r\n        TokenStorage db,\r\n        address caller,\r\n        address to,\r\n        uint256 amount,\r\n        bytes data\r\n    )\r\n        external\r\n        returns (bool)\r\n    {\r\n        require(\r\n            db.transfer(caller, to, amount), \r\n            \"unable to transfer\"\r\n        );\r\n        if (to.isContract()) {\r\n            IERC677Recipient recipient = IERC677Recipient(to);\r\n            require(\r\n                recipient.onTokenTransfer(caller, amount, data),\r\n                \"token handler returns false\"\r\n            );\r\n        }\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/StandardController.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title StandardController\r\n * @dev This is the base contract which delegates token methods [ERC20 and ERC677]\r\n * to their respective library implementations.\r\n * The controller is primarily intended to be interacted with via a token frontend.\r\n */\r\ncontract StandardController is Pausable, Destructible, Claimable {\r\n\r\n    using ERC20Lib for TokenStorage;\r\n    using ERC677Lib for TokenStorage;\r\n\r\n    TokenStorage internal token;\r\n    address internal frontend;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint public decimals = 18;\r\n\r\n    /**\r\n     * @dev Emitted when updating the frontend.\r\n     * @param old Address of the old frontend.\r\n     * @param current Address of the new frontend.\r\n     */\r\n    event Frontend(address indexed old, address indexed current);\r\n\r\n    /**\r\n     * @dev Emitted when updating the storage.\r\n     * @param old Address of the old storage.\r\n     * @param current Address of the new storage.\r\n     */\r\n    event Storage(address indexed old, address indexed current);\r\n\r\n    /**\r\n     * @dev Modifier which prevents the function from being called by unauthorized parties.\r\n     * The caller must either be the sender or the function must be\r\n     * called via the frontend, otherwise the call is reverted.\r\n     * @param caller The address of the passed-in caller. Used to preserve the original caller.\r\n     */\r\n    modifier guarded(address caller) {\r\n        require(\r\n            msg.sender == caller || msg.sender == frontend,\r\n            \"either caller must be sender or calling via frontend\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Contract constructor.\r\n     * @param storage_ Address of the token storage for the controller.\r\n     * @param initialSupply The amount of tokens to mint upon creation.\r\n     * @param frontend_ Address of the authorized frontend.\r\n     */\r\n    constructor(address storage_, uint initialSupply, address frontend_) public {\r\n        require(\r\n            storage_ == 0x0 || initialSupply == 0,\r\n            \"either a token storage must be initialized or no initial supply\"\r\n        );\r\n        if (storage_ == 0x0) {\r\n            token = new TokenStorage();\r\n            token.addBalance(msg.sender, initialSupply);\r\n        } else {\r\n            token = TokenStorage(storage_);\r\n        }\r\n        frontend = frontend_;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents tokens to be sent to well known blackholes by throwing on known blackholes.\r\n     * @param to The address of the intended recipient.\r\n     */\r\n    function avoidBlackholes(address to) internal view {\r\n        require(to != 0x0, \"must not send to 0x0\");\r\n        require(to != address(this), \"must not send to controller\");\r\n        require(to != address(token), \"must not send to token storage\");\r\n        require(to != frontend, \"must not send to frontend\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current frontend.\r\n     * @return Address of the frontend.\r\n     */\r\n    function getFrontend() external view returns (address) {\r\n        return frontend;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current storage.\r\n     * @return Address of the storage.\r\n     */\r\n    function getStorage() external view returns (address) {\r\n        return address(token);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new frontend.\r\n     * @param frontend_ Address of the new frontend.\r\n     */\r\n    function setFrontend(address frontend_) public onlyOwner {\r\n        emit Frontend(frontend, frontend_);\r\n        frontend = frontend_;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new storage.\r\n     * @param storage_ Address of the new storage.\r\n     */\r\n    function setStorage(address storage_) external onlyOwner {\r\n        emit Storage(address(token), storage_);\r\n        token = TokenStorage(storage_);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of the storage.\r\n     * @param newOwner Address of the new storage owner.\r\n     */\r\n    function transferStorageOwnership(address newOwner) public onlyOwner {\r\n        token.transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Claims the ownership of the storage.\r\n     */\r\n    function claimStorageOwnership() public onlyOwner {\r\n        token.claimOwnership();\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens [ERC20].\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens to transfer.\r\n     */\r\n    function transfer_withCaller(address caller, address to, uint amount)\r\n        public\r\n        guarded(caller)\r\n        whenNotPaused\r\n        returns (bool ok)\r\n    {\r\n        avoidBlackholes(to);\r\n        return token.transfer(caller, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from a specific address [ERC20].\r\n     * The address owner has to approve the spender beforehand.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param from Address to debet the tokens from.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens to transfer.\r\n     */\r\n    function transferFrom_withCaller(address caller, address from, address to, uint amount)\r\n        public\r\n        guarded(caller)\r\n        whenNotPaused\r\n        returns (bool ok)\r\n    {\r\n        avoidBlackholes(to);\r\n        return token.transferFrom(caller, from, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Approves a spender [ERC20].\r\n     * Note that using the approve/transferFrom presents a possible\r\n     * security vulnerability described in:\r\n     * https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.quou09mcbpzw\r\n     * Use transferAndCall to mitigate.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param spender The address of the future spender.\r\n     * @param amount The allowance of the spender.\r\n     */\r\n    function approve_withCaller(address caller, address spender, uint amount)\r\n        public\r\n        guarded(caller)\r\n        whenNotPaused\r\n        returns (bool ok)\r\n    {\r\n        return token.approve(caller, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens and subsequently calls a method on the recipient [ERC677].\r\n     * If the recipient is a non-contract address this method behaves just like transfer.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens to transfer.\r\n     * @param data Additional data passed to the recipient's tokenFallback method.\r\n     */\r\n    function transferAndCall_withCaller(\r\n        address caller,\r\n        address to,\r\n        uint256 amount,\r\n        bytes data\r\n    )\r\n        public\r\n        guarded(caller)\r\n        whenNotPaused\r\n        returns (bool ok)\r\n    {\r\n        avoidBlackholes(to);\r\n        return token.transferAndCall(caller, to, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total supply.\r\n     * @return Number of tokens.\r\n     */\r\n    function totalSupply() external view returns (uint) {\r\n        return token.getSupply();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number tokens associated with an address.\r\n     * @param who Address to lookup.\r\n     * @return Balance of address.\r\n     */\r\n    function balanceOf(address who) external view returns (uint) {\r\n        return token.getBalance(who);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the allowance for a spender\r\n     * @param owner The address of the owner of the tokens.\r\n     * @param spender The address of the spender.\r\n     * @return Number of tokens the spender is allowed to spend.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint) {\r\n        return token.allowance(owner, spender);\r\n    }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/rbac/Roles.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n * See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n  {\r\n    require(has(_role, _addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _role.bearer[_addr];\r\n  }\r\n}\r\n\r\n// File: contracts/SystemRole.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title SystemRole\r\n * @dev SystemRole accounts have been approved to perform operational actions (e.g. mint and burn).\r\n * @notice addSystemAccount and removeSystemAccount are unprotected by default, i.e. anyone can call them.\r\n * @notice Contracts inheriting SystemRole *should* authorize the caller by overriding them.\r\n */\r\ncontract SystemRole {\r\n\r\n    using Roles for Roles.Role;\r\n    Roles.Role private systemAccounts;\r\n\r\n    /**\r\n     * @dev Emitted when system account is added.\r\n     * @param account is a new system account.\r\n     */\r\n    event SystemAccountAdded(address indexed account);\r\n\r\n    /**\r\n     * @dev Emitted when system account is removed.\r\n     * @param account is the old system account.\r\n     */\r\n    event SystemAccountRemoved(address indexed account);\r\n\r\n    /**\r\n     * @dev Modifier which prevents non-system accounts from calling protected functions.\r\n     */\r\n    modifier onlySystemAccounts() {\r\n        require(isSystemAccount(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier which prevents non-system accounts from being passed to the guard.\r\n     * @param account The account to check.\r\n     */\r\n    modifier onlySystemAccount(address account) {\r\n        require(\r\n            isSystemAccount(account),\r\n            \"must be a system account\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev System Role constructor.\r\n     * @notice The contract is an abstract contract as a result of the internal modifier.\r\n     */\r\n    constructor() internal {}\r\n\r\n    /**\r\n     * @dev Checks whether an address is a system account.\r\n     * @param account the address to check.\r\n     * @return true if system account.\r\n     */\r\n    function isSystemAccount(address account) public view returns (bool) {\r\n        return systemAccounts.has(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns the system role to an account.\r\n     * @notice This method is unprotected and should be authorized in the child contract.\r\n     */\r\n    function addSystemAccount(address account) public {\r\n        systemAccounts.add(account);\r\n        emit SystemAccountAdded(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes the system role from an account.\r\n     * @notice This method is unprotected and should be authorized in the child contract.\r\n     */\r\n    function removeSystemAccount(address account) public {\r\n        systemAccounts.remove(account);\r\n        emit SystemAccountRemoved(account);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/MintableController.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n/**\r\n* @title MintableController\r\n* @dev This contracts implements functionality allowing for minting and burning of tokens.\r\n*/\r\ncontract MintableController is SystemRole, StandardController {\r\n\r\n    using MintableTokenLib for TokenStorage;\r\n\r\n    /**\r\n     * @dev Contract constructor.\r\n     * @param storage_ Address of the token storage for the controller.\r\n     * @param initialSupply The amount of tokens to mint upon creation.\r\n     * @param frontend_ Address of the authorized frontend.\r\n     */\r\n    constructor(address storage_, uint initialSupply, address frontend_)\r\n        public\r\n        StandardController(storage_, initialSupply, frontend_)\r\n    { }\r\n\r\n    /**\r\n     * @dev Assigns the system role to an account.\r\n     */\r\n    function addSystemAccount(address account) public onlyOwner {\r\n        super.addSystemAccount(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes the system role from an account.\r\n     */\r\n    function removeSystemAccount(address account) public onlyOwner {\r\n        super.removeSystemAccount(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints new tokens.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param to Address to credit the tokens.\r\n     * @param amount Number of tokens to mint.\r\n     */\r\n    function mintTo_withCaller(address caller, address to, uint amount)\r\n        public\r\n        guarded(caller)\r\n        onlySystemAccount(caller)\r\n        returns (bool)\r\n    {\r\n        avoidBlackholes(to);\r\n        return token.mint(to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns tokens from token owner.\r\n     * This removfes the burned tokens from circulation.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param from Address of the token owner.\r\n     * @param amount Number of tokens to burn.\r\n     * @param h Hash which the token owner signed.\r\n     * @param v Signature component.\r\n     * @param r Signature component.\r\n     * @param s Sigature component.\r\n     */\r\n    function burnFrom_withCaller(address caller, address from, uint amount, bytes32 h, uint8 v, bytes32 r, bytes32 s)\r\n        public\r\n        guarded(caller)\r\n        onlySystemAccount(caller)\r\n        returns (bool)\r\n    {\r\n        return token.burn(from, amount, h, v, r, s);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/SmartController.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SmartController\r\n * @dev This contract adds \"smart\" functionality which is required from a regulatory perspective.\r\n */\r\ncontract SmartController is MintableController {\r\n\r\n    using SmartTokenLib for SmartTokenLib.SmartStorage;\r\n\r\n    SmartTokenLib.SmartStorage internal smartToken;\r\n\r\n    bytes3 public ticker;\r\n    uint constant public INITIAL_SUPPLY = 0;\r\n\r\n    /**\r\n     * @dev Contract constructor.\r\n     * @param storage_ Address of the token storage for the controller.\r\n     * @param validator Address of validator.\r\n     * @param ticker_ 3 letter currency ticker.\r\n     * @param frontend_ Address of the authorized frontend.\r\n     */\r\n    constructor(address storage_, address validator, bytes3 ticker_, address frontend_)\r\n        public\r\n        MintableController(storage_, INITIAL_SUPPLY, frontend_)\r\n    {\r\n        require(validator != 0x0, \"validator cannot be the null address\");\r\n        smartToken.setValidator(validator);\r\n        ticker = ticker_;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new validator.\r\n     * @param validator Address of validator.\r\n     */\r\n    function setValidator(address validator) external onlySystemAccounts {\r\n        smartToken.setValidator(validator);\r\n    }\r\n\r\n    /**\r\n     * @dev Recovers tokens from an address and reissues them to another address.\r\n     * In case a user loses its private key the tokens can be recovered by burning\r\n     * the tokens from that address and reissuing to a new address.\r\n     * To recover tokens the contract owner needs to provide a signature\r\n     * proving that the token owner has authorized the owner to do so.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param from Address to burn tokens from.\r\n     * @param to Address to mint tokens to.\r\n     * @param h Hash which the token owner signed.\r\n     * @param v Signature component.\r\n     * @param r Signature component.\r\n     * @param s Sigature component.\r\n     * @return Amount recovered.\r\n     */\r\n    function recover_withCaller(address caller, address from, address to, bytes32 h, uint8 v, bytes32 r, bytes32 s)\r\n        external\r\n        guarded(caller)\r\n        onlySystemAccount(caller)\r\n        returns (uint)\r\n    {\r\n        avoidBlackholes(to);\r\n        return SmartTokenLib.recover(token, from, to, h, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens [ERC20].\r\n     * The caller, to address and amount are validated before executing method.\r\n     * Prior to transfering tokens the validator needs to approve.\r\n     * @notice Overrides method in a parent.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens to transfer.\r\n     */\r\n    function transfer_withCaller(address caller, address to, uint amount)\r\n        public\r\n        guarded(caller)\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        require(smartToken.validate(caller, to, amount), \"transfer request not valid\");\r\n        return super.transfer_withCaller(caller, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from a specific address [ERC20].\r\n     * The address owner has to approve the spender beforehand.\r\n     * The from address, to address and amount are validated before executing method.\r\n     * @notice Overrides method in a parent.\r\n     * Prior to transfering tokens the validator needs to approve.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param from Address to debet the tokens from.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens to transfer.\r\n     */\r\n    function transferFrom_withCaller(address caller, address from, address to, uint amount)\r\n        public\r\n        guarded(caller)\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        require(smartToken.validate(from, to, amount), \"transferFrom request not valid\");\r\n        return super.transferFrom_withCaller(caller, from, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens and subsequently calls a method on the recipient [ERC677].\r\n     * If the recipient is a non-contract address this method behaves just like transfer.\r\n     * The caller, to address and amount are validated before executing method.\r\n     * @notice Overrides method in a parent.\r\n     * @param caller Address of the caller passed through the frontend.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens to transfer.\r\n     * @param data Additional data passed to the recipient's tokenFallback method.\r\n     */\r\n    function transferAndCall_withCaller(\r\n        address caller,\r\n        address to,\r\n        uint256 amount,\r\n        bytes data\r\n    )\r\n        public\r\n        guarded(caller)\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        require(smartToken.validate(caller, to, amount), \"transferAndCall request not valid\");\r\n        return super.transferAndCall_withCaller(caller, to, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the current validator.\r\n     * @return Address of validator.\r\n     */\r\n    function getValidator() external view returns (address) {\r\n        return smartToken.getValidator();\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/TokenFrontend.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenFrontend\r\n * @dev This contract implements a token forwarder.\r\n * The token frontend is [ERC20 and ERC677] compliant and forwards\r\n * standard methods to a controller. The primary function is to allow\r\n * for a statically deployed contract for users to interact with while\r\n * simultaneously allow the controllers to be upgraded when bugs are\r\n * discovered or new functionality needs to be added.\r\n */\r\ncontract TokenFrontend is Destructible, Claimable, CanReclaimToken, NoOwner, IERC20 {\r\n\r\n    SmartController internal controller;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    bytes3 public ticker;\r\n\r\n    /**\r\n     * @dev Emitted when tokens are transferred.\r\n     * @param from Sender address.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens transferred.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n\r\n    /**\r\n     * @dev Emitted when tokens are transferred.\r\n     * @param from Sender address.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens transferred.\r\n     * @param data Additional data passed to the recipient's tokenFallback method.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint amount, bytes data);\r\n\r\n    /**\r\n     * @dev Emitted when spender is granted an allowance.\r\n     * @param owner Address of the owner of the tokens to spend.\r\n     * @param spender The address of the future spender.\r\n     * @param amount The allowance of the spender.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n\r\n    /**\r\n     * @dev Emitted when updating the controller.\r\n     * @param ticker Three letter ticker representing the currency.\r\n     * @param old Address of the old controller.\r\n     * @param current Address of the new controller.\r\n     */\r\n    event Controller(bytes3 indexed ticker, address indexed old, address indexed current);\r\n\r\n    /**\r\n     * @dev Contract constructor.\r\n     * @notice The contract is an abstract contract as a result of the internal modifier.\r\n     * @param name_ Token name.\r\n     * @param symbol_ Token symbol.\r\n     * @param ticker_ 3 letter currency ticker.\r\n     */\r\n    constructor(string name_, string symbol_, bytes3 ticker_) internal {\r\n        name = name_;\r\n        symbol = symbol_;\r\n        ticker = ticker_;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new controller.\r\n     * @param address_ Address of the controller.\r\n     */\r\n    function setController(address address_) external onlyOwner {\r\n        require(address_ != 0x0, \"controller address cannot be the null address\");\r\n        emit Controller(ticker, controller, address_);\r\n        controller = SmartController(address_);\r\n        require(controller.getFrontend() == address(this), \"controller frontend does not point back\");\r\n        require(controller.ticker() == ticker, \"ticker does not match controller ticket\");\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens [ERC20].\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens to transfer.\r\n     */\r\n    function transfer(address to, uint amount) external returns (bool ok) {\r\n        ok = controller.transfer_withCaller(msg.sender, to, amount);\r\n        emit Transfer(msg.sender, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from a specific address [ERC20].\r\n     * The address owner has to approve the spender beforehand.\r\n     * @param from Address to debet the tokens from.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens to transfer.\r\n     */\r\n    function transferFrom(address from, address to, uint amount) external returns (bool ok) {\r\n        ok = controller.transferFrom_withCaller(msg.sender, from, to, amount);\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Approves a spender [ERC20].\r\n     * Note that using the approve/transferFrom presents a possible\r\n     * security vulnerability described in:\r\n     * https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.quou09mcbpzw\r\n     * Use transferAndCall to mitigate.\r\n     * @param spender The address of the future spender.\r\n     * @param amount The allowance of the spender.\r\n     */\r\n    function approve(address spender, uint amount) external returns (bool ok) {\r\n        ok = controller.approve_withCaller(msg.sender, spender, amount);\r\n        emit Approval(msg.sender, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens and subsequently calls a method on the recipient [ERC677].\r\n     * If the recipient is a non-contract address this method behaves just like transfer.\r\n     * @param to Recipient address.\r\n     * @param amount Number of tokens to transfer.\r\n     * @param data Additional data passed to the recipient's tokenFallback method.\r\n     */\r\n    function transferAndCall(address to, uint256 amount, bytes data)\r\n        external\r\n        returns (bool ok)\r\n    {\r\n        ok = controller.transferAndCall_withCaller(msg.sender, to, amount, data);\r\n        emit Transfer(msg.sender, to, amount);\r\n        emit Transfer(msg.sender, to, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints new tokens.\r\n     * @param to Address to credit the tokens.\r\n     * @param amount Number of tokens to mint.\r\n     */\r\n    function mintTo(address to, uint amount)\r\n        external\r\n        returns (bool ok)\r\n    {\r\n        ok = controller.mintTo_withCaller(msg.sender, to, amount);\r\n        emit Transfer(0x0, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns tokens from token owner.\r\n     * This removfes the burned tokens from circulation.\r\n     * @param from Address of the token owner.\r\n     * @param amount Number of tokens to burn.\r\n     * @param h Hash which the token owner signed.\r\n     * @param v Signature component.\r\n     * @param r Signature component.\r\n     * @param s Sigature component.\r\n     */\r\n    function burnFrom(address from, uint amount, bytes32 h, uint8 v, bytes32 r, bytes32 s)\r\n        external\r\n        returns (bool ok)\r\n    {\r\n        ok = controller.burnFrom_withCaller(msg.sender, from, amount, h, v, r, s);\r\n        emit Transfer(from, 0x0, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Recovers tokens from an address and reissues them to another address.\r\n     * In case a user loses its private key the tokens can be recovered by burning\r\n     * the tokens from that address and reissuing to a new address.\r\n     * To recover tokens the contract owner needs to provide a signature\r\n     * proving that the token owner has authorized the owner to do so.\r\n     * @param from Address to burn tokens from.\r\n     * @param to Address to mint tokens to.\r\n     * @param h Hash which the token owner signed.\r\n     * @param v Signature component.\r\n     * @param r Signature component.\r\n     * @param s Sigature component.\r\n     * @return Amount recovered.\r\n     */\r\n    function recover(address from, address to, bytes32 h, uint8 v, bytes32 r, bytes32 s)\r\n        external\r\n        returns (uint amount)\r\n    {\r\n        amount = controller.recover_withCaller(msg.sender, from, to, h ,v, r, s);\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the current controller.\r\n     * @return Address of the controller.\r\n     */\r\n    function getController() external view returns (address) {\r\n        return address(controller);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total supply.\r\n     * @return Number of tokens.\r\n     */\r\n    function totalSupply() external view returns (uint) {\r\n        return controller.totalSupply();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number tokens associated with an address.\r\n     * @param who Address to lookup.\r\n     * @return Balance of address.\r\n     */\r\n    function balanceOf(address who) external view returns (uint) {\r\n        return controller.balanceOf(who);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the allowance for a spender\r\n     * @param owner The address of the owner of the tokens.\r\n     * @param spender The address of the spender.\r\n     * @return Number of tokens the spender is allowed to spend.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint) {\r\n        return controller.allowance(owner, spender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals in one token.\r\n     * @return Number of decimals.\r\n     */\r\n    function decimals() external view returns (uint) {\r\n        return controller.decimals();\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/USD.sol\r\n\r\n/**\r\n * Copyright 2019 Monerium ehf.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\ncontract USD is TokenFrontend {\r\n\r\n    constructor()\r\n        public\r\n        TokenFrontend(\"Monerium USD emoney\", \"USDe\", \"USD\")\r\n    { }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddr\",\"type\":\"address\"}],\"name\":\"reclaimContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"h\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintTo\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"h\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"recover\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticker\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes3\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ticker\",\"type\":\"bytes3\"},{\"indexed\":true,\"name\":\"old\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"current\",\"type\":\"address\"}],\"name\":\"Controller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"USD","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"Apache-2.0","SwarmSource":"bzzr://d8dcc356623e80cf33ea7884cf1d7ef6e5129219db7f006f5a66767d126d5dcb"}]}