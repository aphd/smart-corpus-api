{"status":"1","message":"OK","result":[{"SourceCode":"{\"LTRConceptArt_Looping.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"./LTRFactory.sol\\\";\\r\\n\\r\\ncontract LTRConceptArtLoop {\\r\\n    \\r\\n\\tstruct LTRGiftAddress\\t{\\r\\n        address _address;\\r\\n\\t\\tuint _assetGiven; \\r\\n\\t\\t\\t// 1: Should give Y01\\r\\n\\t\\t\\t// 2: Should give Y02\\r\\n\\t\\t\\t// 3: Should give Y03\\r\\n\\t\\t\\t// 4: Already gave Y01\\r\\n\\t\\t\\t// 5: Already gave Y02\\r\\n\\t\\t\\t// 6: Already gave Y03\\r\\n    }\\r\\n\\t\\r\\n    LTRGiftAddress[] public _LTRGiftCampaign;\\r\\n\\t\\r\\n\\tmapping (address =\\u003e uint) public _arrayIdsPlusOne;\\r\\n\\t\\r\\n\\taddress public _owner;\\r\\n\\tItemFactory _factoryContract;\\r\\n\\tmodifier onlyOwner() {\\r\\n\\t\\trequire(msg.sender == _owner);\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\t\\r\\n\\tconstructor (address _factoryContractAddress) public {\\r\\n        _owner = msg.sender;\\r\\n\\t\\t_factoryContract = ItemFactory(_factoryContractAddress);\\r\\n    }\\r\\n\\t\\r\\n\\tfunction changeOwner(address _newOwner) public onlyOwner returns (bool) {\\r\\n\\t\\t_owner = _newOwner;\\r\\n\\t\\t\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction transferOwnershipOfFactory(address _newOwner) public onlyOwner returns (bool) {\\r\\n\\t\\t_factoryContract.transferOwnership(_newOwner);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\t\\r\\n\\t\\r\\n\\tfunction addNewAddress(address _newAddress, uint _assetIDtoGive) public onlyOwner returns (uint) {\\r\\n\\t\\trequire(_arrayIdsPlusOne[_newAddress] == 0);\\r\\n\\t\\t\\r\\n\\t\\tLTRGiftAddress memory _newLTRGiftAddress = LTRGiftAddress(_newAddress, _assetIDtoGive);\\r\\n\\t\\tuint id = (_LTRGiftCampaign.push(_newLTRGiftAddress) - 1);\\r\\n\\t\\t_arrayIdsPlusOne[_newAddress] = id+1;\\r\\n\\t\\treturn id;\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction sendToAddress(address _address) public onlyOwner returns (bool) {\\r\\n\\t\\trequire(_arrayIdsPlusOne[_address] != 0);\\r\\n\\t\\trequire(_LTRGiftCampaign[_arrayIdsPlusOne[_address]-1]._assetGiven \\u003c 4);\\r\\n\\t\\t\\r\\n\\t\\t// HERE, call the factory contract\\r\\n\\t\\t\\r\\n        _factoryContract.mint(_LTRGiftCampaign[_arrayIdsPlusOne[_address]-1]._assetGiven - 1, _address);\\r\\n\\t\\t\\r\\n\\t\\t_LTRGiftCampaign[_arrayIdsPlusOne[_address]-1]._assetGiven += 3;\\r\\n\\t\\t\\r\\n\\t\\treturn true;\\r\\n    }\\r\\n    \\r\\n    function addAddressAndSend(address _newAddress, uint _assetIDtoGive) public onlyOwner returns (bool) {\\r\\n        \\r\\n        require(_arrayIdsPlusOne[_newAddress] == 0);\\r\\n\\t\\t\\r\\n\\t\\tLTRGiftAddress memory _newLTRGiftAddress = LTRGiftAddress(_newAddress, _assetIDtoGive);\\r\\n\\t\\tuint id = (_LTRGiftCampaign.push(_newLTRGiftAddress) - 1);\\r\\n\\t\\t_arrayIdsPlusOne[_newAddress] = id+1;\\r\\n        \\r\\n\\t\\trequire(_LTRGiftCampaign[_arrayIdsPlusOne[_newAddress]-1]._assetGiven \\u003c 4);\\r\\n\\t\\t\\r\\n\\t\\t// HERE, call the factory contract\\r\\n\\t\\t\\r\\n        _factoryContract.mint(_LTRGiftCampaign[_arrayIdsPlusOne[_newAddress]-1]._assetGiven - 1, _newAddress);\\r\\n\\t\\t\\r\\n\\t\\t_LTRGiftCampaign[_arrayIdsPlusOne[_newAddress]-1]._assetGiven += 3;\\r\\n\\t\\t\\r\\n\\t\\treturn true;\\r\\n    }\\r\\n}\"},\"LTRFactory.sol\":{\"content\":\"/**\\r\\n *Submitted for verification at Etherscan.io on 2019-06-05\\r\\n*/\\r\\n\\r\\npragma solidity ^0.4.24;\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\r\\n */\\r\\ncontract Ownable {\\r\\n  address public owner;\\r\\n\\r\\n\\r\\n  event OwnershipRenounced(address indexed previousOwner);\\r\\n  event OwnershipTransferred(\\r\\n    address indexed previousOwner,\\r\\n    address indexed newOwner\\r\\n  );\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n   * account.\\r\\n   */\\r\\n  constructor() public {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Throws if called by any account other than the owner.\\r\\n   */\\r\\n  modifier onlyOwner() {\\r\\n    require(msg.sender == owner);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows the current owner to relinquish control of the contract.\\r\\n   * @notice Renouncing to ownership will leave the contract without an owner.\\r\\n   * It will not be possible to call the functions with the `onlyOwner`\\r\\n   * modifier anymore.\\r\\n   */\\r\\n  function renounceOwnership() public onlyOwner {\\r\\n    emit OwnershipRenounced(owner);\\r\\n    owner = address(0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n   * @param _newOwner The address to transfer ownership to.\\r\\n   */\\r\\n  function transferOwnership(address _newOwner) public onlyOwner {\\r\\n    _transferOwnership(_newOwner);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers control of the contract to a newOwner.\\r\\n   * @param _newOwner The address to transfer ownership to.\\r\\n   */\\r\\n  function _transferOwnership(address _newOwner) internal {\\r\\n    require(_newOwner != address(0));\\r\\n    emit OwnershipTransferred(owner, _newOwner);\\r\\n    owner = _newOwner;\\r\\n  }\\r\\n}\\r\\n\\r\\n// File: contracts/Factory.sol\\r\\n\\r\\n/**\\r\\n * This is a generic factory contract that can be used to mint tokens. The configuration\\r\\n * for minting is specified by an _optionId, which can be used to delineate various \\r\\n * ways of minting.\\r\\n */\\r\\ninterface Factory {\\r\\n  /**\\r\\n   * Returns the name of this factory.\\r\\n   */\\r\\n  function name() external view returns (string);\\r\\n\\r\\n  /**\\r\\n   * Returns the symbol for this factory.\\r\\n   */\\r\\n  function symbol() external view returns (string);\\r\\n\\r\\n  /**\\r\\n   * Number of options the factory supports.\\r\\n   */\\r\\n  function numOptions() public view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns whether the option ID can be minted. Can return false if the developer wishes to\\r\\n   * restrict a total supply per option ID (or overall).\\r\\n   */\\r\\n  function canMint(uint256 _optionId) public view returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns a URL specifying some metadata about the option. This metadata can be of the\\r\\n   * same structure as the ERC721 metadata.\\r\\n   */\\r\\n  function tokenURI(uint256 _optionId) public view returns (string);\\r\\n\\r\\n  /**\\r\\n   * Indicates that this is a factory contract. Ideally would use EIP 165 supportsInterface()\\r\\n   */\\r\\n  function supportsFactoryInterface() public view returns (bool);\\r\\n\\r\\n  /**\\r\\n    * @dev Mints asset(s) in accordance to a specific address with a particular \\\"option\\\". This should be \\r\\n    * callable only by the contract owner or the owner\\u0027s Wyvern Proxy (later universal login will solve this).\\r\\n    * Options should also be delineated 0 - (numOptions() - 1) for convenient indexing.\\r\\n    * @param _optionId the option id\\r\\n    * @param _toAddress address of the future owner of the asset(s)\\r\\n    */\\r\\n  function mint(uint256 _optionId, address _toAddress) external;\\r\\n}\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\\r\\n\\r\\n/**\\r\\n * @title ERC165\\r\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\r\\n */\\r\\ninterface ERC165 {\\r\\n\\r\\n  /**\\r\\n   * @notice Query if a contract implements an interface\\r\\n   * @param _interfaceId The interface identifier, as specified in ERC-165\\r\\n   * @dev Interface identification is specified in ERC-165. This function\\r\\n   * uses less than 30,000 gas.\\r\\n   */\\r\\n  function supportsInterface(bytes4 _interfaceId)\\r\\n    external\\r\\n    view\\r\\n    returns (bool);\\r\\n}\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol\\r\\n\\r\\n/**\\r\\n * @title ERC721 Non-Fungible Token Standard basic interface\\r\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721Basic is ERC165 {\\r\\n\\r\\n  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\\r\\n  /*\\r\\n   * 0x80ac58cd ===\\r\\n   *   bytes4(keccak256(\\u0027balanceOf(address)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027ownerOf(uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027approve(address,uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027getApproved(uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027setApprovalForAll(address,bool)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027isApprovedForAll(address,address)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027transferFrom(address,address,uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256,bytes)\\u0027))\\r\\n   */\\r\\n\\r\\n  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\\r\\n  /*\\r\\n   * 0x4f558e79 ===\\r\\n   *   bytes4(keccak256(\\u0027exists(uint256)\\u0027))\\r\\n   */\\r\\n\\r\\n  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\\r\\n  /**\\r\\n   * 0x780e9d63 ===\\r\\n   *   bytes4(keccak256(\\u0027totalSupply()\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027tokenOfOwnerByIndex(address,uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027tokenByIndex(uint256)\\u0027))\\r\\n   */\\r\\n\\r\\n  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\\r\\n  /**\\r\\n   * 0x5b5e139f ===\\r\\n   *   bytes4(keccak256(\\u0027name()\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027symbol()\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027tokenURI(uint256)\\u0027))\\r\\n   */\\r\\n\\r\\n  event Transfer(\\r\\n    address indexed _from,\\r\\n    address indexed _to,\\r\\n    uint256 indexed _tokenId\\r\\n  );\\r\\n  event Approval(\\r\\n    address indexed _owner,\\r\\n    address indexed _approved,\\r\\n    uint256 indexed _tokenId\\r\\n  );\\r\\n  event ApprovalForAll(\\r\\n    address indexed _owner,\\r\\n    address indexed _operator,\\r\\n    bool _approved\\r\\n  );\\r\\n\\r\\n  function balanceOf(address _owner) public view returns (uint256 _balance);\\r\\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\\r\\n  function exists(uint256 _tokenId) public view returns (bool _exists);\\r\\n\\r\\n  function approve(address _to, uint256 _tokenId) public;\\r\\n  function getApproved(uint256 _tokenId)\\r\\n    public view returns (address _operator);\\r\\n\\r\\n  function setApprovalForAll(address _operator, bool _approved) public;\\r\\n  function isApprovedForAll(address _owner, address _operator)\\r\\n    public view returns (bool);\\r\\n\\r\\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\\r\\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\\r\\n    public;\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId,\\r\\n    bytes _data\\r\\n  )\\r\\n    public;\\r\\n}\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\r\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721Enumerable is ERC721Basic {\\r\\n  function totalSupply() public view returns (uint256);\\r\\n  function tokenOfOwnerByIndex(\\r\\n    address _owner,\\r\\n    uint256 _index\\r\\n  )\\r\\n    public\\r\\n    view\\r\\n    returns (uint256 _tokenId);\\r\\n\\r\\n  function tokenByIndex(uint256 _index) public view returns (uint256);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721Metadata is ERC721Basic {\\r\\n  function name() external view returns (string _name);\\r\\n  function symbol() external view returns (string _symbol);\\r\\n  function tokenURI(uint256 _tokenId) public view returns (string);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\\r\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\\r\\n}\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Receiver.sol\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ncontract ERC721Receiver {\\r\\n  /**\\r\\n   * @dev Magic value to be returned upon successful reception of an NFT\\r\\n   *  Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`,\\r\\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\\r\\n   */\\r\\n  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\\r\\n\\r\\n  /**\\r\\n   * @notice Handle the receipt of an NFT\\r\\n   * @dev The ERC721 smart contract calls this function on the recipient\\r\\n   * after a `safetransfer`. This function MAY throw to revert and reject the\\r\\n   * transfer. Return of other than the magic value MUST result in the\\r\\n   * transaction being reverted.\\r\\n   * Note: the contract address is always the message sender.\\r\\n   * @param _operator The address which called `safeTransferFrom` function\\r\\n   * @param _from The address which previously owned the token\\r\\n   * @param _tokenId The NFT identifier which is being transferred\\r\\n   * @param _data Additional data with no specified format\\r\\n   * @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n   */\\r\\n  function onERC721Received(\\r\\n    address _operator,\\r\\n    address _from,\\r\\n    uint256 _tokenId,\\r\\n    bytes _data\\r\\n  )\\r\\n    public\\r\\n    returns(bytes4);\\r\\n}\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, throws on overflow.\\r\\n  */\\r\\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\r\\n    // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\r\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n    if (_a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    c = _a * _b;\\r\\n    assert(c / _a == _b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Integer division of two numbers, truncating the quotient.\\r\\n  */\\r\\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\r\\n    // assert(_b \\u003e 0); // Solidity automatically throws when dividing by 0\\r\\n    // uint256 c = _a / _b;\\r\\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\\u0027t hold\\r\\n    return _a / _b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\r\\n    assert(_b \\u003c= _a);\\r\\n    return _a - _b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, throws on overflow.\\r\\n  */\\r\\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\r\\n    c = _a + _b;\\r\\n    assert(c \\u003e= _a);\\r\\n    return c;\\r\\n  }\\r\\n}\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\\r\\n\\r\\n/**\\r\\n * Utility library of inline functions on addresses\\r\\n */\\r\\nlibrary AddressUtils {\\r\\n\\r\\n  /**\\r\\n   * Returns whether the target address is a contract\\r\\n   * @dev This function will return false if invoked during the constructor of a contract,\\r\\n   * as the code is not actually created until after the constructor finishes.\\r\\n   * @param _addr address to check\\r\\n   * @return whether the target address is a contract\\r\\n   */\\r\\n  function isContract(address _addr) internal view returns (bool) {\\r\\n    uint256 size;\\r\\n    // XXX Currently there is no better way to check if there is a contract in an address\\r\\n    // than to check the size of the code at that address.\\r\\n    // See https://ethereum.stackexchange.com/a/14016/36603\\r\\n    // for more details about how this works.\\r\\n    // TODO Check this again before the Serenity release, because all addresses will be\\r\\n    // contracts then.\\r\\n    // solium-disable-next-line security/no-inline-assembly\\r\\n    assembly { size := extcodesize(_addr) }\\r\\n    return size \\u003e 0;\\r\\n  }\\r\\n\\r\\n}\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/introspection/SupportsInterfaceWithLookup.sol\\r\\n\\r\\n/**\\r\\n * @title SupportsInterfaceWithLookup\\r\\n * @author Matt Condon (@shrugs)\\r\\n * @dev Implements ERC165 using a lookup table.\\r\\n */\\r\\ncontract SupportsInterfaceWithLookup is ERC165 {\\r\\n\\r\\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\\r\\n  /**\\r\\n   * 0x01ffc9a7 ===\\r\\n   *   bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027))\\r\\n   */\\r\\n\\r\\n  /**\\r\\n   * @dev a mapping of interface id to whether or not it\\u0027s supported\\r\\n   */\\r\\n  mapping(bytes4 =\\u003e bool) internal supportedInterfaces;\\r\\n\\r\\n  /**\\r\\n   * @dev A contract implementing SupportsInterfaceWithLookup\\r\\n   * implement ERC165 itself\\r\\n   */\\r\\n  constructor()\\r\\n    public\\r\\n  {\\r\\n    _registerInterface(InterfaceId_ERC165);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev implement supportsInterface(bytes4) using a lookup table\\r\\n   */\\r\\n  function supportsInterface(bytes4 _interfaceId)\\r\\n    external\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    return supportedInterfaces[_interfaceId];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev private method for registering an interface\\r\\n   */\\r\\n  function _registerInterface(bytes4 _interfaceId)\\r\\n    internal\\r\\n  {\\r\\n    require(_interfaceId != 0xffffffff);\\r\\n    supportedInterfaces[_interfaceId] = true;\\r\\n  }\\r\\n}\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721BasicToken.sol\\r\\n\\r\\n/**\\r\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\r\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {\\r\\n\\r\\n  using SafeMath for uint256;\\r\\n  using AddressUtils for address;\\r\\n\\r\\n  // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\\r\\n  bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\\r\\n\\r\\n  // Mapping from token ID to owner\\r\\n  mapping (uint256 =\\u003e address) internal tokenOwner;\\r\\n\\r\\n  // Mapping from token ID to approved address\\r\\n  mapping (uint256 =\\u003e address) internal tokenApprovals;\\r\\n\\r\\n  // Mapping from owner to number of owned token\\r\\n  mapping (address =\\u003e uint256) internal ownedTokensCount;\\r\\n\\r\\n  // Mapping from owner to operator approvals\\r\\n  mapping (address =\\u003e mapping (address =\\u003e bool)) internal operatorApprovals;\\r\\n\\r\\n  constructor()\\r\\n    public\\r\\n  {\\r\\n    // register the supported interfaces to conform to ERC721 via ERC165\\r\\n    _registerInterface(InterfaceId_ERC721);\\r\\n    _registerInterface(InterfaceId_ERC721Exists);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the balance of the specified address\\r\\n   * @param _owner address to query the balance of\\r\\n   * @return uint256 representing the amount owned by the passed address\\r\\n   */\\r\\n  function balanceOf(address _owner) public view returns (uint256) {\\r\\n    require(_owner != address(0));\\r\\n    return ownedTokensCount[_owner];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the owner of the specified token ID\\r\\n   * @param _tokenId uint256 ID of the token to query the owner of\\r\\n   * @return owner address currently marked as the owner of the given token ID\\r\\n   */\\r\\n  function ownerOf(uint256 _tokenId) public view returns (address) {\\r\\n    address owner = tokenOwner[_tokenId];\\r\\n    require(owner != address(0));\\r\\n    return owner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns whether the specified token exists\\r\\n   * @param _tokenId uint256 ID of the token to query the existence of\\r\\n   * @return whether the token exists\\r\\n   */\\r\\n  function exists(uint256 _tokenId) public view returns (bool) {\\r\\n    address owner = tokenOwner[_tokenId];\\r\\n    return owner != address(0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Approves another address to transfer the given token ID\\r\\n   * The zero address indicates there is no approved address.\\r\\n   * There can only be one approved address per token at a given time.\\r\\n   * Can only be called by the token owner or an approved operator.\\r\\n   * @param _to address to be approved for the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be approved\\r\\n   */\\r\\n  function approve(address _to, uint256 _tokenId) public {\\r\\n    address owner = ownerOf(_tokenId);\\r\\n    require(_to != owner);\\r\\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\\r\\n\\r\\n    tokenApprovals[_tokenId] = _to;\\r\\n    emit Approval(owner, _to, _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the approved address for a token ID, or zero if no address set\\r\\n   * @param _tokenId uint256 ID of the token to query the approval of\\r\\n   * @return address currently approved for the given token ID\\r\\n   */\\r\\n  function getApproved(uint256 _tokenId) public view returns (address) {\\r\\n    return tokenApprovals[_tokenId];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets or unsets the approval of a given operator\\r\\n   * An operator is allowed to transfer all tokens of the sender on their behalf\\r\\n   * @param _to operator address to set the approval\\r\\n   * @param _approved representing the status of the approval to be set\\r\\n   */\\r\\n  function setApprovalForAll(address _to, bool _approved) public {\\r\\n    require(_to != msg.sender);\\r\\n    operatorApprovals[msg.sender][_to] = _approved;\\r\\n    emit ApprovalForAll(msg.sender, _to, _approved);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Tells whether an operator is approved by a given owner\\r\\n   * @param _owner owner address which you want to query the approval of\\r\\n   * @param _operator operator address which you want to query the approval of\\r\\n   * @return bool whether the given operator is approved by the given owner\\r\\n   */\\r\\n  function isApprovedForAll(\\r\\n    address _owner,\\r\\n    address _operator\\r\\n  )\\r\\n    public\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    return operatorApprovals[_owner][_operator];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers the ownership of a given token ID to another address\\r\\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\\r\\n   * Requires the msg sender to be the owner, approved, or operator\\r\\n   * @param _from current owner of the token\\r\\n   * @param _to address to receive the ownership of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be transferred\\r\\n  */\\r\\n  function transferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    public\\r\\n  {\\r\\n    require(isApprovedOrOwner(msg.sender, _tokenId));\\r\\n    require(_from != address(0));\\r\\n    require(_to != address(0));\\r\\n\\r\\n    clearApproval(_from, _tokenId);\\r\\n    removeTokenFrom(_from, _tokenId);\\r\\n    addTokenTo(_to, _tokenId);\\r\\n\\r\\n    emit Transfer(_from, _to, _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers the ownership of a given token ID to another address\\r\\n   * If the target address is a contract, it must implement `onERC721Received`,\\r\\n   * which is called upon a safe transfer, and return the magic value\\r\\n   * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\r\\n   * the transfer is reverted.\\r\\n   *\\r\\n   * Requires the msg sender to be the owner, approved, or operator\\r\\n   * @param _from current owner of the token\\r\\n   * @param _to address to receive the ownership of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be transferred\\r\\n  */\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    public\\r\\n  {\\r\\n    // solium-disable-next-line arg-overflow\\r\\n    safeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers the ownership of a given token ID to another address\\r\\n   * If the target address is a contract, it must implement `onERC721Received`,\\r\\n   * which is called upon a safe transfer, and return the magic value\\r\\n   * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\r\\n   * the transfer is reverted.\\r\\n   * Requires the msg sender to be the owner, approved, or operator\\r\\n   * @param _from current owner of the token\\r\\n   * @param _to address to receive the ownership of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be transferred\\r\\n   * @param _data bytes data to send along with a safe transfer check\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId,\\r\\n    bytes _data\\r\\n  )\\r\\n    public\\r\\n  {\\r\\n    transferFrom(_from, _to, _tokenId);\\r\\n    // solium-disable-next-line arg-overflow\\r\\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns whether the given spender can transfer a given token ID\\r\\n   * @param _spender address of the spender to query\\r\\n   * @param _tokenId uint256 ID of the token to be transferred\\r\\n   * @return bool whether the msg.sender is approved for the given token ID,\\r\\n   *  is an operator of the owner, or is the owner of the token\\r\\n   */\\r\\n  function isApprovedOrOwner(\\r\\n    address _spender,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    internal\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    address owner = ownerOf(_tokenId);\\r\\n    // Disable solium check because of\\r\\n    // https://github.com/duaraghav8/Solium/issues/175\\r\\n    // solium-disable-next-line operator-whitespace\\r\\n    return (\\r\\n      _spender == owner ||\\r\\n      getApproved(_tokenId) == _spender ||\\r\\n      isApprovedForAll(owner, _spender)\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to mint a new token\\r\\n   * Reverts if the given token ID already exists\\r\\n   * @param _to The address that will own the minted token\\r\\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\\r\\n   */\\r\\n  function _mint(address _to, uint256 _tokenId) internal {\\r\\n    require(_to != address(0));\\r\\n    addTokenTo(_to, _tokenId);\\r\\n    emit Transfer(address(0), _to, _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to burn a specific token\\r\\n   * Reverts if the token does not exist\\r\\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\\r\\n   */\\r\\n  function _burn(address _owner, uint256 _tokenId) internal {\\r\\n    clearApproval(_owner, _tokenId);\\r\\n    removeTokenFrom(_owner, _tokenId);\\r\\n    emit Transfer(_owner, address(0), _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to clear current approval of a given token ID\\r\\n   * Reverts if the given address is not indeed the owner of the token\\r\\n   * @param _owner owner of the token\\r\\n   * @param _tokenId uint256 ID of the token to be transferred\\r\\n   */\\r\\n  function clearApproval(address _owner, uint256 _tokenId) internal {\\r\\n    require(ownerOf(_tokenId) == _owner);\\r\\n    if (tokenApprovals[_tokenId] != address(0)) {\\r\\n      tokenApprovals[_tokenId] = address(0);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to add a token ID to the list of a given address\\r\\n   * @param _to address representing the new owner of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\\r\\n   */\\r\\n  function addTokenTo(address _to, uint256 _tokenId) internal {\\r\\n    require(tokenOwner[_tokenId] == address(0));\\r\\n    tokenOwner[_tokenId] = _to;\\r\\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to remove a token ID from the list of a given address\\r\\n   * @param _from address representing the previous owner of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\\r\\n   */\\r\\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\\r\\n    require(ownerOf(_tokenId) == _from);\\r\\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\\r\\n    tokenOwner[_tokenId] = address(0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to invoke `onERC721Received` on a target address\\r\\n   * The call is not executed if the target address is not a contract\\r\\n   * @param _from address representing the previous owner of the given token ID\\r\\n   * @param _to target address that will receive the tokens\\r\\n   * @param _tokenId uint256 ID of the token to be transferred\\r\\n   * @param _data bytes optional data to send along with the call\\r\\n   * @return whether the call correctly returned the expected magic value\\r\\n   */\\r\\n  function checkAndCallSafeTransfer(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId,\\r\\n    bytes _data\\r\\n  )\\r\\n    internal\\r\\n    returns (bool)\\r\\n  {\\r\\n    if (!_to.isContract()) {\\r\\n      return true;\\r\\n    }\\r\\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(\\r\\n      msg.sender, _from, _tokenId, _data);\\r\\n    return (retval == ERC721_RECEIVED);\\r\\n  }\\r\\n}\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Token.sol\\r\\n\\r\\n/**\\r\\n * @title Full ERC721 Token\\r\\n * This implementation includes all the required and some optional functionality of the ERC721 standard\\r\\n * Moreover, it includes approve all functionality using operator terminology\\r\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {\\r\\n\\r\\n  // Token name\\r\\n  string internal name_;\\r\\n\\r\\n  // Token symbol\\r\\n  string internal symbol_;\\r\\n\\r\\n  // Mapping from owner to list of owned token IDs\\r\\n  mapping(address =\\u003e uint256[]) internal ownedTokens;\\r\\n\\r\\n  // Mapping from token ID to index of the owner tokens list\\r\\n  mapping(uint256 =\\u003e uint256) internal ownedTokensIndex;\\r\\n\\r\\n  // Array with all token ids, used for enumeration\\r\\n  uint256[] internal allTokens;\\r\\n\\r\\n  // Mapping from token id to position in the allTokens array\\r\\n  mapping(uint256 =\\u003e uint256) internal allTokensIndex;\\r\\n\\r\\n  // Optional mapping for token URIs\\r\\n  mapping(uint256 =\\u003e string) internal tokenURIs;\\r\\n\\r\\n  /**\\r\\n   * @dev Constructor function\\r\\n   */\\r\\n  constructor(string _name, string _symbol) public {\\r\\n    name_ = _name;\\r\\n    symbol_ = _symbol;\\r\\n\\r\\n    // register the supported interfaces to conform to ERC721 via ERC165\\r\\n    _registerInterface(InterfaceId_ERC721Enumerable);\\r\\n    _registerInterface(InterfaceId_ERC721Metadata);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the token name\\r\\n   * @return string representing the token name\\r\\n   */\\r\\n  function name() external view returns (string) {\\r\\n    return name_;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the token symbol\\r\\n   * @return string representing the token symbol\\r\\n   */\\r\\n  function symbol() external view returns (string) {\\r\\n    return symbol_;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns an URI for a given token ID\\r\\n   * Throws if the token ID does not exist. May return an empty string.\\r\\n   * @param _tokenId uint256 ID of the token to query\\r\\n   */\\r\\n  function tokenURI(uint256 _tokenId) public view returns (string) {\\r\\n    require(exists(_tokenId));\\r\\n    return tokenURIs[_tokenId];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\\r\\n   * @param _owner address owning the tokens list to be accessed\\r\\n   * @param _index uint256 representing the index to be accessed of the requested tokens list\\r\\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\\r\\n   */\\r\\n  function tokenOfOwnerByIndex(\\r\\n    address _owner,\\r\\n    uint256 _index\\r\\n  )\\r\\n    public\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    require(_index \\u003c balanceOf(_owner));\\r\\n    return ownedTokens[_owner][_index];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the total amount of tokens stored by the contract\\r\\n   * @return uint256 representing the total amount of tokens\\r\\n   */\\r\\n  function totalSupply() public view returns (uint256) {\\r\\n    return allTokens.length;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the token ID at a given index of all the tokens in this contract\\r\\n   * Reverts if the index is greater or equal to the total number of tokens\\r\\n   * @param _index uint256 representing the index to be accessed of the tokens list\\r\\n   * @return uint256 token ID at the given index of the tokens list\\r\\n   */\\r\\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\\r\\n    require(_index \\u003c totalSupply());\\r\\n    return allTokens[_index];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to set the token URI for a given token\\r\\n   * Reverts if the token ID does not exist\\r\\n   * @param _tokenId uint256 ID of the token to set its URI\\r\\n   * @param _uri string URI to assign\\r\\n   */\\r\\n  function _setTokenURI(uint256 _tokenId, string _uri) internal {\\r\\n    require(exists(_tokenId));\\r\\n    tokenURIs[_tokenId] = _uri;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to add a token ID to the list of a given address\\r\\n   * @param _to address representing the new owner of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\\r\\n   */\\r\\n  function addTokenTo(address _to, uint256 _tokenId) internal {\\r\\n    super.addTokenTo(_to, _tokenId);\\r\\n    uint256 length = ownedTokens[_to].length;\\r\\n    ownedTokens[_to].push(_tokenId);\\r\\n    ownedTokensIndex[_tokenId] = length;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to remove a token ID from the list of a given address\\r\\n   * @param _from address representing the previous owner of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\\r\\n   */\\r\\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\\r\\n    super.removeTokenFrom(_from, _tokenId);\\r\\n\\r\\n    // To prevent a gap in the array, we store the last token in the index of the token to delete, and\\r\\n    // then delete the last slot.\\r\\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\\r\\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\\r\\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\\r\\n\\r\\n    ownedTokens[_from][tokenIndex] = lastToken;\\r\\n    // This also deletes the contents at the last position of the array\\r\\n    ownedTokens[_from].length--;\\r\\n\\r\\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\\r\\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\\r\\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\\r\\n\\r\\n    ownedTokensIndex[_tokenId] = 0;\\r\\n    ownedTokensIndex[lastToken] = tokenIndex;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to mint a new token\\r\\n   * Reverts if the given token ID already exists\\r\\n   * @param _to address the beneficiary that will own the minted token\\r\\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\\r\\n   */\\r\\n  function _mint(address _to, uint256 _tokenId) internal {\\r\\n    super._mint(_to, _tokenId);\\r\\n\\r\\n    allTokensIndex[_tokenId] = allTokens.length;\\r\\n    allTokens.push(_tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to burn a specific token\\r\\n   * Reverts if the token does not exist\\r\\n   * @param _owner owner of the token to burn\\r\\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\\r\\n   */\\r\\n  function _burn(address _owner, uint256 _tokenId) internal {\\r\\n    super._burn(_owner, _tokenId);\\r\\n\\r\\n    // Clear metadata (if any)\\r\\n    if (bytes(tokenURIs[_tokenId]).length != 0) {\\r\\n      delete tokenURIs[_tokenId];\\r\\n    }\\r\\n\\r\\n    // Reorg all tokens array\\r\\n    uint256 tokenIndex = allTokensIndex[_tokenId];\\r\\n    uint256 lastTokenIndex = allTokens.length.sub(1);\\r\\n    uint256 lastToken = allTokens[lastTokenIndex];\\r\\n\\r\\n    allTokens[tokenIndex] = lastToken;\\r\\n    allTokens[lastTokenIndex] = 0;\\r\\n\\r\\n    allTokens.length--;\\r\\n    allTokensIndex[_tokenId] = 0;\\r\\n    allTokensIndex[lastToken] = tokenIndex;\\r\\n  }\\r\\n\\r\\n}\\r\\n\\r\\n// File: contracts/Strings.sol\\r\\n\\r\\nlibrary Strings {\\r\\n  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\\r\\n  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\\r\\n      bytes memory _ba = bytes(_a);\\r\\n      bytes memory _bb = bytes(_b);\\r\\n      bytes memory _bc = bytes(_c);\\r\\n      bytes memory _bd = bytes(_d);\\r\\n      bytes memory _be = bytes(_e);\\r\\n      string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\\r\\n      bytes memory babcde = bytes(abcde);\\r\\n      uint k = 0;\\r\\n      for (uint i = 0; i \\u003c _ba.length; i++) babcde[k++] = _ba[i];\\r\\n      for (i = 0; i \\u003c _bb.length; i++) babcde[k++] = _bb[i];\\r\\n      for (i = 0; i \\u003c _bc.length; i++) babcde[k++] = _bc[i];\\r\\n      for (i = 0; i \\u003c _bd.length; i++) babcde[k++] = _bd[i];\\r\\n      for (i = 0; i \\u003c _be.length; i++) babcde[k++] = _be[i];\\r\\n      return string(babcde);\\r\\n    }\\r\\n\\r\\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\\r\\n        return strConcat(_a, _b, _c, _d, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\\r\\n        return strConcat(_a, _b, _c, \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(string _a, string _b) internal pure returns (string) {\\r\\n        return strConcat(_a, _b, \\\"\\\", \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function uint2str(uint i) internal pure returns (string) {\\r\\n        if (i == 0) return \\\"0\\\";\\r\\n        uint j = i;\\r\\n        uint len;\\r\\n        while (j != 0){\\r\\n            len++;\\r\\n            j /= 10;\\r\\n        }\\r\\n        bytes memory bstr = new bytes(len);\\r\\n        uint k = len - 1;\\r\\n        while (i != 0){\\r\\n            bstr[k--] = byte(48 + i % 10);\\r\\n            i /= 10;\\r\\n        }\\r\\n        return string(bstr);\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/TradeableERC721Token.sol\\r\\n\\r\\ncontract OwnableDelegateProxy { }\\r\\n\\r\\ncontract ProxyRegistry {\\r\\n    mapping(address =\\u003e OwnableDelegateProxy) public proxies;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title TradeableERC721Token\\r\\n * TradeableERC721Token - ERC721 contract that whitelists a trading address, and has minting functionality.\\r\\n */\\r\\ncontract TradeableERC721Token is ERC721Token, Ownable {\\r\\n  using Strings for string;\\r\\n\\r\\n  address proxyRegistryAddress;\\r\\n  \\r\\n  // Mapping from token ID to item type.\\r\\n  mapping (uint256 =\\u003e uint256) public itemTypes;\\r\\n\\r\\n  constructor(string _name, string _symbol, address _proxyRegistryAddress) ERC721Token(_name, _symbol) public {\\r\\n    proxyRegistryAddress = _proxyRegistryAddress;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Mints a token to an address with a tokenURI.\\r\\n    * @param _to address of the future owner of the token\\r\\n    */\\r\\n  function mintTo(address _to, uint256 _itemType) public onlyOwner {\\r\\n    uint256 newTokenId = _getNextTokenId();\\r\\n    _mint(_to, newTokenId);\\r\\n    itemTypes[newTokenId] = _itemType;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev calculates the next token ID based on totalSupply\\r\\n    * @return uint256 for the next token ID\\r\\n    */\\r\\n  function _getNextTokenId() private view returns (uint256) {\\r\\n    return totalSupply().add(1);\\r\\n  }\\r\\n\\r\\n  function baseTokenURI() public view returns (string) {\\r\\n    return \\\"\\\";\\r\\n  }\\r\\n\\r\\n  function tokenURI(uint256 _tokenId) public view returns (string) {\\r\\n    return Strings.strConcat(\\r\\n        baseTokenURI(),\\r\\n        Strings.uint2str(itemTypes[_tokenId]),\\r\\n        \\\"/\\\",\\r\\n        Strings.uint2str(_tokenId)\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Override isApprovedForAll to whitelist user\\u0027s OpenSea proxy accounts to enable gas-less listings.\\r\\n   */\\r\\n  function isApprovedForAll(\\r\\n    address owner,\\r\\n    address operator\\r\\n  )\\r\\n    public\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    // Whitelist OpenSea proxy contract for easy trading.\\r\\n    ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\\r\\n    if (proxyRegistry.proxies(owner) == operator) {\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    return super.isApprovedForAll(owner, operator);\\r\\n  }\\r\\n}\\r\\n\\r\\n// File: contracts/Item.sol\\r\\n\\r\\n/**\\r\\n * @title Item\\r\\n * Item - a contract for my non-fungible items.\\r\\n */\\r\\ncontract Item is TradeableERC721Token {\\r\\n  constructor(address _proxyRegistryAddress) TradeableERC721Token(\\\"LTR Item\\\", \\\"LTRI\\\", _proxyRegistryAddress) public {  }\\r\\n\\r\\n  function baseTokenURI() public view returns (string) {\\r\\n    return \\\"https://ltr-item-metadata.herokuapp.com/api/item/\\\";\\r\\n  }\\r\\n}\\r\\n\\r\\n// File: contracts/ItemFactory.sol\\r\\n\\r\\ncontract ItemFactory is Factory, Ownable {\\r\\n  using Strings for string;\\r\\n\\r\\n  address public proxyRegistryAddress;\\r\\n  address public nftAddress;\\r\\n  address public lootBoxNftAddress;\\r\\n  string public baseURI = \\\"https://ltr-item-metadata.herokuapp.com/api/factory/\\\";\\r\\n  \\r\\n  uint256 NUM_OPTIONS = 3;\\r\\n\\r\\n  constructor(address _proxyRegistryAddress, address _nftAddress) public {\\r\\n    proxyRegistryAddress = _proxyRegistryAddress;\\r\\n    nftAddress = _nftAddress;\\r\\n  }\\r\\n\\r\\n  function name() external view returns (string) {\\r\\n    return \\\"LTR Item Sale\\\";\\r\\n  }\\r\\n\\r\\n  function symbol() external view returns (string) {\\r\\n    return \\\"LTRIS\\\";\\r\\n  }\\r\\n\\r\\n  function supportsFactoryInterface() public view returns (bool) {\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function numOptions() public view returns (uint256) {\\r\\n    return NUM_OPTIONS;\\r\\n  }\\r\\n\\r\\n  function setNumOptions(uint256 numOptions) public onlyOwner {\\r\\n    NUM_OPTIONS = numOptions;\\r\\n  }\\r\\n  \\r\\n  function mint(uint256 _optionId, address _toAddress) public {\\r\\n    // Must be sent from the owner proxy or owner.\\r\\n    ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\\r\\n    assert(proxyRegistry.proxies(owner) == msg.sender || owner == msg.sender || msg.sender == lootBoxNftAddress);\\r\\n    require(canMint(_optionId));\\r\\n\\r\\n    Item itemContract = Item(nftAddress);\\r\\n    itemContract.mintTo(_toAddress, _optionId);\\r\\n  }\\r\\n\\r\\n  function canMint(uint256 _optionId) public view returns (bool) {\\r\\n    return (_optionId \\u003c numOptions());\\r\\n  }\\r\\n  \\r\\n  function tokenURI(uint256 _optionId) public view returns (string) {\\r\\n    return Strings.strConcat(\\r\\n        baseURI,\\r\\n        Strings.uint2str(_optionId)\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Hack to get things to work automatically on OpenSea.\\r\\n   * Use transferFrom so the frontend doesn\\u0027t have to worry about different method names.\\r\\n   */\\r\\n  function transferFrom(address _from, address _to, uint256 _tokenId) public {\\r\\n    mint(_tokenId, _to);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Hack to get things to work automatically on OpenSea.\\r\\n   * Use isApprovedForAll so the frontend doesn\\u0027t have to worry about different method names.\\r\\n   */\\r\\n  function isApprovedForAll(\\r\\n    address _owner,\\r\\n    address _operator\\r\\n  )\\r\\n    public\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    if (owner == _owner \\u0026\\u0026 _owner == _operator) {\\r\\n      return true;\\r\\n    }\\r\\n\\r\\n    ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\\r\\n    if (owner == _owner \\u0026\\u0026 proxyRegistry.proxies(_owner) == _operator) {\\r\\n      return true;\\r\\n    }\\r\\n\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Hack to get things to work automatically on OpenSea.\\r\\n   * Use isApprovedForAll so the frontend doesn\\u0027t have to worry about different method names.\\r\\n   */\\r\\n  function ownerOf(uint256 _tokenId) public view returns (address _owner) {\\r\\n    return owner;\\r\\n  }\\r\\n}\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"sendToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnershipOfFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"},{\"name\":\"_assetIDtoGive\",\"type\":\"uint256\"}],\"name\":\"addNewAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_arrayIdsPlusOne\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_LTRGiftCampaign\",\"outputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_assetGiven\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"},{\"name\":\"_assetIDtoGive\",\"type\":\"uint256\"}],\"name\":\"addAddressAndSend\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_factoryContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"LTRConceptArtLoop","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000494791d2c0bda0502f35cda78caee80c8bed67f2","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://e3f1bc93b5a9dff9e753f93e97d4fc660cab43a89fb9007ea888b8decbe486c6"}]}