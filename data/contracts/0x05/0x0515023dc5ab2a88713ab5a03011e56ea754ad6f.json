{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-08-11\r\n*/\r\n\r\npragma solidity ^0.5.10;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    // counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n// File: contracts/commons/Ownable.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event TransferOwnership(address _from, address _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit TransferOwnership(address(0), msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only owner\");\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _owner) external onlyOwner {\r\n        emit TransferOwnership(owner, _owner);\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\n// File: contracts/commons/StorageUnit.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\ncontract StorageUnit {\r\n    address private owner;\r\n    mapping(bytes32 => bytes32) private store;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function write(bytes32 _key, bytes32 _value) external {\r\n        /* solium-disable-next-line */\r\n        require(msg.sender == owner);\r\n        store[_key] = _value;\r\n    }\r\n\r\n    function read(bytes32 _key) external view returns (bytes32) {\r\n        return store[_key];\r\n    }\r\n}\r\n\r\n// File: contracts/utils/IsContract.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\nlibrary IsContract {\r\n    function isContract(address _addr) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        /* solium-disable-next-line */\r\n        assembly { codehash := extcodehash(_addr) }\r\n        return codehash != bytes32(0) && codehash != bytes32(0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\r\n    }\r\n}\r\n\r\n// File: contracts/utils/DistributedStorage.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\nlibrary DistributedStorage {\r\n    function contractSlot(bytes32 _struct) private view returns (address) {\r\n        return address(\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0xff),\r\n                        address(this),\r\n                        _struct,\r\n                        keccak256(type(StorageUnit).creationCode)\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    function deploy(bytes32 _struct) private {\r\n        bytes memory slotcode = type(StorageUnit).creationCode;\r\n        /* solium-disable-next-line */\r\n        assembly{ pop(create2(0, add(slotcode, 0x20), mload(slotcode), _struct)) }\r\n    }\r\n\r\n    function write(\r\n        bytes32 _struct,\r\n        bytes32 _key,\r\n        bytes32 _value\r\n    ) internal {\r\n        StorageUnit store = StorageUnit(contractSlot(_struct));\r\n        if (!IsContract.isContract(address(store))) {\r\n            deploy(_struct);\r\n        }\r\n\r\n        /* solium-disable-next-line */\r\n        (bool success, ) = address(store).call(\r\n            abi.encodeWithSelector(\r\n                store.write.selector,\r\n                _key,\r\n                _value\r\n            )\r\n        );\r\n\r\n        require(success, \"error writing storage\");\r\n    }\r\n\r\n    function read(\r\n        bytes32 _struct,\r\n        bytes32 _key\r\n    ) internal view returns (bytes32) {\r\n        StorageUnit store = StorageUnit(contractSlot(_struct));\r\n        if (!IsContract.isContract(address(store))) {\r\n            return bytes32(0);\r\n        }\r\n\r\n        /* solium-disable-next-line */\r\n        (bool success, bytes memory data) = address(store).staticcall(\r\n            abi.encodeWithSelector(\r\n                store.read.selector,\r\n                _key\r\n            )\r\n        );\r\n\r\n        require(success, \"error reading storage\");\r\n        return abi.decode(data, (bytes32));\r\n    }\r\n}\r\n\r\n// File: contracts/utils/SafeMath.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        uint256 z = x + y;\r\n        require(z >= x, \"Add overflow\");\r\n        return z;\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(x >= y, \"Sub underflow\");\r\n        return x - y;\r\n    }\r\n\r\n    function mult(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 z = x * y;\r\n        require(z / x == y, \"Mult overflow\");\r\n        return z;\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"Div by zero\");\r\n        return x / y;\r\n    }\r\n\r\n    function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"Div by zero\");\r\n        uint256 r = x / y;\r\n        if (x % y != 0) {\r\n            r = r + 1;\r\n        }\r\n\r\n        return r;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/Math.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\nlibrary Math {\r\n    function orderOfMagnitude(uint256 input) internal pure returns (uint256){\r\n        uint256 counter = uint(-1);\r\n        uint256 temp = input;\r\n\r\n        do {\r\n            temp /= 10;\r\n            counter++;\r\n        } while (temp != 0);\r\n\r\n        return counter;\r\n    }\r\n\r\n    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a < _b) {\r\n            return _a;\r\n        } else {\r\n            return _b;\r\n        }\r\n    }\r\n\r\n    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a > _b) {\r\n            return _a;\r\n        } else {\r\n            return _b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/utils/GasPump.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\ncontract GasPump {\r\n    bytes32 private stub;\r\n\r\n    modifier requestGas(uint256 _factor) {\r\n        if (tx.gasprice == 0 || gasleft() > block.gaslimit) {\r\n            uint256 startgas = gasleft();\r\n            _;\r\n            uint256 delta = startgas - gasleft();\r\n            uint256 target = (delta * _factor) / 100;\r\n            startgas = gasleft();\r\n            while (startgas - gasleft() < target) {\r\n                // Burn gas\r\n                stub = keccak256(abi.encodePacked(stub));\r\n            }\r\n        } else {\r\n            _;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n}\r\n\r\n// File: contracts/commons/AddressMinHeap.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n/*\r\n    @author Agustin Aguilar <agusxrun@gmail.com>\r\n*/\r\n\r\n\r\nlibrary AddressMinHeap {\r\n    using AddressMinHeap for AddressMinHeap.Heap;\r\n\r\n    struct Heap {\r\n        uint256[] entries;\r\n        mapping(address => uint256) index;\r\n    }\r\n\r\n    function initialize(Heap storage _heap) internal {\r\n        require(_heap.entries.length == 0, \"already initialized\");\r\n        _heap.entries.push(0);\r\n    }\r\n\r\n    function encode(address _addr, uint256 _value) internal pure returns (uint256 _entry) {\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            _entry := not(or(and(0xffffffffffffffffffffffffffffffffffffffff, _addr), shl(160, _value)))\r\n        }\r\n    }\r\n\r\n    function decode(uint256 _entry) internal pure returns (address _addr, uint256 _value) {\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            let entry := not(_entry)\r\n            _addr := and(entry, 0xffffffffffffffffffffffffffffffffffffffff)\r\n            _value := shr(160, entry)\r\n        }\r\n    }\r\n\r\n    function decodeAddress(uint256 _entry) internal pure returns (address _addr) {\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            _addr := and(not(_entry), 0xffffffffffffffffffffffffffffffffffffffff)\r\n        }\r\n    }\r\n\r\n    function top(Heap storage _heap) internal view returns(address, uint256) {\r\n        if (_heap.entries.length < 2) {\r\n            return (address(0), 0);\r\n        }\r\n\r\n        return decode(_heap.entries[1]);\r\n    }\r\n\r\n    function has(Heap storage _heap, address _addr) internal view returns (bool) {\r\n        return _heap.index[_addr] != 0;\r\n    }\r\n\r\n    function size(Heap storage _heap) internal view returns (uint256) {\r\n        return _heap.entries.length - 1;\r\n    }\r\n\r\n    function entry(Heap storage _heap, uint256 _i) internal view returns (address, uint256) {\r\n        return decode(_heap.entries[_i + 1]);\r\n    }\r\n\r\n    // RemoveMax pops off the root element of the heap (the highest value here) and rebalances the heap\r\n    function popTop(Heap storage _heap) internal returns(address _addr, uint256 _value) {\r\n        // Ensure the heap exists\r\n        uint256 heapLength = _heap.entries.length;\r\n        require(heapLength > 1, \"The heap does not exists\");\r\n\r\n        // take the root value of the heap\r\n        (_addr, _value) = decode(_heap.entries[1]);\r\n        _heap.index[_addr] = 0;\r\n\r\n        if (heapLength == 2) {\r\n            _heap.entries.length = 1;\r\n        } else {\r\n            // Takes the last element of the array and put it at the root\r\n            uint256 val = _heap.entries[heapLength - 1];\r\n            _heap.entries[1] = val;\r\n\r\n            // Delete the last element from the array\r\n            _heap.entries.length = heapLength - 1;\r\n\r\n            // Start at the top\r\n            uint256 ind = 1;\r\n\r\n            // Bubble down\r\n            ind = _heap.bubbleDown(ind, val);\r\n\r\n            // Update index\r\n            _heap.index[decodeAddress(val)] = ind;\r\n        }\r\n    }\r\n\r\n    // Inserts adds in a value to our heap.\r\n    function insert(Heap storage _heap, address _addr, uint256 _value) internal {\r\n        require(_heap.index[_addr] == 0, \"The entry already exists\");\r\n\r\n        // Add the value to the end of our array\r\n        uint256 encoded = encode(_addr, _value);\r\n        _heap.entries.push(encoded);\r\n\r\n        // Start at the end of the array\r\n        uint256 currentIndex = _heap.entries.length - 1;\r\n\r\n        // Bubble Up\r\n        currentIndex = _heap.bubbleUp(currentIndex, encoded);\r\n\r\n        // Update index\r\n        _heap.index[_addr] = currentIndex;\r\n    }\r\n\r\n    function update(Heap storage _heap, address _addr, uint256 _value) internal {\r\n        uint256 ind = _heap.index[_addr];\r\n        require(ind != 0, \"The entry does not exists\");\r\n\r\n        uint256 can = encode(_addr, _value);\r\n        uint256 val = _heap.entries[ind];\r\n        uint256 newInd;\r\n\r\n        if (can < val) {\r\n            // Bubble down\r\n            newInd = _heap.bubbleDown(ind, can);\r\n        } else if (can > val) {\r\n            // Bubble up\r\n            newInd = _heap.bubbleUp(ind, can);\r\n        } else {\r\n            // no changes needed\r\n            return;\r\n        }\r\n\r\n        // Update entry\r\n        _heap.entries[newInd] = can;\r\n\r\n        // Update index\r\n        if (newInd != ind) {\r\n            _heap.index[_addr] = newInd;\r\n        }\r\n    }\r\n\r\n    function bubbleUp(Heap storage _heap, uint256 _ind, uint256 _val) internal returns (uint256 ind) {\r\n        // Bubble up\r\n        ind = _ind;\r\n        if (ind != 1) {\r\n            uint256 parent = _heap.entries[ind / 2];\r\n            while (parent < _val) {\r\n                // If the parent value is lower than our current value, we swap them\r\n                (_heap.entries[ind / 2], _heap.entries[ind]) = (_val, parent);\r\n\r\n                // Update moved Index\r\n                _heap.index[decodeAddress(parent)] = ind;\r\n\r\n                // change our current Index to go up to the parent\r\n                ind = ind / 2;\r\n                if (ind == 1) {\r\n                    break;\r\n                }\r\n\r\n                // Update parent\r\n                parent = _heap.entries[ind / 2];\r\n            }\r\n        }\r\n    }\r\n\r\n    function bubbleDown(Heap storage _heap, uint256 _ind, uint256 _val) internal returns (uint256 ind) {\r\n        // Bubble down\r\n        ind = _ind;\r\n\r\n        uint256 lenght = _heap.entries.length;\r\n        uint256 target = lenght - 1;\r\n\r\n        while (ind * 2 < lenght) {\r\n            // get the current index of the children\r\n            uint256 j = ind * 2;\r\n\r\n            // left child value\r\n            uint256 leftChild = _heap.entries[j];\r\n\r\n            // Store the value of the child\r\n            uint256 childValue;\r\n\r\n            if (target > j) {\r\n                // The parent has two childs 👨‍👧‍👦\r\n\r\n                // Load right child value\r\n                uint256 rightChild = _heap.entries[j + 1];\r\n\r\n                // Compare the left and right child.\r\n                // if the rightChild is greater, then point j to it's index\r\n                // and save the value\r\n                if (leftChild < rightChild) {\r\n                    childValue = rightChild;\r\n                    j = j + 1;\r\n                } else {\r\n                    // The left child is greater\r\n                    childValue = leftChild;\r\n                }\r\n            } else {\r\n                // The parent has a single child 👨‍👦\r\n                childValue = leftChild;\r\n            }\r\n\r\n            // Check if the child has a lower value\r\n            if (_val > childValue) {\r\n                break;\r\n            }\r\n\r\n            // else swap the value\r\n            (_heap.entries[ind], _heap.entries[j]) = (childValue, _val);\r\n\r\n            // Update moved Index\r\n            _heap.index[decodeAddress(childValue)] = ind;\r\n\r\n            // and let's keep going down the heap\r\n            ind = j;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Heap.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\ncontract Heap is Ownable {\r\n    using AddressMinHeap for AddressMinHeap.Heap;\r\n\r\n    // heap\r\n    AddressMinHeap.Heap private heap;\r\n\r\n    // Heap events\r\n    event JoinHeap(address indexed _address, uint256 _balance, uint256 _prevSize);\r\n    event LeaveHeap(address indexed _address, uint256 _balance, uint256 _prevSize);\r\n\r\n    uint256 public constant TOP_SIZE = 512;\r\n\r\n    constructor() public {\r\n        heap.initialize();\r\n    }\r\n\r\n    function topSize() external pure returns (uint256) {\r\n        return TOP_SIZE;\r\n    }\r\n\r\n    function addressAt(uint256 _i) external view returns (address addr) {\r\n        (addr, ) = heap.entry(_i);\r\n    }\r\n\r\n    function indexOf(address _addr) external view returns (uint256) {\r\n        return heap.index[_addr];\r\n    }\r\n\r\n    function entry(uint256 _i) external view returns (address, uint256) {\r\n        return heap.entry(_i);\r\n    }\r\n\r\n    function top() external view returns (address, uint256) {\r\n        return heap.top();\r\n    }\r\n\r\n    function size() external view returns (uint256) {\r\n        return heap.size();\r\n    }\r\n\r\n    function update(address _addr, uint256 _new) external onlyOwner {\r\n        uint256 _size = heap.size();\r\n\r\n        // If the heap is empty\r\n        // join the _addr\r\n        if (_size == 0) {\r\n            emit JoinHeap(_addr, _new, 0);\r\n            heap.insert(_addr, _new);\r\n            return;\r\n        }\r\n\r\n        // Load top value of the heap\r\n        (, uint256 lastBal) = heap.top();\r\n\r\n        // If our target address already is in the heap\r\n        if (heap.has(_addr)) {\r\n            // Update the target address value\r\n            heap.update(_addr, _new);\r\n            // If the new value is 0\r\n            // always pop the heap\r\n            // we updated the heap, so our address should be on top\r\n            if (_new == 0) {\r\n                heap.popTop();\r\n                emit LeaveHeap(_addr, 0, _size);\r\n            }\r\n        } else {\r\n            // IF heap is full or new balance is higher than pop heap\r\n            if (_new != 0 && (_size < TOP_SIZE || lastBal < _new)) {\r\n                // If heap is full pop heap\r\n                if (_size >= TOP_SIZE) {\r\n                    (address _poped, uint256 _balance) = heap.popTop();\r\n                    emit LeaveHeap(_poped, _balance, _size);\r\n                }\r\n\r\n                // Insert new value\r\n                heap.insert(_addr, _new);\r\n                emit JoinHeap(_addr, _new, _size);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/ShuffleToken.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ShuffleToken is Ownable, GasPump, IERC20 {\r\n    using DistributedStorage for bytes32;\r\n    using SafeMath for uint256;\r\n\r\n    // Shuffle events\r\n    event Winner(address indexed _addr, uint256 _value);\r\n\r\n    // Managment events\r\n    event SetName(string _prev, string _new);\r\n    event SetExtraGas(uint256 _prev, uint256 _new);\r\n    event SetHeap(address _prev, address _new);\r\n    event WhitelistFrom(address _addr, bool _whitelisted);\r\n    event WhitelistTo(address _addr, bool _whitelisted);\r\n\r\n    uint256 public totalSupply;\r\n\r\n    bytes32 private constant BALANCE_KEY = keccak256(\"balance\");\r\n\r\n    // game\r\n    uint256 public constant FEE = 100;\r\n\r\n    // metadata\r\n    string public name = \"Shuffle.Monster V3\";\r\n    string public constant symbol = \"SHUF\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    // fee whitelist\r\n    mapping(address => bool) public whitelistFrom;\r\n    mapping(address => bool) public whitelistTo;\r\n\r\n    // heap\r\n    Heap public heap;\r\n\r\n    // internal\r\n    uint256 public extraGas;\r\n    bool inited;\r\n\r\n    function init(\r\n        address _to,\r\n        uint256 _amount\r\n    ) external {\r\n        // Only init once\r\n        assert(!inited);\r\n        inited = true;\r\n\r\n        // Sanity checks\r\n        assert(totalSupply == 0);\r\n        assert(address(heap) == address(0));\r\n\r\n        // Create Heap\r\n        heap = new Heap();\r\n        emit SetHeap(address(0), address(heap));\r\n\r\n        // Init contract variables and mint\r\n        // entire token balance\r\n        extraGas = 15;\r\n        emit SetExtraGas(0, extraGas);\r\n        emit Transfer(address(0), _to, _amount);\r\n        _setBalance(_to, _amount);\r\n        totalSupply = _amount;\r\n    }\r\n\r\n    ///\r\n    // Storage access functions\r\n    ///\r\n\r\n    // Getters\r\n\r\n    function _toKey(address a) internal pure returns (bytes32) {\r\n        return bytes32(uint256(a));\r\n    }\r\n\r\n    function _balanceOf(address _addr) internal view returns (uint256) {\r\n        return uint256(_toKey(_addr).read(BALANCE_KEY));\r\n    }\r\n\r\n    function _allowance(address _addr, address _spender) internal view returns (uint256) {\r\n        return uint256(_toKey(_addr).read(keccak256(abi.encodePacked(\"allowance\", _spender))));\r\n    }\r\n\r\n    function _nonce(address _addr, uint256 _cat) internal view returns (uint256) {\r\n        return uint256(_toKey(_addr).read(keccak256(abi.encodePacked(\"nonce\", _cat))));\r\n    }\r\n\r\n    // Setters\r\n\r\n    function _setAllowance(address _addr, address _spender, uint256 _value) internal {\r\n        _toKey(_addr).write(keccak256(abi.encodePacked(\"allowance\", _spender)), bytes32(_value));\r\n    }\r\n\r\n    function _setNonce(address _addr, uint256 _cat, uint256 _value) internal {\r\n        _toKey(_addr).write(keccak256(abi.encodePacked(\"nonce\", _cat)), bytes32(_value));\r\n    }\r\n\r\n    function _setBalance(address _addr, uint256 _balance) internal {\r\n        _toKey(_addr).write(BALANCE_KEY, bytes32(_balance));\r\n        heap.update(_addr, _balance);\r\n    }\r\n\r\n    ///\r\n    // Internal methods\r\n    ///\r\n\r\n    function _isWhitelisted(address _from, address _to) internal view returns (bool) {\r\n        return whitelistFrom[_from]||whitelistTo[_to];\r\n    }\r\n\r\n    function _random(address _s1, uint256 _s2, uint256 _s3, uint256 _max) internal pure returns (uint256) {\r\n        uint256 rand = uint256(keccak256(abi.encodePacked(_s1, _s2, _s3)));\r\n        return rand % (_max + 1);\r\n    }\r\n\r\n    function _pickWinner(address _from, uint256 _value) internal returns (address winner) {\r\n        // Get order of magnitude of the tx\r\n        uint256 magnitude = Math.orderOfMagnitude(_value);\r\n        // Pull nonce for a given order of magnitude\r\n        uint256 nonce = _nonce(_from, magnitude);\r\n        _setNonce(_from, magnitude, nonce + 1);\r\n        // pick entry from heap\r\n        winner = heap.addressAt(_random(_from, nonce, magnitude, heap.size() - 1));\r\n    }\r\n\r\n    function _transferFrom(address _operator, address _from, address _to, uint256 _value, bool _payFee) internal {\r\n        // If transfer amount is zero\r\n        // emit event and stop execution\r\n        if (_value == 0) {\r\n            emit Transfer(_from, _to, 0);\r\n            return;\r\n        }\r\n\r\n        // Load sender balance\r\n        uint256 balanceFrom = _balanceOf(_from);\r\n        require(balanceFrom >= _value, \"balance not enough\");\r\n\r\n        // Check if operator is sender\r\n        if (_from != _operator) {\r\n            // If not, validate allowance\r\n            uint256 allowanceFrom = _allowance(_from, _operator);\r\n            // If allowance is not 2 ** 256 - 1, consume allowance\r\n            if (allowanceFrom != uint(-1)) {\r\n                // Check allowance and save new one\r\n                require(allowanceFrom >= _value, \"allowance not enough\");\r\n                _setAllowance(_from, _operator, allowanceFrom.sub(_value));\r\n            }\r\n        }\r\n\r\n        // Calculate receiver balance\r\n        // initial receive is full value\r\n        uint256 receive = _value;\r\n        uint256 burn = 0;\r\n        uint256 shuf = 0;\r\n\r\n        // Change sender balance\r\n        _setBalance(_from, balanceFrom.sub(_value));\r\n\r\n        // If the transaction is not whitelisted\r\n        // or if sender requested to pay the fee\r\n        // calculate fees\r\n        if (_payFee || !_isWhitelisted(_from, _to)) {\r\n            // Fee is the same for BURN and SHUF\r\n            // If we are sending value one\r\n            // give priority to BURN\r\n            burn = _value.divRound(FEE);\r\n            shuf = _value == 1 ? 0 : burn;\r\n\r\n            // Subtract fees from receiver amount\r\n            receive = receive.sub(burn.add(shuf));\r\n\r\n            // Burn tokens\r\n            totalSupply = totalSupply.sub(burn);\r\n            emit Transfer(_from, address(0), burn);\r\n\r\n            // Shuffle tokens\r\n            // Pick winner pseudo-randomly\r\n            address winner = _pickWinner(_from, _value);\r\n            // Transfer balance to winner\r\n            _setBalance(winner, _balanceOf(winner).add(shuf));\r\n            emit Winner(winner, shuf);\r\n            emit Transfer(_from, winner, shuf);\r\n        }\r\n\r\n        // Sanity checks\r\n        // no tokens where created\r\n        assert(burn.add(shuf).add(receive) == _value);\r\n\r\n        // Add tokens to receiver\r\n        _setBalance(_to, _balanceOf(_to).add(receive));\r\n        emit Transfer(_from, _to, receive);\r\n    }\r\n\r\n    ///\r\n    // Managment\r\n    ///\r\n\r\n    function setWhitelistedTo(address _addr, bool _whitelisted) external onlyOwner {\r\n        emit WhitelistTo(_addr, _whitelisted);\r\n        whitelistTo[_addr] = _whitelisted;\r\n    }\r\n\r\n    function setWhitelistedFrom(address _addr, bool _whitelisted) external onlyOwner {\r\n        emit WhitelistFrom(_addr, _whitelisted);\r\n        whitelistFrom[_addr] = _whitelisted;\r\n    }\r\n\r\n    function setName(string calldata _name) external onlyOwner {\r\n        emit SetName(name, _name);\r\n        name = _name;\r\n    }\r\n\r\n    function setExtraGas(uint256 _gas) external onlyOwner {\r\n        emit SetExtraGas(extraGas, _gas);\r\n        extraGas = _gas;\r\n    }\r\n\r\n    function setHeap(Heap _heap) external onlyOwner {\r\n        emit SetHeap(address(heap), address(_heap));\r\n        heap = _heap;\r\n    }\r\n\r\n    /////\r\n    // Heap methods\r\n    /////\r\n\r\n    function topSize() external view returns (uint256) {\r\n        return heap.topSize();\r\n    }\r\n\r\n    function heapSize() external view returns (uint256) {\r\n        return heap.size();\r\n    }\r\n\r\n    function heapEntry(uint256 _i) external view returns (address, uint256) {\r\n        return heap.entry(_i);\r\n    }\r\n\r\n    function heapTop() external view returns (address, uint256) {\r\n        return heap.top();\r\n    }\r\n\r\n    function heapIndex(address _addr) external view returns (uint256) {\r\n        return heap.indexOf(_addr);\r\n    }\r\n\r\n    function getNonce(address _addr, uint256 _cat) external view returns (uint256) {\r\n        return _nonce(_addr, _cat);\r\n    }\r\n\r\n    /////\r\n    // ERC20\r\n    /////\r\n\r\n    function balanceOf(address _addr) external view returns (uint256) {\r\n        return _balanceOf(_addr);\r\n    }\r\n\r\n    function allowance(address _addr, address _spender) external view returns (uint256) {\r\n        return _allowance(_addr, _spender);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool) {\r\n        emit Approval(msg.sender, _spender, _value);\r\n        _setAllowance(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) external requestGas(extraGas) returns (bool) {\r\n        _transferFrom(msg.sender, msg.sender, _to, _value, false);\r\n        return true;\r\n    }\r\n\r\n    function transferWithFee(address _to, uint256 _value) external requestGas(extraGas) returns (bool) {\r\n        _transferFrom(msg.sender, msg.sender, _to, _value, true);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) external requestGas(extraGas) returns (bool) {\r\n        _transferFrom(msg.sender, _from, _to, _value, false);\r\n        return true;\r\n    }\r\n\r\n    function transferFromWithFee(address _from, address _to, uint256 _value) external requestGas(extraGas) returns (bool) {\r\n        _transferFrom(msg.sender, _from, _to, _value, true);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/SigUtils.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\nlibrary SigUtils {\r\n    /**\r\n      @dev Recovers address who signed the message\r\n      @param _hash operation ethereum signed message hash\r\n      @param _signature message `hash` signature\r\n    */\r\n    function ecrecover2(\r\n        bytes32 _hash,\r\n        bytes memory _signature\r\n    ) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            r := mload(add(_signature, 32))\r\n            s := mload(add(_signature, 64))\r\n            v := and(mload(add(_signature, 65)), 255)\r\n        }\r\n\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        return ecrecover(\r\n            _hash,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/utils/SafeCast.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\nlibrary SafeCast {\r\n    function toUint96(uint256 _a) internal pure returns (uint96) {\r\n        require(_a <= 2 ** 96 - 1, \"cast uint96 overflow\");\r\n        return uint96(_a);\r\n    }\r\n}\r\n\r\n// File: contracts/Airdrop.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Airdrop is Ownable, ReentrancyGuard {\r\n    using IsContract for address payable;\r\n    using SafeCast for uint256;\r\n    using SafeMath for uint256;\r\n\r\n    ShuffleToken public shuffleToken;\r\n\r\n    // Managment\r\n    uint64 public maxClaimedBy = 0;\r\n    uint256 public refsCut;\r\n    mapping(address => uint256) public customMaxClaimedBy;\r\n    bool public paused;\r\n\r\n    event SetMaxClaimedBy(uint256 _max);\r\n    event SetCustomMaxClaimedBy(address _address, uint256 _max);\r\n    event SetSigner(address _signer, bool _active);\r\n    event SetMigrator(address _migrator, bool _active);\r\n    event SetFuse(address _fuse, bool _active);\r\n    event SetPaused(bool _paused);\r\n    event SetRefsCut(uint256 _prev, uint256 _new);\r\n    event Claimed(address _by, address _to, address _signer, uint256 _value, uint256 _claimed, bytes _signature);\r\n    event RefClaim(address _ref, uint256 _val);\r\n    event ClaimedOwner(address _owner, uint256 _tokens);\r\n\r\n    uint256 public constant MINT_AMOUNT = 1000000 * 10 ** 18;\r\n    uint256 public constant SHUFLE_BY_ETH = 150;\r\n    uint256 public constant MAX_CLAIM_ETH = 10 ether;\r\n\r\n    mapping(address => bool) public isSigner;\r\n    mapping(address => bool) public isMigrator;\r\n    mapping(address => bool) public isFuse;\r\n\r\n    mapping(address => uint256) public claimed;\r\n    mapping(address => uint256) public numberClaimedBy;\r\n\r\n    constructor(ShuffleToken _token) public {\r\n        shuffleToken = _token;\r\n        emit SetMaxClaimedBy(maxClaimedBy);\r\n    }\r\n\r\n    // ///\r\n    // Managment\r\n    // ///\r\n\r\n    modifier notPaused() {\r\n        require(!paused, \"contract is paused\");\r\n        _;\r\n    }\r\n\r\n    function setMaxClaimedBy(uint64 _max) external onlyOwner {\r\n        maxClaimedBy = _max;\r\n        emit SetMaxClaimedBy(_max);\r\n    }\r\n\r\n    function setSigner(address _signer, bool _active) external onlyOwner {\r\n        isSigner[_signer] = _active;\r\n        emit SetSigner(_signer, _active);\r\n    }\r\n\r\n    function setMigrator(address _migrator, bool _active) external onlyOwner {\r\n        isMigrator[_migrator] = _active;\r\n        emit SetMigrator(_migrator, _active);\r\n    }\r\n\r\n    function setFuse(address _fuse, bool _active) external onlyOwner {\r\n        isFuse[_fuse] = _active;\r\n        emit SetFuse(_fuse, _active);\r\n    }\r\n\r\n    function setSigners(address[] calldata _signers, bool _active) external onlyOwner {\r\n        for (uint256 i = 0; i < _signers.length; i++) {\r\n            address signer = _signers[i];\r\n            isSigner[signer] = _active;\r\n            emit SetSigner(signer, _active);\r\n        }\r\n    }\r\n\r\n    function setCustomMaxClaimedBy(address _address, uint256 _max) external onlyOwner {\r\n        customMaxClaimedBy[_address] = _max;\r\n        emit SetCustomMaxClaimedBy(_address, _max);\r\n    }\r\n\r\n    function setRefsCut(uint256 _val) external onlyOwner {\r\n        emit SetRefsCut(refsCut, _val);\r\n        refsCut = _val;\r\n    }\r\n\r\n    function pause() external {\r\n        require(\r\n            isFuse[msg.sender] ||\r\n            msg.sender == owner ||\r\n            isMigrator[msg.sender] ||\r\n            isSigner[msg.sender],\r\n            \"not authorized\"\r\n        );\r\n\r\n        paused = true;\r\n        emit SetPaused(true);\r\n    }\r\n\r\n    function start() external onlyOwner {\r\n        emit SetPaused(false);\r\n        paused = false;\r\n    }\r\n\r\n    // ///\r\n    // Airdrop\r\n    // ///\r\n\r\n    function _selfBalance() internal view returns (uint256) {\r\n        return shuffleToken.balanceOf(address(this));\r\n    }\r\n\r\n    function checkFallback(address _to) private returns (bool success) {\r\n        /* solium-disable-next-line */\r\n        (success, ) = _to.call.value(1)(\"\");\r\n    }\r\n\r\n    function claim(\r\n        address _to,\r\n        address _ref,\r\n        uint256 _val,\r\n        bytes calldata _sig\r\n    ) external notPaused nonReentrant {\r\n        // Load values\r\n        uint96 val = _val.toUint96();\r\n\r\n        // Validate signature\r\n        bytes32 _hash = keccak256(abi.encodePacked(_to, val));\r\n        address signer = SigUtils.ecrecover2(_hash, _sig);\r\n        require(isSigner[signer], \"signature not valid\");\r\n\r\n        // Prepare claim amount\r\n        uint256 balance = _selfBalance();\r\n        uint256 claimVal = Math.min(\r\n            balance,\r\n            Math.min(\r\n                val,\r\n                MAX_CLAIM_ETH\r\n            ).mult(SHUFLE_BY_ETH)\r\n        );\r\n\r\n        // Sanity checks\r\n        assert(claimVal <= SHUFLE_BY_ETH.mult(val));\r\n        assert(claimVal <= MAX_CLAIM_ETH.mult(SHUFLE_BY_ETH));\r\n        assert(claimVal.div(SHUFLE_BY_ETH) <= MAX_CLAIM_ETH);\r\n        assert(\r\n            claimVal.div(SHUFLE_BY_ETH) == _val ||\r\n            claimVal.div(SHUFLE_BY_ETH) == MAX_CLAIM_ETH ||\r\n            claimVal == balance\r\n        );\r\n\r\n        // Claim, only once\r\n        require(claimed[_to] == 0, \"already claimed\");\r\n        claimed[_to] = claimVal;\r\n\r\n        // External claim checks\r\n        if (msg.sender != _to) {\r\n            // Validate max external claims\r\n            uint256 _numberClaimedBy = numberClaimedBy[msg.sender].add(1);\r\n            require(_numberClaimedBy <= Math.max(maxClaimedBy, customMaxClaimedBy[msg.sender]), \"max claim reached\");\r\n            numberClaimedBy[msg.sender] = _numberClaimedBy;\r\n            // Check if _to address can receive ETH\r\n            require(checkFallback(_to), \"_to address can't receive tokens\");\r\n        }\r\n\r\n        // Transfer Shuffle token, paying fee\r\n        shuffleToken.transferWithFee(_to, claimVal);\r\n\r\n        // Emit events\r\n        emit Claimed(msg.sender, _to, signer, val, claimVal, _sig);\r\n\r\n        // Ref links\r\n        if (refsCut != 0) {\r\n            // Only valid for self-claims\r\n            if (msg.sender == _to && _ref != address(0)) {\r\n                // Calc transfer extra\r\n                uint256 extra = claimVal.mult(refsCut).div(10000);\r\n                // Ignore ref fee if Airdrop balance is not enought\r\n                if (_selfBalance() >= extra) {\r\n                    shuffleToken.transferWithFee(_ref, extra);\r\n                    emit RefClaim(_ref, extra);\r\n\r\n                    // Sanity checks\r\n                    assert(extra <= MAX_CLAIM_ETH.mult(SHUFLE_BY_ETH));\r\n                    assert(extra <= claimVal);\r\n                    assert(extra == (claimVal * refsCut) / 10000);\r\n                }\r\n            }\r\n        }\r\n\r\n        // If contract is empty, perform self destruct\r\n        if (balance == claimVal && _selfBalance() == 0) {\r\n            selfdestruct(address(uint256(owner)));\r\n        }\r\n    }\r\n\r\n    // Migration methods\r\n\r\n    event Migrated(address _addr, uint256 _balance);\r\n    mapping(address => uint256) public migrated;\r\n\r\n    function migrate(address _addr, uint256 _balance, uint256 _require) external notPaused {\r\n        // Check if migrator is a migrator\r\n        require(isMigrator[msg.sender], \"only migrator can migrate\");\r\n\r\n        // Check if expected migrated matches current migrated\r\n        require(migrated[_addr] == _require, \"_require prev migrate failed\");\r\n\r\n        // Save migrated amount\r\n        migrated[_addr] = migrated[_addr].add(_balance);\r\n\r\n        // Transfer tokens and emit event\r\n        shuffleToken.transfer(_addr, _balance);\r\n        emit Migrated(_addr, _balance);\r\n    }\r\n\r\n    function fund() external payable { }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"shuffleToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signers\",\"type\":\"address[]\"},{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setSigners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"customMaxClaimedBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_max\",\"type\":\"uint64\"}],\"name\":\"setMaxClaimedBy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"},{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxClaimedBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"migrated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_migrator\",\"type\":\"address\"},{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setMigrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINT_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_CLAIM_ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fuse\",\"type\":\"address\"},{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setFuse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"setCustomMaxClaimedBy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"numberClaimedBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refsCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setRefsCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SHUFLE_BY_ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_ref\",\"type\":\"address\"},{\"name\":\"_val\",\"type\":\"uint256\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMigrator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFuse\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_balance\",\"type\":\"uint256\"},{\"name\":\"_require\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"SetMaxClaimedBy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"SetCustomMaxClaimedBy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_signer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"SetSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_migrator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"SetMigrator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_fuse\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"SetFuse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"SetPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prev\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"SetRefsCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_signer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_claimed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ref\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"RefClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"ClaimedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"Migrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"}]","ContractName":"Airdrop","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003a9fff453d50d4ac52a6890647b823379ba36b9e","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://438b5e61c241bee579a2e8c2886844992c329efd0e9ac020192eab76be5c712b"}]}