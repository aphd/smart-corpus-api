{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/IManager.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\ncontract IManager {\r\n    event SetController(address controller);\r\n    event ParameterUpdate(string param);\r\n\r\n    function setController(address _controller) external;\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/IController.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n\r\ncontract IController is Pausable {\r\n    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);\r\n\r\n    function setContractInfo(bytes32 _id, address _contractAddress, bytes20 _gitCommitHash) external;\r\n    function updateController(bytes32 _id, address _controller) external;\r\n    function getContract(bytes32 _id) public view returns (address);\r\n}\r\n\r\n// File: contracts/Manager.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n\r\n\r\ncontract Manager is IManager {\r\n    // Controller that contract is registered with\r\n    IController public controller;\r\n\r\n    // Check if sender is controller\r\n    modifier onlyController() {\r\n        require(msg.sender == address(controller));\r\n        _;\r\n    }\r\n\r\n    // Check if sender is controller owner\r\n    modifier onlyControllerOwner() {\r\n        require(msg.sender == controller.owner());\r\n        _;\r\n    }\r\n\r\n    // Check if controller is not paused\r\n    modifier whenSystemNotPaused() {\r\n        require(!controller.paused());\r\n        _;\r\n    }\r\n\r\n    // Check if controller is paused\r\n    modifier whenSystemPaused() {\r\n        require(controller.paused());\r\n        _;\r\n    }\r\n\r\n    function Manager(address _controller) public {\r\n        controller = IController(_controller);\r\n    }\r\n\r\n    /*\r\n     * @dev Set controller. Only callable by current controller\r\n     * @param _controller Controller contract address\r\n     */\r\n    function setController(address _controller) external onlyController {\r\n        controller = IController(_controller);\r\n\r\n        SetController(_controller);\r\n    }\r\n}\r\n\r\n// File: contracts/ManagerProxyTarget.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n\r\n/**\r\n * @title ManagerProxyTarget\r\n * @dev The base contract that target contracts used by a proxy contract should inherit from\r\n * Note: Both the target contract and the proxy contract (implemented as ManagerProxy) MUST inherit from ManagerProxyTarget in order to guarantee\r\n * that both contracts have the same storage layout. Differing storage layouts in a proxy contract and target contract can\r\n * potentially break the delegate proxy upgradeability mechanism\r\n */\r\ncontract ManagerProxyTarget is Manager {\r\n    // Used to look up target contract address in controller's registry\r\n    bytes32 public targetContractId;\r\n}\r\n\r\n// File: contracts/jobs/IJobsManager.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n/*\r\n * @title Interface for JobsManager\r\n * TODO: switch to interface type\r\n */\r\ncontract IJobsManager {\r\n    event Deposit(address indexed broadcaster, uint256 amount);\r\n    event Withdraw(address indexed broadcaster);\r\n    event NewJob(address indexed broadcaster, uint256 jobId, string streamId, string transcodingOptions, uint256 maxPricePerSegment, uint256 creationBlock);\r\n    event NewClaim(address indexed transcoder, uint256 indexed jobId, uint256 claimId);\r\n    event Verify(address indexed transcoder, uint256 indexed jobId, uint256 indexed claimId, uint256 segmentNumber);\r\n    event DistributeFees(address indexed transcoder, uint256 indexed jobId, uint256 indexed claimId, uint256 fees);\r\n    event PassedVerification(address indexed transcoder, uint256 indexed jobId, uint256 indexed claimId, uint256 segmentNumber);\r\n    event FailedVerification(address indexed transcoder, uint256 indexed jobId, uint256 indexed claimId, uint256 segmentNumber);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ECRecovery.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/MerkleProof.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/*\r\n * @title MerkleProof\r\n * @dev Merkle proof verification\r\n * @note Based on https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\r\n */\r\nlibrary MerkleProof {\r\n  /*\r\n   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\r\n   * and each pair of pre-images is sorted.\r\n   * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\r\n   * @param _root Merkle root\r\n   * @param _leaf Leaf of Merkle tree\r\n   */\r\n  function verifyProof(bytes _proof, bytes32 _root, bytes32 _leaf) public pure returns (bool) {\r\n    // Check if proof length is a multiple of 32\r\n    if (_proof.length % 32 != 0) return false;\r\n\r\n    bytes32 proofElement;\r\n    bytes32 computedHash = _leaf;\r\n\r\n    for (uint256 i = 32; i <= _proof.length; i += 32) {\r\n      assembly {\r\n        // Load the current element of the proof\r\n        proofElement := mload(add(_proof, i))\r\n      }\r\n\r\n      if (computedHash < proofElement) {\r\n        // Hash(current computed hash + current element of the proof)\r\n        computedHash = keccak256(computedHash, proofElement);\r\n      } else {\r\n        // Hash(current element of the proof + current computed hash)\r\n        computedHash = keccak256(proofElement, computedHash);\r\n      }\r\n    }\r\n\r\n    // Check if the computed hash (root) is equal to the provided root\r\n    return computedHash == _root;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/jobs/libraries/JobLib.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n\r\n\r\n\r\nlibrary JobLib {\r\n    using SafeMath for uint256;\r\n    // Prefix hashed with message hash when a signature is produced by the eth_sign RPC call\r\n    string constant PERSONAL_HASH_PREFIX = \"\\u0019Ethereum Signed Message:\\n32\";\r\n    // # of bytes used to store a video profile identifier as a utf8 encoded string\r\n    // Video profile identifier is currently stored as bytes4(keccak256(PROFILE_NAME))\r\n    // We use 2 * 4 = 8 bytes because we store the bytes in a utf8 encoded string so\r\n    // the identifiers can be easily parsed off-chain\r\n    uint8 constant VIDEO_PROFILE_SIZE = 8;\r\n\r\n    /*\r\n     * @dev Checks if a transcoding options string is valid\r\n     * A transcoding options string is composed of video profile ids so its length\r\n     * must be a multiple of VIDEO_PROFILE_SIZE\r\n     * @param _transcodingOptions Transcoding options string\r\n     */\r\n    function validTranscodingOptions(string _transcodingOptions) public pure returns (bool) {\r\n        uint256 transcodingOptionsLength = bytes(_transcodingOptions).length;\r\n        return transcodingOptionsLength > 0 && transcodingOptionsLength % VIDEO_PROFILE_SIZE == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Computes the amount of fees given total segments, total number of profiles and price per segment\r\n     * @param _totalSegments # of segments\r\n     * @param _transcodingOptions String containing video profiles for a job\r\n     * @param _pricePerSegment Price in LPT base units per segment\r\n     */\r\n    function calcFees(uint256 _totalSegments, string _transcodingOptions, uint256 _pricePerSegment) public pure returns (uint256) {\r\n        // Calculate total profiles defined in the transcoding options string\r\n        uint256 totalProfiles = bytes(_transcodingOptions).length.div(VIDEO_PROFILE_SIZE);\r\n        return _totalSegments.mul(totalProfiles).mul(_pricePerSegment);\r\n    }\r\n\r\n    /*\r\n     * Computes whether a segment is eligible for verification based on the last call to claimWork()\r\n     * @param _segmentNumber Sequence number of segment in stream\r\n     * @param _segmentRange Range of segments claimed\r\n     * @param _challengeBlock Block afer the block when claimWork() was called\r\n     * @param _challengeBlockHash Block hash of challenge block\r\n     * @param _verificationRate Rate at which a particular segment should be verified\r\n     */\r\n    function shouldVerifySegment(\r\n        uint256 _segmentNumber,\r\n        uint256[2] _segmentRange,\r\n        uint256 _challengeBlock,\r\n        bytes32 _challengeBlockHash,\r\n        uint64 _verificationRate\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // Segment must be in segment range\r\n        if (_segmentNumber < _segmentRange[0] || _segmentNumber > _segmentRange[1]) {\r\n            return false;\r\n        }\r\n\r\n        // Use block hash and block number of the block after a claim to determine if a segment\r\n        // should be verified\r\n        if (uint256(keccak256(_challengeBlock, _challengeBlockHash, _segmentNumber)) % _verificationRate == 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if a segment was signed by a broadcaster address\r\n     * @param _streamId Stream ID for the segment\r\n     * @param _segmentNumber Sequence number of segment in the stream\r\n     * @param _dataHash Hash of segment data\r\n     * @param _broadcasterSig Broadcaster signature over h(streamId, segmentNumber, dataHash)\r\n     * @param _broadcaster Broadcaster address\r\n     */\r\n    function validateBroadcasterSig(\r\n        string _streamId,\r\n        uint256 _segmentNumber,\r\n        bytes32 _dataHash,\r\n        bytes _broadcasterSig,\r\n        address _broadcaster\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return ECRecovery.recover(personalSegmentHash(_streamId, _segmentNumber, _dataHash), _broadcasterSig) == _broadcaster;\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if a transcode receipt hash was included in a committed merkle root\r\n     * @param _streamId StreamID for the segment\r\n     * @param _segmentNumber Sequence number of segment in the stream\r\n     * @param _dataHash Hash of segment data\r\n     * @param _transcodedDataHash Hash of transcoded segment data\r\n     * @param _broadcasterSig Broadcaster signature over h(streamId, segmentNumber, dataHash)\r\n     * @param _broadcaster Broadcaster address\r\n     */\r\n    function validateReceipt(\r\n        string _streamId,\r\n        uint256 _segmentNumber,\r\n        bytes32 _dataHash,\r\n        bytes32 _transcodedDataHash,\r\n        bytes _broadcasterSig,\r\n        bytes _proof,\r\n        bytes32 _claimRoot\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return MerkleProof.verifyProof(_proof, _claimRoot, transcodeReceiptHash(_streamId, _segmentNumber, _dataHash, _transcodedDataHash, _broadcasterSig));\r\n    }\r\n\r\n    /*\r\n     * Compute the hash of a segment\r\n     * @param _streamId Stream identifier\r\n     * @param _segmentSequenceNumber Segment sequence number in stream\r\n     * @param _dataHash Content-addressed storage hash of segment data\r\n     */\r\n    function segmentHash(string _streamId, uint256 _segmentNumber, bytes32 _dataHash) public pure returns (bytes32) {\r\n        return keccak256(_streamId, _segmentNumber, _dataHash);\r\n    }\r\n\r\n    /*\r\n     * @dev Compute the personal segment hash of a segment. Hashes the concatentation of the personal hash prefix and the segment hash\r\n     * @param _streamId Stream identifier\r\n     * @param _segmentSequenceNumber Segment sequence number in stream\r\n     * @param _dataHash Content-addrssed storage hash of segment data\r\n     */\r\n    function personalSegmentHash(string _streamId, uint256 _segmentNumber, bytes32 _dataHash) public pure returns (bytes32) {\r\n        bytes memory prefixBytes = bytes(PERSONAL_HASH_PREFIX);\r\n\r\n        return keccak256(prefixBytes, segmentHash(_streamId, _segmentNumber, _dataHash));\r\n    }\r\n\r\n    /*\r\n     * Compute the hash of a transcode receipt\r\n     * @param _streamId Stream identifier\r\n     * @param _segmentSequenceNumber Segment sequence number in stream\r\n     * @param _dataHash Content-addressed storage hash of segment data\r\n     * @param _transcodedDataHash Content-addressed storage hash of transcoded segment data\r\n     * @param _broadcasterSig Broadcaster's signature over segment\r\n     */\r\n    function transcodeReceiptHash(\r\n        string _streamId,\r\n        uint256 _segmentNumber,\r\n        bytes32 _dataHash,\r\n        bytes32 _transcodedDataHash,\r\n        bytes _broadcasterSig\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(_streamId, _segmentNumber, _dataHash, _transcodedDataHash, _broadcasterSig);\r\n    }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20Basic.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/token/ILivepeerToken.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n\r\n\r\ncontract ILivepeerToken is ERC20, Ownable {\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n    function burn(uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/token/IMinter.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n\r\n/**\r\n * @title Minter interface\r\n */\r\ncontract IMinter {\r\n    // Events\r\n    event SetCurrentRewardTokens(uint256 currentMintableTokens, uint256 currentInflation);\r\n\r\n    // External functions\r\n    function createReward(uint256 _fracNum, uint256 _fracDenom) external returns (uint256);\r\n    function trustedTransferTokens(address _to, uint256 _amount) external;\r\n    function trustedBurnTokens(uint256 _amount) external;\r\n    function trustedWithdrawETH(address _to, uint256 _amount) external;\r\n    function depositETH() external payable returns (bool);\r\n    function setCurrentRewardTokens() external;\r\n\r\n    // Public functions\r\n    function getController() public view returns (IController);\r\n}\r\n\r\n// File: contracts/bonding/IBondingManager.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n/*\r\n * @title Interface for BondingManager\r\n * TODO: switch to interface type\r\n */\r\ncontract IBondingManager {\r\n    event TranscoderUpdate(address indexed transcoder, uint256 pendingRewardCut, uint256 pendingFeeShare, uint256 pendingPricePerSegment, bool registered);\r\n    event TranscoderEvicted(address indexed transcoder);\r\n    event TranscoderResigned(address indexed transcoder);\r\n    event TranscoderSlashed(address indexed transcoder, address finder, uint256 penalty, uint256 finderReward);\r\n    event Reward(address indexed transcoder, uint256 amount);\r\n    event Bond(address indexed newDelegate, address indexed oldDelegate, address indexed delegator, uint256 additionalAmount, uint256 bondedAmount);\r\n    event Unbond(address indexed delegate, address indexed delegator, uint256 unbondingLockId, uint256 amount, uint256 withdrawRound);\r\n    event Rebond(address indexed delegate, address indexed delegator, uint256 unbondingLockId, uint256 amount);\r\n    event WithdrawStake(address indexed delegator, uint256 unbondingLockId, uint256 amount, uint256 withdrawRound);\r\n    event WithdrawFees(address indexed delegator);\r\n\r\n    // Deprecated events\r\n    // These event signatures can be used to construct the appropriate topic hashes to filter for past logs corresponding\r\n    // to these deprecated events.\r\n    // event Bond(address indexed delegate, address indexed delegator);\r\n    // event Unbond(address indexed delegate, address indexed delegator);\r\n    // event WithdrawStake(address indexed delegator);\r\n\r\n    // External functions\r\n    function setActiveTranscoders() external;\r\n    function updateTranscoderWithFees(address _transcoder, uint256 _fees, uint256 _round) external;\r\n    function slashTranscoder(address _transcoder, address _finder, uint256 _slashAmount, uint256 _finderFee) external;\r\n    function electActiveTranscoder(uint256 _maxPricePerSegment, bytes32 _blockHash, uint256 _round) external view returns (address);\r\n\r\n    // Public functions\r\n    function transcoderTotalStake(address _transcoder) public view returns (uint256);\r\n    function activeTranscoderTotalStake(address _transcoder, uint256 _round) public view returns (uint256);\r\n    function isRegisteredTranscoder(address _transcoder) public view returns (bool);\r\n    function getTotalBonded() public view returns (uint256);\r\n}\r\n\r\n// File: contracts/rounds/IRoundsManager.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n/**\r\n * @title RoundsManager interface\r\n */\r\ncontract IRoundsManager {\r\n    // Events\r\n    event NewRound(uint256 round);\r\n\r\n    // External functions\r\n    function initializeRound() external;\r\n\r\n    // Public functions\r\n    function blockNum() public view returns (uint256);\r\n    function blockHash(uint256 _block) public view returns (bytes32);\r\n    function currentRound() public view returns (uint256);\r\n    function currentRoundStartBlock() public view returns (uint256);\r\n    function currentRoundInitialized() public view returns (bool);\r\n    function currentRoundLocked() public view returns (bool);\r\n}\r\n\r\n// File: contracts/verification/IVerifiable.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n/*\r\n * @title Interface for contract that receives verification results\r\n * TODO: switch to interface type\r\n */\r\ncontract IVerifiable {\r\n    // External functions\r\n    function receiveVerification(uint256 _jobId, uint256 _claimId, uint256 _segmentNumber, bool _result) external;\r\n}\r\n\r\n// File: contracts/verification/IVerifier.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n/**\r\n * @title Interface for a Verifier. Can be backed by any implementaiton including oracles or Truebit\r\n */\r\ncontract IVerifier {\r\n    function verify(\r\n        uint256 _jobId,\r\n        uint256 _claimId,\r\n        uint256 _segmentNumber,\r\n        string _transcodingOptions,\r\n        string _dataStorageHash,\r\n        bytes32[2] _dataHashes\r\n    )\r\n        external\r\n        payable;\r\n\r\n    function getPrice() public view returns (uint256);\r\n}\r\n\r\n// File: contracts/libraries/MathUtils.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n\r\nlibrary MathUtils {\r\n    using SafeMath for uint256;\r\n\r\n    // Divisor used for representing percentages\r\n    uint256 public constant PERC_DIVISOR = 1000000;\r\n\r\n    /*\r\n     * @dev Returns whether an amount is a valid percentage out of PERC_DIVISOR\r\n     * @param _amount Amount that is supposed to be a percentage\r\n     */\r\n    function validPerc(uint256 _amount) internal pure returns (bool) {\r\n        return _amount <= PERC_DIVISOR;\r\n    }\r\n\r\n    /*\r\n     * @dev Compute percentage of a value with the percentage represented by a fraction\r\n     * @param _amount Amount to take the percentage of\r\n     * @param _fracNum Numerator of fraction representing the percentage\r\n     * @param _fracDenom Denominator of fraction representing the percentage\r\n     */\r\n    function percOf(uint256 _amount, uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\r\n        return _amount.mul(percPoints(_fracNum, _fracDenom)).div(PERC_DIVISOR);\r\n    }\r\n\r\n    /*\r\n     * @dev Compute percentage of a value with the percentage represented by a fraction over PERC_DIVISOR\r\n     * @param _amount Amount to take the percentage of\r\n     * @param _fracNum Numerator of fraction representing the percentage with PERC_DIVISOR as the denominator\r\n     */\r\n    function percOf(uint256 _amount, uint256 _fracNum) internal pure returns (uint256) {\r\n        return _amount.mul(_fracNum).div(PERC_DIVISOR);\r\n    }\r\n\r\n    /*\r\n     * @dev Compute percentage representation of a fraction\r\n     * @param _fracNum Numerator of fraction represeting the percentage\r\n     * @param _fracDenom Denominator of fraction represeting the percentage\r\n     */\r\n    function percPoints(uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\r\n        return _fracNum.mul(PERC_DIVISOR).div(_fracDenom);\r\n    }\r\n}\r\n\r\n// File: contracts/jobs/JobsManager.sol\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract JobsManager is ManagerProxyTarget, IVerifiable, IJobsManager {\r\n    using SafeMath for uint256;\r\n\r\n    // % of segments to be verified. 1 / verificationRate == % to be verified\r\n    uint64 public verificationRate;\r\n\r\n    // Time after a transcoder calls claimWork() that it has to complete verification of claimed work\r\n    uint256 public verificationPeriod;\r\n\r\n    // Time after a claim's verification period during which anyone can slash the transcoder for missing a required verification\r\n    uint256 public verificationSlashingPeriod;\r\n\r\n    // % of stake slashed for failed verification\r\n    uint256 public failedVerificationSlashAmount;\r\n\r\n    // % of stake slashed for missed verification\r\n    uint256 public missedVerificationSlashAmount;\r\n\r\n    // % of stake slashed for double claiming a segment\r\n    uint256 public doubleClaimSegmentSlashAmount;\r\n\r\n    // % of of slashed amount awarded to finder\r\n    uint256 public finderFee;\r\n\r\n    struct Broadcaster {\r\n        uint256 deposit;         // Deposited ETH for jobs\r\n        uint256 withdrawBlock;   // Block at which a deposit can be withdrawn\r\n    }\r\n\r\n    // Mapping broadcaster address => broadcaster info\r\n    mapping (address => Broadcaster) public broadcasters;\r\n\r\n    // Represents a transcode job\r\n    struct Job {\r\n        uint256 jobId;                        // Unique identifer for job\r\n        string streamId;                      // Unique identifier for stream.\r\n        string transcodingOptions;            // Options used for transcoding\r\n        uint256 maxPricePerSegment;           // Max price (in LPT base units) per segment of a stream\r\n        address broadcasterAddress;           // Address of broadcaster that requestes a transcoding job\r\n        address transcoderAddress;            // Address of transcoder selected for the job\r\n        uint256 creationRound;                // Round that a job is created\r\n        uint256 creationBlock;                // Block that a job is created\r\n        uint256 endBlock;                     // Block at which the job is ended and considered inactive\r\n        Claim[] claims;                       // Claims submitted for this job\r\n        uint256 escrow;                       // Claim fees before verification and slashing periods are complete\r\n    }\r\n\r\n    // States of a job\r\n    enum JobStatus { Inactive, Active }\r\n\r\n    // Represents a transcode claim\r\n    struct Claim {\r\n        uint256 claimId;                                   // Unique identifier for claim\r\n        uint256[2] segmentRange;                           // Range of segments claimed\r\n        bytes32 claimRoot;                                 // Merkle root of segment transcode proof data\r\n        uint256 claimBlock;                                // Block number that claim was submitted\r\n        uint256 endVerificationBlock;                      // End of verification period for this claim\r\n        uint256 endVerificationSlashingBlock;              // End of verification slashing period for this claim\r\n        mapping (uint256 => bool) segmentVerifications;    // Mapping segment number => whether segment was submitted for verification\r\n        ClaimStatus status;                                // Status of claim (pending, slashed, complete)\r\n    }\r\n\r\n    // States of a transcode claim\r\n    enum ClaimStatus { Pending, Slashed, Complete }\r\n\r\n    // Transcode jobs\r\n    mapping (uint256 => Job) public jobs;\r\n    // Number of jobs created. Also used for sequential identifiers\r\n    uint256 public numJobs;\r\n\r\n    // Check if sender is Verifier\r\n    modifier onlyVerifier() {\r\n        require(msg.sender == controller.getContract(keccak256(\"Verifier\")));\r\n        _;\r\n    }\r\n\r\n    // Check if job exists\r\n    modifier jobExists(uint256 _jobId) {\r\n        require(_jobId < numJobs);\r\n        _;\r\n    }\r\n\r\n    // Check if sender provided enough payment for verification\r\n    modifier sufficientPayment() {\r\n        require(msg.value >= verifier().getPrice());\r\n        _;\r\n    }\r\n\r\n    function JobsManager(address _controller) public Manager(_controller) {}\r\n\r\n    /*\r\n     * @dev Set verification rate. Only callable by the controller owner\r\n     * @param _verificationRate Verification rate such that 1 / verificationRate of segments are challenged\r\n     */\r\n    function setVerificationRate(uint64 _verificationRate) external onlyControllerOwner {\r\n        // verificationRate cannot be 0\r\n        require(_verificationRate > 0);\r\n\r\n        verificationRate = _verificationRate;\r\n\r\n        ParameterUpdate(\"verificationRate\");\r\n    }\r\n\r\n    /*\r\n     * @dev Set verification period. Only callable by the controller owner\r\n     * @param _verificationPeriod Number of blocks to complete verification of claimed work\r\n     */\r\n    function setVerificationPeriod(uint256 _verificationPeriod) external onlyControllerOwner {\r\n        // Verification period + verification slashing period currently cannot be longer than 256 blocks\r\n        // because contracts can only access the last 256 blocks from\r\n        // the current block\r\n        require(_verificationPeriod.add(verificationSlashingPeriod) <= 256);\r\n\r\n        verificationPeriod = _verificationPeriod;\r\n\r\n        ParameterUpdate(\"verificationPeriod\");\r\n    }\r\n\r\n    /*\r\n     * @dev Set verification slashing period. Only callable by the controller owner\r\n     * @param _verificationSlashingPeriod Number of blocks after the verification period to submit slashing proofs\r\n     */\r\n    function setVerificationSlashingPeriod(uint256 _verificationSlashingPeriod) external onlyControllerOwner {\r\n        // Verification period + verification slashing period currently cannot be longer than 256 blocks\r\n        // because contracts can only access the last 256 blocks from\r\n        // the current block\r\n        require(verificationPeriod.add(_verificationSlashingPeriod) <= 256);\r\n\r\n        verificationSlashingPeriod = _verificationSlashingPeriod;\r\n\r\n        ParameterUpdate(\"verificationSlashingPeriod\");\r\n    }\r\n\r\n    /*\r\n     * @dev Set failed verification slash amount. Only callable by the controller owner\r\n     * @param _failedVerificationSlashAmount % of stake slashed for failed verification\r\n     */\r\n    function setFailedVerificationSlashAmount(uint256 _failedVerificationSlashAmount) external onlyControllerOwner {\r\n        // Must be a valid percentage\r\n        require(MathUtils.validPerc(_failedVerificationSlashAmount));\r\n\r\n        failedVerificationSlashAmount = _failedVerificationSlashAmount;\r\n\r\n        ParameterUpdate(\"failedVerificationSlashAmount\");\r\n    }\r\n\r\n    /*\r\n     * @dev Set missed verification slash amount. Only callable by the controller owner\r\n     * @param _missedVerificationSlashAmount % of stake slashed for missed verification\r\n     */\r\n    function setMissedVerificationSlashAmount(uint256 _missedVerificationSlashAmount) external onlyControllerOwner {\r\n        // Must be a valid percentage\r\n        require(MathUtils.validPerc(_missedVerificationSlashAmount));\r\n\r\n        missedVerificationSlashAmount = _missedVerificationSlashAmount;\r\n\r\n        ParameterUpdate(\"missedVerificationSlashAmount\");\r\n    }\r\n\r\n    /*\r\n     * @dev Set double claim slash amount. Only callable by the controller owner\r\n     * @param _doubleClaimSegmentSlashAmount % of stake slashed for double claiming a segment\r\n     */\r\n    function setDoubleClaimSegmentSlashAmount(uint256 _doubleClaimSegmentSlashAmount) external onlyControllerOwner {\r\n        // Must be a valid percentage\r\n        require(MathUtils.validPerc(_doubleClaimSegmentSlashAmount));\r\n\r\n        doubleClaimSegmentSlashAmount = _doubleClaimSegmentSlashAmount;\r\n\r\n        ParameterUpdate(\"doubleClaimSegmentSlashAmount\");\r\n    }\r\n\r\n    /*\r\n     * @dev Set finder fee. Only callable by the controller owner\r\n     * @param _finderFee % of slashed amount awarded to finder\r\n     */\r\n    function setFinderFee(uint256 _finderFee) external onlyControllerOwner {\r\n        // Must be a valid percentage\r\n        require(MathUtils.validPerc(_finderFee));\r\n\r\n        finderFee = _finderFee;\r\n    }\r\n\r\n    /*\r\n     * @dev Deposit ETH for jobs\r\n     */\r\n    function deposit() external payable whenSystemNotPaused {\r\n        broadcasters[msg.sender].deposit = broadcasters[msg.sender].deposit.add(msg.value);\r\n        // Transfer ETH for deposit to Minter\r\n        minter().depositETH.value(msg.value)();\r\n\r\n        Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * @dev Withdraw deposited funds\r\n     */\r\n    function withdraw() external whenSystemNotPaused {\r\n        // Can only withdraw at or after the broadcster's withdraw block\r\n        require(broadcasters[msg.sender].withdrawBlock <= roundsManager().blockNum());\r\n\r\n        uint256 amount = broadcasters[msg.sender].deposit;\r\n        delete broadcasters[msg.sender];\r\n        minter().trustedWithdrawETH(msg.sender, amount);\r\n\r\n        Withdraw(msg.sender);\r\n    }\r\n\r\n    /*\r\n     * @dev Submit a transcoding job\r\n     * @param _streamId Unique stream identifier\r\n     * @param _transcodingOptions Output bitrates, formats, encodings\r\n     * @param _maxPricePerSegment Max price (in LPT base units) to pay for transcoding a segment of a stream\r\n     * @param _endBlock Block at which this job becomes inactive\r\n     */\r\n    function job(string _streamId, string _transcodingOptions, uint256 _maxPricePerSegment, uint256 _endBlock)\r\n        external\r\n        whenSystemNotPaused\r\n    {\r\n        uint256 blockNum = roundsManager().blockNum();\r\n\r\n        // End block must be in the future\r\n        require(_endBlock > blockNum);\r\n        // Transcoding options must be valid\r\n        require(JobLib.validTranscodingOptions(_transcodingOptions));\r\n\r\n        Job storage job = jobs[numJobs];\r\n        job.jobId = numJobs;\r\n        job.streamId = _streamId;\r\n        job.transcodingOptions = _transcodingOptions;\r\n        job.maxPricePerSegment = _maxPricePerSegment;\r\n        job.broadcasterAddress = msg.sender;\r\n        job.creationRound = roundsManager().currentRound();\r\n        job.creationBlock = blockNum;\r\n        job.endBlock = _endBlock;\r\n\r\n        NewJob(\r\n            msg.sender,\r\n            numJobs,\r\n            _streamId,\r\n            _transcodingOptions,\r\n            _maxPricePerSegment,\r\n            blockNum\r\n        );\r\n\r\n        // Increment number of created jobs\r\n        numJobs = numJobs.add(1);\r\n\r\n        if (_endBlock > broadcasters[msg.sender].withdrawBlock) {\r\n            // Set new withdraw block if job end block is greater than current\r\n            // broadcaster withdraw block\r\n            broadcasters[msg.sender].withdrawBlock = _endBlock;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Submit claim for a range of segments\r\n     * @param _jobId Job identifier\r\n     * @param _segmentRange Range of claimed segments\r\n     * @param _claimRoot Merkle root of transcoded segment proof data for claimed segments\r\n     */\r\n    function claimWork(uint256 _jobId, uint256[2] _segmentRange, bytes32 _claimRoot)\r\n        external\r\n        whenSystemNotPaused\r\n        jobExists(_jobId)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n\r\n        // Job cannot be inactive\r\n        require(jobStatus(_jobId) != JobStatus.Inactive);\r\n        // Segment range must be valid\r\n        require(_segmentRange[1] >= _segmentRange[0]);\r\n        // Caller must be registered transcoder\r\n        require(bondingManager().isRegisteredTranscoder(msg.sender));\r\n\r\n        uint256 blockNum = roundsManager().blockNum();\r\n\r\n        if (job.transcoderAddress != address(0)) {\r\n            // If transcoder already assigned, check if sender is\r\n            // the assigned transcoder\r\n            require(job.transcoderAddress == msg.sender);\r\n        } else {\r\n            // If transcoder is not already assigned, check if sender should be assigned\r\n            // roundsManager.blockHash() will ensure that the job creation block has been mined and it has not\r\n            // been more than 256 blocks since the creation block\r\n            require(bondingManager().electActiveTranscoder(job.maxPricePerSegment, roundsManager().blockHash(job.creationBlock), job.creationRound) == msg.sender);\r\n\r\n            job.transcoderAddress = msg.sender;\r\n        }\r\n\r\n        // Move fees from broadcaster deposit to escrow\r\n        uint256 fees = JobLib.calcFees(_segmentRange[1].sub(_segmentRange[0]).add(1), job.transcodingOptions, job.maxPricePerSegment);\r\n        broadcasters[job.broadcasterAddress].deposit = broadcasters[job.broadcasterAddress].deposit.sub(fees);\r\n        job.escrow = job.escrow.add(fees);\r\n\r\n        uint256 endVerificationBlock = blockNum.add(verificationPeriod);\r\n        uint256 endVerificationSlashingBlock = endVerificationBlock.add(verificationSlashingPeriod);\r\n\r\n        job.claims.push(\r\n            Claim({\r\n                claimId: job.claims.length,\r\n                segmentRange: _segmentRange,\r\n                claimRoot: _claimRoot,\r\n                claimBlock: blockNum,\r\n                endVerificationBlock: endVerificationBlock,\r\n                endVerificationSlashingBlock: endVerificationSlashingBlock,\r\n                status: ClaimStatus.Pending\r\n           })\r\n        );\r\n\r\n        NewClaim(job.transcoderAddress, _jobId, job.claims.length - 1);\r\n    }\r\n\r\n    /*\r\n     * @dev Submit transcode receipt and invoke transcoding verification\r\n     * @param _jobId Job identifier\r\n     * @param _segmentNumber Segment sequence number in stream\r\n     * @param _dataStorageHash Content-addressed storage hash of segment data\r\n     * @param _dataHashes Hash of segment data and hash of transcoded segment data\r\n     * @param _broadcasterSig Broadcaster's signature over segment hash\r\n     * @param _proof Merkle proof for transcode receipt\r\n     */\r\n    function verify(\r\n        uint256 _jobId,\r\n        uint256 _claimId,\r\n        uint256 _segmentNumber,\r\n        string _dataStorageHash,\r\n        bytes32[2] _dataHashes,\r\n        bytes _broadcasterSig,\r\n        bytes _proof\r\n    )\r\n        external\r\n        payable\r\n        whenSystemNotPaused\r\n        sufficientPayment\r\n        jobExists(_jobId)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n        Claim storage claim = job.claims[_claimId];\r\n\r\n        // Sender must be elected transcoder\r\n        require(job.transcoderAddress == msg.sender);\r\n\r\n        uint256 challengeBlock = claim.claimBlock + 1;\r\n        // Segment must be eligible for verification\r\n        // roundsManager().blockHash() ensures that the challenge block is within the last 256 blocks from the current block\r\n        require(JobLib.shouldVerifySegment(_segmentNumber, claim.segmentRange, challengeBlock, roundsManager().blockHash(challengeBlock), verificationRate));\r\n        // Segment must be signed by broadcaster\r\n        require(\r\n            JobLib.validateBroadcasterSig(\r\n                job.streamId,\r\n                _segmentNumber,\r\n                _dataHashes[0],\r\n                _broadcasterSig,\r\n                job.broadcasterAddress\r\n            )\r\n        );\r\n        // Receipt must be valid\r\n        require(\r\n            JobLib.validateReceipt(\r\n                job.streamId,\r\n                _segmentNumber,\r\n                _dataHashes[0],\r\n                _dataHashes[1],\r\n                _broadcasterSig,\r\n                _proof,\r\n                claim.claimRoot\r\n           )\r\n        );\r\n\r\n        // Mark segment as submitted for verification\r\n        claim.segmentVerifications[_segmentNumber] = true;\r\n\r\n        // Invoke transcoding verification. This is async and will result in a callback to receiveVerification() which is implemented by this contract\r\n        invokeVerification(_jobId, _claimId, _segmentNumber, _dataStorageHash, _dataHashes);\r\n\r\n        Verify(msg.sender, _jobId, _claimId, _segmentNumber);\r\n    }\r\n\r\n    /*\r\n     * @dev Callback function that receives the results of transcoding verification\r\n     * @param _jobId Job identifier\r\n     * @param _segmentNumber Segment being verified for job\r\n     * @param _result Boolean result of whether verification succeeded or not\r\n     */\r\n    function receiveVerification(uint256 _jobId, uint256 _claimId, uint256 _segmentNumber, bool _result)\r\n        external\r\n        whenSystemNotPaused\r\n        onlyVerifier\r\n        jobExists(_jobId)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n        Claim storage claim = job.claims[_claimId];\r\n        // Claim must not be slashed\r\n        require(claim.status != ClaimStatus.Slashed);\r\n        // Segment must have been submitted for verification\r\n        require(claim.segmentVerifications[_segmentNumber]);\r\n\r\n        address transcoder = job.transcoderAddress;\r\n\r\n        if (!_result) {\r\n            // Refund broadcaster\r\n            refundBroadcaster(_jobId);\r\n            // Set claim as slashed\r\n            claim.status = ClaimStatus.Slashed;\r\n            // Protocol slashes transcoder for failing verification (no finder)\r\n            bondingManager().slashTranscoder(transcoder, address(0), failedVerificationSlashAmount, 0);\r\n\r\n            FailedVerification(transcoder, _jobId, _claimId, _segmentNumber);\r\n        } else {\r\n            PassedVerification(transcoder, _jobId, _claimId, _segmentNumber);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Distribute fees for multiple claims\r\n     * @param _jobId Job identifier\r\n     * @param _claimId Claim identifier\r\n     */\r\n    function batchDistributeFees(uint256 _jobId, uint256[] _claimIds)\r\n        external\r\n        whenSystemNotPaused\r\n    {\r\n        for (uint256 i = 0; i < _claimIds.length; i++) {\r\n            distributeFees(_jobId, _claimIds[i]);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Slash transcoder for missing verification\r\n     * @param _jobId Job identifier\r\n     * @param _claimId Claim identifier\r\n     * @param _segmentNumber Segment that was not verified\r\n     */\r\n    function missedVerificationSlash(uint256 _jobId, uint256 _claimId, uint256 _segmentNumber)\r\n        external\r\n        whenSystemNotPaused\r\n        jobExists(_jobId)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n        Claim storage claim = job.claims[_claimId];\r\n\r\n        uint256 blockNum = roundsManager().blockNum();\r\n        uint256 challengeBlock = claim.claimBlock + 1;\r\n        // Must be after verification period\r\n        require(blockNum >= claim.endVerificationBlock);\r\n        // Must be before end of slashing period\r\n        require(blockNum < claim.endVerificationSlashingBlock);\r\n        // Claim must be pending\r\n        require(claim.status == ClaimStatus.Pending);\r\n        // Segment must be eligible for verification\r\n        // roundsManager().blockHash() ensures that the challenge block is within the last 256 blocks from the current block\r\n        require(JobLib.shouldVerifySegment(_segmentNumber, claim.segmentRange, challengeBlock, roundsManager().blockHash(challengeBlock), verificationRate));\r\n        // Transcoder must have missed verification for the segment\r\n        require(!claim.segmentVerifications[_segmentNumber]);\r\n\r\n        refundBroadcaster(_jobId);\r\n\r\n        // Slash transcoder and provide finder params\r\n        bondingManager().slashTranscoder(job.transcoderAddress, msg.sender, missedVerificationSlashAmount, finderFee);\r\n\r\n        // Set claim as slashed\r\n        claim.status = ClaimStatus.Slashed;\r\n    }\r\n\r\n    /*\r\n     * @dev Slash transcoder for claiming a segment twice\r\n     * @param _jobId Job identifier\r\n     * @param _claimId1 Claim 1 identifier\r\n     * @param _claimId2 Claim 2 identifier\r\n     * @param _segmentNumber Segment that was claimed twice\r\n     */\r\n    function doubleClaimSegmentSlash(\r\n        uint256 _jobId,\r\n        uint256 _claimId1,\r\n        uint256 _claimId2,\r\n        uint256 _segmentNumber\r\n    )\r\n        external\r\n        whenSystemNotPaused\r\n        jobExists(_jobId)\r\n    {\r\n        // The provided claims must be different (i.e different IDs)\r\n        require(_claimId1 != _claimId2);\r\n\r\n        Job storage job = jobs[_jobId];\r\n        Claim storage claim1 = job.claims[_claimId1];\r\n        Claim storage claim2 = job.claims[_claimId2];\r\n\r\n        // Claim 1 must not be slashed\r\n        require(claim1.status != ClaimStatus.Slashed);\r\n        // Claim 2 must not be slashed\r\n        require(claim2.status != ClaimStatus.Slashed);\r\n        // Segment must be in claim 1 segment range\r\n        require(_segmentNumber >= claim1.segmentRange[0] && _segmentNumber <= claim1.segmentRange[1]);\r\n        // Segment must be in claim 2 segment range\r\n        require(_segmentNumber >= claim2.segmentRange[0] && _segmentNumber <= claim2.segmentRange[1]);\r\n\r\n        // Slash transcoder and provide finder params\r\n        bondingManager().slashTranscoder(job.transcoderAddress, msg.sender, doubleClaimSegmentSlashAmount, finderFee);\r\n\r\n        refundBroadcaster(_jobId);\r\n\r\n        // Set claim 1 as slashed\r\n        claim1.status = ClaimStatus.Slashed;\r\n        // Set claim 2 as slashed\r\n        claim2.status = ClaimStatus.Slashed;\r\n    }\r\n\r\n    /*\r\n     * @dev Distribute fees for a particular claim\r\n     * @param _jobId Job identifier\r\n     * @param _claimId Claim identifier\r\n     */\r\n    function distributeFees(uint256 _jobId, uint256 _claimId)\r\n        public\r\n        whenSystemNotPaused\r\n        jobExists(_jobId)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n        Claim storage claim = job.claims[_claimId];\r\n\r\n        // Sender must be elected transcoder for job\r\n        require(job.transcoderAddress == msg.sender);\r\n        // Claim must not be complete\r\n        require(claim.status == ClaimStatus.Pending);\r\n        // Slashing period must be over for claim\r\n        require(claim.endVerificationSlashingBlock <= roundsManager().blockNum());\r\n\r\n        uint256 fees = JobLib.calcFees(claim.segmentRange[1].sub(claim.segmentRange[0]).add(1), job.transcodingOptions, job.maxPricePerSegment);\r\n        // Deduct fees from escrow\r\n        job.escrow = job.escrow.sub(fees);\r\n        // Add fees to transcoder's fee pool\r\n        bondingManager().updateTranscoderWithFees(msg.sender, fees, job.creationRound);\r\n\r\n        // Set claim as complete\r\n        claim.status = ClaimStatus.Complete;\r\n\r\n        DistributeFees(msg.sender, _jobId, _claimId, fees);\r\n    }\r\n\r\n    /*\r\n     * @dev Compute status of job\r\n     * @param _jobId Job identifier\r\n     */\r\n    function jobStatus(uint256 _jobId) public view returns (JobStatus) {\r\n        if (jobs[_jobId].endBlock <= roundsManager().blockNum()) {\r\n            // A job is inactive if the current block is greater than or equal to the job's end block\r\n            return JobStatus.Inactive;\r\n        } else {\r\n            // A job is active if the current block is less than the job's end block\r\n            return JobStatus.Active;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Return job info\r\n     * @param _jobId Job identifier\r\n     */\r\n    function getJob(\r\n        uint256 _jobId\r\n    )\r\n        public\r\n        view\r\n        returns (string streamId, string transcodingOptions, uint256 maxPricePerSegment, address broadcasterAddress, address transcoderAddress, uint256 creationRound, uint256 creationBlock, uint256 endBlock, uint256 escrow, uint256 totalClaims)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n\r\n        streamId = job.streamId;\r\n        transcodingOptions = job.transcodingOptions;\r\n        maxPricePerSegment = job.maxPricePerSegment;\r\n        broadcasterAddress = job.broadcasterAddress;\r\n        transcoderAddress = job.transcoderAddress;\r\n        creationRound = job.creationRound;\r\n        creationBlock = job.creationBlock;\r\n        endBlock = job.endBlock;\r\n        escrow = job.escrow;\r\n        totalClaims = job.claims.length;\r\n    }\r\n\r\n    /*\r\n     * @dev Return claim info\r\n     * @param _jobId Job identifier\r\n     * @param _claimId Claim identifier\r\n     */\r\n    function getClaim(\r\n        uint256 _jobId,\r\n        uint256 _claimId\r\n    )\r\n        public\r\n        view\r\n        returns (uint256[2] segmentRange, bytes32 claimRoot, uint256 claimBlock, uint256 endVerificationBlock, uint256 endVerificationSlashingBlock, ClaimStatus status)\r\n    {\r\n        Claim storage claim = jobs[_jobId].claims[_claimId];\r\n\r\n        segmentRange = claim.segmentRange;\r\n        claimRoot = claim.claimRoot;\r\n        claimBlock = claim.claimBlock;\r\n        endVerificationBlock = claim.endVerificationBlock;\r\n        endVerificationSlashingBlock = claim.endVerificationSlashingBlock;\r\n        status = claim.status;\r\n    }\r\n\r\n    /*\r\n     * @dev Return whether a segment was verified for a claim\r\n     * @param _jobId Job identifier\r\n     * @param _claimId Claim identifier\r\n     * @param _segmentNumber Segment number\r\n     */\r\n    function isClaimSegmentVerified(\r\n        uint256 _jobId,\r\n        uint256 _claimId,\r\n        uint256 _segmentNumber\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return jobs[_jobId].claims[_claimId].segmentVerifications[_segmentNumber];\r\n    }\r\n\r\n    /*\r\n     * @dev Invoke transcoding verification by calling the Verifier contract\r\n     * @param _jobId Job identifier\r\n     * @param _claimId Claim identifier\r\n     * @param _segmentNumber Segment sequence number in stream\r\n     * @param _dataStorageHash Content addressable storage hash of segment data\r\n     * @param _dataHashes Hash of segment data and hash of transcoded segment data\r\n     */\r\n    function invokeVerification(\r\n        uint256 _jobId,\r\n        uint256 _claimId,\r\n        uint256 _segmentNumber,\r\n        string _dataStorageHash,\r\n        bytes32[2] _dataHashes\r\n    )\r\n        internal\r\n    {\r\n        IVerifier verifierContract = verifier();\r\n\r\n        uint256 price = verifierContract.getPrice();\r\n\r\n        // Send payment to verifier if price is greater than zero\r\n        if (price > 0) {\r\n            verifierContract.verify.value(price)(\r\n                _jobId,\r\n                _claimId,\r\n                _segmentNumber,\r\n                jobs[_jobId].transcodingOptions,\r\n                _dataStorageHash,\r\n                _dataHashes\r\n            );\r\n        } else {\r\n            // If price is 0, reject any value transfers\r\n            require(msg.value == 0);\r\n\r\n            verifierContract.verify(\r\n                _jobId,\r\n                _claimId,\r\n                _segmentNumber,\r\n                jobs[_jobId].transcodingOptions,\r\n                _dataStorageHash,\r\n                _dataHashes\r\n            );\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Refund broadcaster for a job\r\n     * @param _jobId Job identifier\r\n     */\r\n    function refundBroadcaster(uint256 _jobId) internal {\r\n        Job storage job = jobs[_jobId];\r\n\r\n        // Return all escrowed fees for a job\r\n        uint256 fees = job.escrow;\r\n        job.escrow = job.escrow.sub(fees);\r\n        broadcasters[job.broadcasterAddress].deposit = broadcasters[job.broadcasterAddress].deposit.add(fees);\r\n        // Set end block of job to current block - job becomes inactive\r\n        job.endBlock = roundsManager().blockNum();\r\n    }\r\n\r\n    /*\r\n     * @dev Returns Minter\r\n     */\r\n    function minter() internal view returns (IMinter) {\r\n        return IMinter(controller.getContract(keccak256(\"Minter\")));\r\n    }\r\n\r\n    /*\r\n     * @dev Returns BondingManager\r\n     */\r\n    function bondingManager() internal view returns (IBondingManager) {\r\n        return IBondingManager(controller.getContract(keccak256(\"BondingManager\")));\r\n    }\r\n\r\n    /*\r\n     * @dev Returns RoundsManager\r\n     */\r\n    function roundsManager() internal view returns (IRoundsManager) {\r\n        return IRoundsManager(controller.getContract(keccak256(\"RoundsManager\")));\r\n    }\r\n\r\n    /*\r\n     * @dev Returns Verifier\r\n     */\r\n    function verifier() internal view returns (IVerifier) {\r\n        return IVerifier(controller.getContract(keccak256(\"Verifier\")));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_verificationPeriod\",\"type\":\"uint256\"}],\"name\":\"setVerificationPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_missedVerificationSlashAmount\",\"type\":\"uint256\"}],\"name\":\"setMissedVerificationSlashAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_verificationRate\",\"type\":\"uint64\"}],\"name\":\"setVerificationRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"jobs\",\"outputs\":[{\"name\":\"jobId\",\"type\":\"uint256\"},{\"name\":\"streamId\",\"type\":\"string\"},{\"name\":\"transcodingOptions\",\"type\":\"string\"},{\"name\":\"maxPricePerSegment\",\"type\":\"uint256\"},{\"name\":\"broadcasterAddress\",\"type\":\"address\"},{\"name\":\"transcoderAddress\",\"type\":\"address\"},{\"name\":\"creationRound\",\"type\":\"uint256\"},{\"name\":\"creationBlock\",\"type\":\"uint256\"},{\"name\":\"endBlock\",\"type\":\"uint256\"},{\"name\":\"escrow\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"uint256\"},{\"name\":\"_claimId\",\"type\":\"uint256\"},{\"name\":\"_segmentNumber\",\"type\":\"uint256\"},{\"name\":\"_result\",\"type\":\"bool\"}],\"name\":\"receiveVerification\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finderFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"string\"},{\"name\":\"_transcodingOptions\",\"type\":\"string\"},{\"name\":\"_maxPricePerSegment\",\"type\":\"uint256\"},{\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"name\":\"job\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"missedVerificationSlashAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"uint256\"},{\"name\":\"_segmentRange\",\"type\":\"uint256[2]\"},{\"name\":\"_claimRoot\",\"type\":\"bytes32\"}],\"name\":\"claimWork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"uint256\"},{\"name\":\"_claimId\",\"type\":\"uint256\"}],\"name\":\"getClaim\",\"outputs\":[{\"name\":\"segmentRange\",\"type\":\"uint256[2]\"},{\"name\":\"claimRoot\",\"type\":\"bytes32\"},{\"name\":\"claimBlock\",\"type\":\"uint256\"},{\"name\":\"endVerificationBlock\",\"type\":\"uint256\"},{\"name\":\"endVerificationSlashingBlock\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_verificationSlashingPeriod\",\"type\":\"uint256\"}],\"name\":\"setVerificationSlashingPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"targetContractId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"uint256\"},{\"name\":\"_claimId\",\"type\":\"uint256\"},{\"name\":\"_segmentNumber\",\"type\":\"uint256\"},{\"name\":\"_dataStorageHash\",\"type\":\"string\"},{\"name\":\"_dataHashes\",\"type\":\"bytes32[2]\"},{\"name\":\"_broadcasterSig\",\"type\":\"bytes\"},{\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"uint256\"},{\"name\":\"_claimId1\",\"type\":\"uint256\"},{\"name\":\"_claimId2\",\"type\":\"uint256\"},{\"name\":\"_segmentNumber\",\"type\":\"uint256\"}],\"name\":\"doubleClaimSegmentSlash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"doubleClaimSegmentSlashAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_failedVerificationSlashAmount\",\"type\":\"uint256\"}],\"name\":\"setFailedVerificationSlashAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"uint256\"},{\"name\":\"_claimId\",\"type\":\"uint256\"},{\"name\":\"_segmentNumber\",\"type\":\"uint256\"}],\"name\":\"isClaimSegmentVerified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verificationRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_doubleClaimSegmentSlashAmount\",\"type\":\"uint256\"}],\"name\":\"setDoubleClaimSegmentSlashAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"uint256\"},{\"name\":\"_claimId\",\"type\":\"uint256\"}],\"name\":\"distributeFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"broadcasters\",\"outputs\":[{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"withdrawBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"uint256\"},{\"name\":\"_claimIds\",\"type\":\"uint256[]\"}],\"name\":\"batchDistributeFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numJobs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verificationSlashingPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"uint256\"}],\"name\":\"jobStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verificationPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_finderFee\",\"type\":\"uint256\"}],\"name\":\"setFinderFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"failedVerificationSlashAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"uint256\"}],\"name\":\"getJob\",\"outputs\":[{\"name\":\"streamId\",\"type\":\"string\"},{\"name\":\"transcodingOptions\",\"type\":\"string\"},{\"name\":\"maxPricePerSegment\",\"type\":\"uint256\"},{\"name\":\"broadcasterAddress\",\"type\":\"address\"},{\"name\":\"transcoderAddress\",\"type\":\"address\"},{\"name\":\"creationRound\",\"type\":\"uint256\"},{\"name\":\"creationBlock\",\"type\":\"uint256\"},{\"name\":\"endBlock\",\"type\":\"uint256\"},{\"name\":\"escrow\",\"type\":\"uint256\"},{\"name\":\"totalClaims\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"uint256\"},{\"name\":\"_claimId\",\"type\":\"uint256\"},{\"name\":\"_segmentNumber\",\"type\":\"uint256\"}],\"name\":\"missedVerificationSlash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"broadcaster\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"broadcaster\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"broadcaster\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"jobId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"streamId\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"transcodingOptions\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"maxPricePerSegment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creationBlock\",\"type\":\"uint256\"}],\"name\":\"NewJob\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transcoder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"claimId\",\"type\":\"uint256\"}],\"name\":\"NewClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transcoder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"claimId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"segmentNumber\",\"type\":\"uint256\"}],\"name\":\"Verify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transcoder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"claimId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"DistributeFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transcoder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"claimId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"segmentNumber\",\"type\":\"uint256\"}],\"name\":\"PassedVerification\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transcoder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"claimId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"segmentNumber\",\"type\":\"uint256\"}],\"name\":\"FailedVerification\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"SetController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"param\",\"type\":\"string\"}],\"name\":\"ParameterUpdate\",\"type\":\"event\"}]","ContractName":"JobsManager","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f96d54e490317c557a967abfa5d6e33006be69b3","Library":"JobLib:4969dccf5186e1c49411638fc8a2a020fdab752e","LicenseType":"MIT","SwarmSource":"bzzr://798988581f54215099c15b8a74b0d9b3a190f88f9d3224a0beb81f3672b66d70"}]}