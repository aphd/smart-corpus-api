{"status":"1","message":"OK","result":[{"SourceCode":"// File: ERC20.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n/// @title ERC20 interface is a subset of the ERC20 specification.\r\n/// @notice see https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function balanceOf(address _who) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\n// File: SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: SafeERC20.sol\r\n\r\n/**\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2016-2019 zOS Global Limited\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(ERC20 token, bytes memory data) internal {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: transferrable.sol\r\n\r\n/**\r\n *  Transferrable - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n/// @title SafeTransfer, allowing contract to withdraw tokens accidentally sent to itself\r\ncontract Transferrable {\r\n\r\n    using SafeERC20 for ERC20;\r\n\r\n\r\n    /// @dev This function is used to move tokens sent accidentally to this contract method.\r\n    /// @dev The owner can chose the new destination address\r\n    /// @param _to is the recipient's address.\r\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\r\n    /// @param _amount is the amount to be transferred in base units.\r\n    function _safeTransfer(address payable _to, address _asset, uint _amount) internal {\r\n        // address(0) is used to denote ETH\r\n        if (_asset == address(0)) {\r\n            _to.transfer(_amount);\r\n        } else {\r\n            ERC20(_asset).safeTransfer(_to, _amount);\r\n        }\r\n    }\r\n}\r\n\r\n// File: balanceable.sol\r\n\r\n/**\r\n *  Balanceable - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n/// @title Balanceable - This is a contract used to get a balance\r\ncontract Balanceable {\r\n\r\n    /// @dev This function is used to get a balance\r\n    /// @param _address of which balance we are trying to ascertain\r\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\r\n    /// @return balance associated with an address, for any token, in the wei equivalent\r\n    function _balance(address _address, address _asset) internal view returns (uint) {\r\n        if (_asset != address(0)) {\r\n            return ERC20(_asset).balanceOf(_address);\r\n        } else {\r\n            return _address.balance;\r\n        }\r\n    }\r\n}\r\n\r\n// File: burner.sol\r\n\r\n/**\r\n *  IBurner - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n// The BurnerToken interface is the interface to a token contract which\r\n// provides the total burnable supply for the TokenHolder contract.\r\ninterface IBurner {\r\n    function currentSupply() external view returns (uint);\r\n}\r\n\r\n// File: ownable.sol\r\n\r\n/**\r\n *  Ownable - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n/// @title Ownable has an owner address and provides basic authorization control functions.\r\n/// This contract is modified version of the MIT OpenZepplin Ownable contract\r\n/// This contract allows for the transferOwnership operation to be made impossible\r\n/// https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\ncontract Ownable {\r\n    event TransferredOwnership(address _from, address _to);\r\n    event LockedOwnership(address _locked);\r\n\r\n    address payable private _owner;\r\n    bool private _isTransferable;\r\n\r\n    /// @notice Constructor sets the original owner of the contract and whether or not it is one time transferable.\r\n    constructor(address payable _account_, bool _transferable_) internal {\r\n        _owner = _account_;\r\n        _isTransferable = _transferable_;\r\n        // Emit the LockedOwnership event if no longer transferable.\r\n        if (!_isTransferable) {\r\n            emit LockedOwnership(_account_);\r\n        }\r\n        emit TransferredOwnership(address(0), _account_);\r\n    }\r\n\r\n    /// @notice Reverts if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(_isOwner(msg.sender), \"sender is not an owner\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a new address.\r\n    /// @param _account address to transfer ownership to.\r\n    /// @param _transferable indicates whether to keep the ownership transferable.\r\n    function transferOwnership(address payable _account, bool _transferable) external onlyOwner {\r\n        // Require that the ownership is transferable.\r\n        require(_isTransferable, \"ownership is not transferable\");\r\n        // Require that the new owner is not the zero address.\r\n        require(_account != address(0), \"owner cannot be set to zero address\");\r\n        // Set the transferable flag to the value _transferable passed in.\r\n        _isTransferable = _transferable;\r\n        // Emit the LockedOwnership event if no longer transferable.\r\n        if (!_transferable) {\r\n            emit LockedOwnership(_account);\r\n        }\r\n        // Emit the ownership transfer event.\r\n        emit TransferredOwnership(_owner, _account);\r\n        // Set the owner to the provided address.\r\n        _owner = _account;\r\n    }\r\n\r\n    /// @notice check if the ownership is transferable.\r\n    /// @return true if the ownership is transferable.\r\n    function isTransferable() external view returns (bool) {\r\n        return _isTransferable;\r\n    }\r\n\r\n    /// @notice Allows the current owner to relinquish control of the contract.\r\n    /// @dev Renouncing to ownership will leave the contract without an owner and unusable.\r\n    /// @dev It will not be possible to call the functions with the `onlyOwner` modifier anymore.\r\n    function renounceOwnership() external onlyOwner {\r\n        // Require that the ownership is transferable.\r\n        require(_isTransferable, \"ownership is not transferable\");\r\n        // note that this could be terminal\r\n        _owner = address(0);\r\n\r\n        emit TransferredOwnership(_owner, address(0));\r\n    }\r\n\r\n    /// @notice Find out owner address\r\n    /// @return address of the owner.\r\n    function owner() public view returns (address payable) {\r\n        return _owner;\r\n    }\r\n\r\n    /// @notice Check if owner address\r\n    /// @return true if sender is the owner of the contract.\r\n    function _isOwner(address _address) internal view returns (bool) {\r\n        return _address == _owner;\r\n    }\r\n}\r\n\r\n// File: controller.sol\r\n\r\n/**\r\n *  Controller - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n/// @title The IController interface provides access to the isController and isAdmin checks.\r\ninterface IController {\r\n    function isController(address) external view returns (bool);\r\n    function isAdmin(address) external view returns (bool);\r\n}\r\n\r\n\r\n/// @title Controller stores a list of controller addresses that can be used for authentication in other contracts.\r\n/// @notice The Controller implements a hierarchy of concepts, Owner, Admin, and the Controllers.\r\n/// @dev Owner can change the Admins\r\n/// @dev Admins and can the Controllers\r\n/// @dev Controllers are used by the application.\r\ncontract Controller is IController, Ownable, Transferrable {\r\n\r\n    event AddedController(address _sender, address _controller);\r\n    event RemovedController(address _sender, address _controller);\r\n\r\n    event AddedAdmin(address _sender, address _admin);\r\n    event RemovedAdmin(address _sender, address _admin);\r\n\r\n    event Claimed(address _to, address _asset, uint _amount);\r\n\r\n    event Stopped(address _sender);\r\n    event Started(address _sender);\r\n\r\n    mapping (address => bool) private _isAdmin;\r\n    uint private _adminCount;\r\n\r\n    mapping (address => bool) private _isController;\r\n    uint private _controllerCount;\r\n\r\n    bool private _stopped;\r\n\r\n    /// @notice Constructor initializes the owner with the provided address.\r\n    /// @param _ownerAddress_ address of the owner.\r\n    constructor(address payable _ownerAddress_) Ownable(_ownerAddress_, false) public {}\r\n\r\n    /// @notice Checks if message sender is an admin.\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(msg.sender), \"sender is not an admin\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Check if Owner or Admin\r\n    modifier onlyAdminOrOwner() {\r\n        require(_isOwner(msg.sender) || isAdmin(msg.sender), \"sender is not an admin\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Check if controller is stopped\r\n    modifier notStopped() {\r\n        require(!isStopped(), \"controller is stopped\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Add a new admin to the list of admins.\r\n    /// @param _account address to add to the list of admins.\r\n    function addAdmin(address _account) external onlyOwner notStopped {\r\n        _addAdmin(_account);\r\n    }\r\n\r\n    /// @notice Remove a admin from the list of admins.\r\n    /// @param _account address to remove from the list of admins.\r\n    function removeAdmin(address _account) external onlyOwner {\r\n        _removeAdmin(_account);\r\n    }\r\n\r\n    /// @return the current number of admins.\r\n    function adminCount() external view returns (uint) {\r\n        return _adminCount;\r\n    }\r\n\r\n    /// @notice Add a new controller to the list of controllers.\r\n    /// @param _account address to add to the list of controllers.\r\n    function addController(address _account) external onlyAdminOrOwner notStopped {\r\n        _addController(_account);\r\n    }\r\n\r\n    /// @notice Remove a controller from the list of controllers.\r\n    /// @param _account address to remove from the list of controllers.\r\n    function removeController(address _account) external onlyAdminOrOwner {\r\n        _removeController(_account);\r\n    }\r\n\r\n    /// @notice count the Controllers\r\n    /// @return the current number of controllers.\r\n    function controllerCount() external view returns (uint) {\r\n        return _controllerCount;\r\n    }\r\n\r\n    /// @notice is an address an Admin?\r\n    /// @return true if the provided account is an admin.\r\n    function isAdmin(address _account) public view notStopped returns (bool) {\r\n        return _isAdmin[_account];\r\n    }\r\n\r\n    /// @notice is an address a Controller?\r\n    /// @return true if the provided account is a controller.\r\n    function isController(address _account) public view notStopped returns (bool) {\r\n        return _isController[_account];\r\n    }\r\n\r\n    /// @notice this function can be used to see if the controller has been stopped\r\n    /// @return true is the Controller has been stopped\r\n    function isStopped() public view returns (bool) {\r\n        return _stopped;\r\n    }\r\n\r\n    /// @notice Internal-only function that adds a new admin.\r\n    function _addAdmin(address _account) private {\r\n        require(!_isAdmin[_account], \"provided account is already an admin\");\r\n        require(!_isController[_account], \"provided account is already a controller\");\r\n        require(!_isOwner(_account), \"provided account is already the owner\");\r\n        require(_account != address(0), \"provided account is the zero address\");\r\n        _isAdmin[_account] = true;\r\n        _adminCount++;\r\n        emit AddedAdmin(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice Internal-only function that removes an existing admin.\r\n    function _removeAdmin(address _account) private {\r\n        require(_isAdmin[_account], \"provided account is not an admin\");\r\n        _isAdmin[_account] = false;\r\n        _adminCount--;\r\n        emit RemovedAdmin(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice Internal-only function that adds a new controller.\r\n    function _addController(address _account) private {\r\n        require(!_isAdmin[_account], \"provided account is already an admin\");\r\n        require(!_isController[_account], \"provided account is already a controller\");\r\n        require(!_isOwner(_account), \"provided account is already the owner\");\r\n        require(_account != address(0), \"provided account is the zero address\");\r\n        _isController[_account] = true;\r\n        _controllerCount++;\r\n        emit AddedController(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice Internal-only function that removes an existing controller.\r\n    function _removeController(address _account) private {\r\n        require(_isController[_account], \"provided account is not a controller\");\r\n        _isController[_account] = false;\r\n        _controllerCount--;\r\n        emit RemovedController(msg.sender, _account);\r\n    }\r\n\r\n    /// @notice stop our controllers and admins from being useable\r\n    function stop() external onlyAdminOrOwner {\r\n        _stopped = true;\r\n        emit Stopped(msg.sender);\r\n    }\r\n\r\n    /// @notice start our controller again\r\n    function start() external onlyOwner {\r\n        _stopped = false;\r\n        emit Started(msg.sender);\r\n    }\r\n\r\n    //// @notice Withdraw tokens from the smart contract to the specified account.\r\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin notStopped {\r\n        _safeTransfer(_to, _asset, _amount);\r\n        emit Claimed(_to, _asset, _amount);\r\n    }\r\n}\r\n\r\n// File: ENS.sol\r\n\r\n/**\r\n * BSD 2-Clause License\r\n *\r\n * Copyright (c) 2018, True Names Limited\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n *\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\npragma solidity ^0.5.0;\r\n\r\ninterface ENS {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n\r\n}\r\n\r\n// File: ResolverBase.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract ResolverBase {\r\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == INTERFACE_META_ID;\r\n    }\r\n\r\n    function isAuthorised(bytes32 node) internal view returns(bool);\r\n\r\n    modifier authorised(bytes32 node) {\r\n        require(isAuthorised(node));\r\n        _;\r\n    }\r\n}\r\n\r\n// File: ABIResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract ABIResolver is ResolverBase {\r\n    bytes4 constant private ABI_INTERFACE_ID = 0x2203ab56;\r\n\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n\r\n    mapping(bytes32=>mapping(uint256=>bytes)) abis;\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external authorised(node) {\r\n        // Content types must be powers of 2\r\n        require(((contentType - 1) & contentType) == 0);\r\n\r\n        abis[node][contentType] = data;\r\n        emit ABIChanged(node, contentType);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory) {\r\n        mapping(uint256=>bytes) storage abiset = abis[node];\r\n\r\n        for (uint256 contentType = 1; contentType <= contentTypes; contentType <<= 1) {\r\n            if ((contentType & contentTypes) != 0 && abiset[contentType].length > 0) {\r\n                return (contentType, abiset[contentType]);\r\n            }\r\n        }\r\n\r\n        return (0, bytes(\"\"));\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == ABI_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: AddrResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract AddrResolver is ResolverBase {\r\n    bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n\r\n    mapping(bytes32=>address) addresses;\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) external authorised(node) {\r\n        addresses[node] = addr;\r\n        emit AddrChanged(node, addr);\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public view returns (address) {\r\n        return addresses[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: ContentHashResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract ContentHashResolver is ResolverBase {\r\n    bytes4 constant private CONTENT_HASH_INTERFACE_ID = 0xbc1c58d1;\r\n\r\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n\r\n    mapping(bytes32=>bytes) hashes;\r\n\r\n    /**\r\n     * Sets the contenthash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param hash The contenthash to set\r\n     */\r\n    function setContenthash(bytes32 node, bytes calldata hash) external authorised(node) {\r\n        hashes[node] = hash;\r\n        emit ContenthashChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Returns the contenthash associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function contenthash(bytes32 node) external view returns (bytes memory) {\r\n        return hashes[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == CONTENT_HASH_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: InterfaceResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract InterfaceResolver is ResolverBase, AddrResolver {\r\n    bytes4 constant private INTERFACE_INTERFACE_ID = bytes4(keccak256(\"interfaceImplementer(bytes32,bytes4)\"));\r\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\r\n\r\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\r\n\r\n    mapping(bytes32=>mapping(bytes4=>address)) interfaces;\r\n\r\n    /**\r\n     * Sets an interface associated with a name.\r\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\r\n     * @param node The node to update.\r\n     * @param interfaceID The EIP 168 interface ID.\r\n     * @param implementer The address of a contract that implements this interface for this node.\r\n     */\r\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external authorised(node) {\r\n        interfaces[node][interfaceID] = implementer;\r\n        emit InterfaceChanged(node, interfaceID, implementer);\r\n    }\r\n\r\n    /**\r\n     * Returns the address of a contract that implements the specified interface for this name.\r\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\r\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\r\n     * contract implements EIP168 and returns `true` for the specified interfaceID, its address\r\n     * will be returned.\r\n     * @param node The ENS node to query.\r\n     * @param interfaceID The EIP 168 interface ID to check for.\r\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\r\n     */\r\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address) {\r\n        address implementer = interfaces[node][interfaceID];\r\n        if(implementer != address(0)) {\r\n            return implementer;\r\n        }\r\n\r\n        address a = addr(node);\r\n        if(a == address(0)) {\r\n            return address(0);\r\n        }\r\n\r\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\", INTERFACE_META_ID));\r\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\r\n            // EIP 168 not supported by target\r\n            return address(0);\r\n        }\r\n\r\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\", interfaceID));\r\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\r\n            // Specified interface not supported by target\r\n            return address(0);\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == INTERFACE_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: NameResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract NameResolver is ResolverBase {\r\n    bytes4 constant private NAME_INTERFACE_ID = 0x691f3431;\r\n\r\n    event NameChanged(bytes32 indexed node, string name);\r\n\r\n    mapping(bytes32=>string) names;\r\n\r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param name The name to set.\r\n     */\r\n    function setName(bytes32 node, string calldata name) external authorised(node) {\r\n        names[node] = name;\r\n        emit NameChanged(node, name);\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) external view returns (string memory) {\r\n        return names[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == NAME_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: PubkeyResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract PubkeyResolver is ResolverBase {\r\n    bytes4 constant private PUBKEY_INTERFACE_ID = 0xc8690233;\r\n\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    mapping(bytes32=>PublicKey) pubkeys;\r\n\r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external authorised(node) {\r\n        pubkeys[node] = PublicKey(x, y);\r\n        emit PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x, y the X and Y coordinates of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y) {\r\n        return (pubkeys[node].x, pubkeys[node].y);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == PUBKEY_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: TextResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract TextResolver is ResolverBase {\r\n    bytes4 constant private TEXT_INTERFACE_ID = 0x59d1d43c;\r\n\r\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\r\n\r\n    mapping(bytes32=>mapping(string=>string)) texts;\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(bytes32 node, string calldata key, string calldata value) external authorised(node) {\r\n        texts[node][key] = value;\r\n        emit TextChanged(node, key, key);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string calldata key) external view returns (string memory) {\r\n        return texts[node][key];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\r\n        return interfaceID == TEXT_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n\r\n// File: PublicResolver.sol\r\n\r\n/**\r\n * BSD 2-Clause License\r\n *\r\n * Copyright (c) 2018, True Names Limited\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n *\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * A simple resolver anyone can use; only allows the owner of a node to set its\r\n * address.\r\n */\r\ncontract PublicResolver is ABIResolver, AddrResolver, ContentHashResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\r\n    ENS ens;\r\n\r\n    /**\r\n     * A mapping of authorisations. An address that is authorised for a name\r\n     * may make any changes to the name that the owner could, but may not update\r\n     * the set of authorisations.\r\n     * (node, owner, caller) => isAuthorised\r\n     */\r\n    mapping(bytes32=>mapping(address=>mapping(address=>bool))) public authorisations;\r\n\r\n    event AuthorisationChanged(bytes32 indexed node, address indexed owner, address indexed target, bool isAuthorised);\r\n\r\n    constructor(ENS _ens) public {\r\n        ens = _ens;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or clears an authorisation.\r\n     * Authorisations are specific to the caller. Any account can set an authorisation\r\n     * for any name, but the authorisation that is checked will be that of the\r\n     * current owner of a name. Thus, transferring a name effectively clears any\r\n     * existing authorisations, and new authorisations can be set in advance of\r\n     * an ownership transfer if desired.\r\n     *\r\n     * @param node The name to change the authorisation on.\r\n     * @param target The address that is to be authorised or deauthorised.\r\n     * @param isAuthorised True if the address should be authorised, or false if it should be deauthorised.\r\n     */\r\n    function setAuthorisation(bytes32 node, address target, bool isAuthorised) external {\r\n        authorisations[node][msg.sender][target] = isAuthorised;\r\n        emit AuthorisationChanged(node, msg.sender, target, isAuthorised);\r\n    }\r\n\r\n    function isAuthorised(bytes32 node) internal view returns(bool) {\r\n        address owner = ens.owner(node);\r\n        return owner == msg.sender || authorisations[node][owner][msg.sender];\r\n    }\r\n}\r\n\r\n// File: ensResolvable.sol\r\n\r\n/**\r\n *  ENSResolvable - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n///@title ENSResolvable - Ethereum Name Service Resolver\r\n///@notice contract should be used to get an address for an ENS node\r\ncontract ENSResolvable {\r\n    /// @notice _ens is an instance of ENS\r\n    ENS private _ens;\r\n\r\n    /// @notice _ensRegistry points to the ENS registry smart contract.\r\n    address private _ensRegistry;\r\n\r\n    /// @param _ensReg_ is the ENS registry used\r\n    constructor(address _ensReg_) internal {\r\n        _ensRegistry = _ensReg_;\r\n        _ens = ENS(_ensRegistry);\r\n    }\r\n\r\n    /// @notice this is used to that one can observe which ENS registry is being used\r\n    function ensRegistry() external view returns (address) {\r\n        return _ensRegistry;\r\n    }\r\n\r\n    /// @notice helper function used to get the address of a node\r\n    /// @param _node of the ENS entry that needs resolving\r\n    /// @return the address of the said node\r\n    function _ensResolve(bytes32 _node) internal view returns (address) {\r\n        return PublicResolver(_ens.resolver(_node)).addr(_node);\r\n    }\r\n\r\n}\r\n\r\n// File: controllable.sol\r\n\r\n/**\r\n *  Controllable - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n/// @title Controllable implements access control functionality of the Controller found via ENS.\r\ncontract Controllable is ENSResolvable {\r\n    /// @dev Is the registered ENS node identifying the controller contract.\r\n    bytes32 private _controllerNode;\r\n\r\n    /// @notice Constructor initializes the controller contract object.\r\n    /// @param _controllerNode_ is the ENS node of the Controller.\r\n    constructor(bytes32 _controllerNode_) internal {\r\n        _controllerNode = _controllerNode_;\r\n    }\r\n\r\n    /// @notice Checks if message sender is a controller.\r\n    modifier onlyController() {\r\n        require(_isController(msg.sender), \"sender is not a controller\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Checks if message sender is an admin.\r\n    modifier onlyAdmin() {\r\n        require(_isAdmin(msg.sender), \"sender is not an admin\");\r\n        _;\r\n    }\r\n\r\n    /// @return the controller node registered in ENS.\r\n    function controllerNode() external view returns (bytes32) {\r\n        return _controllerNode;\r\n    }\r\n\r\n    /// @return true if the provided account is a controller.\r\n    function _isController(address _account) internal view returns (bool) {\r\n        return IController(_ensResolve(_controllerNode)).isController(_account);\r\n    }\r\n\r\n    /// @return true if the provided account is an admin.\r\n    function _isAdmin(address _account) internal view returns (bool) {\r\n        return IController(_ensResolve(_controllerNode)).isAdmin(_account);\r\n    }\r\n\r\n}\r\n\r\n// File: bytesUtils.sol\r\n\r\n/**\r\n *  BytesUtils - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n/// @title BytesUtils provides basic byte slicing and casting functionality.\r\nlibrary BytesUtils {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev This function converts to an address\r\n    /// @param _bts bytes\r\n    /// @param _from start position\r\n    function _bytesToAddress(bytes memory _bts, uint _from) internal pure returns (address) {\r\n\r\n        require(_bts.length >= _from.add(20), \"slicing out of range\");\r\n\r\n        bytes20 convertedAddress;\r\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\r\n\r\n        assembly {\r\n            convertedAddress := mload(add(_bts, startByte))\r\n        }\r\n\r\n        return address(convertedAddress);\r\n    }\r\n\r\n    /// @dev This function slices bytes into bytes4\r\n    /// @param _bts some bytes\r\n    /// @param _from start position\r\n    function _bytesToBytes4(bytes memory _bts, uint _from) internal pure returns (bytes4) {\r\n        require(_bts.length >= _from.add(4), \"slicing out of range\");\r\n\r\n        bytes4 slicedBytes4;\r\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\r\n\r\n        assembly {\r\n            slicedBytes4 := mload(add(_bts, startByte))\r\n        }\r\n\r\n        return slicedBytes4;\r\n\r\n    }\r\n\r\n    /// @dev This function slices a uint\r\n    /// @param _bts some bytes\r\n    /// @param _from start position\r\n    // credit to https://ethereum.stackexchange.com/questions/51229/how-to-convert-bytes-to-uint-in-solidity\r\n    // and Nick Johnson https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity/4177#4177\r\n    function _bytesToUint256(bytes memory _bts, uint _from) internal pure returns (uint) {\r\n        require(_bts.length >= _from.add(32), \"slicing out of range\");\r\n\r\n        uint convertedUint256;\r\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\r\n        \r\n        assembly {\r\n            convertedUint256 := mload(add(_bts, startByte))\r\n        }\r\n\r\n        return convertedUint256;\r\n    }\r\n}\r\n\r\n// File: strings.sol\r\n\r\n/*\r\n * Copyright 2016 Nick Johnson\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/*\r\n * @title String & slice utility library for Solidity contracts.\r\n * @author Nick Johnson <arachnid@notdot.net>\r\n *\r\n * @dev Functionality in this library is largely implemented using an\r\n *      abstraction called a 'slice'. A slice represents a part of a string -\r\n *      anything from the entire string to a single character, or even no\r\n *      characters at all (a 0-length slice). Since a slice only has to specify\r\n *      an offset and a length, copying and manipulating slices is a lot less\r\n *      expensive than copying and manipulating the strings they reference.\r\n *\r\n *      To further reduce gas costs, most functions on slice that need to return\r\n *      a slice modify the original one instead of allocating a new one; for\r\n *      instance, `s.split(\".\")` will return the text up to the first '.',\r\n *      modifying s to only contain the remainder of the string after the '.'.\r\n *      In situations where you do not want to modify the original slice, you\r\n *      can make a copy first with `.copy()`, for example:\r\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\r\n *      Solidity has no memory management, it will result in allocating many\r\n *      short-lived slices that are later discarded.\r\n *\r\n *      Functions that return two slices come in two versions: a non-allocating\r\n *      version that takes the second slice as an argument, modifying it in\r\n *      place, and an allocating version that allocates and returns the second\r\n *      slice; see `nextRune` for example.\r\n *\r\n *      Functions that have to copy string data will return strings rather than\r\n *      slices; these can be cast back to slices for further processing if\r\n *      required.\r\n *\r\n *      For convenience, some functions are provided with non-modifying\r\n *      variants that create a new slice and return both; for instance,\r\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\r\n *      corresponding to the left and right parts of the string.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal pure returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (uint(self) & 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (uint(self) & 0xffffffffffffffff == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (uint(self) & 0xffffffff == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (uint(self) & 0xffff == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (uint(self) & 0xff == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-terminated utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\r\n        // Allocate space for `self` in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice memory self) internal pure returns (slice memory) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice memory self) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call `slice.empty()` if you only need to know whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice memory self) internal pure returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        uint ptr = self._ptr - 31;\r\n        uint end = ptr + self._len;\r\n        for (l = 0; ptr < end; l++) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if (b < 0xE0) {\r\n                ptr += 2;\r\n            } else if (b < 0xF0) {\r\n                ptr += 3;\r\n            } else if (b < 0xF8) {\r\n                ptr += 4;\r\n            } else if (b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice memory self) internal pure returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len < self._len)\r\n            shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint256 mask = uint256(-1); // 0xffff...\r\n                if (shortest < 32) {\r\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                uint256 diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\r\n     *      slice to point to the next rune and returning `self`.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `rune`.\r\n     */\r\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint l;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b < 0x80) {\r\n            l = 1;\r\n        } else if (b < 0xE0) {\r\n            l = 2;\r\n        } else if (b < 0xF0) {\r\n            l = 3;\r\n        } else {\r\n            l = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (l > self._len) {\r\n            rune._len = self._len;\r\n            self._ptr += self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr += l;\r\n        self._len -= l;\r\n        rune._len = l;\r\n        return rune;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from `self`.\r\n     */\r\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice memory self) internal pure returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        uint b = word / divisor;\r\n        if (b < 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if (b < 0xE0) {\r\n            ret = b & 0x1F;\r\n            length = 2;\r\n        } else if (b < 0xF0) {\r\n            ret = b & 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b & 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length > self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i < length; i++) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) & 0xFF;\r\n            if (b & 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b & 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if `self` starts with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr += needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice ends with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` ends with `needle`, `needle` is removed from the\r\n     *      end of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr >= end)\r\n                        return selfptr + selflen;\r\n                    ptr++;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // `needle` in `self`, or the address of `self` if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                ptr = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr <= selfptr)\r\n                        return selfptr;\r\n                    ptr--;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr + needlelen;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n                ptr = selfptr + (selflen - needlelen);\r\n                while (ptr >= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr + needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\n     *      if `needle` is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain the part of the string from the start of\r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\r\n     *      is not found, `self` is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr + self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n            self._ptr = ptr + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and returning everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\n     */\r\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and `token` to everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and returning everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` after the last occurrence of `delim`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The number of occurrences of `needle` found in `self`.\r\n     */\r\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n        while (ptr <= self._ptr + self._len) {\r\n            cnt++;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns True if `self` contains `needle`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return True if `needle` is found in `self`, false otherwise.\r\n     */\r\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\n     *         joined with `self`.\r\n     */\r\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\r\n        if (parts.length == 0)\r\n            return \"\";\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for (uint i = 0; i < parts.length; i++) {\r\n            length += parts[i]._len;\r\n        }\r\n\r\n        string memory ret = new string(length);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for (uint i = 0; i < parts.length; i++) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr += parts[i]._len;\r\n            if (i < parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr += self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\n\r\n// File: tokenWhitelist.sol\r\n\r\n/**\r\n *  TokenWhitelist - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title The ITokenWhitelist interface provides access to a whitelist of tokens.\r\ninterface ITokenWhitelist {\r\n    function getTokenInfo(address) external view returns (string memory, uint256, uint256, bool, bool, bool, uint256);\r\n    function getStablecoinInfo() external view returns (string memory, uint256, uint256, bool, bool, bool, uint256);\r\n    function tokenAddressArray() external view returns (address[] memory);\r\n    function redeemableTokens() external view returns (address[] memory);\r\n    function methodIdWhitelist(bytes4) external view returns (bool);\r\n    function getERC20RecipientAndAmount(address, bytes calldata) external view returns (address, uint);\r\n    function stablecoin() external view returns (address);\r\n    function updateTokenRate(address, uint, uint) external;\r\n}\r\n\r\n\r\n/// @title TokenWhitelist stores a list of tokens used by the Consumer Contract Wallet, the Oracle, the TKN Holder and the TKN Licence Contract\r\ncontract TokenWhitelist is ENSResolvable, Controllable, Transferrable {\r\n    using strings for *;\r\n    using SafeMath for uint256;\r\n    using BytesUtils for bytes;\r\n\r\n    event UpdatedTokenRate(address _sender, address _token, uint _rate);\r\n\r\n    event UpdatedTokenLoadable(address _sender, address _token, bool _loadable);\r\n    event UpdatedTokenRedeemable(address _sender, address _token, bool _redeemable);\r\n\r\n    event AddedToken(address _sender, address _token, string _symbol, uint _magnitude, bool _loadable, bool _redeemable);\r\n    event RemovedToken(address _sender, address _token);\r\n\r\n    event AddedMethodId(bytes4 _methodId);\r\n    event RemovedMethodId(bytes4 _methodId);\r\n    event AddedExclusiveMethod(address _token, bytes4 _methodId);\r\n    event RemovedExclusiveMethod(address _token, bytes4 _methodId);\r\n\r\n    event Claimed(address _to, address _asset, uint _amount);\r\n\r\n    /// @dev these are the methods whitelisted by default in executeTransaction() for protected tokens\r\n    bytes4 private constant _APPROVE = 0x095ea7b3; // keccak256(approve(address,uint256)) => 0x095ea7b3\r\n    bytes4 private constant _BURN = 0x42966c68; // keccak256(burn(uint256)) => 0x42966c68\r\n    bytes4 private constant _TRANSFER= 0xa9059cbb; // keccak256(transfer(address,uint256)) => 0xa9059cbb\r\n    bytes4 private constant _TRANSFER_FROM = 0x23b872dd; // keccak256(transferFrom(address,address,uint256)) => 0x23b872dd\r\n\r\n    struct Token {\r\n        string symbol;    // Token symbol\r\n        uint magnitude;   // 10^decimals\r\n        uint rate;        // Token exchange rate in wei\r\n        bool available;   // Flags if the token is available or not\r\n        bool loadable;    // Flags if token is loadable to the TokenCard\r\n        bool redeemable;    // Flags if token is redeemable in the TKN Holder contract\r\n        uint lastUpdate;  // Time of the last rate update\r\n    }\r\n\r\n    mapping(address => Token) private _tokenInfoMap;\r\n\r\n    // @notice specifies whitelisted methodIds for protected tokens in wallet's excuteTranaction() e.g. keccak256(transfer(address,uint256)) => 0xa9059cbb\r\n    mapping(bytes4 => bool) private _methodIdWhitelist;\r\n\r\n    address[] private _tokenAddressArray;\r\n\r\n    /// @notice keeping track of how many redeemable tokens are in the tokenWhitelist\r\n    uint private _redeemableCounter;\r\n\r\n    /// @notice Address of the stablecoin.\r\n    address private _stablecoin;\r\n\r\n    /// @notice is registered ENS node identifying the oracle contract.\r\n    bytes32 private _oracleNode;\r\n\r\n    /// @notice Constructor initializes ENSResolvable, and Controllable.\r\n    /// @param _ens_ is the ENS registry address.\r\n    /// @param _oracleNode_ is the ENS node of the Oracle.\r\n    /// @param _controllerNode_ is our Controllers node.\r\n    /// @param _stablecoinAddress_ is the address of the stablecoint used by the wallet for the card load limit.\r\n    constructor(address _ens_, bytes32 _oracleNode_, bytes32 _controllerNode_, address _stablecoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNode_) public {\r\n        _oracleNode = _oracleNode_;\r\n        _stablecoin = _stablecoinAddress_;\r\n        //a priori ERC20 whitelisted methods\r\n        _methodIdWhitelist[_APPROVE] = true;\r\n        _methodIdWhitelist[_BURN] = true;\r\n        _methodIdWhitelist[_TRANSFER] = true;\r\n        _methodIdWhitelist[_TRANSFER_FROM] = true;\r\n    }\r\n\r\n    modifier onlyAdminOrOracle() {\r\n        address oracleAddress = _ensResolve(_oracleNode);\r\n        require (_isAdmin(msg.sender) || msg.sender == oracleAddress, \"either oracle or admin\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Add ERC20 tokens to the list of whitelisted tokens.\r\n    /// @param _tokens ERC20 token contract addresses.\r\n    /// @param _symbols ERC20 token names.\r\n    /// @param _magnitude 10 to the power of number of decimal places used by each ERC20 token.\r\n    /// @param _loadable is a bool that states whether or not a token is loadable to the TokenCard.\r\n    /// @param _redeemable is a bool that states whether or not a token is redeemable in the TKN Holder Contract.\r\n    /// @param _lastUpdate is a unit representing an ISO datetime e.g. 20180913153211.\r\n    function addTokens(address[] calldata _tokens, bytes32[] calldata _symbols, uint[] calldata _magnitude, bool[] calldata _loadable, bool[] calldata _redeemable, uint _lastUpdate) external onlyAdmin {\r\n        // Require that all parameters have the same length.\r\n        require(_tokens.length == _symbols.length && _tokens.length == _magnitude.length && _tokens.length == _loadable.length && _tokens.length == _loadable.length, \"parameter lengths do not match\");\r\n        // Add each token to the list of supported tokens.\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            // Require that the token isn't already available.\r\n            require(!_tokenInfoMap[_tokens[i]].available, \"token already available\");\r\n            // Store the intermediate values.\r\n            string memory symbol = _symbols[i].toSliceB32().toString();\r\n            // Add the token to the token list.\r\n            _tokenInfoMap[_tokens[i]] = Token({\r\n                symbol : symbol,\r\n                magnitude : _magnitude[i],\r\n                rate : 0,\r\n                available : true,\r\n                loadable : _loadable[i],\r\n                redeemable: _redeemable[i],\r\n                lastUpdate : _lastUpdate\r\n                });\r\n            // Add the token address to the address list.\r\n            _tokenAddressArray.push(_tokens[i]);\r\n            //if the token is redeemable increase the redeemableCounter\r\n            if (_redeemable[i]){\r\n                _redeemableCounter = _redeemableCounter.add(1);\r\n            }\r\n            // Emit token addition event.\r\n            emit AddedToken(msg.sender, _tokens[i], symbol, _magnitude[i], _loadable[i], _redeemable[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Remove ERC20 tokens from the whitelist of tokens.\r\n    /// @param _tokens ERC20 token contract addresses.\r\n    function removeTokens(address[] calldata _tokens) external onlyAdmin {\r\n        // Delete each token object from the list of supported tokens based on the addresses provided.\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            // Store the token address.\r\n            address token = _tokens[i];\r\n            //token must be available, reverts on duplicates as well\r\n            require(_tokenInfoMap[token].available, \"token is not available\");\r\n            //if the token is redeemable decrease the redeemableCounter\r\n            if (_tokenInfoMap[token].redeemable){\r\n                _redeemableCounter = _redeemableCounter.sub(1);\r\n            }\r\n            // Delete the token object.\r\n            delete _tokenInfoMap[token];\r\n            // Remove the token address from the address list.\r\n            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\r\n                if (_tokenAddressArray[j] == token) {\r\n                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\r\n                    break;\r\n                }\r\n            }\r\n            _tokenAddressArray.length--;\r\n            // Emit token removal event.\r\n            emit RemovedToken(msg.sender, token);\r\n        }\r\n    }\r\n\r\n    /// @notice based on the method it returns the recipient address and amount/value, ERC20 specific.\r\n    /// @param _data is the transaction payload.\r\n    function getERC20RecipientAndAmount(address _token, bytes calldata _data) external view returns (address, uint) {\r\n        // Require that there exist enough bytes for encoding at least a method signature + data in the transaction payload:\r\n        // 4 (signature)  + 32(address or uint256)\r\n        require(_data.length >= 4 + 32, \"not enough method-encoding bytes\");\r\n        // Get the method signature\r\n        bytes4 signature = _data._bytesToBytes4(0);\r\n        // Check if method Id is supported\r\n        require(isERC20MethodSupported(_token, signature), \"unsupported method\");\r\n        // returns the recipient's address and amount is the value to be transferred\r\n        if (signature == _BURN) {\r\n            // 4 (signature) + 32(uint256)\r\n            return (_token, _data._bytesToUint256(4));\r\n        } else if (signature == _TRANSFER_FROM) {\r\n            // 4 (signature) + 32(address) + 32(address) + 32(uint256)\r\n            require(_data.length >= 4 + 32 + 32 + 32, \"not enough data for transferFrom\");\r\n            return ( _data._bytesToAddress(4 + 32 + 12), _data._bytesToUint256(4 + 32 + 32));\r\n        } else { //transfer or approve\r\n            // 4 (signature) + 32(address) + 32(uint)\r\n            require(_data.length >= 4 + 32 + 32, \"not enough data for transfer/appprove\");\r\n            return (_data._bytesToAddress(4 + 12), _data._bytesToUint256(4 + 32));\r\n        }\r\n    }\r\n\r\n    /// @notice Toggles whether or not a token is loadable or not.\r\n    function setTokenLoadable(address _token, bool _loadable) external onlyAdmin {\r\n        // Require that the token exists.\r\n        require(_tokenInfoMap[_token].available, \"token is not available\");\r\n\r\n        // this sets the loadable flag to the value passed in\r\n        _tokenInfoMap[_token].loadable = _loadable;\r\n\r\n        emit UpdatedTokenLoadable(msg.sender, _token, _loadable);\r\n    }\r\n\r\n    /// @notice Toggles whether or not a token is redeemable or not.\r\n    function setTokenRedeemable(address _token, bool _redeemable) external onlyAdmin {\r\n        // Require that the token exists.\r\n        require(_tokenInfoMap[_token].available, \"token is not available\");\r\n\r\n        // this sets the redeemable flag to the value passed in\r\n        _tokenInfoMap[_token].redeemable = _redeemable;\r\n\r\n        emit UpdatedTokenRedeemable(msg.sender, _token, _redeemable);\r\n    }\r\n\r\n    /// @notice Update ERC20 token exchange rate.\r\n    /// @param _token ERC20 token contract address.\r\n    /// @param _rate ERC20 token exchange rate in wei.\r\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\r\n    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyAdminOrOracle {\r\n        // Require that the token exists.\r\n        require(_tokenInfoMap[_token].available, \"token is not available\");\r\n        // Update the token's rate.\r\n        _tokenInfoMap[_token].rate = _rate;\r\n        // Update the token's last update timestamp.\r\n        _tokenInfoMap[_token].lastUpdate = _updateDate;\r\n        // Emit the rate update event.\r\n        emit UpdatedTokenRate(msg.sender, _token, _rate);\r\n    }\r\n\r\n    //// @notice Withdraw tokens from the smart contract to the specified account.\r\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin {\r\n        _safeTransfer(_to, _asset, _amount);\r\n        emit Claimed(_to, _asset, _amount);\r\n    }\r\n\r\n    /// @notice This returns all of the fields for a given token.\r\n    /// @param _a is the address of a given token.\r\n    /// @return string of the token's symbol.\r\n    /// @return uint of the token's magnitude.\r\n    /// @return uint of the token's exchange rate to ETH.\r\n    /// @return bool whether the token is available.\r\n    /// @return bool whether the token is loadable to the TokenCard.\r\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\r\n    /// @return uint of the lastUpdated time of the token's exchange rate.\r\n    function getTokenInfo(address _a) external view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\r\n        Token storage tokenInfo = _tokenInfoMap[_a];\r\n        return (tokenInfo.symbol, tokenInfo.magnitude, tokenInfo.rate, tokenInfo.available, tokenInfo.loadable, tokenInfo.redeemable, tokenInfo.lastUpdate);\r\n    }\r\n\r\n    /// @notice This returns all of the fields for our StableCoin.\r\n    /// @return string of the token's symbol.\r\n    /// @return uint of the token's magnitude.\r\n    /// @return uint of the token's exchange rate to ETH.\r\n    /// @return bool whether the token is available.\r\n    /// @return bool whether the token is loadable to the TokenCard.\r\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\r\n    /// @return uint of the lastUpdated time of the token's exchange rate.\r\n    function getStablecoinInfo() external view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\r\n        Token storage stablecoinInfo = _tokenInfoMap[_stablecoin];\r\n        return (stablecoinInfo.symbol, stablecoinInfo.magnitude, stablecoinInfo.rate, stablecoinInfo.available, stablecoinInfo.loadable, stablecoinInfo.redeemable, stablecoinInfo.lastUpdate);\r\n    }\r\n\r\n    /// @notice This returns an array of all whitelisted token addresses.\r\n    /// @return address[] of whitelisted tokens.\r\n    function tokenAddressArray() external view returns (address[] memory) {\r\n        return _tokenAddressArray;\r\n    }\r\n\r\n    /// @notice This returns an array of all redeemable token addresses.\r\n    /// @return address[] of redeemable tokens.\r\n    function redeemableTokens() external view returns (address[] memory) {\r\n        address[] memory redeemableAddresses = new address[](_redeemableCounter);\r\n        uint redeemableIndex = 0;\r\n        for (uint i = 0; i < _tokenAddressArray.length; i++) {\r\n            address token = _tokenAddressArray[i];\r\n            if (_tokenInfoMap[token].redeemable){\r\n                redeemableAddresses[redeemableIndex] = token;\r\n                redeemableIndex += 1;\r\n            }\r\n        }\r\n        return redeemableAddresses;\r\n    }\r\n\r\n\r\n    /// @notice This returns true if a method Id is supported for the specific token.\r\n    /// @return true if _methodId is supported in general or just for the specific token.\r\n    function isERC20MethodSupported(address _token, bytes4 _methodId) public view returns (bool) {\r\n        require(_tokenInfoMap[_token].available, \"non-existing token\");\r\n        return (_methodIdWhitelist[_methodId]);\r\n    }\r\n\r\n    /// @notice This returns true if the method is supported for all protected tokens.\r\n    /// @return true if _methodId is in the method whitelist.\r\n    function isERC20MethodWhitelisted(bytes4 _methodId) external view returns (bool) {\r\n        return (_methodIdWhitelist[_methodId]);\r\n    }\r\n\r\n    /// @notice This returns the number of redeemable tokens.\r\n    /// @return current # of redeemables.\r\n    function redeemableCounter() external view returns (uint) {\r\n        return _redeemableCounter;\r\n    }\r\n\r\n    /// @notice This returns the address of our stablecoin of choice.\r\n    /// @return the address of the stablecoin contract.\r\n    function stablecoin() external view returns (address) {\r\n        return _stablecoin;\r\n    }\r\n\r\n    /// @notice this returns the node hash of our Oracle.\r\n    /// @return the oracle node registered in ENS.\r\n    function oracleNode() external view returns (bytes32) {\r\n        return _oracleNode;\r\n    }\r\n}\r\n\r\n// File: tokenWhitelistable.sol\r\n\r\n/**\r\n *  TokenWhitelistable - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n/// @title TokenWhitelistable implements access to the TokenWhitelist located behind ENS.\r\ncontract TokenWhitelistable is ENSResolvable {\r\n\r\n    /// @notice Is the registered ENS node identifying the tokenWhitelist contract\r\n    bytes32 private _tokenWhitelistNode;\r\n\r\n    /// @notice Constructor initializes the TokenWhitelistable object.\r\n    /// @param _tokenWhitelistNode_ is the ENS node of the TokenWhitelist.\r\n    constructor(bytes32 _tokenWhitelistNode_) internal {\r\n        _tokenWhitelistNode = _tokenWhitelistNode_;\r\n    }\r\n\r\n    /// @notice This shows what TokenWhitelist is being used\r\n    /// @return TokenWhitelist's node registered in ENS.\r\n    function tokenWhitelistNode() external view returns (bytes32) {\r\n        return _tokenWhitelistNode;\r\n    }\r\n\r\n    /// @notice This returns all of the fields for a given token.\r\n    /// @param _a is the address of a given token.\r\n    /// @return string of the token's symbol.\r\n    /// @return uint of the token's magnitude.\r\n    /// @return uint of the token's exchange rate to ETH.\r\n    /// @return bool whether the token is available.\r\n    /// @return bool whether the token is loadable to the TokenCard.\r\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\r\n    /// @return uint of the lastUpdated time of the token's exchange rate.\r\n    function _getTokenInfo(address _a) internal view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getTokenInfo(_a);\r\n    }\r\n\r\n    /// @notice This returns all of the fields for our stablecoin token.\r\n    /// @return string of the token's symbol.\r\n    /// @return uint of the token's magnitude.\r\n    /// @return uint of the token's exchange rate to ETH.\r\n    /// @return bool whether the token is available.\r\n    /// @return bool whether the token is loadable to the TokenCard.\r\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\r\n    /// @return uint of the lastUpdated time of the token's exchange rate.\r\n    function _getStablecoinInfo() internal view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getStablecoinInfo();\r\n    }\r\n\r\n    /// @notice This returns an array of our whitelisted addresses.\r\n    /// @return address[] of our whitelisted tokens.\r\n    function _tokenAddressArray() internal view returns (address[] memory) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).tokenAddressArray();\r\n    }\r\n\r\n    /// @notice This returns an array of all redeemable token addresses.\r\n    /// @return address[] of redeemable tokens.\r\n    function _redeemableTokens() internal view returns (address[] memory) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).redeemableTokens();\r\n    }\r\n\r\n    /// @notice Update ERC20 token exchange rate.\r\n    /// @param _token ERC20 token contract address.\r\n    /// @param _rate ERC20 token exchange rate in wei.\r\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\r\n    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\r\n        ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).updateTokenRate(_token, _rate, _updateDate);\r\n    }\r\n\r\n    /// @notice based on the method it returns the recipient address and amount/value, ERC20 specific.\r\n    /// @param _data is the transaction payload.\r\n    function _getERC20RecipientAndAmount(address _destination, bytes memory _data) internal view returns (address, uint) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getERC20RecipientAndAmount(_destination, _data);\r\n    }\r\n\r\n    /// @notice Checks whether a token is available.\r\n    /// @return bool available or not.\r\n    function _isTokenAvailable(address _a) internal view returns (bool) {\r\n        ( , , , bool available, , , ) = _getTokenInfo(_a);\r\n        return available;\r\n    }\r\n\r\n    /// @notice Checks whether a token is redeemable.\r\n    /// @return bool redeemable or not.\r\n    function _isTokenRedeemable(address _a) internal view returns (bool) {\r\n        ( , , , , , bool redeemable, ) = _getTokenInfo(_a);\r\n        return redeemable;\r\n    }\r\n\r\n    /// @notice Checks whether a token is loadable.\r\n    /// @return bool loadable or not.\r\n    function _isTokenLoadable(address _a) internal view returns (bool) {\r\n        ( , , , , bool loadable, , ) = _getTokenInfo(_a);\r\n        return loadable;\r\n    }\r\n\r\n    /// @notice This gets the address of the stablecoin.\r\n    /// @return the address of the stablecoin contract.\r\n    function _stablecoin() internal view returns (address) {\r\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).stablecoin();\r\n    }\r\n\r\n}\r\n\r\n// File: holder.sol\r\n\r\n/**\r\n *  Holder (aka Asset Contract) - The Consumer Contract Wallet\r\n *  Copyright (C) 2019 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Holder - The TKN Asset Contract\r\n/// @notice When the TKN contract calls the burn method, a share of the tokens held by this contract are disbursed to the burner.\r\ncontract Holder is Balanceable, ENSResolvable, Controllable, Transferrable, TokenWhitelistable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event Received(address _from, uint _amount);\r\n    event CashAndBurned(address _to, address _asset, uint _amount);\r\n    event Claimed(address _to, address _asset, uint _amount);\r\n\r\n    /// @dev Check if the sender is the burner contract\r\n    modifier onlyBurner() {\r\n        require (msg.sender == _burner, \"burner contract is not the sender\");\r\n        _;\r\n    }\r\n\r\n    // Burner token which can be burned to redeem shares.\r\n    address private _burner;\r\n\r\n    /// @notice Constructor initializes the holder contract.\r\n    /// @param _burnerContract_ is the address of the token contract TKN with burning functionality.\r\n    /// @param _ens_ is the address of the ENS registry.\r\n    /// @param _tokenWhitelistNode_ is the ENS node of the Token whitelist.\r\n    /// @param _controllerNode_ is the ENS node of the Controller\r\n    constructor (address _burnerContract_, address _ens_, bytes32 _tokenWhitelistNode_, bytes32 _controllerNode_) ENSResolvable(_ens_) Controllable(_controllerNode_) TokenWhitelistable(_tokenWhitelistNode_) public {\r\n        _burner = _burnerContract_;\r\n    }\r\n\r\n    /// @notice Ether may be sent from anywhere.\r\n    function() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice Burn handles disbursing a share of tokens in this contract to a given address.\r\n    /// @param _to The address to disburse to\r\n    /// @param _amount The amount of TKN that will be burned if this succeeds\r\n    function burn(address payable _to, uint _amount) external onlyBurner returns (bool) {\r\n        if (_amount == 0) {\r\n            return true;\r\n        }\r\n        // The burner token deducts from the supply before calling.\r\n        uint supply = IBurner(_burner).currentSupply().add(_amount);\r\n        address[] memory redeemableAddresses = _redeemableTokens();\r\n        for (uint i = 0; i < redeemableAddresses.length; i++) {\r\n            uint redeemableBalance = _balance(address(this), redeemableAddresses[i]);\r\n            if (redeemableBalance > 0) {\r\n                uint redeemableAmount = redeemableBalance.mul(_amount).div(supply);\r\n                _safeTransfer(_to, redeemableAddresses[i], redeemableAmount);\r\n                emit CashAndBurned(_to, redeemableAddresses[i], redeemableAmount);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice This allows for the admin to reclaim the non-redeemableTokens\r\n    /// @param _to this is the address which the reclaimed tokens will be sent to\r\n    /// @param _nonRedeemableAddresses this is the array of tokens to be claimed\r\n    function nonRedeemableTokenClaim(address payable _to, address[] calldata _nonRedeemableAddresses) external onlyAdmin returns (bool) {\r\n        for (uint i = 0; i < _nonRedeemableAddresses.length; i++) {\r\n            //revert if token is redeemable\r\n            require(!_isTokenRedeemable(_nonRedeemableAddresses[i]), \"redeemables cannot be claimed\");\r\n            uint claimBalance = _balance(address(this), _nonRedeemableAddresses[i]);\r\n            if (claimBalance > 0) {\r\n                _safeTransfer(_to, _nonRedeemableAddresses[i], claimBalance);\r\n                emit Claimed(_to, _nonRedeemableAddresses[i], claimBalance);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Returned the address of the burner contract\r\n    /// @return the TKN address\r\n    function burner() external view returns (address) {\r\n        return _burner;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"burner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_nonRedeemableAddresses\",\"type\":\"address[]\"}],\"name\":\"nonRedeemableTokenClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ensRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenWhitelistNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllerNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_burnerContract_\",\"type\":\"address\"},{\"name\":\"_ens_\",\"type\":\"address\"},{\"name\":\"_tokenWhitelistNode_\",\"type\":\"bytes32\"},{\"name\":\"_controllerNode_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"CashAndBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"}]","ContractName":"Holder","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000aaaf91d9b90df800df4f55c205fd6989c977e73a000000000000000000000000314159265dd8dbb310642f98f50c066173c1259be84f90570f13fe09f288f2411ff9cf50da611ed0c7db7f73d48053ffc974d3967f2ce995617d2816b426c5c8698c5ec2952f7a34bb10f38326f74933d5893697","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://3b68b4250f0c8813dc24bb500350e4d13a81095b7e30a608d69ebb3c76e06260"}]}