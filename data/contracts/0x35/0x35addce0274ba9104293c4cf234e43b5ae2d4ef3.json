{"status":"1","message":"OK","result":[{"SourceCode":"// File: @digix/cacp-contracts-dao/contracts/ACOwned.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n/// @title Owner based access control\r\n/// @author DigixGlobal\r\n\r\ncontract ACOwned {\r\n\r\n  address public owner;\r\n  address public new_owner;\r\n  bool is_ac_owned_init;\r\n\r\n  /// @dev Modifier to check if msg.sender is the contract owner\r\n  modifier if_owner() {\r\n    require(is_owner());\r\n    _;\r\n  }\r\n\r\n  function init_ac_owned()\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (is_ac_owned_init == false) {\r\n      owner = msg.sender;\r\n      is_ac_owned_init = true;\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function is_owner()\r\n           private\r\n           constant\r\n           returns (bool _is_owner)\r\n  {\r\n    _is_owner = (msg.sender == owner);\r\n  }\r\n\r\n  function change_owner(address _new_owner)\r\n           if_owner()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    new_owner = _new_owner;\r\n    _success = true;\r\n  }\r\n\r\n  function claim_ownership()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(msg.sender == new_owner);\r\n    owner = new_owner;\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/Constants.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n/// @title Some useful constants\r\n/// @author DigixGlobal\r\n\r\ncontract Constants {\r\n  address constant NULL_ADDRESS = address(0x0);\r\n  uint256 constant ZERO = uint256(0);\r\n  bytes32 constant EMPTY = bytes32(0x0);\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/ContractResolver.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n/// @title Contract Name Registry\r\n/// @author DigixGlobal\r\n\r\ncontract ContractResolver is ACOwned, Constants {\r\n\r\n  mapping (bytes32 => address) contracts;\r\n  bool public locked_forever;\r\n\r\n  modifier unless_registered(bytes32 _key) {\r\n    require(contracts[_key] == NULL_ADDRESS);\r\n    _;\r\n  }\r\n\r\n  modifier if_owner_origin() {\r\n    require(tx.origin == owner);\r\n    _;\r\n  }\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(msg.sender == get_contract(_contract));\r\n    _;\r\n  }\r\n\r\n  modifier if_not_locked() {\r\n    require(locked_forever == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev ContractResolver constructor will perform the following: 1. Set msg.sender as the contract owner.\r\n  constructor() public\r\n  {\r\n    require(init_ac_owned());\r\n    locked_forever = false;\r\n  }\r\n\r\n  /// @dev Called at contract initialization\r\n  /// @param _key bytestring for CACP name\r\n  /// @param _contract_address The address of the contract to be registered\r\n  /// @return _success if the operation is successful\r\n  function init_register_contract(bytes32 _key, address _contract_address)\r\n           if_owner_origin()\r\n           if_not_locked()\r\n           unless_registered(_key)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(_contract_address != NULL_ADDRESS);\r\n    contracts[_key] = _contract_address;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Lock the resolver from any further modifications.  This can only be called from the owner\r\n  /// @return _success if the operation is successful\r\n  function lock_resolver_forever()\r\n           if_owner\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    locked_forever = true;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Get address of a contract\r\n  /// @param _key the bytestring name of the contract to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           view\r\n           returns (address _contract)\r\n  {\r\n    require(contracts[_key] != NULL_ADDRESS);\r\n    _contract = contracts[_key];\r\n  }\r\n\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/ResolverClient.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n/// @title Contract Resolver Interface\r\n/// @author DigixGlobal\r\n\r\ncontract ResolverClient {\r\n\r\n  /// The address of the resolver contract for this project\r\n  address public resolver;\r\n  bytes32 public key;\r\n\r\n  /// Make our own address available to us as a constant\r\n  address public CONTRACT_ADDRESS;\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(sender_is(_contract));\r\n    _;\r\n  }\r\n\r\n  function sender_is(bytes32 _contract) internal view returns (bool _isFrom) {\r\n    _isFrom = msg.sender == ContractResolver(resolver).get_contract(_contract);\r\n  }\r\n\r\n  modifier if_sender_is_from(bytes32[3] _contracts) {\r\n    require(sender_is_from(_contracts));\r\n    _;\r\n  }\r\n\r\n  function sender_is_from(bytes32[3] _contracts) internal view returns (bool _isFrom) {\r\n    uint256 _n = _contracts.length;\r\n    for (uint256 i = 0; i < _n; i++) {\r\n      if (_contracts[i] == bytes32(0x0)) continue;\r\n      if (msg.sender == ContractResolver(resolver).get_contract(_contracts[i])) {\r\n        _isFrom = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// Function modifier to check resolver's locking status.\r\n  modifier unless_resolver_is_locked() {\r\n    require(is_locked() == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev Initialize new contract\r\n  /// @param _key the resolver key for this contract\r\n  /// @return _success if the initialization is successful\r\n  function init(bytes32 _key, address _resolver)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    bool _is_locked = ContractResolver(_resolver).locked_forever();\r\n    if (_is_locked == false) {\r\n      CONTRACT_ADDRESS = address(this);\r\n      resolver = _resolver;\r\n      key = _key;\r\n      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\r\n      _success = true;\r\n    }  else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Check if resolver is locked\r\n  /// @return _locked if the resolver is currently locked\r\n  function is_locked()\r\n           private\r\n           view\r\n           returns (bool _locked)\r\n  {\r\n    _locked = ContractResolver(resolver).locked_forever();\r\n  }\r\n\r\n  /// @dev Get the address of a contract\r\n  /// @param _key the resolver key to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           view\r\n           returns (address _contract)\r\n  {\r\n    _contract = ContractResolver(resolver).get_contract(_key);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/common/DaoConstants.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ncontract DaoConstants {\r\n    using SafeMath for uint256;\r\n    bytes32 EMPTY_BYTES = bytes32(0x0);\r\n    address EMPTY_ADDRESS = address(0x0);\r\n\r\n\r\n    bytes32 PROPOSAL_STATE_PREPROPOSAL = \"proposal_state_preproposal\";\r\n    bytes32 PROPOSAL_STATE_DRAFT = \"proposal_state_draft\";\r\n    bytes32 PROPOSAL_STATE_MODERATED = \"proposal_state_moderated\";\r\n    bytes32 PROPOSAL_STATE_ONGOING = \"proposal_state_ongoing\";\r\n    bytes32 PROPOSAL_STATE_CLOSED = \"proposal_state_closed\";\r\n    bytes32 PROPOSAL_STATE_ARCHIVED = \"proposal_state_archived\";\r\n\r\n    uint256 PRL_ACTION_STOP = 1;\r\n    uint256 PRL_ACTION_PAUSE = 2;\r\n    uint256 PRL_ACTION_UNPAUSE = 3;\r\n\r\n    uint256 COLLATERAL_STATUS_UNLOCKED = 1;\r\n    uint256 COLLATERAL_STATUS_LOCKED = 2;\r\n    uint256 COLLATERAL_STATUS_CLAIMED = 3;\r\n\r\n    bytes32 INTERMEDIATE_DGD_IDENTIFIER = \"inter_dgd_id\";\r\n    bytes32 INTERMEDIATE_MODERATOR_DGD_IDENTIFIER = \"inter_mod_dgd_id\";\r\n    bytes32 INTERMEDIATE_BONUS_CALCULATION_IDENTIFIER = \"inter_bonus_calculation_id\";\r\n\r\n    // interactive contracts\r\n    bytes32 CONTRACT_DAO = \"dao\";\r\n    bytes32 CONTRACT_DAO_SPECIAL_PROPOSAL = \"dao:special:proposal\";\r\n    bytes32 CONTRACT_DAO_STAKE_LOCKING = \"dao:stake-locking\";\r\n    bytes32 CONTRACT_DAO_VOTING = \"dao:voting\";\r\n    bytes32 CONTRACT_DAO_VOTING_CLAIMS = \"dao:voting:claims\";\r\n    bytes32 CONTRACT_DAO_SPECIAL_VOTING_CLAIMS = \"dao:svoting:claims\";\r\n    bytes32 CONTRACT_DAO_IDENTITY = \"dao:identity\";\r\n    bytes32 CONTRACT_DAO_REWARDS_MANAGER = \"dao:rewards-manager\";\r\n    bytes32 CONTRACT_DAO_REWARDS_MANAGER_EXTRAS = \"dao:rewards-extras\";\r\n    bytes32 CONTRACT_DAO_ROLES = \"dao:roles\";\r\n    bytes32 CONTRACT_DAO_FUNDING_MANAGER = \"dao:funding-manager\";\r\n    bytes32 CONTRACT_DAO_WHITELISTING = \"dao:whitelisting\";\r\n    bytes32 CONTRACT_DAO_INFORMATION = \"dao:information\";\r\n\r\n    // service contracts\r\n    bytes32 CONTRACT_SERVICE_ROLE = \"service:role\";\r\n    bytes32 CONTRACT_SERVICE_DAO_INFO = \"service:dao:info\";\r\n    bytes32 CONTRACT_SERVICE_DAO_LISTING = \"service:dao:listing\";\r\n    bytes32 CONTRACT_SERVICE_DAO_CALCULATOR = \"service:dao:calculator\";\r\n\r\n    // storage contracts\r\n    bytes32 CONTRACT_STORAGE_DAO = \"storage:dao\";\r\n    bytes32 CONTRACT_STORAGE_DAO_COUNTER = \"storage:dao:counter\";\r\n    bytes32 CONTRACT_STORAGE_DAO_UPGRADE = \"storage:dao:upgrade\";\r\n    bytes32 CONTRACT_STORAGE_DAO_IDENTITY = \"storage:dao:identity\";\r\n    bytes32 CONTRACT_STORAGE_DAO_POINTS = \"storage:dao:points\";\r\n    bytes32 CONTRACT_STORAGE_DAO_SPECIAL = \"storage:dao:special\";\r\n    bytes32 CONTRACT_STORAGE_DAO_CONFIG = \"storage:dao:config\";\r\n    bytes32 CONTRACT_STORAGE_DAO_STAKE = \"storage:dao:stake\";\r\n    bytes32 CONTRACT_STORAGE_DAO_REWARDS = \"storage:dao:rewards\";\r\n    bytes32 CONTRACT_STORAGE_DAO_WHITELISTING = \"storage:dao:whitelisting\";\r\n    bytes32 CONTRACT_STORAGE_INTERMEDIATE_RESULTS = \"storage:intermediate:results\";\r\n\r\n    bytes32 CONTRACT_DGD_TOKEN = \"t:dgd\";\r\n    bytes32 CONTRACT_DGX_TOKEN = \"t:dgx\";\r\n    bytes32 CONTRACT_BADGE_TOKEN = \"t:badge\";\r\n\r\n    uint8 ROLES_ROOT = 1;\r\n    uint8 ROLES_FOUNDERS = 2;\r\n    uint8 ROLES_PRLS = 3;\r\n    uint8 ROLES_KYC_ADMINS = 4;\r\n\r\n    uint256 QUARTER_DURATION = 90 days;\r\n\r\n    bytes32 CONFIG_MINIMUM_LOCKED_DGD = \"min_dgd_participant\";\r\n    bytes32 CONFIG_MINIMUM_DGD_FOR_MODERATOR = \"min_dgd_moderator\";\r\n    bytes32 CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR = \"min_reputation_moderator\";\r\n\r\n    bytes32 CONFIG_LOCKING_PHASE_DURATION = \"locking_phase_duration\";\r\n    bytes32 CONFIG_QUARTER_DURATION = \"quarter_duration\";\r\n    bytes32 CONFIG_VOTING_COMMIT_PHASE = \"voting_commit_phase\";\r\n    bytes32 CONFIG_VOTING_PHASE_TOTAL = \"voting_phase_total\";\r\n    bytes32 CONFIG_INTERIM_COMMIT_PHASE = \"interim_voting_commit_phase\";\r\n    bytes32 CONFIG_INTERIM_PHASE_TOTAL = \"interim_voting_phase_total\";\r\n\r\n    bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR = \"draft_quorum_fixed_numerator\";\r\n    bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR = \"draft_quorum_fixed_denominator\";\r\n    bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR = \"draft_quorum_sfactor_numerator\";\r\n    bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR = \"draft_quorum_sfactor_denominator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR = \"vote_quorum_fixed_numerator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR = \"vote_quorum_fixed_denominator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR = \"vote_quorum_sfactor_numerator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR = \"vote_quorum_sfactor_denominator\";\r\n    bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR = \"final_reward_sfactor_numerator\";\r\n    bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR = \"final_reward_sfactor_denominator\";\r\n\r\n    bytes32 CONFIG_DRAFT_QUOTA_NUMERATOR = \"draft_quota_numerator\";\r\n    bytes32 CONFIG_DRAFT_QUOTA_DENOMINATOR = \"draft_quota_denominator\";\r\n    bytes32 CONFIG_VOTING_QUOTA_NUMERATOR = \"voting_quota_numerator\";\r\n    bytes32 CONFIG_VOTING_QUOTA_DENOMINATOR = \"voting_quota_denominator\";\r\n\r\n    bytes32 CONFIG_MINIMAL_QUARTER_POINT = \"minimal_qp\";\r\n    bytes32 CONFIG_QUARTER_POINT_SCALING_FACTOR = \"quarter_point_scaling_factor\";\r\n    bytes32 CONFIG_REPUTATION_POINT_SCALING_FACTOR = \"rep_point_scaling_factor\";\r\n\r\n    bytes32 CONFIG_MODERATOR_MINIMAL_QUARTER_POINT = \"minimal_mod_qp\";\r\n    bytes32 CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR = \"mod_qp_scaling_factor\";\r\n    bytes32 CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR = \"mod_rep_point_scaling_factor\";\r\n\r\n    bytes32 CONFIG_QUARTER_POINT_DRAFT_VOTE = \"quarter_point_draft_vote\";\r\n    bytes32 CONFIG_QUARTER_POINT_VOTE = \"quarter_point_vote\";\r\n    bytes32 CONFIG_QUARTER_POINT_INTERIM_VOTE = \"quarter_point_interim_vote\";\r\n\r\n    /// this is per 10000 ETHs\r\n    bytes32 CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH = \"q_p_milestone_completion\";\r\n\r\n    bytes32 CONFIG_BONUS_REPUTATION_NUMERATOR = \"bonus_reputation_numerator\";\r\n    bytes32 CONFIG_BONUS_REPUTATION_DENOMINATOR = \"bonus_reputation_denominator\";\r\n\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE = \"special_proposal_commit_phase\";\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL = \"special_proposal_phase_total\";\r\n\r\n    bytes32 CONFIG_SPECIAL_QUOTA_NUMERATOR = \"config_special_quota_numerator\";\r\n    bytes32 CONFIG_SPECIAL_QUOTA_DENOMINATOR = \"config_special_quota_denominator\";\r\n\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR = \"special_quorum_numerator\";\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR = \"special_quorum_denominator\";\r\n\r\n    bytes32 CONFIG_MAXIMUM_REPUTATION_DEDUCTION = \"config_max_reputation_deduction\";\r\n    bytes32 CONFIG_PUNISHMENT_FOR_NOT_LOCKING = \"config_punishment_not_locking\";\r\n\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_NUM = \"config_rep_per_extra_qp_num\";\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_DEN = \"config_rep_per_extra_qp_den\";\r\n\r\n    bytes32 CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION = \"config_max_m_rp_deduction\";\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM = \"config_rep_per_extra_m_qp_num\";\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN = \"config_rep_per_extra_m_qp_den\";\r\n\r\n    bytes32 CONFIG_PORTION_TO_MODERATORS_NUM = \"config_mod_portion_num\";\r\n    bytes32 CONFIG_PORTION_TO_MODERATORS_DEN = \"config_mod_portion_den\";\r\n\r\n    bytes32 CONFIG_DRAFT_VOTING_PHASE = \"config_draft_voting_phase\";\r\n\r\n    bytes32 CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE = \"config_rp_boost_per_badge\";\r\n\r\n    bytes32 CONFIG_VOTE_CLAIMING_DEADLINE = \"config_claiming_deadline\";\r\n\r\n    bytes32 CONFIG_PREPROPOSAL_COLLATERAL = \"config_preproposal_collateral\";\r\n\r\n    bytes32 CONFIG_MAX_FUNDING_FOR_NON_DIGIX = \"config_max_funding_nonDigix\";\r\n    bytes32 CONFIG_MAX_MILESTONES_FOR_NON_DIGIX = \"config_max_milestones_nonDigix\";\r\n    bytes32 CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER = \"config_nonDigix_proposal_cap\";\r\n\r\n    bytes32 CONFIG_PROPOSAL_DEAD_DURATION = \"config_dead_duration\";\r\n    bytes32 CONFIG_CARBON_VOTE_REPUTATION_BONUS = \"config_cv_reputation\";\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/lib/DoublyLinkedList.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\nlibrary DoublyLinkedList {\r\n\r\n  struct Item {\r\n    bytes32 item;\r\n    uint256 previous_index;\r\n    uint256 next_index;\r\n  }\r\n\r\n  struct Data {\r\n    uint256 first_index;\r\n    uint256 last_index;\r\n    uint256 count;\r\n    mapping(bytes32 => uint256) item_index;\r\n    mapping(uint256 => bool) valid_indexes;\r\n    Item[] collection;\r\n  }\r\n\r\n  struct IndexedUint {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct IndexedAddress {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct IndexedBytes {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct Address {\r\n    Data data;\r\n  }\r\n\r\n  struct Bytes {\r\n    Data data;\r\n  }\r\n\r\n  struct Uint {\r\n    Data data;\r\n  }\r\n\r\n  uint256 constant NONE = uint256(0);\r\n  bytes32 constant EMPTY_BYTES = bytes32(0x0);\r\n  address constant NULL_ADDRESS = address(0x0);\r\n\r\n  function find(Data storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    if ((self.item_index[_item] == NONE) && (self.count == NONE)) {\r\n      _item_index = NONE;\r\n    } else {\r\n      _item_index = self.item_index[_item];\r\n    }\r\n  }\r\n\r\n  function get(Data storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    if (self.valid_indexes[_item_index] == true) {\r\n      _item = self.collection[_item_index - 1].item;\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function append(Data storage self, bytes32 _data)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (find(self, _data) != NONE || _data == bytes32(\"\")) { // rejects addition of empty values\r\n      _success = false;\r\n    } else {\r\n      uint256 _index = uint256(self.collection.push(Item({item: _data, previous_index: self.last_index, next_index: NONE})));\r\n      if (self.last_index == NONE) {\r\n        if ((self.first_index != NONE) || (self.count != NONE)) {\r\n          revert();\r\n        } else {\r\n          self.first_index = self.last_index = _index;\r\n          self.count = 1;\r\n        }\r\n      } else {\r\n        self.collection[self.last_index - 1].next_index = _index;\r\n        self.last_index = _index;\r\n        self.count++;\r\n      }\r\n      self.valid_indexes[_index] = true;\r\n      self.item_index[_data] = _index;\r\n      _success = true;\r\n    }\r\n  }\r\n\r\n  function remove(Data storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (self.valid_indexes[_index] == true) {\r\n      Item memory item = self.collection[_index - 1];\r\n      if (item.previous_index == NONE) {\r\n        self.first_index = item.next_index;\r\n      } else {\r\n        self.collection[item.previous_index - 1].next_index = item.next_index;\r\n      }\r\n\r\n      if (item.next_index == NONE) {\r\n        self.last_index = item.previous_index;\r\n      } else {\r\n        self.collection[item.next_index - 1].previous_index = item.previous_index;\r\n      }\r\n      delete self.collection[_index - 1];\r\n      self.valid_indexes[_index] = false;\r\n      delete self.item_index[item.item];\r\n      self.count--;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  function remove_item(Data storage self, bytes32 _item)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    uint256 _item_index = find(self, _item);\r\n    if (_item_index != NONE) {\r\n      require(remove(self, _item_index));\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n    return _success;\r\n  }\r\n\r\n  function total(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = self.count;\r\n  }\r\n\r\n  function start(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = self.first_index;\r\n    return _item_index;\r\n  }\r\n\r\n  function start_item(Data storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    uint256 _item_index = start(self);\r\n    if (_item_index != NONE) {\r\n      _item = get(self, _item_index);\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function end(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = self.last_index;\r\n    return _item_index;\r\n  }\r\n\r\n  function end_item(Data storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    uint256 _item_index = end(self);\r\n    if (_item_index != NONE) {\r\n      _item = get(self, _item_index);\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function valid(Data storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = self.valid_indexes[_item_index];\r\n    //_yes = ((_item_index - 1) < self.collection.length);\r\n  }\r\n\r\n  function valid_item(Data storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    uint256 _item_index = self.item_index[_item];\r\n    _yes = self.valid_indexes[_item_index];\r\n  }\r\n\r\n  function previous(Data storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    if (self.valid_indexes[_current_index] == true) {\r\n      _previous_index = self.collection[_current_index - 1].previous_index;\r\n    } else {\r\n      _previous_index = NONE;\r\n    }\r\n  }\r\n\r\n  function previous_item(Data storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    uint256 _current_index = find(self, _current_item);\r\n    if (_current_index != NONE) {\r\n      uint256 _previous_index = previous(self, _current_index);\r\n      _previous_item = get(self, _previous_index);\r\n    } else {\r\n      _previous_item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function next(Data storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    if (self.valid_indexes[_current_index] == true) {\r\n      _next_index = self.collection[_current_index - 1].next_index;\r\n    } else {\r\n      _next_index = NONE;\r\n    }\r\n  }\r\n\r\n  function next_item(Data storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    uint256 _current_index = find(self, _current_item);\r\n    if (_current_index != NONE) {\r\n      uint256 _next_index = next(self, _current_index);\r\n      _next_item = get(self, _next_index);\r\n    } else {\r\n      _next_item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function find(Uint storage self, uint256 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, bytes32(_item));\r\n  }\r\n\r\n  function get(Uint storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = uint256(get(self.data, _item_index));\r\n  }\r\n\r\n\r\n  function append(Uint storage self, uint256 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, bytes32(_data));\r\n  }\r\n\r\n  function remove(Uint storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n  function remove_item(Uint storage self, uint256 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function total(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _start_item)\r\n  {\r\n    _start_item = uint256(start_item(self.data));\r\n  }\r\n\r\n\r\n  function end(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _end_item)\r\n  {\r\n    _end_item = uint256(end_item(self.data));\r\n  }\r\n\r\n  function valid(Uint storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Uint storage self, uint256 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function previous(Uint storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Uint storage self, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_item)\r\n  {\r\n    _previous_item = uint256(previous_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function next(Uint storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Uint storage self, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _next_item)\r\n  {\r\n    _next_item = uint256(next_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function find(Address storage self, address _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, bytes32(_item));\r\n  }\r\n\r\n  function get(Address storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = address(get(self.data, _item_index));\r\n  }\r\n\r\n\r\n  function find(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function get(IndexedUint storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = uint256(get(self.data[_collection_index], _item_index));\r\n  }\r\n\r\n\r\n  function append(IndexedUint storage self, bytes32 _collection_index, uint256 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedUint storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n  function remove_item(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _start_item)\r\n  {\r\n    _start_item = uint256(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _end_item)\r\n  {\r\n    _end_item = uint256(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedUint storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedUint storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedUint storage self, bytes32 _collection_index, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_item)\r\n  {\r\n    _previous_item = uint256(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedUint storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedUint storage self, bytes32 _collection_index, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _next_item)\r\n  {\r\n    _next_item = uint256(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function append(Address storage self, address _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, bytes32(_data));\r\n  }\r\n\r\n  function remove(Address storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n\r\n  function remove_item(Address storage self, address _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function total(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Address storage self)\r\n           public\r\n           constant\r\n           returns (address _start_item)\r\n  {\r\n    _start_item = address(start_item(self.data));\r\n  }\r\n\r\n\r\n  function end(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Address storage self)\r\n           public\r\n           constant\r\n           returns (address _end_item)\r\n  {\r\n    _end_item = address(end_item(self.data));\r\n  }\r\n\r\n  function valid(Address storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Address storage self, address _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function previous(Address storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Address storage self, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _previous_item)\r\n  {\r\n    _previous_item = address(previous_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function next(Address storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Address storage self, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _next_item)\r\n  {\r\n    _next_item = address(next_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function append(IndexedAddress storage self, bytes32 _collection_index, address _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedAddress storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n\r\n  function remove_item(IndexedAddress storage self, bytes32 _collection_index, address _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (address _start_item)\r\n  {\r\n    _start_item = address(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (address _end_item)\r\n  {\r\n    _end_item = address(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedAddress storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedAddress storage self, bytes32 _collection_index, address _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedAddress storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedAddress storage self, bytes32 _collection_index, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _previous_item)\r\n  {\r\n    _previous_item = address(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedAddress storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedAddress storage self, bytes32 _collection_index, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _next_item)\r\n  {\r\n    _next_item = address(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n\r\n  function find(Bytes storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, _item);\r\n  }\r\n\r\n  function get(Bytes storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = get(self.data, _item_index);\r\n  }\r\n\r\n\r\n  function append(Bytes storage self, bytes32 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, _data);\r\n  }\r\n\r\n  function remove(Bytes storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n\r\n  function remove_item(Bytes storage self, bytes32 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, _item);\r\n  }\r\n\r\n  function total(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _start_item)\r\n  {\r\n    _start_item = start_item(self.data);\r\n  }\r\n\r\n\r\n  function end(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _end_item)\r\n  {\r\n    _end_item = end_item(self.data);\r\n  }\r\n\r\n  function valid(Bytes storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Bytes storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, _item);\r\n  }\r\n\r\n  function previous(Bytes storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Bytes storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    _previous_item = previous_item(self.data, _current_item);\r\n  }\r\n\r\n  function next(Bytes storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Bytes storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    _next_item = next_item(self.data, _current_item);\r\n  }\r\n\r\n  function append(IndexedBytes storage self, bytes32 _collection_index, bytes32 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedBytes storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n\r\n  function remove_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _start_item)\r\n  {\r\n    _start_item = bytes32(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _end_item)\r\n  {\r\n    _end_item = bytes32(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedBytes storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedBytes storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    _previous_item = bytes32(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedBytes storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    _next_item = bytes32(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n\r\n}\r\n\r\n// File: contracts/lib/DaoStructs.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\nlibrary DaoStructs {\r\n    using DoublyLinkedList for DoublyLinkedList.Bytes;\r\n    using SafeMath for uint256;\r\n    bytes32 constant EMPTY_BYTES = bytes32(0x0);\r\n\r\n    struct PrlAction {\r\n        // UTC timestamp at which the PRL action was done\r\n        uint256 at;\r\n\r\n        // IPFS hash of the document summarizing the action\r\n        bytes32 doc;\r\n\r\n        // Type of action\r\n        // check PRL_ACTION_* in \"./../common/DaoConstants.sol\"\r\n        uint256 actionId;\r\n    }\r\n\r\n    struct Voting {\r\n        // UTC timestamp at which the voting round starts\r\n        uint256 startTime;\r\n\r\n        // Mapping of whether a commit was used in this voting round\r\n        mapping (bytes32 => bool) usedCommits;\r\n\r\n        // Mapping of commits by address. These are the commits during the commit phase in a voting round\r\n        // This only stores the most recent commit in the voting round\r\n        // In case a vote is edited, the previous commit is overwritten by the new commit\r\n        // Only this new commit is verified at the reveal phase\r\n        mapping (address => bytes32) commits;\r\n\r\n        // This mapping is updated after the reveal phase, when votes are revealed\r\n        // It is a mapping of address to weight of vote\r\n        // Weight implies the lockedDGDStake of the address, at the time of revealing\r\n        // If the address voted \"NO\", or didn't vote, this would be 0\r\n        mapping (address => uint256) yesVotes;\r\n\r\n        // This mapping is updated after the reveal phase, when votes are revealed\r\n        // It is a mapping of address to weight of vote\r\n        // Weight implies the lockedDGDStake of the address, at the time of revealing\r\n        // If the address voted \"YES\", or didn't vote, this would be 0\r\n        mapping (address => uint256) noVotes;\r\n\r\n        // Boolean whether the voting round passed or not\r\n        bool passed;\r\n\r\n        // Boolean whether the voting round results were claimed or not\r\n        // refer the claimProposalVotingResult function in \"./../interative/DaoVotingClaims.sol\"\r\n        bool claimed;\r\n\r\n        // Boolean whether the milestone following this voting round was funded or not\r\n        // The milestone is funded when the proposer calls claimFunding in \"./../interactive/DaoFundingManager.sol\"\r\n        bool funded;\r\n    }\r\n\r\n    struct ProposalVersion {\r\n        // IPFS doc hash of this version of the proposal\r\n        bytes32 docIpfsHash;\r\n\r\n        // UTC timestamp at which this version was created\r\n        uint256 created;\r\n\r\n        // The number of milestones in the proposal as per this version\r\n        uint256 milestoneCount;\r\n\r\n        // The final reward asked by the proposer for completion of the entire proposal\r\n        uint256 finalReward;\r\n\r\n        // List of fundings required by the proposal as per this version\r\n        // The numbers are in wei\r\n        uint256[] milestoneFundings;\r\n\r\n        // When a proposal is finalized (calling Dao.finalizeProposal), the proposer can no longer add proposal versions\r\n        // However, they can still add more details to this final proposal version, in the form of IPFS docs.\r\n        // These IPFS docs are stored in this array\r\n        bytes32[] moreDocs;\r\n    }\r\n\r\n    struct Proposal {\r\n        // ID of the proposal. Also the IPFS hash of the first ProposalVersion\r\n        bytes32 proposalId;\r\n\r\n        // current state of the proposal\r\n        // refer PROPOSAL_STATE_* in \"./../common/DaoConstants.sol\"\r\n        bytes32 currentState;\r\n\r\n        // UTC timestamp at which the proposal was created\r\n        uint256 timeCreated;\r\n\r\n        // DoublyLinkedList of IPFS doc hashes of the various versions of the proposal\r\n        DoublyLinkedList.Bytes proposalVersionDocs;\r\n\r\n        // Mapping of version (IPFS doc hash) to ProposalVersion struct\r\n        mapping (bytes32 => ProposalVersion) proposalVersions;\r\n\r\n        // Voting struct for the draft voting round\r\n        Voting draftVoting;\r\n\r\n        // Mapping of voting round index (starts from 0) to Voting struct\r\n        // votingRounds[0] is the Voting round of the proposal, which lasts for get_uint_config(CONFIG_VOTING_PHASE_TOTAL)\r\n        // votingRounds[i] for i>0 are the Interim Voting rounds of the proposal, which lasts for get_uint_config(CONFIG_INTERIM_PHASE_TOTAL)\r\n        mapping (uint256 => Voting) votingRounds;\r\n\r\n        // Every proposal has a collateral tied to it with a value of\r\n        // get_uint_config(CONFIG_PREPROPOSAL_COLLATERAL) (refer \"./../storage/DaoConfigsStorage.sol\")\r\n        // Collateral can be in different states\r\n        // refer COLLATERAL_STATUS_* in \"./../common/DaoConstants.sol\"\r\n        uint256 collateralStatus;\r\n        uint256 collateralAmount;\r\n\r\n        // The final version of the proposal\r\n        // Every proposal needs to be finalized before it can be voted on\r\n        // This is the IPFS doc hash of the final version\r\n        bytes32 finalVersion;\r\n\r\n        // List of PrlAction structs\r\n        // These are all the actions done by the PRL on the proposal\r\n        PrlAction[] prlActions;\r\n\r\n        // Address of the user who created the proposal\r\n        address proposer;\r\n\r\n        // Address of the moderator who endorsed the proposal\r\n        address endorser;\r\n\r\n        // Boolean whether the proposal is paused/stopped at the moment\r\n        bool isPausedOrStopped;\r\n\r\n        // Boolean whether the proposal was created by a founder role\r\n        bool isDigix;\r\n    }\r\n\r\n    function countVotes(Voting storage _voting, address[] _allUsers)\r\n        external\r\n        view\r\n        returns (uint256 _for, uint256 _against)\r\n    {\r\n        uint256 _n = _allUsers.length;\r\n        for (uint256 i = 0; i < _n; i++) {\r\n            if (_voting.yesVotes[_allUsers[i]] > 0) {\r\n                _for = _for.add(_voting.yesVotes[_allUsers[i]]);\r\n            } else if (_voting.noVotes[_allUsers[i]] > 0) {\r\n                _against = _against.add(_voting.noVotes[_allUsers[i]]);\r\n            }\r\n        }\r\n    }\r\n\r\n    // get the list of voters who voted _vote (true-yes/false-no)\r\n    function listVotes(Voting storage _voting, address[] _allUsers, bool _vote)\r\n        external\r\n        view\r\n        returns (address[] memory _voters, uint256 _length)\r\n    {\r\n        uint256 _n = _allUsers.length;\r\n        uint256 i;\r\n        _length = 0;\r\n        _voters = new address[](_n);\r\n        if (_vote == true) {\r\n            for (i = 0; i < _n; i++) {\r\n                if (_voting.yesVotes[_allUsers[i]] > 0) {\r\n                    _voters[_length] = _allUsers[i];\r\n                    _length++;\r\n                }\r\n            }\r\n        } else {\r\n            for (i = 0; i < _n; i++) {\r\n                if (_voting.noVotes[_allUsers[i]] > 0) {\r\n                    _voters[_length] = _allUsers[i];\r\n                    _length++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function readVote(Voting storage _voting, address _voter)\r\n        public\r\n        view\r\n        returns (bool _vote, uint256 _weight)\r\n    {\r\n        if (_voting.yesVotes[_voter] > 0) {\r\n            _weight = _voting.yesVotes[_voter];\r\n            _vote = true;\r\n        } else {\r\n            _weight = _voting.noVotes[_voter]; // if _voter didnt vote at all, the weight will be 0 anyway\r\n            _vote = false;\r\n        }\r\n    }\r\n\r\n    function revealVote(\r\n        Voting storage _voting,\r\n        address _voter,\r\n        bool _vote,\r\n        uint256 _weight\r\n    )\r\n        public\r\n    {\r\n        if (_vote) {\r\n            _voting.yesVotes[_voter] = _weight;\r\n        } else {\r\n            _voting.noVotes[_voter] = _weight;\r\n        }\r\n    }\r\n\r\n    function readVersion(ProposalVersion storage _version)\r\n        public\r\n        view\r\n        returns (\r\n            bytes32 _doc,\r\n            uint256 _created,\r\n            uint256[] _milestoneFundings,\r\n            uint256 _finalReward\r\n        )\r\n    {\r\n        _doc = _version.docIpfsHash;\r\n        _created = _version.created;\r\n        _milestoneFundings = _version.milestoneFundings;\r\n        _finalReward = _version.finalReward;\r\n    }\r\n\r\n    // read the funding for a particular milestone of a finalized proposal\r\n    // if _milestoneId is the same as _milestoneCount, it returns the final reward\r\n    function readProposalMilestone(Proposal storage _proposal, uint256 _milestoneIndex)\r\n        public\r\n        view\r\n        returns (uint256 _funding)\r\n    {\r\n        bytes32 _finalVersion = _proposal.finalVersion;\r\n        uint256 _milestoneCount = _proposal.proposalVersions[_finalVersion].milestoneFundings.length;\r\n        require(_milestoneIndex <= _milestoneCount);\r\n        require(_finalVersion != EMPTY_BYTES); // the proposal must have been finalized\r\n\r\n        if (_milestoneIndex < _milestoneCount) {\r\n            _funding = _proposal.proposalVersions[_finalVersion].milestoneFundings[_milestoneIndex];\r\n        } else {\r\n            _funding = _proposal.proposalVersions[_finalVersion].finalReward;\r\n        }\r\n    }\r\n\r\n    function addProposalVersion(\r\n        Proposal storage _proposal,\r\n        bytes32 _newDoc,\r\n        uint256[] _newMilestoneFundings,\r\n        uint256 _finalReward\r\n    )\r\n        public\r\n    {\r\n        _proposal.proposalVersionDocs.append(_newDoc);\r\n        _proposal.proposalVersions[_newDoc].docIpfsHash = _newDoc;\r\n        _proposal.proposalVersions[_newDoc].created = now;\r\n        _proposal.proposalVersions[_newDoc].milestoneCount = _newMilestoneFundings.length;\r\n        _proposal.proposalVersions[_newDoc].milestoneFundings = _newMilestoneFundings;\r\n        _proposal.proposalVersions[_newDoc].finalReward = _finalReward;\r\n    }\r\n\r\n    struct SpecialProposal {\r\n        // ID of the special proposal\r\n        // This is the IPFS doc hash of the proposal\r\n        bytes32 proposalId;\r\n\r\n        // UTC timestamp at which the proposal was created\r\n        uint256 timeCreated;\r\n\r\n        // Voting struct for the special proposal\r\n        Voting voting;\r\n\r\n        // List of the new uint256 configs as per the special proposal\r\n        uint256[] uintConfigs;\r\n\r\n        // List of the new address configs as per the special proposal\r\n        address[] addressConfigs;\r\n\r\n        // List of the new bytes32 configs as per the special proposal\r\n        bytes32[] bytesConfigs;\r\n\r\n        // Address of the user who created the special proposal\r\n        // This address should also be in the ROLES_FOUNDERS group\r\n        // refer \"./../storage/DaoIdentityStorage.sol\"\r\n        address proposer;\r\n    }\r\n\r\n    // All configs are as per the DaoConfigsStorage values at the time when\r\n    // calculateGlobalRewardsBeforeNewQuarter is called by founder in that quarter\r\n    struct DaoQuarterInfo {\r\n        // The minimum quarter points required\r\n        // below this, reputation will be deducted\r\n        uint256 minimalParticipationPoint;\r\n\r\n        // The scaling factor for quarter point\r\n        uint256 quarterPointScalingFactor;\r\n\r\n        // The scaling factor for reputation point\r\n        uint256 reputationPointScalingFactor;\r\n\r\n        // The summation of effectiveDGDs in the previous quarter\r\n        // The effectiveDGDs represents the effective participation in DigixDAO in a quarter\r\n        // Which depends on lockedDGDStake, quarter point and reputation point\r\n        // This value is the summation of all participant effectiveDGDs\r\n        // It will be used to calculate the fraction of effectiveDGD a user has,\r\n        // which will determine his portion of DGX rewards for that quarter\r\n        uint256 totalEffectiveDGDPreviousQuarter;\r\n\r\n        // The minimum moderator quarter point required\r\n        // below this, reputation will be deducted for moderators\r\n        uint256 moderatorMinimalParticipationPoint;\r\n\r\n        // the scaling factor for moderator quarter point\r\n        uint256 moderatorQuarterPointScalingFactor;\r\n\r\n        // the scaling factor for moderator reputation point\r\n        uint256 moderatorReputationPointScalingFactor;\r\n\r\n        // The summation of effectiveDGDs (only specific to moderators)\r\n        uint256 totalEffectiveModeratorDGDLastQuarter;\r\n\r\n        // UTC timestamp from which the DGX rewards for the previous quarter are distributable to Holders\r\n        uint256 dgxDistributionDay;\r\n\r\n        // This is the rewards pool for the previous quarter. This is the sum of the DGX fees coming in from the collector, and the demurrage that has incurred\r\n        // when user call claimRewards() in the previous quarter.\r\n        // more graphical explanation: https://ipfs.io/ipfs/QmZDgFFMbyF3dvuuDfoXv5F6orq4kaDPo7m3QvnseUguzo\r\n        uint256 dgxRewardsPoolLastQuarter;\r\n\r\n        // The summation of all dgxRewardsPoolLastQuarter up until this quarter\r\n        uint256 sumRewardsFromBeginning;\r\n    }\r\n\r\n    // There are many function calls where all calculations/summations cannot be done in one transaction\r\n    // and require multiple transactions.\r\n    // This struct stores the intermediate results in between the calculating transactions\r\n    // These intermediate results are stored in IntermediateResultsStorage\r\n    struct IntermediateResults {\r\n        // weight of \"FOR\" votes counted up until the current calculation step\r\n        uint256 currentForCount;\r\n\r\n        // weight of \"AGAINST\" votes counted up until the current calculation step\r\n        uint256 currentAgainstCount;\r\n\r\n        // summation of effectiveDGDs up until the iteration of calculation\r\n        uint256 currentSumOfEffectiveBalance;\r\n\r\n        // Address of user until which the calculation has been done\r\n        address countedUntil;\r\n    }\r\n}\r\n\r\n// File: contracts/storage/DaoRewardsStorage.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n// this contract will receive DGXs fees from the DGX fees distributors\r\ncontract DaoRewardsStorage is ResolverClient, DaoConstants {\r\n    using DaoStructs for DaoStructs.DaoQuarterInfo;\r\n\r\n    // DaoQuarterInfo is a struct that stores the quarter specific information\r\n    // regarding totalEffectiveDGDs, DGX distribution day, etc. pls check\r\n    // docs in lib/DaoStructs\r\n    mapping(uint256 => DaoStructs.DaoQuarterInfo) public allQuartersInfo;\r\n\r\n    // Mapping that stores the DGX that can be claimed as rewards by\r\n    // an address (a participant of DigixDAO)\r\n    mapping(address => uint256) public claimableDGXs;\r\n\r\n    // This stores the total DGX value that has been claimed by participants\r\n    // this can be done by calling the DaoRewardsManager.claimRewards method\r\n    // Note that this value is the only outgoing DGX from DaoRewardsManager contract\r\n    // Note that this value also takes into account the demurrage that has been paid\r\n    // by participants for simply holding their DGXs in the DaoRewardsManager contract\r\n    uint256 public totalDGXsClaimed;\r\n\r\n    // The Quarter ID in which the user last participated in\r\n    // To participate means they had locked more than CONFIG_MINIMUM_LOCKED_DGD\r\n    // DGD tokens. In addition, they should not have withdrawn those tokens in the same\r\n    // quarter. Basically, in the main phase of the quarter, if DaoCommon.isParticipant(_user)\r\n    // was true, they were participants. And that quarter was their lastParticipatedQuarter\r\n    mapping (address => uint256) public lastParticipatedQuarter;\r\n\r\n    // This mapping is only used to update the lastParticipatedQuarter to the\r\n    // previousLastParticipatedQuarter in case users lock and withdraw DGDs\r\n    // within the same quarter's locking phase\r\n    mapping (address => uint256) public previousLastParticipatedQuarter;\r\n\r\n    // This number marks the Quarter in which the rewards were last updated for that user\r\n    // Since the rewards calculation for a specific quarter is only done once that\r\n    // quarter is completed, we need this value to note the last quarter when the rewards were updated\r\n    // We then start adding the rewards for all quarters after that quarter, until the current quarter\r\n    mapping (address => uint256) public lastQuarterThatRewardsWasUpdated;\r\n\r\n    // Similar as the lastQuarterThatRewardsWasUpdated, but this is for reputation updates\r\n    // Note that reputation can also be deducted for no participation (not locking DGDs)\r\n    // This value is used to update the reputation based on all quarters from the lastQuarterThatReputationWasUpdated\r\n    // to the current quarter\r\n    mapping (address => uint256) public lastQuarterThatReputationWasUpdated;\r\n\r\n    constructor(address _resolver)\r\n           public\r\n    {\r\n        require(init(CONTRACT_STORAGE_DAO_REWARDS, _resolver));\r\n    }\r\n\r\n    function updateQuarterInfo(\r\n        uint256 _quarterNumber,\r\n        uint256 _minimalParticipationPoint,\r\n        uint256 _quarterPointScalingFactor,\r\n        uint256 _reputationPointScalingFactor,\r\n        uint256 _totalEffectiveDGDPreviousQuarter,\r\n\r\n        uint256 _moderatorMinimalQuarterPoint,\r\n        uint256 _moderatorQuarterPointScalingFactor,\r\n        uint256 _moderatorReputationPointScalingFactor,\r\n        uint256 _totalEffectiveModeratorDGDLastQuarter,\r\n\r\n        uint256 _dgxDistributionDay,\r\n        uint256 _dgxRewardsPoolLastQuarter,\r\n        uint256 _sumRewardsFromBeginning\r\n    )\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_REWARDS_MANAGER));\r\n        allQuartersInfo[_quarterNumber].minimalParticipationPoint = _minimalParticipationPoint;\r\n        allQuartersInfo[_quarterNumber].quarterPointScalingFactor = _quarterPointScalingFactor;\r\n        allQuartersInfo[_quarterNumber].reputationPointScalingFactor = _reputationPointScalingFactor;\r\n        allQuartersInfo[_quarterNumber].totalEffectiveDGDPreviousQuarter = _totalEffectiveDGDPreviousQuarter;\r\n\r\n        allQuartersInfo[_quarterNumber].moderatorMinimalParticipationPoint = _moderatorMinimalQuarterPoint;\r\n        allQuartersInfo[_quarterNumber].moderatorQuarterPointScalingFactor = _moderatorQuarterPointScalingFactor;\r\n        allQuartersInfo[_quarterNumber].moderatorReputationPointScalingFactor = _moderatorReputationPointScalingFactor;\r\n        allQuartersInfo[_quarterNumber].totalEffectiveModeratorDGDLastQuarter = _totalEffectiveModeratorDGDLastQuarter;\r\n\r\n        allQuartersInfo[_quarterNumber].dgxDistributionDay = _dgxDistributionDay;\r\n        allQuartersInfo[_quarterNumber].dgxRewardsPoolLastQuarter = _dgxRewardsPoolLastQuarter;\r\n        allQuartersInfo[_quarterNumber].sumRewardsFromBeginning = _sumRewardsFromBeginning;\r\n    }\r\n\r\n    function updateClaimableDGX(address _user, uint256 _newClaimableDGX)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_REWARDS_MANAGER));\r\n        claimableDGXs[_user] = _newClaimableDGX;\r\n    }\r\n\r\n    function updateLastParticipatedQuarter(address _user, uint256 _lastQuarter)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\r\n        lastParticipatedQuarter[_user] = _lastQuarter;\r\n    }\r\n\r\n    function updatePreviousLastParticipatedQuarter(address _user, uint256 _lastQuarter)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\r\n        previousLastParticipatedQuarter[_user] = _lastQuarter;\r\n    }\r\n\r\n    function updateLastQuarterThatRewardsWasUpdated(address _user, uint256 _lastQuarter)\r\n        public\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_STAKE_LOCKING, EMPTY_BYTES]));\r\n        lastQuarterThatRewardsWasUpdated[_user] = _lastQuarter;\r\n    }\r\n\r\n    function updateLastQuarterThatReputationWasUpdated(address _user, uint256 _lastQuarter)\r\n        public\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_STAKE_LOCKING, EMPTY_BYTES]));\r\n        lastQuarterThatReputationWasUpdated[_user] = _lastQuarter;\r\n    }\r\n\r\n    function addToTotalDgxClaimed(uint256 _dgxClaimed)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_REWARDS_MANAGER));\r\n        totalDGXsClaimed = totalDGXsClaimed.add(_dgxClaimed);\r\n    }\r\n\r\n    function readQuarterInfo(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _minimalParticipationPoint,\r\n            uint256 _quarterPointScalingFactor,\r\n            uint256 _reputationPointScalingFactor,\r\n            uint256 _totalEffectiveDGDPreviousQuarter,\r\n\r\n            uint256 _moderatorMinimalQuarterPoint,\r\n            uint256 _moderatorQuarterPointScalingFactor,\r\n            uint256 _moderatorReputationPointScalingFactor,\r\n            uint256 _totalEffectiveModeratorDGDLastQuarter,\r\n\r\n            uint256 _dgxDistributionDay,\r\n            uint256 _dgxRewardsPoolLastQuarter,\r\n            uint256 _sumRewardsFromBeginning\r\n        )\r\n    {\r\n        _minimalParticipationPoint = allQuartersInfo[_quarterNumber].minimalParticipationPoint;\r\n        _quarterPointScalingFactor = allQuartersInfo[_quarterNumber].quarterPointScalingFactor;\r\n        _reputationPointScalingFactor = allQuartersInfo[_quarterNumber].reputationPointScalingFactor;\r\n        _totalEffectiveDGDPreviousQuarter = allQuartersInfo[_quarterNumber].totalEffectiveDGDPreviousQuarter;\r\n        _moderatorMinimalQuarterPoint = allQuartersInfo[_quarterNumber].moderatorMinimalParticipationPoint;\r\n        _moderatorQuarterPointScalingFactor = allQuartersInfo[_quarterNumber].moderatorQuarterPointScalingFactor;\r\n        _moderatorReputationPointScalingFactor = allQuartersInfo[_quarterNumber].moderatorReputationPointScalingFactor;\r\n        _totalEffectiveModeratorDGDLastQuarter = allQuartersInfo[_quarterNumber].totalEffectiveModeratorDGDLastQuarter;\r\n        _dgxDistributionDay = allQuartersInfo[_quarterNumber].dgxDistributionDay;\r\n        _dgxRewardsPoolLastQuarter = allQuartersInfo[_quarterNumber].dgxRewardsPoolLastQuarter;\r\n        _sumRewardsFromBeginning = allQuartersInfo[_quarterNumber].sumRewardsFromBeginning;\r\n    }\r\n\r\n    function readQuarterGeneralInfo(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _dgxDistributionDay,\r\n            uint256 _dgxRewardsPoolLastQuarter,\r\n            uint256 _sumRewardsFromBeginning\r\n        )\r\n    {\r\n        _dgxDistributionDay = allQuartersInfo[_quarterNumber].dgxDistributionDay;\r\n        _dgxRewardsPoolLastQuarter = allQuartersInfo[_quarterNumber].dgxRewardsPoolLastQuarter;\r\n        _sumRewardsFromBeginning = allQuartersInfo[_quarterNumber].sumRewardsFromBeginning;\r\n    }\r\n\r\n    function readQuarterModeratorInfo(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _moderatorMinimalQuarterPoint,\r\n            uint256 _moderatorQuarterPointScalingFactor,\r\n            uint256 _moderatorReputationPointScalingFactor,\r\n            uint256 _totalEffectiveModeratorDGDLastQuarter\r\n        )\r\n    {\r\n        _moderatorMinimalQuarterPoint = allQuartersInfo[_quarterNumber].moderatorMinimalParticipationPoint;\r\n        _moderatorQuarterPointScalingFactor = allQuartersInfo[_quarterNumber].moderatorQuarterPointScalingFactor;\r\n        _moderatorReputationPointScalingFactor = allQuartersInfo[_quarterNumber].moderatorReputationPointScalingFactor;\r\n        _totalEffectiveModeratorDGDLastQuarter = allQuartersInfo[_quarterNumber].totalEffectiveModeratorDGDLastQuarter;\r\n    }\r\n\r\n    function readQuarterParticipantInfo(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _minimalParticipationPoint,\r\n            uint256 _quarterPointScalingFactor,\r\n            uint256 _reputationPointScalingFactor,\r\n            uint256 _totalEffectiveDGDPreviousQuarter\r\n        )\r\n    {\r\n        _minimalParticipationPoint = allQuartersInfo[_quarterNumber].minimalParticipationPoint;\r\n        _quarterPointScalingFactor = allQuartersInfo[_quarterNumber].quarterPointScalingFactor;\r\n        _reputationPointScalingFactor = allQuartersInfo[_quarterNumber].reputationPointScalingFactor;\r\n        _totalEffectiveDGDPreviousQuarter = allQuartersInfo[_quarterNumber].totalEffectiveDGDPreviousQuarter;\r\n    }\r\n\r\n    function readDgxDistributionDay(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _distributionDay)\r\n    {\r\n        _distributionDay = allQuartersInfo[_quarterNumber].dgxDistributionDay;\r\n    }\r\n\r\n    function readTotalEffectiveDGDLastQuarter(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _totalEffectiveDGDPreviousQuarter)\r\n    {\r\n        _totalEffectiveDGDPreviousQuarter = allQuartersInfo[_quarterNumber].totalEffectiveDGDPreviousQuarter;\r\n    }\r\n\r\n    function readTotalEffectiveModeratorDGDLastQuarter(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _totalEffectiveModeratorDGDLastQuarter)\r\n    {\r\n        _totalEffectiveModeratorDGDLastQuarter = allQuartersInfo[_quarterNumber].totalEffectiveModeratorDGDLastQuarter;\r\n    }\r\n\r\n    function readRewardsPoolOfLastQuarter(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _rewardsPool)\r\n    {\r\n        _rewardsPool = allQuartersInfo[_quarterNumber].dgxRewardsPoolLastQuarter;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"readTotalEffectiveModeratorDGDLastQuarter\",\"outputs\":[{\"name\":\"_totalEffectiveModeratorDGDLastQuarter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_lastQuarter\",\"type\":\"uint256\"}],\"name\":\"updateLastQuarterThatReputationWasUpdated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastQuarterThatRewardsWasUpdated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"key\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"get_contract\",\"outputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"},{\"name\":\"_minimalParticipationPoint\",\"type\":\"uint256\"},{\"name\":\"_quarterPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"_reputationPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"_totalEffectiveDGDPreviousQuarter\",\"type\":\"uint256\"},{\"name\":\"_moderatorMinimalQuarterPoint\",\"type\":\"uint256\"},{\"name\":\"_moderatorQuarterPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"_moderatorReputationPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"_totalEffectiveModeratorDGDLastQuarter\",\"type\":\"uint256\"},{\"name\":\"_dgxDistributionDay\",\"type\":\"uint256\"},{\"name\":\"_dgxRewardsPoolLastQuarter\",\"type\":\"uint256\"},{\"name\":\"_sumRewardsFromBeginning\",\"type\":\"uint256\"}],\"name\":\"updateQuarterInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"readQuarterInfo\",\"outputs\":[{\"name\":\"_minimalParticipationPoint\",\"type\":\"uint256\"},{\"name\":\"_quarterPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"_reputationPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"_totalEffectiveDGDPreviousQuarter\",\"type\":\"uint256\"},{\"name\":\"_moderatorMinimalQuarterPoint\",\"type\":\"uint256\"},{\"name\":\"_moderatorQuarterPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"_moderatorReputationPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"_totalEffectiveModeratorDGDLastQuarter\",\"type\":\"uint256\"},{\"name\":\"_dgxDistributionDay\",\"type\":\"uint256\"},{\"name\":\"_dgxRewardsPoolLastQuarter\",\"type\":\"uint256\"},{\"name\":\"_sumRewardsFromBeginning\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"readQuarterParticipantInfo\",\"outputs\":[{\"name\":\"_minimalParticipationPoint\",\"type\":\"uint256\"},{\"name\":\"_quarterPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"_reputationPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"_totalEffectiveDGDPreviousQuarter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_newClaimableDGX\",\"type\":\"uint256\"}],\"name\":\"updateClaimableDGX\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimableDGXs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_lastQuarter\",\"type\":\"uint256\"}],\"name\":\"updatePreviousLastParticipatedQuarter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_lastQuarter\",\"type\":\"uint256\"}],\"name\":\"updateLastParticipatedQuarter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"readQuarterModeratorInfo\",\"outputs\":[{\"name\":\"_moderatorMinimalQuarterPoint\",\"type\":\"uint256\"},{\"name\":\"_moderatorQuarterPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"_moderatorReputationPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"_totalEffectiveModeratorDGDLastQuarter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"readDgxDistributionDay\",\"outputs\":[{\"name\":\"_distributionDay\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"readRewardsPoolOfLastQuarter\",\"outputs\":[{\"name\":\"_rewardsPool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"previousLastParticipatedQuarter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastQuarterThatReputationWasUpdated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastParticipatedQuarter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"readQuarterGeneralInfo\",\"outputs\":[{\"name\":\"_dgxDistributionDay\",\"type\":\"uint256\"},{\"name\":\"_dgxRewardsPoolLastQuarter\",\"type\":\"uint256\"},{\"name\":\"_sumRewardsFromBeginning\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dgxClaimed\",\"type\":\"uint256\"}],\"name\":\"addToTotalDgxClaimed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_lastQuarter\",\"type\":\"uint256\"}],\"name\":\"updateLastQuarterThatRewardsWasUpdated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDGXsClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allQuartersInfo\",\"outputs\":[{\"name\":\"minimalParticipationPoint\",\"type\":\"uint256\"},{\"name\":\"quarterPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"reputationPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"totalEffectiveDGDPreviousQuarter\",\"type\":\"uint256\"},{\"name\":\"moderatorMinimalParticipationPoint\",\"type\":\"uint256\"},{\"name\":\"moderatorQuarterPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"moderatorReputationPointScalingFactor\",\"type\":\"uint256\"},{\"name\":\"totalEffectiveModeratorDGDLastQuarter\",\"type\":\"uint256\"},{\"name\":\"dgxDistributionDay\",\"type\":\"uint256\"},{\"name\":\"dgxRewardsPoolLastQuarter\",\"type\":\"uint256\"},{\"name\":\"sumRewardsFromBeginning\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"name\":\"readTotalEffectiveDGDLastQuarter\",\"outputs\":[{\"name\":\"_totalEffectiveDGDPreviousQuarter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DaoRewardsStorage","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000005f60ef7e1443f82ca7de947711f0966ca6e3b5","Library":"","LicenseType":"BSD-3-Clause","SwarmSource":"bzzr://99a60a4e005a8e4397c43e772d5dde1f495e402a7855e3f94efce84a8a0e374a"}]}