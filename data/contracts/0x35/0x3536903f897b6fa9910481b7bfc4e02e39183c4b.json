{"status":"1","message":"OK","result":[{"SourceCode":"// poole_party\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/CoveredCall.sol\r\n\r\npragma solidity 0.5.8;\r\n\r\n\r\ncontract CoveredCall {\r\n\r\n\t// Enum of the different states the contract can be in\r\n\tenum ContractStates {\r\n\t\tNONE,\r\n\t\tSTATUS_INITIALIZED, // In the very beginning after contract creation\r\n\t\tSTATUS_OPEN, // Buyer has paid premium and has the option of redeeming\r\n\t\tSTATUS_REDEEMED, // Buyer has redeemed tokens - end of life\r\n\t\tSTATUS_CLOSED // Seller has decided to close contract - end of life\r\n\t}\r\n\r\n\t// The current state of the contract as it flows through different actions.\r\n\tContractStates public currentState;\r\n\r\n\t// Events triggered when users take action\r\n\tevent PremiumUpdated(address indexed _seller, uint256 _oldPremiumAmount, uint256 _newPremiumAmount);\r\n\tevent Initialized(address indexed _seller, uint256 _underlyingAssetAmount);\r\n\tevent Opened(address indexed _buyer, uint256 _purchaseAmount);\r\n\tevent Redeemed(address indexed _buyer, uint256 _paymentAmount);\r\n\tevent Closed(address indexed _seller);\r\n\r\n\taddress public buyer; // The address that created the contract\r\n\taddress public seller; // The address that purchased the option\r\n\r\n\tIERC20 public underlyingAssetToken; // ERC20 being used as the underlying asset\r\n\tIERC20 public purchasingToken; // ERC20 being used for premium and redeem payments\r\n\r\n\tuint256 public underlyingAssetAmount; // Amount of the underlying asset being offered in the contract\r\n\r\n\tuint256 public strikePrice; // This is the strike price required to redeem. Redeem amount = strike * asset amount.\r\n\tuint256 public premiumAmount; // Amount of payment tokens required to open the contract\r\n\r\n\tuint256 public expirationDate; // Date after which the seller can close out and buyer can no longer can redeem\r\n\r\n\t/**\r\n\t * The Seller initiates the contract by setting all parameters.\r\n\t * The Seller should also have already \"allowed\" the ERC20 to be transferred in by the contract\r\n\t * in the amount specified by premiumAmount.  This will be held in escrow.\r\n\t */\r\n\tconstructor(\r\n\t\tIERC20 _underlyingAssetToken,\r\n\t\tuint256 _underlyingAssetAmount,\r\n\t\tIERC20 _purchasingToken,\r\n\t\tuint256 _strikePrice,\r\n\t\tuint256 _premiumAmount,\r\n\t\tuint _expirationDate\r\n\t) public {\r\n\t\t// Validate inputs\r\n\t\trequire(address(_underlyingAssetToken) != address(0), \"The asset token must not be 0x0\");\r\n\t\trequire(_underlyingAssetAmount > 0, \"The asset amount must be valid\");\r\n\t\trequire(address(_purchasingToken) != address(0), \"The purchasing token must not be 0x0\");\r\n\t\trequire(_strikePrice > 0, \"The strike price must be valid\");\r\n\t\trequire(_premiumAmount > 0, \"The premium amount price must be valid\");\r\n\t\trequire(_expirationDate > now, \"The expiration must be in the future\");\r\n\r\n\t\t// Save off the inputs\r\n\t\tseller = msg.sender;\r\n\t\tunderlyingAssetToken = _underlyingAssetToken;\r\n\t\tunderlyingAssetAmount = _underlyingAssetAmount;\r\n\t\tpurchasingToken = _purchasingToken;\r\n\t\tstrikePrice = _strikePrice;\r\n\t\tpremiumAmount = _premiumAmount;\r\n\t\texpirationDate = _expirationDate;\r\n\r\n\t\t// Make the contract be in a dead state\r\n\t\tcurrentState = ContractStates.NONE;\r\n\t}\r\n\r\n\tfunction initialize() public {\r\n\t\trequire(\r\n\t\t\tcurrentState == ContractStates.NONE,\r\n\t\t\t\"Contract must be in NONE state to allow initialization\"\r\n\t\t);\r\n\r\n\t\trequire(msg.sender == seller, \"Only the original seller can initialize the contract\");\r\n\r\n\t\t// Transfer in the underlying asset to escrow\r\n\t\trequire(underlyingAssetToken.transferFrom(seller, address(this), underlyingAssetAmount), \"Must provide initial escrow token\");\r\n\r\n\t\t// Update the state to initialized\r\n\t\tcurrentState = ContractStates.STATUS_INITIALIZED;\r\n\r\n\t\t// Emit the event\r\n\t\temit Initialized(seller, underlyingAssetAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * When the contract is in an initialized state, the seller can updated the premium amount to reflect real world price changes.\r\n\t */\r\n\tfunction updatePremium(uint256 _premiumAmount) public {\r\n\t\t// Validate contract state\r\n\t\trequire(\r\n\t\t\tcurrentState == ContractStates.STATUS_INITIALIZED,\r\n\t\t\t\"Contract must be in initialized state to allow updates of the premium\"\r\n\t\t);\r\n\t\trequire(msg.sender == seller, \"Only the original seller can update the premium\");\r\n\r\n\t\t// Save off the old value\r\n\t\tuint256 oldPremiumAmount = premiumAmount;\r\n\r\n\t\t// Update to the new value\r\n\t\tpremiumAmount = _premiumAmount;\r\n\r\n\t\t// Emit the event\r\n\t\temit PremiumUpdated(seller, oldPremiumAmount, premiumAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * The buyer can call this to open the contract.\r\n\t * THe buyer must have already \"allowed\" the contract to transfer premiumAmount purchasingTokens\r\n\t */\r\n\tfunction open() public {\r\n\t\t// Validate contract state\r\n\t\trequire(now < expirationDate, \"Cannot open an expired contract\");\r\n\t\trequire(currentState == ContractStates.STATUS_INITIALIZED, \"Contract must be in initialized state to open\");\r\n\r\n\t\t// Save off the buyer\r\n\t\tbuyer = msg.sender;\r\n\r\n\t\t// Transfer the tokens over to the seller\r\n\t\trequire(purchasingToken.transferFrom(buyer, seller, premiumAmount), \"Must pay premium to open contract\");\r\n\r\n\t\t// Set the status to open\r\n\t\tcurrentState = ContractStates.STATUS_OPEN;\r\n\r\n\t\t// Emit the event\r\n\t\temit Opened(buyer, premiumAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * If the contract was never opened by a buyer or the contract was never redeemed and it expired,\r\n\t * the seller can close it out and get back the initial underlying asset token.\r\n\t */\r\n\tfunction close() public {\r\n\t\t// Validate contract state\r\n\t\trequire(\r\n\t\t\tcurrentState == ContractStates.STATUS_INITIALIZED ||\r\n\t\t\t\t(currentState == ContractStates.STATUS_OPEN && now > expirationDate),\r\n\t\t\t\"Contract must be in initialized state or expired in order to close it\"\r\n\t\t);\r\n\t\trequire(msg.sender == seller, \"Only the original seller can close a contract\");\r\n\r\n\t\t// Transfer out the tokens from escrow\r\n\t\tunderlyingAssetToken.transfer(seller, underlyingAssetAmount);\r\n\r\n\t\t// Set the status to closed\r\n\t\tcurrentState = ContractStates.STATUS_CLOSED;\r\n\r\n\t\t// Emit the event\r\n\t\temit Closed(seller);\r\n\t}\r\n\r\n\t/**\r\n\t * After a buyer has opened the contract they can redeem their right to the underlying asset.\r\n\t * They can only do this if the contract is in the open state and it has not expired.\r\n\t * They must pay the purchase price times the asset amount and they will get the underlying asset in return.\r\n\t * The buyer must have already \"allowed\" the contract to transfer the payment amount of purchasingTokens\r\n\t */\r\n\tfunction redeem() public {\r\n\t\t// Validate contract state\r\n\t\trequire(\r\n\t\t\tcurrentState == ContractStates.STATUS_OPEN && now < expirationDate,\r\n\t\t\t\"Contract must be in open state and not expired to redeem it\"\r\n\t\t);\r\n\t\trequire(msg.sender == buyer, \"Only the original buyer can redeem a contract\");\r\n\r\n\t\t// Calculate the amount of tokens that should be paid\r\n\t\tuint256 paymentAmount = underlyingAssetAmount * strikePrice;\r\n\r\n\t\t// Move the payment from the buyer to the seller\r\n\t\trequire(purchasingToken.transferFrom(buyer, seller, paymentAmount), \"Must pay amount * strike to redeem contract\");\r\n\r\n\t\t// Pay out the buyer from escrow\r\n\t\tunderlyingAssetToken.transfer(buyer, underlyingAssetAmount);\r\n\r\n\t\t// Set the status to closed\r\n\t\tcurrentState = ContractStates.STATUS_REDEEMED;\r\n\r\n\t\t// Emit the event\r\n\t\temit Redeemed(buyer, paymentAmount);\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"seller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"premiumAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expirationDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlyingAssetToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"purchasingToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_premiumAmount\",\"type\":\"uint256\"}],\"name\":\"updatePremium\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strikePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlyingAssetAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_underlyingAssetToken\",\"type\":\"address\"},{\"name\":\"_underlyingAssetAmount\",\"type\":\"uint256\"},{\"name\":\"_purchasingToken\",\"type\":\"address\"},{\"name\":\"_strikePrice\",\"type\":\"uint256\"},{\"name\":\"_premiumAmount\",\"type\":\"uint256\"},{\"name\":\"_expirationDate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldPremiumAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newPremiumAmount\",\"type\":\"uint256\"}],\"name\":\"PremiumUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_underlyingAssetAmount\",\"type\":\"uint256\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_purchaseAmount\",\"type\":\"uint256\"}],\"name\":\"Opened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_paymentAmount\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"Closed\",\"type\":\"event\"}]","ContractName":"CoveredCall","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000000000000002ee0000000000000000000000000000000000000000000000001a055690d9db80000000000000000000000000000000000000000000000000000000000005d686700","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://b7a88483c53533da80e54b38a61e4a93c1bde52480693bcc77f8aa672e264875"}]}