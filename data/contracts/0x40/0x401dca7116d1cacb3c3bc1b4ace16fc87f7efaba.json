{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Require.sol\r\n\r\n/**\r\n * @title Require\r\n * @author dYdX\r\n *\r\n * Stringifies parameters to pretty-print revert messages. Costs more gas than regular require()\r\n */\r\nlibrary Require {\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant ASCII_ZERO = 48; // '0'\r\n    uint256 constant ASCII_RELATIVE_ZERO = 87; // 'a' - 10\r\n    uint256 constant ASCII_LOWER_EX = 120; // 'x'\r\n    bytes2 constant COLON = 0x3a20; // ': '\r\n    bytes2 constant COMMA = 0x2c20; // ', '\r\n    bytes2 constant LPAREN = 0x203c; // ' <'\r\n    byte constant RPAREN = 0x3e; // '>'\r\n    uint256 constant FOUR_BIT_MASK = 0xf;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        bytes32 payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        bytes32 payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    function stringifyTruncated(\r\n        bytes32 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        // put the input bytes into the result\r\n        bytes memory result = abi.encodePacked(input);\r\n\r\n        // determine the length of the input by finding the location of the last non-zero byte\r\n        for (uint256 i = 32; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // find the last non-zero byte in order to determine the length\r\n            if (result[i] != 0) {\r\n                uint256 length = i + 1;\r\n\r\n                /* solium-disable-next-line security/no-inline-assembly */\r\n                assembly {\r\n                    mstore(result, length) // r.length = length;\r\n                }\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        // all bytes are zero\r\n        return new bytes(0);\r\n    }\r\n\r\n    function stringify(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (input == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        // get the final string length\r\n        uint256 j = input;\r\n        uint256 length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n\r\n        // allocate the string\r\n        bytes memory bstr = new bytes(length);\r\n\r\n        // populate the string starting with the least-significant character\r\n        j = input;\r\n        for (uint256 i = length; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // take last decimal digit\r\n            bstr[i] = byte(uint8(ASCII_ZERO + (j % 10)));\r\n\r\n            // remove the last decimal digit\r\n            j /= 10;\r\n        }\r\n\r\n        return bstr;\r\n    }\r\n\r\n    function stringify(\r\n        address input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // addresses are \"0x\" followed by 20 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(42);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[41 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[40 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function stringify(\r\n        bytes32 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // bytes32 are \"0x\" followed by 32 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(66);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[65 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[64 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function char(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (byte)\r\n    {\r\n        // return ASCII digit (0-9)\r\n        if (input < 10) {\r\n            return byte(uint8(input + ASCII_ZERO));\r\n        }\r\n\r\n        // return ASCII letter (a-f)\r\n        return byte(uint8(input + ASCII_RELATIVE_ZERO));\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Math.sol\r\n\r\n/**\r\n * @title Math\r\n * @author dYdX\r\n *\r\n * Library for non-standard Math functions\r\n */\r\nlibrary Math {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"Math\";\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /*\r\n     * Return target * (numerator / denominator).\r\n     */\r\n    function getPartial(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    /*\r\n     * Return target * (numerator / denominator), but rounded up.\r\n     */\r\n    function getPartialRoundUp(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (target == 0 || numerator == 0) {\r\n            // SafeMath will check for zero denominator\r\n            return SafeMath.div(0, denominator);\r\n        }\r\n        return target.mul(numerator).sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    function to128(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint128)\r\n    {\r\n        uint128 result = uint128(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint128\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to96(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint96)\r\n    {\r\n        uint96 result = uint96(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint96\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to32(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        uint32 result = uint32(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint32\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Types.sol\r\n\r\n/**\r\n * @title Types\r\n * @author dYdX\r\n *\r\n * Library for interacting with the basic structs used in Solo\r\n */\r\nlibrary Types {\r\n    using Math for uint256;\r\n\r\n    // ============ AssetAmount ============\r\n\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par  // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Par (Principal Amount) ============\r\n\r\n    /* ... */\r\n\r\n    // Individual principal amount for an account\r\n    struct Par {\r\n        bool sign; // true if positive\r\n        uint128 value;\r\n    }\r\n\r\n    /* ... */\r\n\r\n    // ============ Wei (Token Amount) ============\r\n\r\n    // Individual token amount for an account\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n\r\n    /* ... */\r\n}\r\n\r\n// File: contracts/protocol/lib/Account.sol\r\n\r\n/**\r\n * @title Account\r\n * @author dYdX\r\n *\r\n * Library of structs and functions that represent an account\r\n */\r\nlibrary Account {\r\n    // ============ Enums ============\r\n\r\n    /*\r\n     * Most-recently-cached account status.\r\n     *\r\n     * Normal: Can only be liquidated if the account values are violating the global margin-ratio.\r\n     * Liquid: Can be liquidated no matter the account values.\r\n     *         Can be vaporized if there are no more positive account values.\r\n     * Vapor:  Has only negative (or zeroed) account values. Can be vaporized.\r\n     *\r\n     */\r\n    enum Status {\r\n        Normal,\r\n        Liquid,\r\n        Vapor\r\n    }\r\n\r\n    // ============ Structs ============\r\n\r\n    // Represents the unique key that specifies an account\r\n    struct Info {\r\n        address owner;  // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n\r\n    /* ... */\r\n}\r\n\r\n// File: contracts/protocol/lib/Actions.sol\r\n\r\n/**\r\n * @title Actions\r\n * @author dYdX\r\n *\r\n * Library that defines and parses valid Actions\r\n */\r\nlibrary Actions {\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"Actions\";\r\n\r\n    // ============ Enums ============\r\n\r\n    enum ActionType {\r\n        Deposit,   // supply tokens\r\n        Withdraw,  // borrow tokens\r\n        Transfer,  // transfer balance between accounts\r\n        Buy,       // buy an amount of some token (externally)\r\n        Sell,      // sell an amount of some token (externally)\r\n        Trade,     // trade tokens against another account\r\n        Liquidate, // liquidate an undercollateralized or expiring account\r\n        Vaporize,  // use excess tokens to zero-out a completely negative account\r\n        Call       // send arbitrary data to an address\r\n    }\r\n\r\n    enum AccountLayout {\r\n        OnePrimary,\r\n        TwoPrimary,\r\n        PrimaryAndSecondary\r\n    }\r\n\r\n    enum MarketLayout {\r\n        ZeroMarkets,\r\n        OneMarket,\r\n        TwoMarkets\r\n    }\r\n\r\n    // ============ Structs ============\r\n\r\n    /*\r\n     * Arguments that are passed to Solo in an ordered list as part of a single operation.\r\n     * Each ActionArgs has an actionType which specifies which action struct that this data will be\r\n     * parsed into before being processed.\r\n     */\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        Types.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n\r\n    // ============ Helper Functions ============\r\n\r\n    function getMarketLayout(\r\n        ActionType actionType\r\n    )\r\n        internal\r\n        pure\r\n        returns (MarketLayout)\r\n    {\r\n        if (\r\n            actionType == Actions.ActionType.Deposit\r\n            || actionType == Actions.ActionType.Withdraw\r\n            || actionType == Actions.ActionType.Transfer\r\n        ) {\r\n            return MarketLayout.OneMarket;\r\n        }\r\n        else if (actionType == Actions.ActionType.Call) {\r\n            return MarketLayout.ZeroMarkets;\r\n        }\r\n        return MarketLayout.TwoMarkets;\r\n    }\r\n\r\n    function getAccountLayout(\r\n        ActionType actionType\r\n    )\r\n        internal\r\n        pure\r\n        returns (AccountLayout)\r\n    {\r\n        if (\r\n            actionType == Actions.ActionType.Transfer\r\n            || actionType == Actions.ActionType.Trade\r\n        ) {\r\n            return AccountLayout.TwoPrimary;\r\n        } else if (\r\n            actionType == Actions.ActionType.Liquidate\r\n            || actionType == Actions.ActionType.Vaporize\r\n        ) {\r\n            return AccountLayout.PrimaryAndSecondary;\r\n        }\r\n        return AccountLayout.OnePrimary;\r\n    }\r\n\r\n    /* ... */\r\n}\r\n\r\n// File: contracts/protocol/SoloMargin.sol\r\n\r\n\r\n/**\r\n * @title SoloMargin\r\n * @author dYdX\r\n *\r\n * Main contract that inherits from other contracts\r\n */\r\ncontract SoloMargin {\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * The main entry-point to Solo that allows users and contracts to manage accounts.\r\n     * Take one or more actions on one or more accounts. The msg.sender must be the owner or\r\n     * operator of all accounts except for those being liquidated, vaporized, or traded with.\r\n     * One call to operate() is considered a singular \"operation\". Account collateralization is\r\n     * ensured only after the completion of the entire operation.\r\n     *\r\n     * @param  accounts  A list of all accounts that will be used in this operation. Cannot contain\r\n     *                   duplicates. In each action, the relevant account will be referred-to by its\r\n     *                   index in the list.\r\n     * @param  actions   An ordered list of all actions that will be taken in this operation. The\r\n     *                   actions will be processed in order.\r\n     */\r\n    function operate(\r\n        Account.Info[] memory accounts,\r\n        Actions.ActionArgs[] memory actions\r\n    )\r\n        public;\r\n\r\n    // ============ Getters for Permissions ============\r\n\r\n    /**\r\n     * Return true if a particular address is approved as an operator for an owner's accounts.\r\n     * Approved operators can act on the accounts of the owner as if it were the operator's own.\r\n     *\r\n     * @param  owner     The owner of the accounts\r\n     * @param  operator  The possible operator\r\n     * @return           True if operator is approved for owner's accounts\r\n     */\r\n    function getIsLocalOperator(\r\n        address owner,\r\n        address operator\r\n    )\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n    /* ... */\r\n}\r\n\r\n// File: contracts/external/helpers/OnlySolo.sol\r\n\r\n/**\r\n * @title OnlySolo\r\n * @author dYdX\r\n *\r\n * Inheritable contract that restricts the calling of certain functions to Solo only\r\n */\r\ncontract OnlySolo {\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"OnlySolo\";\r\n\r\n    // ============ Storage ============\r\n\r\n    SoloMargin public SOLO_MARGIN;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor (\r\n        address soloMargin\r\n    )\r\n        public\r\n    {\r\n        SOLO_MARGIN = SoloMargin(soloMargin);\r\n    }\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier onlySolo(address from) {\r\n        Require.that(\r\n            from == address(SOLO_MARGIN),\r\n            FILE,\r\n            \"Only Solo can call function\",\r\n            from\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/external/lib/TypedSignature.sol\r\n\r\n/**\r\n * @title TypedSignature\r\n * @author dYdX\r\n *\r\n * Library to unparse typed signatures\r\n */\r\nlibrary TypedSignature {\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant private FILE = \"TypedSignature\";\r\n\r\n    // prepended message with the length of the signed hash in decimal\r\n    bytes constant private PREPEND_DEC = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n    // prepended message with the length of the signed hash in hexadecimal\r\n    bytes constant private PREPEND_HEX = \"\\x19Ethereum Signed Message:\\n\\x20\";\r\n\r\n    // Number of bytes in a typed signature\r\n    uint256 constant private NUM_SIGNATURE_BYTES = 66;\r\n\r\n    // ============ Enums ============\r\n\r\n    enum SignatureType {\r\n        NoPrepend,\r\n        Decimal,\r\n        Hexadecimal,\r\n        Invalid\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    /**\r\n     * Gives the address of the signer of a hash. Also allows for the commonly prepended string of\r\n     * '\\x19Ethereum Signed Message:\\n' + message.length\r\n     *\r\n     * @param  hash               Hash that was signed (does not include prepended message)\r\n     * @param  signatureWithType  Type and ECDSA signature with structure: {32:r}{32:s}{1:v}{1:type}\r\n     * @return                    address of the signer of the hash\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes memory signatureWithType\r\n    )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        Require.that(\r\n            signatureWithType.length == NUM_SIGNATURE_BYTES,\r\n            FILE,\r\n            \"Invalid signature length\"\r\n        );\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        uint8 rawSigType;\r\n\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            r := mload(add(signatureWithType, 0x20))\r\n            s := mload(add(signatureWithType, 0x40))\r\n            let lastSlot := mload(add(signatureWithType, 0x60))\r\n            v := byte(0, lastSlot)\r\n            rawSigType := byte(1, lastSlot)\r\n        }\r\n\r\n        Require.that(\r\n            rawSigType < uint8(SignatureType.Invalid),\r\n            FILE,\r\n            \"Invalid signature type\"\r\n        );\r\n\r\n        SignatureType sigType = SignatureType(rawSigType);\r\n\r\n        bytes32 signedHash;\r\n        if (sigType == SignatureType.NoPrepend) {\r\n            signedHash = hash;\r\n        } else if (sigType == SignatureType.Decimal) {\r\n            signedHash = keccak256(abi.encodePacked(PREPEND_DEC, hash));\r\n        } else {\r\n            assert(sigType == SignatureType.Hexadecimal);\r\n            signedHash = keccak256(abi.encodePacked(PREPEND_HEX, hash));\r\n        }\r\n\r\n        return ecrecover(\r\n            signedHash,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxies/SignedOperationProxy.sol\r\n\r\n/**\r\n * @title SignedOperationProxy\r\n * @author dYdX\r\n *\r\n * Contract for sending operations on behalf of others\r\n */\r\ncontract SignedOperationProxy is\r\n    OnlySolo,\r\n    Ownable\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant private FILE = \"SignedOperationProxy\";\r\n\r\n    // EIP191 header for EIP712 prefix\r\n    bytes2 constant private EIP191_HEADER = 0x1901;\r\n\r\n    // EIP712 Domain Name value\r\n    string constant private EIP712_DOMAIN_NAME = \"SignedOperationProxy\";\r\n\r\n    // EIP712 Domain Version value\r\n    string constant private EIP712_DOMAIN_VERSION = \"1.0\";\r\n\r\n    // EIP712 encodeType of EIP712Domain\r\n    bytes constant private EIP712_DOMAIN_STRING = abi.encodePacked(\r\n        \"EIP712Domain(\",\r\n        \"string name,\",\r\n        \"string version,\",\r\n        \"uint256 chainId,\",\r\n        \"address verifyingContract\",\r\n        \")\"\r\n    );\r\n\r\n    // EIP712 encodeType of Operation\r\n    bytes constant private EIP712_OPERATION_STRING = abi.encodePacked(\r\n        \"Operation(\",\r\n        \"Action[] actions,\",\r\n        \"uint256 expiration,\",\r\n        \"uint256 salt,\",\r\n        \"address sender\",\r\n        \")\"\r\n    );\r\n\r\n    // EIP712 encodeType of Action\r\n    bytes constant private EIP712_ACTION_STRING = abi.encodePacked(\r\n        \"Action(\",\r\n        \"uint8 actionType,\",\r\n        \"address accountOwner,\",\r\n        \"uint256 accountNumber,\",\r\n        \"AssetAmount assetAmount,\",\r\n        \"uint256 primaryMarketId,\",\r\n        \"uint256 secondaryMarketId,\",\r\n        \"address otherAddress,\",\r\n        \"address otherAccountOwner,\",\r\n        \"uint256 otherAccountNumber,\",\r\n        \"bytes data\",\r\n        \")\"\r\n    );\r\n\r\n    // EIP712 encodeType of AssetAmount\r\n    bytes constant private EIP712_ASSET_AMOUNT_STRING = abi.encodePacked(\r\n        \"AssetAmount(\",\r\n        \"bool sign,\",\r\n        \"uint8 denomination,\",\r\n        \"uint8 ref,\",\r\n        \"uint256 value\",\r\n        \")\"\r\n    );\r\n\r\n    // EIP712 typeHash of EIP712Domain\r\n    /* solium-disable-next-line indentation */\r\n    bytes32 constant private EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\r\n        EIP712_DOMAIN_STRING\r\n    ));\r\n\r\n    // EIP712 typeHash of Operation\r\n    /* solium-disable-next-line indentation */\r\n    bytes32 constant private EIP712_OPERATION_HASH = keccak256(abi.encodePacked(\r\n        EIP712_OPERATION_STRING,\r\n        EIP712_ACTION_STRING,\r\n        EIP712_ASSET_AMOUNT_STRING\r\n    ));\r\n\r\n    // EIP712 typeHash of Action\r\n    /* solium-disable-next-line indentation */\r\n    bytes32 constant private EIP712_ACTION_HASH = keccak256(abi.encodePacked(\r\n        EIP712_ACTION_STRING,\r\n        EIP712_ASSET_AMOUNT_STRING\r\n    ));\r\n\r\n    // EIP712 typeHash of AssetAmount\r\n    /* solium-disable-next-line indentation */\r\n    bytes32 constant private EIP712_ASSET_AMOUNT_HASH = keccak256(abi.encodePacked(\r\n        EIP712_ASSET_AMOUNT_STRING\r\n    ));\r\n\r\n    // ============ Structs ============\r\n\r\n    struct Authorization {\r\n        uint256 numActions;\r\n        uint256 expiration;\r\n        uint256 salt;\r\n        address sender;\r\n        bytes signature;\r\n    }\r\n\r\n    struct OperationQueryInput {\r\n        bytes32 operationHash;\r\n        address operationSigner;\r\n    }\r\n\r\n    // ============ Events ============\r\n\r\n    event ContractStatusSet(\r\n        bool operational\r\n    );\r\n\r\n    event LogOperationExecuted(\r\n        bytes32 indexed operationHash,\r\n        address indexed signer,\r\n        address indexed sender\r\n    );\r\n\r\n    event LogOperationCanceled(\r\n        bytes32 indexed operationHash,\r\n        address indexed canceler\r\n    );\r\n\r\n    // ============ Immutable Storage ============\r\n\r\n    // Hash of the EIP712 Domain Separator data\r\n    bytes32 public EIP712_DOMAIN_HASH;\r\n\r\n    // ============ Mutable Storage ============\r\n\r\n     // true if this contract can process operationss\r\n    bool public g_isOperational;\r\n\r\n    // signer => final hash => was executed (or canceled)\r\n    mapping (address => mapping (bytes32 => bool)) public g_invalidated;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor (\r\n        address soloMargin,\r\n        uint256 chainId\r\n    )\r\n        public\r\n        OnlySolo(soloMargin)\r\n    {\r\n        g_isOperational = true;\r\n\r\n        /* solium-disable-next-line indentation */\r\n        EIP712_DOMAIN_HASH = keccak256(abi.encode(\r\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\r\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\r\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\r\n            chainId,\r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    // ============ Admin Functions ============\r\n\r\n     /**\r\n     * The owner can shut down the exchange.\r\n     */\r\n    function shutDown()\r\n        external\r\n        onlyOwner\r\n    {\r\n        g_isOperational = false;\r\n        emit ContractStatusSet(false);\r\n    }\r\n\r\n     /**\r\n     * The owner can start back up the exchange.\r\n     */\r\n    function startUp()\r\n        external\r\n        onlyOwner\r\n    {\r\n        g_isOperational = true;\r\n        emit ContractStatusSet(true);\r\n    }\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Allows a signer to permanently cancel an operation on-chain.\r\n     *\r\n     * @param  operationHash  The EIP712 hash of the Operation message to cancel.\r\n     */\r\n    function cancel(\r\n        bytes32 operationHash\r\n    )\r\n        external\r\n    {\r\n        g_invalidated[msg.sender][operationHash] = true;\r\n        emit LogOperationCanceled(operationHash, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Submits an operation to SoloMargin. Actions for accounts that the msg.sender does not control\r\n     * must be authorized by a signed message. Each authorization can apply to multiple actions at\r\n     * once which must occur in-order next to each other. An empty authorization must be supplied\r\n     * explicitly for each group of actions that do not require a signed message.\r\n     *\r\n     * @param  accounts  The accounts to forward to SoloMargin.operate()\r\n     * @param  actions   The actions to forward to SoloMargin.operate()\r\n     * @param  auths     The signed authorizations for each group of actions\r\n     *                   (or unsigned if msg.sender is already authorized)\r\n     */\r\n    function operate(\r\n        Account.Info[] memory accounts,\r\n        Actions.ActionArgs[] memory actions,\r\n        Authorization[] memory auths\r\n    )\r\n        public\r\n    {\r\n        Require.that(\r\n            g_isOperational,\r\n            FILE,\r\n            \"Contract is not operational\"\r\n        );\r\n\r\n        // cache the index of the first action for this auth\r\n        uint256 actionStartIdx = 0;\r\n\r\n        // loop over all auths\r\n        for (uint256 authIdx = 0; authIdx < auths.length; authIdx++) {\r\n            Authorization memory auth = auths[authIdx];\r\n\r\n            // require that the message is not expired\r\n            Require.that(\r\n                auth.expiration == 0 || auth.expiration >= block.timestamp,\r\n                FILE,\r\n                \"Signed operation is expired\",\r\n                authIdx\r\n            );\r\n\r\n            // require that the sender matches the authorization\r\n            Require.that(\r\n                auth.sender == address(0) || auth.sender == msg.sender,\r\n                FILE,\r\n                \"Operation sender mismatch\",\r\n                authIdx\r\n            );\r\n\r\n            // get the signer of the auth (msg.sender if no signature)\r\n            address signer = getSigner(\r\n                accounts,\r\n                actions,\r\n                auth,\r\n                actionStartIdx\r\n            );\r\n\r\n            // cache the index of the first action after this auth\r\n            uint256 actionEndIdx = actionStartIdx.add(auth.numActions);\r\n\r\n            // loop over all actions for which this auth applies\r\n            for (uint256 actionIdx = actionStartIdx; actionIdx < actionEndIdx; actionIdx++) {\r\n                // validate primary account\r\n                Actions.ActionArgs memory action = actions[actionIdx];\r\n                validateAccountOwner(accounts[action.accountId].owner, signer);\r\n\r\n                // validate second account in the case of a transfer\r\n                if (action.actionType == Actions.ActionType.Transfer) {\r\n                    validateAccountOwner(accounts[action.otherAccountId].owner, signer);\r\n                }\r\n            }\r\n\r\n            // update actionStartIdx\r\n            actionStartIdx = actionEndIdx;\r\n        }\r\n\r\n        // require that all actions are signed or from msg.sender\r\n        Require.that(\r\n            actionStartIdx == actions.length,\r\n            FILE,\r\n            \"Not all actions are signed\"\r\n        );\r\n\r\n        // send the operation\r\n        SOLO_MARGIN.operate(accounts, actions);\r\n    }\r\n\r\n    // ============ Getters ============\r\n\r\n    /**\r\n     * Returns a bool for each operation. True if the operation is invalid (from being canceled or\r\n     * previously executed).\r\n     */\r\n    function getOperationsAreInvalid(\r\n        OperationQueryInput[] memory operations\r\n    )\r\n        public\r\n        view\r\n        returns(bool[] memory)\r\n    {\r\n        uint256 numOperations = operations.length;\r\n        bool[] memory output = new bool[](numOperations);\r\n\r\n        for (uint256 i = 0; i < numOperations; i++) {\r\n            OperationQueryInput memory operation = operations[i];\r\n            output[i] = g_invalidated[operation.operationSigner][operation.operationHash];\r\n        }\r\n        return output;\r\n    }\r\n\r\n    // ============ Private Helper Functions ============\r\n\r\n    /**\r\n     * If the signature is empty, returns msg.sender.\r\n     * If the signature exists, checks that the operation is still valid, invalidates it, and then\r\n     * returns the signer of the authorization.\r\n     */\r\n    function getSigner(\r\n        Account.Info[] memory accounts,\r\n        Actions.ActionArgs[] memory actions,\r\n        Authorization memory auth,\r\n        uint256 startIdx\r\n    )\r\n        private\r\n        returns (address)\r\n    {\r\n        // consider msg.sender to be the signer in the case of empty signature\r\n        if (auth.signature.length == 0) {\r\n            return msg.sender;\r\n        }\r\n\r\n        // get the hash of the operation\r\n        bytes32 operationHash = getOperationHash(\r\n            accounts,\r\n            actions,\r\n            auth,\r\n            startIdx\r\n        );\r\n\r\n        // get the signer\r\n        address signer = TypedSignature.recover(operationHash, auth.signature);\r\n\r\n        // require that this message is still valid\r\n        Require.that(\r\n            !g_invalidated[signer][operationHash],\r\n            FILE,\r\n            \"Hash already used or canceled\",\r\n            operationHash\r\n        );\r\n\r\n        // consider this operationHash to be used (and therefore no longer valid)\r\n        g_invalidated[signer][operationHash] = true;\r\n        emit LogOperationExecuted(operationHash, signer, msg.sender);\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * Validates that either the signer or the msg.sender are the accountOwner (or that either are\r\n     * localOperators of the accountOwner).\r\n     */\r\n    function validateAccountOwner(\r\n        address accountOwner,\r\n        address signer\r\n    )\r\n        private\r\n        view\r\n    {\r\n        bool valid =\r\n            msg.sender == accountOwner\r\n            || signer == accountOwner\r\n            || SOLO_MARGIN.getIsLocalOperator(accountOwner, msg.sender)\r\n            || SOLO_MARGIN.getIsLocalOperator(accountOwner, signer);\r\n\r\n        Require.that(\r\n            valid,\r\n            FILE,\r\n            \"Invalid signer\",\r\n            signer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the EIP712 hash of an Operation message.\r\n     */\r\n    function getOperationHash(\r\n        Account.Info[] memory accounts,\r\n        Actions.ActionArgs[] memory actions,\r\n        Authorization memory auth,\r\n        uint256 startIdx\r\n    )\r\n        private\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        // get the bytes32 hash of each action, then packed together\r\n        bytes32 actionsEncoding = getActionsEncoding(\r\n            accounts,\r\n            actions,\r\n            auth,\r\n            startIdx\r\n        );\r\n\r\n        // compute the EIP712 hashStruct of an Operation struct\r\n        /* solium-disable-next-line indentation */\r\n        bytes32 structHash = keccak256(abi.encode(\r\n            EIP712_OPERATION_HASH,\r\n            actionsEncoding,\r\n            auth.expiration,\r\n            auth.salt,\r\n            auth.sender\r\n        ));\r\n\r\n        // compute eip712 compliant hash\r\n        /* solium-disable-next-line indentation */\r\n        return keccak256(abi.encodePacked(\r\n            EIP191_HEADER,\r\n            EIP712_DOMAIN_HASH,\r\n            structHash\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * Returns the EIP712 encodeData of an Action struct array.\r\n     */\r\n    function getActionsEncoding(\r\n        Account.Info[] memory accounts,\r\n        Actions.ActionArgs[] memory actions,\r\n        Authorization memory auth,\r\n        uint256 startIdx\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        // store hash of each action\r\n        bytes32[] memory actionsBytes = new bytes32[](auth.numActions);\r\n\r\n        // for each action that corresponds to the auth\r\n        for (uint256 i = 0; i < auth.numActions; i++) {\r\n            Actions.ActionArgs memory action = actions[startIdx + i];\r\n\r\n            // if action type has no second account, assume null account\r\n            Account.Info memory otherAccount =\r\n                (Actions.getAccountLayout(action.actionType) == Actions.AccountLayout.OnePrimary)\r\n                ? Account.Info({ owner: address(0), number: 0 })\r\n                : accounts[action.otherAccountId];\r\n\r\n            // compute the individual hash for the action\r\n            /* solium-disable-next-line indentation */\r\n            actionsBytes[i] = getActionHash(\r\n                action,\r\n                accounts[action.accountId],\r\n                otherAccount\r\n            );\r\n        }\r\n\r\n        return keccak256(abi.encodePacked(actionsBytes));\r\n    }\r\n\r\n    /**\r\n     * Returns the EIP712 hashStruct of an Action struct.\r\n     */\r\n    function getActionHash(\r\n        Actions.ActionArgs memory action,\r\n        Account.Info memory primaryAccount,\r\n        Account.Info memory secondaryAccount\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* solium-disable-next-line indentation */\r\n        return keccak256(abi.encode(\r\n            EIP712_ACTION_HASH,\r\n            action.actionType,\r\n            primaryAccount.owner,\r\n            primaryAccount.number,\r\n            getAssetAmountHash(action.amount),\r\n            action.primaryMarketId,\r\n            action.secondaryMarketId,\r\n            action.otherAddress,\r\n            secondaryAccount.owner,\r\n            secondaryAccount.number,\r\n            keccak256(action.data)\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * Returns the EIP712 hashStruct of an AssetAmount struct.\r\n     */\r\n    function getAssetAmountHash(\r\n        Types.AssetAmount memory amount\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* solium-disable-next-line indentation */\r\n        return keccak256(abi.encode(\r\n            EIP712_ASSET_AMOUNT_HASH,\r\n            amount.sign,\r\n            amount.denomination,\r\n            amount.ref,\r\n            amount.value\r\n        ));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"shutDown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SOLO_MARGIN\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"accounts\",\"type\":\"tuple[]\"},{\"components\":[{\"name\":\"actionType\",\"type\":\"uint8\"},{\"name\":\"accountId\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"sign\",\"type\":\"bool\"},{\"name\":\"denomination\",\"type\":\"uint8\"},{\"name\":\"ref\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"amount\",\"type\":\"tuple\"},{\"name\":\"primaryMarketId\",\"type\":\"uint256\"},{\"name\":\"secondaryMarketId\",\"type\":\"uint256\"},{\"name\":\"otherAddress\",\"type\":\"address\"},{\"name\":\"otherAccountId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"actions\",\"type\":\"tuple[]\"},{\"components\":[{\"name\":\"numActions\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"auths\",\"type\":\"tuple[]\"}],\"name\":\"operate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startUp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"operationHash\",\"type\":\"bytes32\"},{\"name\":\"operationSigner\",\"type\":\"address\"}],\"name\":\"operations\",\"type\":\"tuple[]\"}],\"name\":\"getOperationsAreInvalid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operationHash\",\"type\":\"bytes32\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"g_invalidated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_DOMAIN_HASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"g_isOperational\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"soloMargin\",\"type\":\"address\"},{\"name\":\"chainId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operational\",\"type\":\"bool\"}],\"name\":\"ContractStatusSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operationHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"LogOperationExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operationHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"canceler\",\"type\":\"address\"}],\"name\":\"LogOperationCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SignedOperationProxy","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"0000000000000000000000001e0447b19bb6ecfdae1e4ae1694b0c3659614e4e0000000000000000000000000000000000000000000000000000000000000001","Library":"","LicenseType":"Apache-2.0","SwarmSource":"bzzr://e9325b7aa27942ea0816a3b37476897a5712b74a8d8e205be7b2d900104fa6ac"}]}