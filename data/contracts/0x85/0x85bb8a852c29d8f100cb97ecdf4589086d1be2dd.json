{"status":"1","message":"OK","result":[{"SourceCode":"{\"ABIResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\n\\ncontract ABIResolver is ResolverBase {\\n    bytes4 constant private ABI_INTERFACE_ID = 0x2203ab56;\\n\\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\\n\\n    mapping(bytes32=\\u003emapping(uint256=\\u003ebytes)) abis;\\n\\n    /**\\n     * Sets the ABI associated with an ENS node.\\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\\n     * the empty string.\\n     * @param node The node to update.\\n     * @param contentType The content type of the ABI\\n     * @param data The ABI data.\\n     */\\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external authorised(node) {\\n        // Content types must be powers of 2\\n        require(((contentType - 1) \\u0026 contentType) == 0);\\n\\n        abis[node][contentType] = data;\\n        emit ABIChanged(node, contentType);\\n    }\\n\\n    /**\\n     * Returns the ABI associated with an ENS node.\\n     * Defined in EIP205.\\n     * @param node The ENS node to query\\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\n     * @return contentType The content type of the return value\\n     * @return data The ABI data\\n     */\\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory) {\\n        mapping(uint256=\\u003ebytes) storage abiset = abis[node];\\n\\n        for (uint256 contentType = 1; contentType \\u003c= contentTypes; contentType \\u003c\\u003c= 1) {\\n            if ((contentType \\u0026 contentTypes) != 0 \\u0026\\u0026 abiset[contentType].length \\u003e 0) {\\n                return (contentType, abiset[contentType]);\\n            }\\n        }\\n\\n        return (0, bytes(\\\"\\\"));\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == ABI_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Collection of functions related to the address type,\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * \\u003e It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n}\\n\"},\"AddrResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\n\\ncontract AddrResolver is ResolverBase {\\n    bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de;\\n\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    mapping(bytes32=\\u003eaddress) addresses;\\n\\n    /**\\n     * Sets the address associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param addr The address to set.\\n     */\\n    function setAddr(bytes32 node, address addr) external authorised(node) {\\n        addresses[node] = addr;\\n        emit AddrChanged(node, addr);\\n    }\\n\\n    /**\\n     * Returns the address associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node) public view returns (address) {\\n        return addresses[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == ADDR_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"balanceable.sol\":{\"content\":\"/**\\n *  Balanceable - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n\\n/// @title Balanceable - This is a contract used to get a balance\\ncontract Balanceable {\\n\\n    /// @dev This function is used to get a balance\\n    /// @param _address of which balance we are trying to ascertain\\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\\n    /// @return balance associated with an address, for any token, in the wei equivalent\\n    function _balance(address _address, address _asset) internal view returns (uint) {\\n        if (_asset != address(0)) {\\n            return ERC20(_asset).balanceOf(_address);\\n        } else {\\n            return _address.balance;\\n        }\\n    }\\n}\\n\"},\"bytesUtils.sol\":{\"content\":\"/**\\n *  BytesUtils - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/// @title BytesUtils provides basic byte slicing and casting functionality.\\nlibrary BytesUtils {\\n\\n    using SafeMath for uint256;\\n\\n    /// @dev This function converts to an address\\n    /// @param _bts bytes\\n    /// @param _from start position\\n    function _bytesToAddress(bytes memory _bts, uint _from) internal pure returns (address) {\\n\\n        require(_bts.length \\u003e= _from.add(20), \\\"slicing out of range\\\");\\n\\n        bytes20 convertedAddress;\\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\\n\\n        assembly {\\n            convertedAddress := mload(add(_bts, startByte))\\n        }\\n\\n        return address(convertedAddress);\\n    }\\n\\n    /// @dev This function slices bytes into bytes4\\n    /// @param _bts some bytes\\n    /// @param _from start position\\n    function _bytesToBytes4(bytes memory _bts, uint _from) internal pure returns (bytes4) {\\n        require(_bts.length \\u003e= _from.add(4), \\\"slicing out of range\\\");\\n\\n        bytes4 slicedBytes4;\\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\\n\\n        assembly {\\n            slicedBytes4 := mload(add(_bts, startByte))\\n        }\\n\\n        return slicedBytes4;\\n\\n    }\\n\\n    /// @dev This function slices a uint\\n    /// @param _bts some bytes\\n    /// @param _from start position\\n    // credit to https://ethereum.stackexchange.com/questions/51229/how-to-convert-bytes-to-uint-in-solidity\\n    // and Nick Johnson https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity/4177#4177\\n    function _bytesToUint256(bytes memory _bts, uint _from) internal pure returns (uint) {\\n        require(_bts.length \\u003e= _from.add(32), \\\"slicing out of range\\\");\\n\\n        uint convertedUint256;\\n        uint startByte = _from.add(32); //first 32 bytes denote the array length\\n        \\n        assembly {\\n            convertedUint256 := mload(add(_bts, startByte))\\n        }\\n\\n        return convertedUint256;\\n    }\\n}\\n\"},\"ContentHashResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\n\\ncontract ContentHashResolver is ResolverBase {\\n    bytes4 constant private CONTENT_HASH_INTERFACE_ID = 0xbc1c58d1;\\n\\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\\n\\n    mapping(bytes32=\\u003ebytes) hashes;\\n\\n    /**\\n     * Sets the contenthash associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param hash The contenthash to set\\n     */\\n    function setContenthash(bytes32 node, bytes calldata hash) external authorised(node) {\\n        hashes[node] = hash;\\n        emit ContenthashChanged(node, hash);\\n    }\\n\\n    /**\\n     * Returns the contenthash associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function contenthash(bytes32 node) external view returns (bytes memory) {\\n        return hashes[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == CONTENT_HASH_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"controllable.sol\":{\"content\":\"/**\\n *  Controllable - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./controller.sol\\\";\\nimport \\\"./ensResolvable.sol\\\";\\n\\n\\n/// @title Controllable implements access control functionality of the Controller found via ENS.\\ncontract Controllable is ENSResolvable {\\n    /// @dev Is the registered ENS node identifying the controller contract.\\n    bytes32 private _controllerNode;\\n\\n    /// @notice Constructor initializes the controller contract object.\\n    /// @param _controllerNode_ is the ENS node of the Controller.\\n    constructor(bytes32 _controllerNode_) internal {\\n        _controllerNode = _controllerNode_;\\n    }\\n\\n    /// @notice Checks if message sender is a controller.\\n    modifier onlyController() {\\n        require(_isController(msg.sender), \\\"sender is not a controller\\\");\\n        _;\\n    }\\n\\n    /// @notice Checks if message sender is an admin.\\n    modifier onlyAdmin() {\\n        require(_isAdmin(msg.sender), \\\"sender is not an admin\\\");\\n        _;\\n    }\\n\\n    /// @return the controller node registered in ENS.\\n    function controllerNode() external view returns (bytes32) {\\n        return _controllerNode;\\n    }\\n\\n    /// @return true if the provided account is a controller.\\n    function _isController(address _account) internal view returns (bool) {\\n        return IController(_ensResolve(_controllerNode)).isController(_account);\\n    }\\n\\n    /// @return true if the provided account is an admin.\\n    function _isAdmin(address _account) internal view returns (bool) {\\n        return IController(_ensResolve(_controllerNode)).isAdmin(_account);\\n    }\\n\\n}\\n\"},\"controller.sol\":{\"content\":\"/**\\n *  Controller - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./ownable.sol\\\";\\nimport \\\"./transferrable.sol\\\";\\n\\n/// @title The IController interface provides access to the isController and isAdmin checks.\\ninterface IController {\\n    function isController(address) external view returns (bool);\\n    function isAdmin(address) external view returns (bool);\\n}\\n\\n\\n/// @title Controller stores a list of controller addresses that can be used for authentication in other contracts.\\n/// @notice The Controller implements a hierarchy of concepts, Owner, Admin, and the Controllers.\\n/// @dev Owner can change the Admins\\n/// @dev Admins and can the Controllers\\n/// @dev Controllers are used by the application.\\ncontract Controller is IController, Ownable, Transferrable {\\n\\n    event AddedController(address _sender, address _controller);\\n    event RemovedController(address _sender, address _controller);\\n\\n    event AddedAdmin(address _sender, address _admin);\\n    event RemovedAdmin(address _sender, address _admin);\\n\\n    event Claimed(address _to, address _asset, uint _amount);\\n\\n    event Stopped(address _sender);\\n    event Started(address _sender);\\n\\n    mapping (address =\\u003e bool) private _isAdmin;\\n    uint private _adminCount;\\n\\n    mapping (address =\\u003e bool) private _isController;\\n    uint private _controllerCount;\\n\\n    bool private _stopped;\\n\\n    /// @notice Constructor initializes the owner with the provided address.\\n    /// @param _ownerAddress_ address of the owner.\\n    constructor(address payable _ownerAddress_) Ownable(_ownerAddress_, false) public {}\\n\\n    /// @notice Checks if message sender is an admin.\\n    modifier onlyAdmin() {\\n        require(isAdmin(msg.sender), \\\"sender is not an admin\\\");\\n        _;\\n    }\\n\\n    /// @notice Check if Owner or Admin\\n    modifier onlyAdminOrOwner() {\\n        require(_isOwner(msg.sender) || isAdmin(msg.sender), \\\"sender is not an admin\\\");\\n        _;\\n    }\\n\\n    /// @notice Check if controller is stopped\\n    modifier notStopped() {\\n        require(!isStopped(), \\\"controller is stopped\\\");\\n        _;\\n    }\\n\\n    /// @notice Add a new admin to the list of admins.\\n    /// @param _account address to add to the list of admins.\\n    function addAdmin(address _account) external onlyOwner notStopped {\\n        _addAdmin(_account);\\n    }\\n\\n    /// @notice Remove a admin from the list of admins.\\n    /// @param _account address to remove from the list of admins.\\n    function removeAdmin(address _account) external onlyOwner {\\n        _removeAdmin(_account);\\n    }\\n\\n    /// @return the current number of admins.\\n    function adminCount() external view returns (uint) {\\n        return _adminCount;\\n    }\\n\\n    /// @notice Add a new controller to the list of controllers.\\n    /// @param _account address to add to the list of controllers.\\n    function addController(address _account) external onlyAdminOrOwner notStopped {\\n        _addController(_account);\\n    }\\n\\n    /// @notice Remove a controller from the list of controllers.\\n    /// @param _account address to remove from the list of controllers.\\n    function removeController(address _account) external onlyAdminOrOwner {\\n        _removeController(_account);\\n    }\\n\\n    /// @notice count the Controllers\\n    /// @return the current number of controllers.\\n    function controllerCount() external view returns (uint) {\\n        return _controllerCount;\\n    }\\n\\n    /// @notice is an address an Admin?\\n    /// @return true if the provided account is an admin.\\n    function isAdmin(address _account) public view notStopped returns (bool) {\\n        return _isAdmin[_account];\\n    }\\n\\n    /// @notice is an address a Controller?\\n    /// @return true if the provided account is a controller.\\n    function isController(address _account) public view notStopped returns (bool) {\\n        return _isController[_account];\\n    }\\n\\n    /// @notice this function can be used to see if the controller has been stopped\\n    /// @return true is the Controller has been stopped\\n    function isStopped() public view returns (bool) {\\n        return _stopped;\\n    }\\n\\n    /// @notice Internal-only function that adds a new admin.\\n    function _addAdmin(address _account) private {\\n        require(!_isAdmin[_account], \\\"provided account is already an admin\\\");\\n        require(!_isController[_account], \\\"provided account is already a controller\\\");\\n        require(!_isOwner(_account), \\\"provided account is already the owner\\\");\\n        require(_account != address(0), \\\"provided account is the zero address\\\");\\n        _isAdmin[_account] = true;\\n        _adminCount++;\\n        emit AddedAdmin(msg.sender, _account);\\n    }\\n\\n    /// @notice Internal-only function that removes an existing admin.\\n    function _removeAdmin(address _account) private {\\n        require(_isAdmin[_account], \\\"provided account is not an admin\\\");\\n        _isAdmin[_account] = false;\\n        _adminCount--;\\n        emit RemovedAdmin(msg.sender, _account);\\n    }\\n\\n    /// @notice Internal-only function that adds a new controller.\\n    function _addController(address _account) private {\\n        require(!_isAdmin[_account], \\\"provided account is already an admin\\\");\\n        require(!_isController[_account], \\\"provided account is already a controller\\\");\\n        require(!_isOwner(_account), \\\"provided account is already the owner\\\");\\n        require(_account != address(0), \\\"provided account is the zero address\\\");\\n        _isController[_account] = true;\\n        _controllerCount++;\\n        emit AddedController(msg.sender, _account);\\n    }\\n\\n    /// @notice Internal-only function that removes an existing controller.\\n    function _removeController(address _account) private {\\n        require(_isController[_account], \\\"provided account is not a controller\\\");\\n        _isController[_account] = false;\\n        _controllerCount--;\\n        emit RemovedController(msg.sender, _account);\\n    }\\n\\n    /// @notice stop our controllers and admins from being useable\\n    function stop() external onlyAdminOrOwner {\\n        _stopped = true;\\n        emit Stopped(msg.sender);\\n    }\\n\\n    /// @notice start our controller again\\n    function start() external onlyOwner {\\n        _stopped = false;\\n        emit Started(msg.sender);\\n    }\\n\\n    //// @notice Withdraw tokens from the smart contract to the specified account.\\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin notStopped {\\n        _safeTransfer(_to, _asset, _amount);\\n        emit Claimed(_to, _asset, _amount);\\n    }\\n}\\n\"},\"ENS.sol\":{\"content\":\"/**\\n * BSD 2-Clause License\\n *\\n * Copyright (c) 2018, True Names Limited\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n*/\\npragma solidity ^0.5.0;\\n\\ninterface ENS {\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\\n    function setResolver(bytes32 node, address resolver) external;\\n    function setOwner(bytes32 node, address owner) external;\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n    function owner(bytes32 node) external view returns (address);\\n    function resolver(bytes32 node) external view returns (address);\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n}\\n\"},\"ensResolvable.sol\":{\"content\":\"/**\\n *  ENSResolvable - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./ENS.sol\\\";\\nimport \\\"./PublicResolver.sol\\\";\\n\\n\\n///@title ENSResolvable - Ethereum Name Service Resolver\\n///@notice contract should be used to get an address for an ENS node\\ncontract ENSResolvable {\\n    /// @notice _ens is an instance of ENS\\n    ENS private _ens;\\n\\n    /// @notice _ensRegistry points to the ENS registry smart contract.\\n    address private _ensRegistry;\\n\\n    /// @param _ensReg_ is the ENS registry used\\n    constructor(address _ensReg_) internal {\\n        _ensRegistry = _ensReg_;\\n        _ens = ENS(_ensRegistry);\\n    }\\n\\n    /// @notice this is used to that one can observe which ENS registry is being used\\n    function ensRegistry() external view returns (address) {\\n        return _ensRegistry;\\n    }\\n\\n    /// @notice helper function used to get the address of a node\\n    /// @param _node of the ENS entry that needs resolving\\n    /// @return the address of the said node\\n    function _ensResolve(bytes32 _node) internal view returns (address) {\\n        return PublicResolver(_ens.resolver(_node)).addr(_node);\\n    }\\n\\n}\\n\"},\"ERC165.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n/// @title ERC165 interface specifies a standard way of querying if a contract implements an interface.\\ninterface ERC165 {\\n    function supportsInterface(bytes4) external view returns (bool);\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n/// @title ERC20 interface is a subset of the ERC20 specification.\\n/// @notice see https://github.com/ethereum/EIPs/issues/20\\ninterface ERC20 {\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n    function balanceOf(address _who) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n}\\n\"},\"InterfaceResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\nimport \\\"./AddrResolver.sol\\\";\\n\\ncontract InterfaceResolver is ResolverBase, AddrResolver {\\n    bytes4 constant private INTERFACE_INTERFACE_ID = bytes4(keccak256(\\\"interfaceImplementer(bytes32,bytes4)\\\"));\\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\\n\\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\\n\\n    mapping(bytes32=\\u003emapping(bytes4=\\u003eaddress)) interfaces;\\n\\n    /**\\n     * Sets an interface associated with a name.\\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\\n     * @param node The node to update.\\n     * @param interfaceID The EIP 168 interface ID.\\n     * @param implementer The address of a contract that implements this interface for this node.\\n     */\\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external authorised(node) {\\n        interfaces[node][interfaceID] = implementer;\\n        emit InterfaceChanged(node, interfaceID, implementer);\\n    }\\n\\n    /**\\n     * Returns the address of a contract that implements the specified interface for this name.\\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\\n     * contract implements EIP168 and returns `true` for the specified interfaceID, its address\\n     * will be returned.\\n     * @param node The ENS node to query.\\n     * @param interfaceID The EIP 168 interface ID to check for.\\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\\n     */\\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address) {\\n        address implementer = interfaces[node][interfaceID];\\n        if(implementer != address(0)) {\\n            return implementer;\\n        }\\n\\n        address a = addr(node);\\n        if(a == address(0)) {\\n            return address(0);\\n        }\\n\\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\\\"supportsInterface(bytes4)\\\", INTERFACE_META_ID));\\n        if(!success || returnData.length \\u003c 32 || returnData[31] == 0) {\\n            // EIP 168 not supported by target\\n            return address(0);\\n        }\\n\\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\\\"supportsInterface(bytes4)\\\", interfaceID));\\n        if(!success || returnData.length \\u003c 32 || returnData[31] == 0) {\\n            // Specified interface not supported by target\\n            return address(0);\\n        }\\n\\n        return a;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == INTERFACE_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"licence.sol\":{\"content\":\"/**\\n *  Licence - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./controllable.sol\\\";\\nimport \\\"./ensResolvable.sol\\\";\\nimport \\\"./transferrable.sol\\\";\\n\\n/// @title ILicence interface describes methods for loading a TokenCard and updating licence amount.\\ninterface ILicence {\\n    function load(address, uint) external payable;\\n    function updateLicenceAmount(uint) external;\\n}\\n\\n\\n/// @title Licence loads the TokenCard and transfers the licence amout to the TKN Holder Contract.\\n/// @notice the rest of the amount gets sent to the CryptoFloat\\ncontract Licence is Transferrable, ENSResolvable, Controllable {\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for ERC20;\\n\\n    /*******************/\\n    /*     Events     */\\n    /*****************/\\n\\n    event UpdatedLicenceDAO(address _newDAO);\\n    event UpdatedCryptoFloat(address _newFloat);\\n    event UpdatedTokenHolder(address _newHolder);\\n    event UpdatedTKNContractAddress(address _newTKN);\\n    event UpdatedLicenceAmount(uint _newAmount);\\n\\n    event TransferredToTokenHolder(address _from, address _to, address _asset, uint _amount);\\n    event TransferredToCryptoFloat(address _from, address _to, address _asset, uint _amount);\\n\\n    event Claimed(address _to, address _asset, uint _amount);\\n\\n    /// @notice This is 100% scaled up by a factor of 10 to give us an extra 1 decimal place of precision\\n    uint constant public MAX_AMOUNT_SCALE = 1000;\\n    uint constant public MIN_AMOUNT_SCALE = 1;\\n\\n    address private _tknContractAddress = 0xaAAf91D9b90dF800Df4F55c205fd6989c977E73a; // solium-disable-line uppercase\\n\\n    address payable private _cryptoFloat;\\n    address payable private _tokenHolder;\\n    address private _licenceDAO;\\n\\n    bool private _lockedCryptoFloat;\\n    bool private _lockedTokenHolder;\\n    bool private _lockedLicenceDAO;\\n    bool private _lockedTKNContractAddress;\\n\\n    /// @notice This is the _licenceAmountScaled by a factor of 10\\n    /// @dev i.e. 1% is 10 _licenceAmountScaled, 0.1% is 1 _licenceAmountScaled\\n    uint private _licenceAmountScaled;\\n\\n    /// @notice Reverts if called by any address other than the DAO contract.\\n    modifier onlyDAO() {\\n        require(msg.sender == _licenceDAO, \\\"the sender isn\\u0027t the DAO\\\");\\n        _;\\n    }\\n\\n    /// @notice Constructor initializes the card licence contract.\\n    /// @param _licence_ is the initial card licence amount. this number is scaled 10 = 1%, 9 = 0.9%\\n    /// @param _float_ is the address of the multi-sig cryptocurrency float contract.\\n    /// @param _holder_ is the address of the token holder contract\\n    /// @param _tknAddress_ is the address of the TKN ERC20 contract\\n    /// @param _ens_ is the address of the ENS Registry\\n    /// @param _controllerNode_ is the ENS node corresponding to the controller\\n    constructor(uint _licence_, address payable _float_, address payable _holder_, address _tknAddress_, address _ens_, bytes32 _controllerNode_) ENSResolvable(_ens_) Controllable(_controllerNode_) public {\\n        require(MIN_AMOUNT_SCALE \\u003c= _licence_ \\u0026\\u0026 _licence_ \\u003c= MAX_AMOUNT_SCALE, \\\"licence amount out of range\\\");\\n        _licenceAmountScaled = _licence_;\\n        _cryptoFloat = _float_;\\n        _tokenHolder = _holder_;\\n        if (_tknAddress_ != address(0)) {\\n            _tknContractAddress = _tknAddress_;\\n        }\\n    }\\n\\n    /// @notice Ether can be deposited from any source, so this contract should be payable by anyone.\\n    function() external payable {}\\n\\n    /// @notice this allows for people to see the scaled licence amount\\n    /// @return the scaled licence amount, used to calculate the split when loading.\\n    function licenceAmountScaled() external view returns (uint) {\\n        return _licenceAmountScaled;\\n    }\\n\\n    /// @notice allows one to see the address of the CryptoFloat\\n    /// @return the address of the multi-sig cryptocurrency float contract.\\n    function cryptoFloat() external view returns (address) {\\n        return _cryptoFloat;\\n    }\\n\\n    /// @notice allows one to see the address TKN holder contract\\n    /// @return the address of the token holder contract.\\n    function tokenHolder() external view returns (address) {\\n        return _tokenHolder;\\n    }\\n\\n    /// @notice allows one to see the address of the DAO\\n    /// @return the address of the DAO contract.\\n    function licenceDAO() external view returns (address) {\\n        return _licenceDAO;\\n    }\\n\\n    /// @notice The address of the TKN token\\n    /// @return the address of the TKN contract.\\n    function tknContractAddress() external view returns (address) {\\n        return _tknContractAddress;\\n    }\\n\\n    /// @notice This locks the cryptoFloat address\\n    /// @dev so that it can no longer be updated\\n    function lockFloat() external onlyAdmin {\\n        _lockedCryptoFloat = true;\\n    }\\n\\n    /// @notice This locks the TokenHolder address\\n    /// @dev so that it can no longer be updated\\n    function lockHolder() external onlyAdmin {\\n        _lockedTokenHolder = true;\\n    }\\n\\n    /// @notice This locks the DAO address\\n    /// @dev so that it can no longer be updated\\n    function lockLicenceDAO() external onlyAdmin {\\n        _lockedLicenceDAO = true;\\n    }\\n\\n    /// @notice This locks the TKN address\\n    /// @dev so that it can no longer be updated\\n    function lockTKNContractAddress() external onlyAdmin {\\n        _lockedTKNContractAddress = true;\\n    }\\n\\n    /// @notice Updates the address of the cyptoFloat.\\n    /// @param _newFloat This is the new address for the CryptoFloat\\n    function updateFloat(address payable _newFloat) external onlyAdmin {\\n        require(!floatLocked(), \\\"float is locked\\\");\\n        _cryptoFloat = _newFloat;\\n        emit UpdatedCryptoFloat(_newFloat);\\n    }\\n\\n    /// @notice Updates the address of the Holder contract.\\n    /// @param _newHolder This is the new address for the TokenHolder\\n    function updateHolder(address payable _newHolder) external onlyAdmin {\\n        require(!holderLocked(), \\\"holder contract is locked\\\");\\n        _tokenHolder = _newHolder;\\n        emit UpdatedTokenHolder(_newHolder);\\n    }\\n\\n    /// @notice Updates the address of the DAO contract.\\n    /// @param _newDAO This is the new address for the Licence DAO\\n    function updateLicenceDAO(address _newDAO) external onlyAdmin {\\n        require(!licenceDAOLocked(), \\\"DAO is locked\\\");\\n        _licenceDAO = _newDAO;\\n        emit UpdatedLicenceDAO(_newDAO);\\n    }\\n\\n    /// @notice Updates the address of the TKN contract.\\n    /// @param _newTKN This is the new address for the TKN contract\\n    function updateTKNContractAddress(address _newTKN) external onlyAdmin {\\n        require(!tknContractAddressLocked(), \\\"TKN is locked\\\");\\n        _tknContractAddress = _newTKN;\\n        emit UpdatedTKNContractAddress(_newTKN);\\n    }\\n\\n    /// @notice Updates the TKN licence amount\\n    /// @param _newAmount is a number between MIN_AMOUNT_SCALE (1) and MAX_AMOUNT_SCALE\\n    function updateLicenceAmount(uint _newAmount) external onlyDAO {\\n        require(MIN_AMOUNT_SCALE \\u003c= _newAmount \\u0026\\u0026 _newAmount \\u003c= MAX_AMOUNT_SCALE, \\\"licence amount out of range\\\");\\n        _licenceAmountScaled = _newAmount;\\n        emit UpdatedLicenceAmount(_newAmount);\\n    }\\n\\n    /// @notice Load the holder and float contracts based on the licence amount and asset amount.\\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\\n    /// @param _amount is the amount of assets to be transferred including the licence amount.\\n    function load(address _asset, uint _amount) external payable {\\n        uint loadAmount = _amount;\\n        // If TKN then no licence to be paid\\n        if (_asset == _tknContractAddress) {\\n            ERC20(_asset).safeTransferFrom(msg.sender, _cryptoFloat, loadAmount);\\n        } else {\\n            loadAmount = _amount.mul(MAX_AMOUNT_SCALE).div(_licenceAmountScaled + MAX_AMOUNT_SCALE);\\n            uint licenceAmount = _amount.sub(loadAmount);\\n\\n            if (_asset != address(0)) {\\n                ERC20(_asset).safeTransferFrom(msg.sender, _tokenHolder, licenceAmount);\\n                ERC20(_asset).safeTransferFrom(msg.sender, _cryptoFloat, loadAmount);\\n            } else {\\n                require(msg.value == _amount, \\\"ETH sent is not equal to amount\\\");\\n                _tokenHolder.transfer(licenceAmount);\\n                _cryptoFloat.transfer(loadAmount);\\n            }\\n\\n            emit TransferredToTokenHolder(msg.sender, _tokenHolder, _asset, licenceAmount);\\n        }\\n\\n        emit TransferredToCryptoFloat(msg.sender, _cryptoFloat, _asset, loadAmount);\\n    }\\n\\n    //// @notice Withdraw tokens from the smart contract to the specified account.\\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin {\\n        _safeTransfer(_to, _asset, _amount);\\n        emit Claimed(_to, _asset, _amount);\\n    }\\n\\n    /// @notice returns whether or not the CryptoFloat address is locked\\n    function floatLocked() public view returns (bool) {\\n        return _lockedCryptoFloat;\\n    }\\n\\n    /// @notice returns whether or not the TokenHolder address is locked\\n    function holderLocked() public view returns (bool) {\\n        return _lockedTokenHolder;\\n    }\\n\\n    /// @notice returns whether or not the Licence DAO address is locked\\n    function licenceDAOLocked() public view returns (bool) {\\n        return _lockedLicenceDAO;\\n    }\\n\\n    /// @notice returns whether or not the TKN address is locked\\n    function tknContractAddressLocked() public view returns (bool) {\\n        return _lockedTKNContractAddress;\\n    }\\n}\\n\"},\"NameResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\n\\ncontract NameResolver is ResolverBase {\\n    bytes4 constant private NAME_INTERFACE_ID = 0x691f3431;\\n\\n    event NameChanged(bytes32 indexed node, string name);\\n\\n    mapping(bytes32=\\u003estring) names;\\n\\n    /**\\n     * Sets the name associated with an ENS node, for reverse records.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param name The name to set.\\n     */\\n    function setName(bytes32 node, string calldata name) external authorised(node) {\\n        names[node] = name;\\n        emit NameChanged(node, name);\\n    }\\n\\n    /**\\n     * Returns the name associated with an ENS node, for reverse records.\\n     * Defined in EIP181.\\n     * @param node The ENS node to query.\\n     * @return The associated name.\\n     */\\n    function name(bytes32 node) external view returns (string memory) {\\n        return names[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == NAME_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"ownable.sol\":{\"content\":\"/**\\n *  Ownable - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\n\\n/// @title Ownable has an owner address and provides basic authorization control functions.\\n/// This contract is modified version of the MIT OpenZepplin Ownable contract\\n/// This contract allows for the transferOwnership operation to be made impossible\\n/// https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\\ncontract Ownable {\\n    event TransferredOwnership(address _from, address _to);\\n    event LockedOwnership(address _locked);\\n\\n    address payable private _owner;\\n    bool private _isTransferable;\\n\\n    /// @notice Constructor sets the original owner of the contract and whether or not it is one time transferable.\\n    constructor(address payable _account_, bool _transferable_) internal {\\n        _owner = _account_;\\n        _isTransferable = _transferable_;\\n        // Emit the LockedOwnership event if no longer transferable.\\n        if (!_isTransferable) {\\n            emit LockedOwnership(_account_);\\n        }\\n        emit TransferredOwnership(address(0), _account_);\\n    }\\n\\n    /// @notice Reverts if called by any account other than the owner.\\n    modifier onlyOwner() {\\n        require(_isOwner(msg.sender), \\\"sender is not an owner\\\");\\n        _;\\n    }\\n\\n    /// @notice Allows the current owner to transfer control of the contract to a new address.\\n    /// @param _account address to transfer ownership to.\\n    /// @param _transferable indicates whether to keep the ownership transferable.\\n    function transferOwnership(address payable _account, bool _transferable) external onlyOwner {\\n        // Require that the ownership is transferable.\\n        require(_isTransferable, \\\"ownership is not transferable\\\");\\n        // Require that the new owner is not the zero address.\\n        require(_account != address(0), \\\"owner cannot be set to zero address\\\");\\n        // Set the transferable flag to the value _transferable passed in.\\n        _isTransferable = _transferable;\\n        // Emit the LockedOwnership event if no longer transferable.\\n        if (!_transferable) {\\n            emit LockedOwnership(_account);\\n        }\\n        // Emit the ownership transfer event.\\n        emit TransferredOwnership(_owner, _account);\\n        // Set the owner to the provided address.\\n        _owner = _account;\\n    }\\n\\n    /// @notice check if the ownership is transferable.\\n    /// @return true if the ownership is transferable.\\n    function isTransferable() external view returns (bool) {\\n        return _isTransferable;\\n    }\\n\\n    /// @notice Allows the current owner to relinquish control of the contract.\\n    /// @dev Renouncing to ownership will leave the contract without an owner and unusable.\\n    /// @dev It will not be possible to call the functions with the `onlyOwner` modifier anymore.\\n    function renounceOwnership() external onlyOwner {\\n        // Require that the ownership is transferable.\\n        require(_isTransferable, \\\"ownership is not transferable\\\");\\n        // note that this could be terminal\\n        _owner = address(0);\\n\\n        emit TransferredOwnership(_owner, address(0));\\n    }\\n\\n    /// @notice Find out owner address\\n    /// @return address of the owner.\\n    function owner() public view returns (address payable) {\\n        return _owner;\\n    }\\n\\n    /// @notice Check if owner address\\n    /// @return true if sender is the owner of the contract.\\n    function _isOwner(address _address) internal view returns (bool) {\\n        return _address == _owner;\\n    }\\n}\\n\"},\"PubkeyResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\n\\ncontract PubkeyResolver is ResolverBase {\\n    bytes4 constant private PUBKEY_INTERFACE_ID = 0xc8690233;\\n\\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\\n\\n    struct PublicKey {\\n        bytes32 x;\\n        bytes32 y;\\n    }\\n\\n    mapping(bytes32=\\u003ePublicKey) pubkeys;\\n\\n    /**\\n     * Sets the SECP256k1 public key associated with an ENS node.\\n     * @param node The ENS node to query\\n     * @param x the X coordinate of the curve point for the public key.\\n     * @param y the Y coordinate of the curve point for the public key.\\n     */\\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external authorised(node) {\\n        pubkeys[node] = PublicKey(x, y);\\n        emit PubkeyChanged(node, x, y);\\n    }\\n\\n    /**\\n     * Returns the SECP256k1 public key associated with an ENS node.\\n     * Defined in EIP 619.\\n     * @param node The ENS node to query\\n     * @return x, y the X and Y coordinates of the curve point for the public key.\\n     */\\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y) {\\n        return (pubkeys[node].x, pubkeys[node].y);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == PUBKEY_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"PublicResolver.sol\":{\"content\":\"/**\\n * BSD 2-Clause License\\n *\\n * Copyright (c) 2018, True Names Limited\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * * Redistributions of source code must retain the above copyright notice, this\\n *   list of conditions and the following disclaimer.\\n *\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n *   this list of conditions and the following disclaimer in the documentation\\n *   and/or other materials provided with the distribution.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n*/\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./ENS.sol\\\";\\nimport \\\"./ABIResolver.sol\\\";\\nimport \\\"./AddrResolver.sol\\\";\\nimport \\\"./ContentHashResolver.sol\\\";\\nimport \\\"./InterfaceResolver.sol\\\";\\nimport \\\"./NameResolver.sol\\\";\\nimport \\\"./PubkeyResolver.sol\\\";\\nimport \\\"./TextResolver.sol\\\";\\n\\n/**\\n * A simple resolver anyone can use; only allows the owner of a node to set its\\n * address.\\n */\\ncontract PublicResolver is ABIResolver, AddrResolver, ContentHashResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\\n    ENS ens;\\n\\n    /**\\n     * A mapping of authorisations. An address that is authorised for a name\\n     * may make any changes to the name that the owner could, but may not update\\n     * the set of authorisations.\\n     * (node, owner, caller) =\\u003e isAuthorised\\n     */\\n    mapping(bytes32=\\u003emapping(address=\\u003emapping(address=\\u003ebool))) public authorisations;\\n\\n    event AuthorisationChanged(bytes32 indexed node, address indexed owner, address indexed target, bool isAuthorised);\\n\\n    constructor(ENS _ens) public {\\n        ens = _ens;\\n    }\\n\\n    /**\\n     * @dev Sets or clears an authorisation.\\n     * Authorisations are specific to the caller. Any account can set an authorisation\\n     * for any name, but the authorisation that is checked will be that of the\\n     * current owner of a name. Thus, transferring a name effectively clears any\\n     * existing authorisations, and new authorisations can be set in advance of\\n     * an ownership transfer if desired.\\n     *\\n     * @param node The name to change the authorisation on.\\n     * @param target The address that is to be authorised or deauthorised.\\n     * @param isAuthorised True if the address should be authorised, or false if it should be deauthorised.\\n     */\\n    function setAuthorisation(bytes32 node, address target, bool isAuthorised) external {\\n        authorisations[node][msg.sender][target] = isAuthorised;\\n        emit AuthorisationChanged(node, msg.sender, target, isAuthorised);\\n    }\\n\\n    function isAuthorised(bytes32 node) internal view returns(bool) {\\n        address owner = ens.owner(node);\\n        return owner == msg.sender || authorisations[node][owner][msg.sender];\\n    }\\n}\\n\"},\"ResolverBase.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ncontract ResolverBase {\\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == INTERFACE_META_ID;\\n    }\\n\\n    function isAuthorised(bytes32 node) internal view returns(bool);\\n\\n    modifier authorised(bytes32 node) {\\n        require(isAuthorised(node));\\n        _;\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"/**\\n * The MIT License (MIT)\\n *\\n * Copyright (c) 2016-2019 zOS Global Limited\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining\\n * a copy of this software and associated documentation files (the\\n * \\\"Software\\\"), to deal in the Software without restriction, including\\n * without limitation the rights to use, copy, modify, merge, publish,\\n * distribute, sublicense, and/or sell copies of the Software, and to\\n * permit persons to whom the Software is furnished to do so, subject to\\n * the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included\\n * in all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(ERC20 token, bytes memory data) internal {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length \\u003e 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"},\"strings.sol\":{\"content\":\"/*\\n * Copyright 2016 Nick Johnson\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n/*\\n * @title String \\u0026 slice utility library for Solidity contracts.\\n * @author Nick Johnson \\u003carachnid@notdot.net\\u003e\\n *\\n * @dev Functionality in this library is largely implemented using an\\n *      abstraction called a \\u0027slice\\u0027. A slice represents a part of a string -\\n *      anything from the entire string to a single character, or even no\\n *      characters at all (a 0-length slice). Since a slice only has to specify\\n *      an offset and a length, copying and manipulating slices is a lot less\\n *      expensive than copying and manipulating the strings they reference.\\n *\\n *      To further reduce gas costs, most functions on slice that need to return\\n *      a slice modify the original one instead of allocating a new one; for\\n *      instance, `s.split(\\\".\\\")` will return the text up to the first \\u0027.\\u0027,\\n *      modifying s to only contain the remainder of the string after the \\u0027.\\u0027.\\n *      In situations where you do not want to modify the original slice, you\\n *      can make a copy first with `.copy()`, for example:\\n *      `s.copy().split(\\\".\\\")`. Try and avoid using this idiom in loops; since\\n *      Solidity has no memory management, it will result in allocating many\\n *      short-lived slices that are later discarded.\\n *\\n *      Functions that return two slices come in two versions: a non-allocating\\n *      version that takes the second slice as an argument, modifying it in\\n *      place, and an allocating version that allocates and returns the second\\n *      slice; see `nextRune` for example.\\n *\\n *      Functions that have to copy string data will return strings rather than\\n *      slices; these can be cast back to slices for further processing if\\n *      required.\\n *\\n *      For convenience, some functions are provided with non-modifying\\n *      variants that create a new slice and return both; for instance,\\n *      `s.splitNew(\\u0027.\\u0027)` leaves s unmodified, and returns two values\\n *      corresponding to the left and right parts of the string.\\n */\\n\\npragma solidity ^0.5.0;\\n\\nlibrary strings {\\n    struct slice {\\n        uint _len;\\n        uint _ptr;\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for(; len \\u003e= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire string.\\n     * @param self The string to make a slice from.\\n     * @return A newly allocated slice containing the entire string.\\n     */\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns the length of a null-terminated bytes32 string.\\n     * @param self The value to find the length of.\\n     * @return The length of the string, from 0 to 32.\\n     */\\n    function len(bytes32 self) internal pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (uint(self) \\u0026 0xffffffffffffffffffffffffffffffff == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (uint(self) \\u0026 0xffffffffffffffff == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (uint(self) \\u0026 0xffffffff == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (uint(self) \\u0026 0xffff == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (uint(self) \\u0026 0xff == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\\n     *      null-terminated utf-8 string.\\n     * @param self The bytes32 value to convert to a slice.\\n     * @return A new slice containing the value of the input argument up to the\\n     *         first null.\\n     */\\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\\n        // Allocate space for `self` in memory, copy it there, and point ret at it\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(0x40, add(ptr, 0x20))\\n            mstore(ptr, self)\\n            mstore(add(ret, 0x20), ptr)\\n        }\\n        ret._len = len(self);\\n    }\\n\\n    /*\\n     * @dev Returns a new slice containing the same data as the current slice.\\n     * @param self The slice to copy.\\n     * @return A new slice containing the same data as `self`.\\n     */\\n    function copy(slice memory self) internal pure returns (slice memory) {\\n        return slice(self._len, self._ptr);\\n    }\\n\\n    /*\\n     * @dev Copies a slice to a new string.\\n     * @param self The slice to copy.\\n     * @return A newly allocated string containing the slice\\u0027s text.\\n     */\\n    function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the length in runes of the slice. Note that this operation\\n     *      takes time proportional to the length of the slice; avoid using it\\n     *      in loops, and call `slice.empty()` if you only need to know whether\\n     *      the slice is empty or not.\\n     * @param self The slice to operate on.\\n     * @return The length of the slice in runes.\\n     */\\n    function len(slice memory self) internal pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr \\u003c end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b \\u003c 0x80) {\\n                ptr += 1;\\n            } else if (b \\u003c 0xE0) {\\n                ptr += 2;\\n            } else if (b \\u003c 0xF0) {\\n                ptr += 3;\\n            } else if (b \\u003c 0xF8) {\\n                ptr += 4;\\n            } else if (b \\u003c 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns true if the slice is empty (has a length of 0).\\n     * @param self The slice to operate on.\\n     * @return True if the slice is empty, False otherwise.\\n     */\\n    function empty(slice memory self) internal pure returns (bool) {\\n        return self._len == 0;\\n    }\\n\\n    /*\\n     * @dev Returns a positive number if `other` comes lexicographically after\\n     *      `self`, a negative number if it comes before, or zero if the\\n     *      contents of the two slices are equal. Comparison is done per-rune,\\n     *      on unicode codepoints.\\n     * @param self The first slice to compare.\\n     * @param other The second slice to compare.\\n     * @return The result of the comparison.\\n     */\\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\\n        uint shortest = self._len;\\n        if (other._len \\u003c self._len)\\n            shortest = other._len;\\n\\n        uint selfptr = self._ptr;\\n        uint otherptr = other._ptr;\\n        for (uint idx = 0; idx \\u003c shortest; idx += 32) {\\n            uint a;\\n            uint b;\\n            assembly {\\n                a := mload(selfptr)\\n                b := mload(otherptr)\\n            }\\n            if (a != b) {\\n                // Mask out irrelevant bytes and check again\\n                uint256 mask = uint256(-1); // 0xffff...\\n                if (shortest \\u003c 32) {\\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\\n                }\\n                uint256 diff = (a \\u0026 mask) - (b \\u0026 mask);\\n                if (diff != 0)\\n                    return int(diff);\\n            }\\n            selfptr += 32;\\n            otherptr += 32;\\n        }\\n        return int(self._len) - int(other._len);\\n    }\\n\\n    /*\\n     * @dev Returns true if the two slices contain the same text.\\n     * @param self The first slice to compare.\\n     * @param self The second slice to compare.\\n     * @return True if the slices are equal, false otherwise.\\n     */\\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\\n        return compare(self, other) == 0;\\n    }\\n\\n    /*\\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\\n     *      slice to point to the next rune and returning `self`.\\n     * @param self The slice to operate on.\\n     * @param rune The slice that will contain the first rune.\\n     * @return `rune`.\\n     */\\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\\n        rune._ptr = self._ptr;\\n\\n        if (self._len == 0) {\\n            rune._len = 0;\\n            return rune;\\n        }\\n\\n        uint l;\\n        uint b;\\n        // Load the first byte of the rune into the LSBs of b\\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\\n        if (b \\u003c 0x80) {\\n            l = 1;\\n        } else if (b \\u003c 0xE0) {\\n            l = 2;\\n        } else if (b \\u003c 0xF0) {\\n            l = 3;\\n        } else {\\n            l = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (l \\u003e self._len) {\\n            rune._len = self._len;\\n            self._ptr += self._len;\\n            self._len = 0;\\n            return rune;\\n        }\\n\\n        self._ptr += l;\\n        self._len -= l;\\n        rune._len = l;\\n        return rune;\\n    }\\n\\n    /*\\n     * @dev Returns the first rune in the slice, advancing the slice to point\\n     *      to the next rune.\\n     * @param self The slice to operate on.\\n     * @return A slice containing only the first rune from `self`.\\n     */\\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\\n        nextRune(self, ret);\\n    }\\n\\n    /*\\n     * @dev Returns the number of the first codepoint in the slice.\\n     * @param self The slice to operate on.\\n     * @return The number of the first codepoint in the slice.\\n     */\\n    function ord(slice memory self) internal pure returns (uint ret) {\\n        if (self._len == 0) {\\n            return 0;\\n        }\\n\\n        uint word;\\n        uint length;\\n        uint divisor = 2 ** 248;\\n\\n        // Load the rune into the MSBs of b\\n        assembly { word:= mload(mload(add(self, 32))) }\\n        uint b = word / divisor;\\n        if (b \\u003c 0x80) {\\n            ret = b;\\n            length = 1;\\n        } else if (b \\u003c 0xE0) {\\n            ret = b \\u0026 0x1F;\\n            length = 2;\\n        } else if (b \\u003c 0xF0) {\\n            ret = b \\u0026 0x0F;\\n            length = 3;\\n        } else {\\n            ret = b \\u0026 0x07;\\n            length = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (length \\u003e self._len) {\\n            return 0;\\n        }\\n\\n        for (uint i = 1; i \\u003c length; i++) {\\n            divisor = divisor / 256;\\n            b = (word / divisor) \\u0026 0xFF;\\n            if (b \\u0026 0xC0 != 0x80) {\\n                // Invalid UTF-8 sequence\\n                return 0;\\n            }\\n            ret = (ret * 64) | (b \\u0026 0x3F);\\n        }\\n\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the keccak-256 hash of the slice.\\n     * @param self The slice to hash.\\n     * @return The hash of the slice.\\n     */\\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\\n        assembly {\\n            ret := keccak256(mload(add(self, 32)), mload(self))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns true if `self` starts with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\\n        if (self._len \\u003c needle._len) {\\n            return false;\\n        }\\n\\n        if (self._ptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let selfptr := mload(add(self, 0x20))\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` starts with `needle`, `needle` is removed from the\\n     *      beginning of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        if (self._len \\u003c needle._len) {\\n            return self;\\n        }\\n\\n        bool equal = true;\\n        if (self._ptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let selfptr := mload(add(self, 0x20))\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n            self._ptr += needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Returns true if the slice ends with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\\n        if (self._len \\u003c needle._len) {\\n            return false;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n\\n        if (selfptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` ends with `needle`, `needle` is removed from the\\n     *      end of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        if (self._len \\u003c needle._len) {\\n            return self;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n        bool equal = true;\\n        if (selfptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    // Returns the memory address of the first byte of the first occurrence of\\n    // `needle` in `self`, or the first byte after `self` if not found.\\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr = selfptr;\\n        uint idx;\\n\\n        if (needlelen \\u003c= selflen) {\\n            if (needlelen \\u003c= 32) {\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly { needledata := and(mload(needleptr), mask) }\\n\\n                uint end = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly { ptrdata := and(mload(ptr), mask) }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr \\u003e= end)\\n                        return selfptr + selflen;\\n                    ptr++;\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\n                }\\n                return ptr;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly { hash := keccak256(needleptr, needlelen) }\\n\\n                for (idx = 0; idx \\u003c= selflen - needlelen; idx++) {\\n                    bytes32 testHash;\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\n                    if (hash == testHash)\\n                        return ptr;\\n                    ptr += 1;\\n                }\\n            }\\n        }\\n        return selfptr + selflen;\\n    }\\n\\n    // Returns the memory address of the first byte after the last occurrence of\\n    // `needle` in `self`, or the address of `self` if not found.\\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr;\\n\\n        if (needlelen \\u003c= selflen) {\\n            if (needlelen \\u003c= 32) {\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly { needledata := and(mload(needleptr), mask) }\\n\\n                ptr = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly { ptrdata := and(mload(ptr), mask) }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr \\u003c= selfptr)\\n                        return selfptr;\\n                    ptr--;\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\n                }\\n                return ptr + needlelen;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly { hash := keccak256(needleptr, needlelen) }\\n                ptr = selfptr + (selflen - needlelen);\\n                while (ptr \\u003e= selfptr) {\\n                    bytes32 testHash;\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\n                    if (hash == testHash)\\n                        return ptr + needlelen;\\n                    ptr -= 1;\\n                }\\n            }\\n        }\\n        return selfptr;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain everything from the first occurrence of\\n     *      `needle` to the end of the slice. `self` is set to the empty slice\\n     *      if `needle` is not found.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len -= ptr - self._ptr;\\n        self._ptr = ptr;\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain the part of the string from the start of\\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\\n     *      is not found, `self` is set to the empty slice.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len = ptr - self._ptr;\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and `token` to everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = self._ptr;\\n        token._len = ptr - self._ptr;\\n        if (ptr == self._ptr + self._len) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n            self._ptr = ptr + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and returning everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` up to the first occurrence of `delim`.\\n     */\\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\n        split(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything before the last\\n     *      occurrence of `needle`, and `token` to everything after it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = ptr;\\n        token._len = self._len - (ptr - self._ptr);\\n        if (ptr == self._ptr) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything before the last\\n     *      occurrence of `needle`, and returning everything after it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` after the last occurrence of `delim`.\\n     */\\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\n        rsplit(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return The number of occurrences of `needle` found in `self`.\\n     */\\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\\n        while (ptr \\u003c= self._ptr + self._len) {\\n            cnt++;\\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns True if `self` contains `needle`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return True if `needle` is found in `self`, false otherwise.\\n     */\\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\\n    }\\n\\n    /*\\n     * @dev Returns a newly allocated string containing the concatenation of\\n     *      `self` and `other`.\\n     * @param self The first slice to concatenate.\\n     * @param other The second slice to concatenate.\\n     * @return The concatenation of the two strings.\\n     */\\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\\n        string memory ret = new string(self._len + other._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n        memcpy(retptr, self._ptr, self._len);\\n        memcpy(retptr + self._len, other._ptr, other._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\\n     *      newly allocated string.\\n     * @param self The delimiter to use.\\n     * @param parts A list of slices to join.\\n     * @return A newly allocated string containing all the slices in `parts`,\\n     *         joined with `self`.\\n     */\\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\\n        if (parts.length == 0)\\n            return \\\"\\\";\\n\\n        uint length = self._len * (parts.length - 1);\\n        for (uint i = 0; i \\u003c parts.length; i++) {\\n            length += parts[i]._len;\\n        }\\n\\n        string memory ret = new string(length);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        for (uint i = 0; i \\u003c parts.length; i++) {\\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\\n            retptr += parts[i]._len;\\n            if (i \\u003c parts.length - 1) {\\n                memcpy(retptr, self._ptr, self._len);\\n                retptr += self._len;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n}\\n\"},\"TextResolver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ResolverBase.sol\\\";\\n\\ncontract TextResolver is ResolverBase {\\n    bytes4 constant private TEXT_INTERFACE_ID = 0x59d1d43c;\\n\\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\\n\\n    mapping(bytes32=\\u003emapping(string=\\u003estring)) texts;\\n\\n    /**\\n     * Sets the text data associated with an ENS node and key.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param key The key to set.\\n     * @param value The text data value to set.\\n     */\\n    function setText(bytes32 node, string calldata key, string calldata value) external authorised(node) {\\n        texts[node][key] = value;\\n        emit TextChanged(node, key, key);\\n    }\\n\\n    /**\\n     * Returns the text data associated with an ENS node and key.\\n     * @param node The ENS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(bytes32 node, string calldata key) external view returns (string memory) {\\n        return texts[node][key];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns(bool) {\\n        return interfaceID == TEXT_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"},\"tokenWhitelist.sol\":{\"content\":\"/**\\n *  TokenWhitelist - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./controllable.sol\\\";\\nimport \\\"./transferrable.sol\\\";\\nimport \\\"./bytesUtils.sol\\\";\\nimport \\\"./strings.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/// @title The ITokenWhitelist interface provides access to a whitelist of tokens.\\ninterface ITokenWhitelist {\\n    function getTokenInfo(address) external view returns (string memory, uint256, uint256, bool, bool, bool, uint256);\\n    function getStablecoinInfo() external view returns (string memory, uint256, uint256, bool, bool, bool, uint256);\\n    function tokenAddressArray() external view returns (address[] memory);\\n    function redeemableTokens() external view returns (address[] memory);\\n    function methodIdWhitelist(bytes4) external view returns (bool);\\n    function getERC20RecipientAndAmount(address, bytes calldata) external view returns (address, uint);\\n    function stablecoin() external view returns (address);\\n    function updateTokenRate(address, uint, uint) external;\\n}\\n\\n\\n/// @title TokenWhitelist stores a list of tokens used by the Consumer Contract Wallet, the Oracle, the TKN Holder and the TKN Licence Contract\\ncontract TokenWhitelist is ENSResolvable, Controllable, Transferrable {\\n    using strings for *;\\n    using SafeMath for uint256;\\n    using BytesUtils for bytes;\\n\\n    event UpdatedTokenRate(address _sender, address _token, uint _rate);\\n\\n    event UpdatedTokenLoadable(address _sender, address _token, bool _loadable);\\n    event UpdatedTokenRedeemable(address _sender, address _token, bool _redeemable);\\n\\n    event AddedToken(address _sender, address _token, string _symbol, uint _magnitude, bool _loadable, bool _redeemable);\\n    event RemovedToken(address _sender, address _token);\\n\\n    event AddedMethodId(bytes4 _methodId);\\n    event RemovedMethodId(bytes4 _methodId);\\n    event AddedExclusiveMethod(address _token, bytes4 _methodId);\\n    event RemovedExclusiveMethod(address _token, bytes4 _methodId);\\n\\n    event Claimed(address _to, address _asset, uint _amount);\\n\\n    /// @dev these are the methods whitelisted by default in executeTransaction() for protected tokens\\n    bytes4 private constant _APPROVE = 0x095ea7b3; // keccak256(approve(address,uint256)) =\\u003e 0x095ea7b3\\n    bytes4 private constant _BURN = 0x42966c68; // keccak256(burn(uint256)) =\\u003e 0x42966c68\\n    bytes4 private constant _TRANSFER= 0xa9059cbb; // keccak256(transfer(address,uint256)) =\\u003e 0xa9059cbb\\n    bytes4 private constant _TRANSFER_FROM = 0x23b872dd; // keccak256(transferFrom(address,address,uint256)) =\\u003e 0x23b872dd\\n\\n    struct Token {\\n        string symbol;    // Token symbol\\n        uint magnitude;   // 10^decimals\\n        uint rate;        // Token exchange rate in wei\\n        bool available;   // Flags if the token is available or not\\n        bool loadable;    // Flags if token is loadable to the TokenCard\\n        bool redeemable;    // Flags if token is redeemable in the TKN Holder contract\\n        uint lastUpdate;  // Time of the last rate update\\n    }\\n\\n    mapping(address =\\u003e Token) private _tokenInfoMap;\\n\\n    // @notice specifies whitelisted methodIds for protected tokens in wallet\\u0027s excuteTranaction() e.g. keccak256(transfer(address,uint256)) =\\u003e 0xa9059cbb\\n    mapping(bytes4 =\\u003e bool) private _methodIdWhitelist;\\n\\n    address[] private _tokenAddressArray;\\n\\n    /// @notice keeping track of how many redeemable tokens are in the tokenWhitelist\\n    uint private _redeemableCounter;\\n\\n    /// @notice Address of the stablecoin.\\n    address private _stablecoin;\\n\\n    /// @notice is registered ENS node identifying the oracle contract.\\n    bytes32 private _oracleNode;\\n\\n    /// @notice Constructor initializes ENSResolvable, and Controllable.\\n    /// @param _ens_ is the ENS registry address.\\n    /// @param _oracleNode_ is the ENS node of the Oracle.\\n    /// @param _controllerNode_ is our Controllers node.\\n    /// @param _stablecoinAddress_ is the address of the stablecoint used by the wallet for the card load limit.\\n    constructor(address _ens_, bytes32 _oracleNode_, bytes32 _controllerNode_, address _stablecoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNode_) public {\\n        _oracleNode = _oracleNode_;\\n        _stablecoin = _stablecoinAddress_;\\n        //a priori ERC20 whitelisted methods\\n        _methodIdWhitelist[_APPROVE] = true;\\n        _methodIdWhitelist[_BURN] = true;\\n        _methodIdWhitelist[_TRANSFER] = true;\\n        _methodIdWhitelist[_TRANSFER_FROM] = true;\\n    }\\n\\n    modifier onlyAdminOrOracle() {\\n        address oracleAddress = _ensResolve(_oracleNode);\\n        require (_isAdmin(msg.sender) || msg.sender == oracleAddress, \\\"either oracle or admin\\\");\\n        _;\\n    }\\n\\n    /// @notice Add ERC20 tokens to the list of whitelisted tokens.\\n    /// @param _tokens ERC20 token contract addresses.\\n    /// @param _symbols ERC20 token names.\\n    /// @param _magnitude 10 to the power of number of decimal places used by each ERC20 token.\\n    /// @param _loadable is a bool that states whether or not a token is loadable to the TokenCard.\\n    /// @param _redeemable is a bool that states whether or not a token is redeemable in the TKN Holder Contract.\\n    /// @param _lastUpdate is a unit representing an ISO datetime e.g. 20180913153211.\\n    function addTokens(address[] calldata _tokens, bytes32[] calldata _symbols, uint[] calldata _magnitude, bool[] calldata _loadable, bool[] calldata _redeemable, uint _lastUpdate) external onlyAdmin {\\n        // Require that all parameters have the same length.\\n        require(_tokens.length == _symbols.length \\u0026\\u0026 _tokens.length == _magnitude.length \\u0026\\u0026 _tokens.length == _loadable.length \\u0026\\u0026 _tokens.length == _loadable.length, \\\"parameter lengths do not match\\\");\\n        // Add each token to the list of supported tokens.\\n        for (uint i = 0; i \\u003c _tokens.length; i++) {\\n            // Require that the token isn\\u0027t already available.\\n            require(!_tokenInfoMap[_tokens[i]].available, \\\"token already available\\\");\\n            // Store the intermediate values.\\n            string memory symbol = _symbols[i].toSliceB32().toString();\\n            // Add the token to the token list.\\n            _tokenInfoMap[_tokens[i]] = Token({\\n                symbol : symbol,\\n                magnitude : _magnitude[i],\\n                rate : 0,\\n                available : true,\\n                loadable : _loadable[i],\\n                redeemable: _redeemable[i],\\n                lastUpdate : _lastUpdate\\n                });\\n            // Add the token address to the address list.\\n            _tokenAddressArray.push(_tokens[i]);\\n            //if the token is redeemable increase the redeemableCounter\\n            if (_redeemable[i]){\\n                _redeemableCounter = _redeemableCounter.add(1);\\n            }\\n            // Emit token addition event.\\n            emit AddedToken(msg.sender, _tokens[i], symbol, _magnitude[i], _loadable[i], _redeemable[i]);\\n        }\\n    }\\n\\n    /// @notice Remove ERC20 tokens from the whitelist of tokens.\\n    /// @param _tokens ERC20 token contract addresses.\\n    function removeTokens(address[] calldata _tokens) external onlyAdmin {\\n        // Delete each token object from the list of supported tokens based on the addresses provided.\\n        for (uint i = 0; i \\u003c _tokens.length; i++) {\\n            // Store the token address.\\n            address token = _tokens[i];\\n            //token must be available, reverts on duplicates as well\\n            require(_tokenInfoMap[token].available, \\\"token is not available\\\");\\n            //if the token is redeemable decrease the redeemableCounter\\n            if (_tokenInfoMap[token].redeemable){\\n                _redeemableCounter = _redeemableCounter.sub(1);\\n            }\\n            // Delete the token object.\\n            delete _tokenInfoMap[token];\\n            // Remove the token address from the address list.\\n            for (uint j = 0; j \\u003c _tokenAddressArray.length.sub(1); j++) {\\n                if (_tokenAddressArray[j] == token) {\\n                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\\n                    break;\\n                }\\n            }\\n            _tokenAddressArray.length--;\\n            // Emit token removal event.\\n            emit RemovedToken(msg.sender, token);\\n        }\\n    }\\n\\n    /// @notice based on the method it returns the recipient address and amount/value, ERC20 specific.\\n    /// @param _data is the transaction payload.\\n    function getERC20RecipientAndAmount(address _token, bytes calldata _data) external view returns (address, uint) {\\n        // Require that there exist enough bytes for encoding at least a method signature + data in the transaction payload:\\n        // 4 (signature)  + 32(address or uint256)\\n        require(_data.length \\u003e= 4 + 32, \\\"not enough method-encoding bytes\\\");\\n        // Get the method signature\\n        bytes4 signature = _data._bytesToBytes4(0);\\n        // Check if method Id is supported\\n        require(isERC20MethodSupported(_token, signature), \\\"unsupported method\\\");\\n        // returns the recipient\\u0027s address and amount is the value to be transferred\\n        if (signature == _BURN) {\\n            // 4 (signature) + 32(uint256)\\n            return (_token, _data._bytesToUint256(4));\\n        } else if (signature == _TRANSFER_FROM) {\\n            // 4 (signature) + 32(address) + 32(address) + 32(uint256)\\n            require(_data.length \\u003e= 4 + 32 + 32 + 32, \\\"not enough data for transferFrom\\\");\\n            return ( _data._bytesToAddress(4 + 32 + 12), _data._bytesToUint256(4 + 32 + 32));\\n        } else { //transfer or approve\\n            // 4 (signature) + 32(address) + 32(uint)\\n            require(_data.length \\u003e= 4 + 32 + 32, \\\"not enough data for transfer/appprove\\\");\\n            return (_data._bytesToAddress(4 + 12), _data._bytesToUint256(4 + 32));\\n        }\\n    }\\n\\n    /// @notice Toggles whether or not a token is loadable or not.\\n    function setTokenLoadable(address _token, bool _loadable) external onlyAdmin {\\n        // Require that the token exists.\\n        require(_tokenInfoMap[_token].available, \\\"token is not available\\\");\\n\\n        // this sets the loadable flag to the value passed in\\n        _tokenInfoMap[_token].loadable = _loadable;\\n\\n        emit UpdatedTokenLoadable(msg.sender, _token, _loadable);\\n    }\\n\\n    /// @notice Toggles whether or not a token is redeemable or not.\\n    function setTokenRedeemable(address _token, bool _redeemable) external onlyAdmin {\\n        // Require that the token exists.\\n        require(_tokenInfoMap[_token].available, \\\"token is not available\\\");\\n\\n        // this sets the redeemable flag to the value passed in\\n        _tokenInfoMap[_token].redeemable = _redeemable;\\n\\n        emit UpdatedTokenRedeemable(msg.sender, _token, _redeemable);\\n    }\\n\\n    /// @notice Update ERC20 token exchange rate.\\n    /// @param _token ERC20 token contract address.\\n    /// @param _rate ERC20 token exchange rate in wei.\\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\\n    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyAdminOrOracle {\\n        // Require that the token exists.\\n        require(_tokenInfoMap[_token].available, \\\"token is not available\\\");\\n        // Update the token\\u0027s rate.\\n        _tokenInfoMap[_token].rate = _rate;\\n        // Update the token\\u0027s last update timestamp.\\n        _tokenInfoMap[_token].lastUpdate = _updateDate;\\n        // Emit the rate update event.\\n        emit UpdatedTokenRate(msg.sender, _token, _rate);\\n    }\\n\\n    //// @notice Withdraw tokens from the smart contract to the specified account.\\n    function claim(address payable _to, address _asset, uint _amount) external onlyAdmin {\\n        _safeTransfer(_to, _asset, _amount);\\n        emit Claimed(_to, _asset, _amount);\\n    }\\n\\n    /// @notice This returns all of the fields for a given token.\\n    /// @param _a is the address of a given token.\\n    /// @return string of the token\\u0027s symbol.\\n    /// @return uint of the token\\u0027s magnitude.\\n    /// @return uint of the token\\u0027s exchange rate to ETH.\\n    /// @return bool whether the token is available.\\n    /// @return bool whether the token is loadable to the TokenCard.\\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\\n    /// @return uint of the lastUpdated time of the token\\u0027s exchange rate.\\n    function getTokenInfo(address _a) external view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\\n        Token storage tokenInfo = _tokenInfoMap[_a];\\n        return (tokenInfo.symbol, tokenInfo.magnitude, tokenInfo.rate, tokenInfo.available, tokenInfo.loadable, tokenInfo.redeemable, tokenInfo.lastUpdate);\\n    }\\n\\n    /// @notice This returns all of the fields for our StableCoin.\\n    /// @return string of the token\\u0027s symbol.\\n    /// @return uint of the token\\u0027s magnitude.\\n    /// @return uint of the token\\u0027s exchange rate to ETH.\\n    /// @return bool whether the token is available.\\n    /// @return bool whether the token is loadable to the TokenCard.\\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\\n    /// @return uint of the lastUpdated time of the token\\u0027s exchange rate.\\n    function getStablecoinInfo() external view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\\n        Token storage stablecoinInfo = _tokenInfoMap[_stablecoin];\\n        return (stablecoinInfo.symbol, stablecoinInfo.magnitude, stablecoinInfo.rate, stablecoinInfo.available, stablecoinInfo.loadable, stablecoinInfo.redeemable, stablecoinInfo.lastUpdate);\\n    }\\n\\n    /// @notice This returns an array of all whitelisted token addresses.\\n    /// @return address[] of whitelisted tokens.\\n    function tokenAddressArray() external view returns (address[] memory) {\\n        return _tokenAddressArray;\\n    }\\n\\n    /// @notice This returns an array of all redeemable token addresses.\\n    /// @return address[] of redeemable tokens.\\n    function redeemableTokens() external view returns (address[] memory) {\\n        address[] memory redeemableAddresses = new address[](_redeemableCounter);\\n        uint redeemableIndex = 0;\\n        for (uint i = 0; i \\u003c _tokenAddressArray.length; i++) {\\n            address token = _tokenAddressArray[i];\\n            if (_tokenInfoMap[token].redeemable){\\n                redeemableAddresses[redeemableIndex] = token;\\n                redeemableIndex += 1;\\n            }\\n        }\\n        return redeemableAddresses;\\n    }\\n\\n\\n    /// @notice This returns true if a method Id is supported for the specific token.\\n    /// @return true if _methodId is supported in general or just for the specific token.\\n    function isERC20MethodSupported(address _token, bytes4 _methodId) public view returns (bool) {\\n        require(_tokenInfoMap[_token].available, \\\"non-existing token\\\");\\n        return (_methodIdWhitelist[_methodId]);\\n    }\\n\\n    /// @notice This returns true if the method is supported for all protected tokens.\\n    /// @return true if _methodId is in the method whitelist.\\n    function isERC20MethodWhitelisted(bytes4 _methodId) external view returns (bool) {\\n        return (_methodIdWhitelist[_methodId]);\\n    }\\n\\n    /// @notice This returns the number of redeemable tokens.\\n    /// @return current # of redeemables.\\n    function redeemableCounter() external view returns (uint) {\\n        return _redeemableCounter;\\n    }\\n\\n    /// @notice This returns the address of our stablecoin of choice.\\n    /// @return the address of the stablecoin contract.\\n    function stablecoin() external view returns (address) {\\n        return _stablecoin;\\n    }\\n\\n    /// @notice this returns the node hash of our Oracle.\\n    /// @return the oracle node registered in ENS.\\n    function oracleNode() external view returns (bytes32) {\\n        return _oracleNode;\\n    }\\n}\\n\"},\"tokenWhitelistable.sol\":{\"content\":\"/**\\n *  TokenWhitelistable - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./tokenWhitelist.sol\\\";\\nimport \\\"./ensResolvable.sol\\\";\\n\\n\\n/// @title TokenWhitelistable implements access to the TokenWhitelist located behind ENS.\\ncontract TokenWhitelistable is ENSResolvable {\\n\\n    /// @notice Is the registered ENS node identifying the tokenWhitelist contract\\n    bytes32 private _tokenWhitelistNode;\\n\\n    /// @notice Constructor initializes the TokenWhitelistable object.\\n    /// @param _tokenWhitelistNode_ is the ENS node of the TokenWhitelist.\\n    constructor(bytes32 _tokenWhitelistNode_) internal {\\n        _tokenWhitelistNode = _tokenWhitelistNode_;\\n    }\\n\\n    /// @notice This shows what TokenWhitelist is being used\\n    /// @return TokenWhitelist\\u0027s node registered in ENS.\\n    function tokenWhitelistNode() external view returns (bytes32) {\\n        return _tokenWhitelistNode;\\n    }\\n\\n    /// @notice This returns all of the fields for a given token.\\n    /// @param _a is the address of a given token.\\n    /// @return string of the token\\u0027s symbol.\\n    /// @return uint of the token\\u0027s magnitude.\\n    /// @return uint of the token\\u0027s exchange rate to ETH.\\n    /// @return bool whether the token is available.\\n    /// @return bool whether the token is loadable to the TokenCard.\\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\\n    /// @return uint of the lastUpdated time of the token\\u0027s exchange rate.\\n    function _getTokenInfo(address _a) internal view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getTokenInfo(_a);\\n    }\\n\\n    /// @notice This returns all of the fields for our stablecoin token.\\n    /// @return string of the token\\u0027s symbol.\\n    /// @return uint of the token\\u0027s magnitude.\\n    /// @return uint of the token\\u0027s exchange rate to ETH.\\n    /// @return bool whether the token is available.\\n    /// @return bool whether the token is loadable to the TokenCard.\\n    /// @return bool whether the token is redeemable to the TKN Holder Contract.\\n    /// @return uint of the lastUpdated time of the token\\u0027s exchange rate.\\n    function _getStablecoinInfo() internal view returns (string memory, uint256, uint256, bool, bool, bool, uint256) {\\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getStablecoinInfo();\\n    }\\n\\n    /// @notice This returns an array of our whitelisted addresses.\\n    /// @return address[] of our whitelisted tokens.\\n    function _tokenAddressArray() internal view returns (address[] memory) {\\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).tokenAddressArray();\\n    }\\n\\n    /// @notice This returns an array of all redeemable token addresses.\\n    /// @return address[] of redeemable tokens.\\n    function _redeemableTokens() internal view returns (address[] memory) {\\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).redeemableTokens();\\n    }\\n\\n    /// @notice Update ERC20 token exchange rate.\\n    /// @param _token ERC20 token contract address.\\n    /// @param _rate ERC20 token exchange rate in wei.\\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\\n    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\\n        ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).updateTokenRate(_token, _rate, _updateDate);\\n    }\\n\\n    /// @notice based on the method it returns the recipient address and amount/value, ERC20 specific.\\n    /// @param _data is the transaction payload.\\n    function _getERC20RecipientAndAmount(address _destination, bytes memory _data) internal view returns (address, uint) {\\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getERC20RecipientAndAmount(_destination, _data);\\n    }\\n\\n    /// @notice Checks whether a token is available.\\n    /// @return bool available or not.\\n    function _isTokenAvailable(address _a) internal view returns (bool) {\\n        ( , , , bool available, , , ) = _getTokenInfo(_a);\\n        return available;\\n    }\\n\\n    /// @notice Checks whether a token is redeemable.\\n    /// @return bool redeemable or not.\\n    function _isTokenRedeemable(address _a) internal view returns (bool) {\\n        ( , , , , , bool redeemable, ) = _getTokenInfo(_a);\\n        return redeemable;\\n    }\\n\\n    /// @notice Checks whether a token is loadable.\\n    /// @return bool loadable or not.\\n    function _isTokenLoadable(address _a) internal view returns (bool) {\\n        ( , , , , bool loadable, , ) = _getTokenInfo(_a);\\n        return loadable;\\n    }\\n\\n    /// @notice This gets the address of the stablecoin.\\n    /// @return the address of the stablecoin contract.\\n    function _stablecoin() internal view returns (address) {\\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).stablecoin();\\n    }\\n\\n}\\n\"},\"transferrable.sol\":{\"content\":\"/**\\n *  Transferrable - The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\n\\n/// @title SafeTransfer, allowing contract to withdraw tokens accidentally sent to itself\\ncontract Transferrable {\\n\\n    using SafeERC20 for ERC20;\\n\\n\\n    /// @dev This function is used to move tokens sent accidentally to this contract method.\\n    /// @dev The owner can chose the new destination address\\n    /// @param _to is the recipient\\u0027s address.\\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\\n    /// @param _amount is the amount to be transferred in base units.\\n    function _safeTransfer(address payable _to, address _asset, uint _amount) internal {\\n        // address(0) is used to denote ETH\\n        if (_asset == address(0)) {\\n            _to.transfer(_amount);\\n        } else {\\n            ERC20(_asset).safeTransfer(_to, _amount);\\n        }\\n    }\\n}\\n\"},\"wallet.sol\":{\"content\":\"/**\\n *  The Consumer Contract Wallet\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./licence.sol\\\";\\nimport \\\"./ownable.sol\\\";\\nimport \\\"./controllable.sol\\\";\\nimport \\\"./balanceable.sol\\\";\\nimport \\\"./transferrable.sol\\\";\\nimport \\\"./ensResolvable.sol\\\";\\nimport \\\"./tokenWhitelistable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\n\\n\\n/// @title ControllableOwnable combines Controllable and Ownable\\n/// @dev providing an additional modifier to check if Owner or Controller\\ncontract ControllableOwnable is Controllable, Ownable {\\n    /// @dev Check if the sender is the Owner or one of the Controllers\\n    modifier onlyOwnerOrController() {\\n        require (_isOwner(msg.sender) || _isController(msg.sender), \\\"either owner or controller\\\");\\n        _;\\n    }\\n}\\n\\n\\n/// @title AddressWhitelist provides payee-whitelist functionality.\\n/// @dev This contract will allow the user to maintain a whitelist of addresses\\n/// @dev These addresses will live outside of the various spend limits\\ncontract AddressWhitelist is ControllableOwnable {\\n    using SafeMath for uint256;\\n\\n    event AddedToWhitelist(address _sender, address[] _addresses);\\n    event SubmittedWhitelistAddition(address[] _addresses, bytes32 _hash);\\n    event CancelledWhitelistAddition(address _sender, bytes32 _hash);\\n\\n    event RemovedFromWhitelist(address _sender, address[] _addresses);\\n    event SubmittedWhitelistRemoval(address[] _addresses, bytes32 _hash);\\n    event CancelledWhitelistRemoval(address _sender, bytes32 _hash);\\n\\n    mapping(address =\\u003e bool) public whitelistMap;\\n    address[] public whitelistArray;\\n    address[] private _pendingWhitelistAddition;\\n    address[] private _pendingWhitelistRemoval;\\n    bool public submittedWhitelistAddition;\\n    bool public submittedWhitelistRemoval;\\n    bool public isSetWhitelist;\\n\\n    /// @dev Check if the provided addresses contain the owner or the zero-address address.\\n    modifier hasNoOwnerOrZeroAddress(address[] memory _addresses) {\\n        for (uint i = 0; i \\u003c _addresses.length; i++) {\\n            require(!_isOwner(_addresses[i]), \\\"provided whitelist contains the owner address\\\");\\n            require(_addresses[i] != address(0), \\\"provided whitelist contains the zero address\\\");\\n        }\\n        _;\\n    }\\n\\n    /// @dev Check that neither addition nor removal operations have already been submitted.\\n    modifier noActiveSubmission() {\\n        require(!submittedWhitelistAddition \\u0026\\u0026 !submittedWhitelistRemoval, \\\"whitelist operation has already been submitted\\\");\\n        _;\\n    }\\n\\n    /// @dev Getter for pending addition array.\\n    function pendingWhitelistAddition() external view returns (address[] memory) {\\n        return _pendingWhitelistAddition;\\n    }\\n\\n    /// @dev Getter for pending removal array.\\n    function pendingWhitelistRemoval() external view returns (address[] memory) {\\n        return _pendingWhitelistRemoval;\\n    }\\n\\n    /// @dev Add initial addresses to the whitelist.\\n    /// @param _addresses are the Ethereum addresses to be whitelisted.\\n    function setWhitelist(address[] calldata _addresses) external onlyOwner hasNoOwnerOrZeroAddress(_addresses) {\\n        // Require that the whitelist has not been initialized.\\n        require(!isSetWhitelist, \\\"whitelist has already been initialized\\\");\\n        // Add each of the provided addresses to the whitelist.\\n        for (uint i = 0; i \\u003c _addresses.length; i++) {\\n            // adds to the whitelist mapping\\n            whitelistMap[_addresses[i]] = true;\\n            // adds to the whitelist array\\n            whitelistArray.push(_addresses[i]);\\n        }\\n        isSetWhitelist = true;\\n        // Emit the addition event.\\n        emit AddedToWhitelist(msg.sender, _addresses);\\n    }\\n\\n    /// @dev Add addresses to the whitelist.\\n    /// @param _addresses are the Ethereum addresses to be whitelisted.\\n    function submitWhitelistAddition(address[] calldata _addresses) external onlyOwner noActiveSubmission hasNoOwnerOrZeroAddress(_addresses) {\\n        // Require that the whitelist has been initialized.\\n        require(isSetWhitelist, \\\"whitelist has not been initialized\\\");\\n        // Require this array of addresses not empty\\n        require(_addresses.length \\u003e 0, \\\"pending whitelist addition is empty\\\");\\n        // Set the provided addresses to the pending addition addresses.\\n        _pendingWhitelistAddition = _addresses;\\n        // Flag the operation as submitted.\\n        submittedWhitelistAddition = true;\\n        // Emit the submission event.\\n        emit SubmittedWhitelistAddition(_addresses, calculateHash(_addresses));\\n    }\\n\\n    /// @dev Confirm pending whitelist addition.\\n    /// @dev This will only ever be applied post 2FA, by one of the Controllers\\n    /// @param _hash is the hash of the pending whitelist array, a form of lamport lock\\n    function confirmWhitelistAddition(bytes32 _hash) external onlyController {\\n        // Require that the whitelist addition has been submitted.\\n        require(submittedWhitelistAddition, \\\"whitelist addition has not been submitted\\\");\\n        // Require that confirmation hash and the hash of the pending whitelist addition match\\n        require(_hash == calculateHash(_pendingWhitelistAddition), \\\"hash of the pending whitelist addition do not match\\\");\\n        // Whitelist pending addresses.\\n        for (uint i = 0; i \\u003c _pendingWhitelistAddition.length; i++) {\\n            // check if it doesn\\u0027t exist already.\\n            if (!whitelistMap[_pendingWhitelistAddition[i]]) {\\n                // add to the Map and the Array\\n                whitelistMap[_pendingWhitelistAddition[i]] = true;\\n                whitelistArray.push(_pendingWhitelistAddition[i]);\\n            }\\n        }\\n        // Emit the addition event.\\n        emit AddedToWhitelist(msg.sender, _pendingWhitelistAddition);\\n        // Reset pending addresses.\\n        delete _pendingWhitelistAddition;\\n        // Reset the submission flag.\\n        submittedWhitelistAddition = false;\\n    }\\n\\n    /// @dev Cancel pending whitelist addition.\\n    function cancelWhitelistAddition(bytes32 _hash) external onlyOwnerOrController {\\n        // Check if operation has been submitted.\\n        require(submittedWhitelistAddition, \\\"whitelist addition has not been submitted\\\");\\n        // Require that confirmation hash and the hash of the pending whitelist addition match\\n        require(_hash == calculateHash(_pendingWhitelistAddition), \\\"hash of the pending whitelist addition does not match\\\");\\n        // Reset pending addresses.\\n        delete _pendingWhitelistAddition;\\n        // Reset the submitted operation flag.\\n        submittedWhitelistAddition = false;\\n        // Emit the cancellation event.\\n        emit CancelledWhitelistAddition(msg.sender, _hash);\\n    }\\n\\n    /// @dev Remove addresses from the whitelist.\\n    /// @param _addresses are the Ethereum addresses to be removed.\\n    function submitWhitelistRemoval(address[] calldata _addresses) external onlyOwner noActiveSubmission {\\n        // Require that the whitelist has been initialized.\\n        require(isSetWhitelist, \\\"whitelist has not been initialized\\\");\\n        // Require that the array of addresses is not empty\\n        require(_addresses.length \\u003e 0, \\\"pending whitelist removal is empty\\\");\\n        // Add the provided addresses to the pending addition list.\\n        _pendingWhitelistRemoval = _addresses;\\n        // Flag the operation as submitted.\\n        submittedWhitelistRemoval = true;\\n        // Emit the submission event.\\n        emit SubmittedWhitelistRemoval(_addresses, calculateHash(_addresses));\\n    }\\n\\n    /// @dev Confirm pending removal of whitelisted addresses.\\n    function confirmWhitelistRemoval(bytes32 _hash) external onlyController {\\n        // Require that the pending whitelist is not empty and the operation has been submitted.\\n        require(submittedWhitelistRemoval, \\\"whitelist removal has not been submitted\\\");\\n        // Require that confirmation hash and the hash of the pending whitelist removal match\\n        require(_hash == calculateHash(_pendingWhitelistRemoval), \\\"hash of the pending whitelist removal does not match the confirmed hash\\\");\\n        // Remove pending addresses.\\n        for (uint i = 0; i \\u003c _pendingWhitelistRemoval.length; i++) {\\n            // check if it exists\\n            if (whitelistMap[_pendingWhitelistRemoval[i]]) {\\n                whitelistMap[_pendingWhitelistRemoval[i]] = false;\\n                for (uint j = 0; j \\u003c whitelistArray.length.sub(1); j++) {\\n                    if (whitelistArray[j] == _pendingWhitelistRemoval[i]) {\\n                        whitelistArray[j] = whitelistArray[whitelistArray.length - 1];\\n                        break;\\n                    }\\n                }\\n                whitelistArray.length--;\\n            }\\n        }\\n        // Emit the removal event.\\n        emit RemovedFromWhitelist(msg.sender, _pendingWhitelistRemoval);\\n        // Reset pending addresses.\\n        delete _pendingWhitelistRemoval;\\n        // Reset the submission flag.\\n        submittedWhitelistRemoval = false;\\n    }\\n\\n    /// @dev Cancel pending removal of whitelisted addresses.\\n    function cancelWhitelistRemoval(bytes32 _hash) external onlyOwnerOrController {\\n        // Check if operation has been submitted.\\n        require(submittedWhitelistRemoval, \\\"whitelist removal has not been submitted\\\");\\n        // Require that confirmation hash and the hash of the pending whitelist removal match\\n        require(_hash == calculateHash(_pendingWhitelistRemoval), \\\"hash of the pending whitelist removal do not match\\\");\\n        // Reset pending addresses.\\n        delete _pendingWhitelistRemoval;\\n        // Reset pending addresses.\\n        submittedWhitelistRemoval = false;\\n        // Emit the cancellation event.\\n        emit CancelledWhitelistRemoval(msg.sender, _hash);\\n    }\\n\\n    /// @dev Method used to hash our whitelist address arrays.\\n    function calculateHash(address[] memory _addresses) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_addresses));\\n    }\\n}\\n\\n/// @title DailyLimitTrait This trait allows for daily limits to be included in other contracts.\\n/// This contract will allow for a DailyLimit object to be instantiated and used.\\nlibrary DailyLimitTrait {\\n    using SafeMath for uint256;\\n\\n    event UpdatedAvailableLimit();\\n\\n    struct DailyLimit {\\n        uint value;\\n        uint available;\\n        uint limitTimestamp;\\n        uint pending;\\n        bool updateable;\\n    }\\n\\n    /// @dev Returns the available daily balance - accounts for daily limit reset.\\n    /// @return amount of available to spend within the current day in base units.\\n    function _getAvailableLimit(DailyLimit storage self) internal view returns (uint) {\\n        if (now \\u003e self.limitTimestamp.add(24 hours)) {\\n            return self.value;\\n        } else {\\n            return self.available;\\n        }\\n    }\\n\\n    /// @dev Use up amount within the daily limit. Will fail if amount is larger than daily limit.\\n    function _enforceLimit(DailyLimit storage self, uint _amount) internal {\\n        // Account for the spend limit daily reset.\\n        _updateAvailableLimit(self);\\n        require(self.available \\u003e= _amount, \\\"available has to be greater or equal to use amount\\\");\\n        self.available = self.available.sub(_amount);\\n    }\\n\\n    /// @dev Set the daily limit.\\n    /// @param _amount is the daily limit amount in base units.\\n    function _setLimit(DailyLimit storage self, uint _amount) internal {\\n        // Require that the spend limit has not been set yet.\\n        require(!self.updateable, \\\"daily limit not updateable\\\");\\n        // Modify spend limit based on the provided value.\\n        _modifyLimit(self, _amount);\\n        // Flag the operation as set.\\n        self.updateable = true;\\n    }\\n\\n    /// @dev Submit a daily limit update, needs to be confirmed.\\n    /// @param _amount is the daily limit amount in base units.\\n    function _submitLimitUpdate(DailyLimit storage self, uint _amount) internal {\\n        // Require that the spend limit has been set.\\n        require(self.updateable, \\\"daily limit is still updateable\\\");\\n        // Assign the provided amount to pending daily limit.\\n        self.pending = _amount;\\n    }\\n\\n    /// @dev Confirm pending set daily limit operation.\\n    function _confirmLimitUpdate(DailyLimit storage self, uint _amount) internal {\\n        // Require that pending and confirmed spend limit are the same\\n        require(self.pending == _amount, \\\"confirmed and submitted limits dont match\\\");\\n        // Modify spend limit based on the pending value.\\n        _modifyLimit(self, self.pending);\\n    }\\n\\n    /// @dev Update available spend limit based on the daily reset.\\n    function _updateAvailableLimit(DailyLimit storage self) private {\\n        if (now \\u003e self.limitTimestamp.add(24 hours)) {\\n            // Update the current timestamp.\\n            self.limitTimestamp = now;\\n            // Set the available limit to the current spend limit.\\n            self.available = self.value;\\n            emit UpdatedAvailableLimit();\\n        }\\n    }\\n\\n    /// @dev Modify the spend limit and spend available based on the provided value.\\n    /// @dev _amount is the daily limit amount in wei.\\n    function _modifyLimit(DailyLimit storage self, uint _amount) private {\\n        // Account for the spend limit daily reset.\\n        _updateAvailableLimit(self);\\n        // Set the daily limit to the provided amount.\\n        self.value = _amount;\\n        // Lower the available limit if it\\u0027s higher than the new daily limit.\\n        if (self.available \\u003e self.value) {\\n            self.available = self.value;\\n        }\\n    }\\n}\\n\\n\\n/// @title  it provides daily spend limit functionality.\\ncontract SpendLimit is ControllableOwnable {\\n    event SetSpendLimit(address _sender, uint _amount);\\n    event SubmittedSpendLimitUpdate(uint _amount);\\n\\n    using DailyLimitTrait for DailyLimitTrait.DailyLimit;\\n\\n    DailyLimitTrait.DailyLimit internal _spendLimit;\\n\\n    /// @dev Constructor initializes the daily spend limit in wei.\\n    constructor(uint _limit_) internal {\\n        _spendLimit = DailyLimitTrait.DailyLimit(_limit_, _limit_, now, 0, false);\\n    }\\n\\n    /// @dev Sets the initial daily spend (aka transfer) limit for non-whitelisted addresses.\\n    /// @param _amount is the daily limit amount in wei.\\n    function setSpendLimit(uint _amount) external onlyOwner {\\n        _spendLimit._setLimit(_amount);\\n        emit SetSpendLimit(msg.sender, _amount);\\n    }\\n\\n    /// @dev Submit a daily transfer limit update for non-whitelisted addresses.\\n    /// @param _amount is the daily limit amount in wei.\\n    function submitSpendLimitUpdate(uint _amount) external onlyOwner {\\n        _spendLimit._submitLimitUpdate(_amount);\\n        emit SubmittedSpendLimitUpdate(_amount);\\n    }\\n\\n    /// @dev Confirm pending set daily limit operation.\\n    function confirmSpendLimitUpdate(uint _amount) external onlyController {\\n        _spendLimit._confirmLimitUpdate(_amount);\\n        emit SetSpendLimit(msg.sender, _amount);\\n    }\\n\\n    function spendLimitAvailable() external view returns (uint) {\\n        return _spendLimit._getAvailableLimit();\\n    }\\n\\n    function spendLimitValue() external view returns (uint) {\\n        return _spendLimit.value;\\n    }\\n\\n    function spendLimitUpdateable() external view returns (bool) {\\n        return _spendLimit.updateable;\\n    }\\n\\n    function spendLimitPending() external view returns (uint) {\\n        return _spendLimit.pending;\\n    }\\n}\\n\\n\\n//// @title GasTopUpLimit provides daily limit functionality.\\ncontract GasTopUpLimit is ControllableOwnable {\\n\\n    event SetGasTopUpLimit(address _sender, uint _amount);\\n    event SubmittedGasTopUpLimitUpdate(uint _amount);\\n\\n    uint constant private _MINIMUM_GAS_TOPUP_LIMIT = 1 finney;\\n    uint constant private _MAXIMUM_GAS_TOPUP_LIMIT = 500 finney;\\n\\n    using DailyLimitTrait for DailyLimitTrait.DailyLimit;\\n\\n    DailyLimitTrait.DailyLimit internal _gasTopUpLimit;\\n\\n    /// @dev Constructor initializes the daily gas topup limit in wei.\\n    constructor() internal {\\n        _gasTopUpLimit = DailyLimitTrait.DailyLimit(_MAXIMUM_GAS_TOPUP_LIMIT, _MAXIMUM_GAS_TOPUP_LIMIT, now, 0, false);\\n    }\\n\\n    /// @dev Sets the daily gas top up limit.\\n    /// @param _amount is the gas top up amount in wei.\\n    function setGasTopUpLimit(uint _amount) external onlyOwner {\\n        require(_MINIMUM_GAS_TOPUP_LIMIT \\u003c= _amount \\u0026\\u0026 _amount \\u003c= _MAXIMUM_GAS_TOPUP_LIMIT, \\\"gas top up amount is outside the min/max range\\\");\\n        _gasTopUpLimit._setLimit(_amount);\\n        emit SetGasTopUpLimit(msg.sender, _amount);\\n    }\\n\\n    /// @dev Submit a daily gas top up limit update.\\n    /// @param _amount is the daily top up gas limit amount in wei.\\n    function submitGasTopUpLimitUpdate(uint _amount) external onlyOwner {\\n        require(_MINIMUM_GAS_TOPUP_LIMIT \\u003c= _amount \\u0026\\u0026 _amount \\u003c= _MAXIMUM_GAS_TOPUP_LIMIT, \\\"gas top up amount is outside the min/max range\\\");\\n        _gasTopUpLimit._submitLimitUpdate(_amount);\\n        emit SubmittedGasTopUpLimitUpdate(_amount);\\n    }\\n\\n    /// @dev Confirm pending set top up gas limit operation.\\n    function confirmGasTopUpLimitUpdate(uint _amount) external onlyController {\\n        _gasTopUpLimit._confirmLimitUpdate(_amount);\\n        emit SetGasTopUpLimit(msg.sender, _amount);\\n    }\\n\\n    function gasTopUpLimitAvailable() external view returns (uint) {\\n        return _gasTopUpLimit._getAvailableLimit();\\n    }\\n\\n    function gasTopUpLimitValue() external view returns (uint) {\\n        return _gasTopUpLimit.value;\\n    }\\n\\n    function gasTopUpLimitUpdateable() external view returns (bool) {\\n        return _gasTopUpLimit.updateable;\\n    }\\n\\n    function gasTopUpLimitPending() external view returns (uint) {\\n        return _gasTopUpLimit.pending;\\n    }\\n}\\n\\n\\n/// @title LoadLimit provides daily load limit functionality.\\ncontract LoadLimit is ControllableOwnable {\\n\\n    event SetLoadLimit(address _sender, uint _amount);\\n    event SubmittedLoadLimitUpdate(uint _amount);\\n\\n    uint constant private _MINIMUM_LOAD_LIMIT = 1 finney;\\n    uint private _maximumLoadLimit;\\n\\n    using DailyLimitTrait for DailyLimitTrait.DailyLimit;\\n\\n    DailyLimitTrait.DailyLimit internal _loadLimit;\\n\\n    /// @dev Sets a daily card load limit.\\n    /// @param _amount is the card load amount in current stablecoin base units.\\n    function setLoadLimit(uint _amount) external onlyOwner {\\n        require(_MINIMUM_LOAD_LIMIT \\u003c= _amount \\u0026\\u0026 _amount \\u003c= _maximumLoadLimit, \\\"card load amount is outside the min/max range\\\");\\n        _loadLimit._setLimit(_amount);\\n        emit SetLoadLimit(msg.sender, _amount);\\n    }\\n\\n    /// @dev Submit a daily load limit update.\\n    /// @param _amount is the daily load limit amount in wei.\\n    function submitLoadLimitUpdate(uint _amount) external onlyOwner {\\n        require(_MINIMUM_LOAD_LIMIT \\u003c= _amount \\u0026\\u0026 _amount \\u003c= _maximumLoadLimit, \\\"card load amount is outside the min/max range\\\");\\n        _loadLimit._submitLimitUpdate(_amount);\\n        emit SubmittedLoadLimitUpdate(_amount);\\n    }\\n\\n    /// @dev Confirm pending set load limit operation.\\n    function confirmLoadLimitUpdate(uint _amount) external onlyController {\\n        _loadLimit._confirmLimitUpdate(_amount);\\n        emit SetLoadLimit(msg.sender, _amount);\\n    }\\n\\n    function loadLimitAvailable() external view returns (uint) {\\n        return _loadLimit._getAvailableLimit();\\n    }\\n\\n    function loadLimitValue() external view returns (uint) {\\n        return _loadLimit.value;\\n    }\\n\\n    function loadLimitUpdateable() external view returns (bool) {\\n        return _loadLimit.updateable;\\n    }\\n\\n    function loadLimitPending() external view returns (uint) {\\n        return _loadLimit.pending;\\n    }\\n\\n    /// @dev initializes the daily load limit.\\n    /// @param _maxLimit is the maximum load limit amount in stablecoin base units.\\n    function _initializeLoadLimit(uint _maxLimit) internal {\\n        _maximumLoadLimit = _maxLimit;\\n        _loadLimit = DailyLimitTrait.DailyLimit(_maximumLoadLimit, _maximumLoadLimit, now, 0, false);\\n    }\\n}\\n\\n\\n//// @title Asset store with extra security features.\\ncontract Vault is AddressWhitelist, SpendLimit, ERC165, Transferrable, Balanceable, TokenWhitelistable {\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for ERC20;\\n\\n    event Received(address _from, uint _amount);\\n    event Transferred(address _to, address _asset, uint _amount);\\n    event BulkTransferred(address _to, address[] _assets);\\n\\n    /// @dev Supported ERC165 interface ID.\\n    bytes4 private constant _ERC165_INTERFACE_ID = 0x01ffc9a7; // solium-disable-line uppercase\\n\\n    /// @dev Constructor initializes the vault with an owner address and spend limit. It also sets up the controllable and tokenWhitelist contracts with the right name registered in ENS.\\n    /// @param _owner_ is the owner account of the wallet contract.\\n    /// @param _transferable_ indicates whether the contract ownership can be transferred.\\n    /// @param _tokenWhitelistNode_ is the ENS node of the Token whitelist.\\n    /// @param _controllerNode_ is the ENS name node of the controller.\\n    /// @param _spendLimit_ is the initial spend limit.\\n    constructor(address payable _owner_, bool _transferable_, bytes32 _tokenWhitelistNode_, bytes32 _controllerNode_, uint _spendLimit_) SpendLimit(_spendLimit_) Ownable(_owner_, _transferable_) Controllable(_controllerNode_) TokenWhitelistable(_tokenWhitelistNode_) public {}\\n\\n    /// @dev Checks if the value is not zero.\\n    modifier isNotZero(uint _value) {\\n        require(_value != 0, \\\"provided value cannot be zero\\\");\\n        _;\\n    }\\n\\n    /// @dev Ether can be deposited from any source, so this contract must be payable by anyone.\\n    function() external payable {\\n        emit Received(msg.sender, msg.value);\\n    }\\n\\n    /// @dev Checks for interface support based on ERC165.\\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\\n        return _interfaceID == _ERC165_INTERFACE_ID;\\n    }\\n\\n    /// @dev This is a bulk transfer convenience function, used to migrate contracts.\\n    /// @notice If any of the transfers fail, this will revert.\\n    /// @param _to is the recipient\\u0027s address, can\\u0027t be the zero (0x0) address: transfer() will revert.\\n    /// @param _assets is an array of addresses of ERC20 tokens or 0x0 for ether.\\n    function bulkTransfer(address payable _to, address[] calldata _assets) external onlyOwner {\\n        // check to make sure that _assets isn\\u0027t empty\\n        require(_assets.length != 0, \\\"asset array should be non-empty\\\");\\n        // This loops through all of the transfers to be made\\n        for (uint i = 0; i \\u003c _assets.length; i++) {\\n            uint amount = _balance(address(this), _assets[i]);\\n            // use our safe, daily limit protected transfer\\n            transfer(_to, _assets[i], amount);\\n        }\\n\\n        emit BulkTransferred(_to, _assets);\\n    }\\n\\n    /// @dev Transfers the specified asset to the recipient\\u0027s address.\\n    /// @param _to is the recipient\\u0027s address.\\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\\n    /// @param _amount is the amount of assets to be transferred in base units.\\n    function transfer(address payable _to, address _asset, uint _amount) public onlyOwner isNotZero(_amount) {\\n        // Checks if the _to address is not the zero-address\\n        require(_to != address(0), \\\"_to address cannot be set to 0x0\\\");\\n\\n        // If address is not whitelisted, take daily limit into account.\\n        if (!whitelistMap[_to]) {\\n            // initialize ether value in case the asset is ETH\\n            uint etherValue = _amount;\\n            // Convert token amount to ether value if asset is an ERC20 token.\\n            if (_asset != address(0)) {\\n                etherValue = convertToEther(_asset, _amount);\\n            }\\n            // Check against the daily spent limit and update accordingly\\n            // Check against the daily spent limit and update accordingly, require that the value is under remaining limit.\\n            _spendLimit._enforceLimit(etherValue);\\n        }\\n        // Transfer token or ether based on the provided address.\\n        _safeTransfer(_to, _asset, _amount);\\n        // Emit the transfer event.\\n        emit Transferred(_to, _asset, _amount);\\n    }\\n\\n    /// @dev Convert ERC20 token amount to the corresponding ether amount.\\n    /// @param _token ERC20 token contract address.\\n    /// @param _amount amount of token in base units.\\n    function convertToEther(address _token, uint _amount) public view returns (uint) {\\n        // Store the token in memory to save map entry lookup gas.\\n        (,uint256 magnitude, uint256 rate, bool available, , , ) = _getTokenInfo(_token);\\n        // If the token exists require that its rate is not zero.\\n        if (available) {\\n            require(rate != 0, \\\"token rate is 0\\\");\\n            // Safely convert the token amount to ether based on the exchange rate.\\n            return _amount.mul(rate).div(magnitude);\\n        }\\n        return 0;\\n    }\\n}\\n\\n\\n//// @title Asset wallet with extra security features, gas top up management and card integration.\\ncontract Wallet is ENSResolvable, Vault, GasTopUpLimit, LoadLimit {\\n\\n    using SafeERC20 for ERC20;\\n    using Address for address;\\n\\n    event ToppedUpGas(address _sender, address _owner, uint _amount);\\n    event LoadedTokenCard(address _asset, uint _amount);\\n    event ExecutedTransaction(address _destination, uint _value, bytes _data, bytes _returndata);\\n    event UpdatedAvailableLimit();\\n\\n    string constant public WALLET_VERSION = \\\"2.2.0\\\";\\n    uint constant private _DEFAULT_MAX_STABLECOIN_LOAD_LIMIT = 10000; //10,000 USD\\n\\n    /// @dev Is the registered ENS node identifying the licence contract.\\n    bytes32 private _licenceNode;\\n\\n    /// @dev Constructor initializes the wallet top up limit and the vault contract.\\n    /// @param _owner_ is the owner account of the wallet contract.\\n    /// @param _transferable_ indicates whether the contract ownership can be transferred.\\n    /// @param _ens_ is the address of the ENS registry.\\n    /// @param _tokenWhitelistNode_ is the ENS name node of the Token whitelist.\\n    /// @param _controllerNode_ is the ENS name node of the Controller contract.\\n    /// @param _licenceNode_ is the ENS name node of the Licence contract.\\n    /// @param _spendLimit_ is the initial spend limit.\\n    constructor(address payable _owner_, bool _transferable_, address _ens_, bytes32 _tokenWhitelistNode_, bytes32 _controllerNode_, bytes32 _licenceNode_, uint _spendLimit_) ENSResolvable(_ens_) Vault(_owner_, _transferable_, _tokenWhitelistNode_, _controllerNode_, _spendLimit_) public {\\n        // Get the stablecoin\\u0027s magnitude.\\n        ( ,uint256 stablecoinMagnitude, , , , , ) = _getStablecoinInfo();\\n        require(stablecoinMagnitude \\u003e 0, \\\"stablecoin not set\\\");\\n        _initializeLoadLimit(_DEFAULT_MAX_STABLECOIN_LOAD_LIMIT * stablecoinMagnitude);\\n        _licenceNode = _licenceNode_;\\n    }\\n\\n    /// @dev Refill owner\\u0027s gas balance, revert if the transaction amount is too large\\n    /// @param _amount is the amount of ether to transfer to the owner account in wei.\\n    function topUpGas(uint _amount) external isNotZero(_amount) onlyOwnerOrController {\\n        // Check against the daily spent limit and update accordingly, require that the value is under remaining limit.\\n        _gasTopUpLimit._enforceLimit(_amount);\\n        // Then perform the transfer\\n        owner().transfer(_amount);\\n        // Emit the gas top up event.\\n        emit ToppedUpGas(msg.sender, owner(), _amount);\\n    }\\n\\n    /// @dev Load a token card with the specified asset amount.\\n    /// @dev the amount send should be inclusive of the percent licence.\\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\\n    /// @param _amount is the amount of assets to be transferred in base units.\\n    function loadTokenCard(address _asset, uint _amount) external payable onlyOwner {\\n        // check if token is allowed to be used for loading the card\\n        require(_isTokenLoadable(_asset), \\\"token not loadable\\\");\\n        // Convert token amount to stablecoin value.\\n        uint stablecoinValue = convertToStablecoin(_asset, _amount);\\n        // Check against the daily spent limit and update accordingly, require that the value is under remaining limit.\\n        _loadLimit._enforceLimit(stablecoinValue);\\n        // Get the TKN licenceAddress from ENS\\n        address licenceAddress = _ensResolve(_licenceNode);\\n        if (_asset != address(0)) {\\n            ERC20(_asset).safeApprove(licenceAddress, _amount);\\n            ILicence(licenceAddress).load(_asset, _amount);\\n        } else {\\n            ILicence(licenceAddress).load.value(_amount)(_asset, _amount);\\n        }\\n\\n        emit LoadedTokenCard(_asset, _amount);\\n\\n    }\\n\\n    /// @dev This function allows for the owner to send transaction from the Wallet to arbitrary addresses\\n    /// @param _destination address of the transaction\\n    /// @param _value ETH amount in wei\\n    /// @param _data transaction payload binary\\n    function executeTransaction(address _destination, uint _value, bytes calldata _data) external onlyOwner returns (bytes memory) {\\n        // If value is send across as a part of this executeTransaction, this will be sent to any payable\\n        // destination. As a result enforceLimit if destination is not whitelisted.\\n        if (!whitelistMap[_destination]) {\\n            _spendLimit._enforceLimit(_value);\\n        }\\n        // Check if the destination is a Contract and it is one of our supported tokens\\n        if (address(_destination).isContract() \\u0026\\u0026 _isTokenAvailable(_destination)) {\\n            // to is the recipient\\u0027s address and amount is the value to be transferred\\n            address to;\\n            uint amount;\\n            (to, amount) = _getERC20RecipientAndAmount(_destination, _data);\\n            if (!whitelistMap[to]) {\\n                // If the address (of the token contract, e.g) is not in the TokenWhitelist used by the convert method...\\n                // ...then etherValue will be zero\\n                uint etherValue = convertToEther(_destination, amount);\\n                _spendLimit._enforceLimit(etherValue);\\n            }\\n            // use callOptionalReturn provided in SafeERC20 in case the ERC20 method\\n            // returns flase instead of reverting!\\n            ERC20(_destination).callOptionalReturn(_data);\\n\\n            // if ERC20 call completes, return a boolean \\\"true\\\" as bytes emulating ERC20\\n            bytes memory b = new bytes(32);\\n            b[31] = 0x01;\\n\\n            emit ExecutedTransaction(_destination, _value, _data, b);\\n            return b;\\n        }\\n\\n        (bool success, bytes memory returndata) = _destination.call.value(_value)(_data);\\n        require(success, \\\"low-level call failed\\\");\\n\\n        emit ExecutedTransaction(_destination, _value, _data, returndata);\\n        // returns all of the bytes returned by _destination contract\\n        return returndata;\\n    }\\n\\n    /// @return licence contract node registered in ENS.\\n    function licenceNode() external view returns (bytes32) {\\n        return _licenceNode;\\n    }\\n\\n    /// @dev Convert ether or ERC20 token amount to the corresponding stablecoin amount.\\n    /// @param _token ERC20 token contract address.\\n    /// @param _amount amount of token in base units.\\n    function convertToStablecoin(address _token, uint _amount) public view returns (uint) {\\n        // avoid the unnecessary calculations if the token to be loaded is the stablecoin itself\\n        if (_token == _stablecoin()) {\\n            return _amount;\\n        }\\n        uint amountToSend = _amount;\\n\\n        // 0x0 represents ether\\n        if (_token != address(0)) {\\n            // convert to eth first, same as convertToEther()\\n            // Store the token in memory to save map entry lookup gas.\\n            (,uint256 magnitude, uint256 rate, bool available, , , ) = _getTokenInfo(_token);\\n            // require that token both exists in the whitelist and its rate is not zero.\\n            require(available, \\\"token is not available\\\");\\n            require(rate != 0, \\\"token rate is 0\\\");\\n            // Safely convert the token amount to ether based on the exchange rate.\\n            amountToSend = _amount.mul(rate).div(magnitude);\\n        }\\n        // _amountToSend now is in ether\\n        // Get the stablecoin\\u0027s magnitude and its current rate.\\n        ( ,uint256 stablecoinMagnitude, uint256 stablecoinRate, bool stablecoinAvailable, , , ) = _getStablecoinInfo();\\n        // Check if the stablecoin rate is set.\\n        require(stablecoinAvailable, \\\"token is not available\\\");\\n        require(stablecoinRate != 0, \\\"stablecoin rate is 0\\\");\\n        // Safely convert the token amount to stablecoin based on its exchange rate and the stablecoin exchange rate.\\n        return amountToSend.mul(stablecoinMagnitude).div(stablecoinRate);\\n    }\\n\\n}\\n\"},\"walletDeployer.sol\":{\"content\":\"/**\\n *  The Consumer Contract Wallet Deployer\\n *  Copyright (C) 2019 The Contract Wallet Company Limited\\n *\\n *  This program is free software: you can redistribute it and/or modify\\n *  it under the terms of the GNU General Public License as published by\\n *  the Free Software Foundation, either version 3 of the License, or\\n *  (at your option) any later version.\\n\\n *  This program is distributed in the hope that it will be useful,\\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n *  GNU General Public License for more details.\\n\\n *  You should have received a copy of the GNU General Public License\\n *  along with this program.  If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n */\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"./wallet.sol\\\";\\nimport \\\"./controllable.sol\\\";\\nimport \\\"./ensResolvable.sol\\\";\\n\\n//// @title Wallet deployer with pre-caching if wallets functionality.\\ncontract WalletDeployer is ENSResolvable, Controllable {\\n\\n    event CachedWallet(Wallet _wallet);\\n    event DeployedWallet(Wallet _wallet, address _owner);\\n    event MigratedWallet(Wallet _wallet, Wallet _oldWallet, address _owner);\\n\\n    /*****   Constants   *****/\\n    bytes32 public constant controllerNode = 0x7f2ce995617d2816b426c5c8698c5ec2952f7a34bb10f38326f74933d5893697;\\n    bytes32 public constant licenceNode = 0xd0ff8bd67f6e25e4e4b010df582a36a0ee9b78e49afe6cc1cff5dd5a83040330;\\n    bytes32 public constant tokenWhitelistNode = 0xe84f90570f13fe09f288f2411ff9cf50da611ed0c7db7f73d48053ffc974d396;\\n\\n    mapping(address =\\u003e address) public deployedWallets;\\n    Wallet[] public cachedWallets;\\n\\n    address public ens;\\n    uint public defaultSpendLimit;\\n\\n    /// @notice parameters are passed in so that they can be used to construct new instances of the wallet\\n    constructor(address _ens, uint _defaultSpendLimit) ENSResolvable(_ens) Controllable(controllerNode) public {\\n        ens = _ens;\\n        defaultSpendLimit = _defaultSpendLimit;\\n    }\\n\\n    /// @dev This contract must be payable by anyone, as the Wallet Owner needs to be payable\\n    function() external payable {}\\n\\n    /// @notice This public method allows anyone to pre-cache wallets\\n    function cacheWallet() public {\\n        Wallet wallet = new Wallet(address(this), true, ens, tokenWhitelistNode, controllerNode, licenceNode, defaultSpendLimit);\\n        cachedWallets.push(wallet);\\n        emit CachedWallet(wallet);\\n    }\\n\\n    /// @notice This function is used to deploy a Wallet for a given owner address\\n    /// @param _owner is the owner address for the new Wallet to be\\n    function deployWallet(address payable _owner) external onlyController {\\n        if (cachedWallets.length \\u003c 1) {\\n            cacheWallet();\\n        }\\n        Wallet wallet = cachedWallets[cachedWallets.length-1];\\n        cachedWallets.pop();\\n        wallet.transferOwnership(_owner, false);\\n        deployedWallets[_owner] = address(wallet);\\n        emit DeployedWallet(wallet, _owner);\\n    }\\n\\n    /// @notice This function is used to migrate an owner\\u0027s security settings from a previous version of the wallet\\n    /// @param _owner is the owner address for the new Wallet to be\\n    /// @param _spendLimit is the user\\u0027s set daily spend limit\\n    /// @param _gasTopUpLimit is the user\\u0027s set daily gas top-up limit\\n    /// @param _whitelistedAddresses is the set of the user\\u0027s whitelisted addresses\\n    function migrateWallet(address payable _owner, Wallet _oldWallet, bool _initializedSpendLimit, bool _initializedGasTopUpLimit, bool _initializedWhitelist, uint _spendLimit, uint _gasTopUpLimit, address[] calldata _whitelistedAddresses) external onlyController {\\n        if (cachedWallets.length \\u003c 1) {\\n            cacheWallet();\\n    \\t}\\n\\n        Wallet  wallet = cachedWallets[cachedWallets.length-1];\\n        cachedWallets.pop();\\n\\n        if (_initializedSpendLimit) {\\n            wallet.setSpendLimit(_spendLimit);\\n        }\\n        if (_initializedGasTopUpLimit) {\\n            wallet.setGasTopUpLimit(_gasTopUpLimit);\\n        }\\n        if (_initializedWhitelist) {\\n            wallet.setWhitelist(_whitelistedAddresses);\\n        }\\n\\n        wallet.transferOwnership(_owner, false);\\n        deployedWallets[_owner] = address(wallet);\\n\\n        emit MigratedWallet(wallet, _oldWallet, _owner);\\n    }\\n\\n    /// @notice returns the number of pre-cached wallets\\n    function cachedWalletsCount() external view returns (uint) {\\n        return cachedWallets.length;\\n    }\\n\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_oldWallet\",\"type\":\"address\"},{\"name\":\"_initializedSpendLimit\",\"type\":\"bool\"},{\"name\":\"_initializedGasTopUpLimit\",\"type\":\"bool\"},{\"name\":\"_initializedWhitelist\",\"type\":\"bool\"},{\"name\":\"_spendLimit\",\"type\":\"uint256\"},{\"name\":\"_gasTopUpLimit\",\"type\":\"uint256\"},{\"name\":\"_whitelistedAddresses\",\"type\":\"address[]\"}],\"name\":\"migrateWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cacheWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cachedWalletsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"licenceNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ensRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deployedWallets\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenWhitelistNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultSpendLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"deployWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllerNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cachedWallets\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ens\",\"type\":\"address\"},{\"name\":\"_defaultSpendLimit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"CachedWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"DeployedWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"MigratedWallet\",\"type\":\"event\"}]","ContractName":"WalletDeployer","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b0000000000000000000000000000000000000000000000008ac7230489e80000","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://39e2230799e2b1b8110aa9cd82e7957bafc7e3e93ad2f3e907547017aa513c44"}]}