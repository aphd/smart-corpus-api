{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.4;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Eternal Storage for the Reserve Token\r\n *\r\n * @dev Eternal Storage facilitates future upgrades.\r\n *\r\n * If Reserve chooses to release an upgraded contract for the Reserve  in the future, Reserve\r\n * will have the option of reusing the deployed version of this data contract to simplify migration.\r\n *\r\n * The use of this contract does not imply that Reserve will choose to do a future upgrade, nor that\r\n * any future upgrades will necessarily re-use this storage. It merely provides option value.\r\n */\r\ncontract ReserveEternalStorage {\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n\r\n    // ===== auth =====\r\n\r\n    address public owner;\r\n    address public escapeHatch;\r\n\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n    event EscapeHatchTransferred(address indexed oldEscapeHatch, address indexed newEscapeHatch);\r\n\r\n    /// On construction, set auth fields.\r\n    constructor(address escapeHatchAddress) public {\r\n        owner = msg.sender;\r\n        escapeHatch = escapeHatchAddress;\r\n    }\r\n\r\n    /// Only run modified function if sent by `owner`.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"onlyOwner\");\r\n        _;\r\n    }\r\n\r\n    /// Set `owner`.\r\n    function transferOwnership(address newOwner) external {\r\n        require(msg.sender == owner || msg.sender == escapeHatch, \"not authorized\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /// Set `escape hatch`.\r\n    function transferEscapeHatch(address newEscapeHatch) external {\r\n        require(msg.sender == escapeHatch, \"not authorized\");\r\n        emit EscapeHatchTransferred(escapeHatch, newEscapeHatch);\r\n        escapeHatch = newEscapeHatch;\r\n    }\r\n\r\n\r\n\r\n    // ===== balance =====\r\n\r\n    mapping(address => uint256) public balance;\r\n\r\n    /// Add `value` to `balance[key]`, unless this causes integer overflow.\r\n    ///\r\n    /// @dev This is a slight divergence from the strict Eternal Storage pattern, but it reduces the gas\r\n    /// for the by-far most common token usage, it's a *very simple* divergence, and `setBalance` is\r\n    /// available anyway.\r\n    function addBalance(address key, uint256 value) external onlyOwner {\r\n        balance[key] = balance[key].add(value);\r\n    }\r\n\r\n    /// Subtract `value` from `balance[key]`, unless this causes integer underflow.\r\n    function subBalance(address key, uint256 value) external onlyOwner {\r\n        balance[key] = balance[key].sub(value);\r\n    }\r\n\r\n    /// Set `balance[key]` to `value`.\r\n    function setBalance(address key, uint256 value) external onlyOwner {\r\n        balance[key] = value;\r\n    }\r\n\r\n\r\n\r\n    // ===== allowed =====\r\n\r\n    mapping(address => mapping(address => uint256)) public allowed;\r\n\r\n    /// Set `to`'s allowance of `from`'s tokens to `value`.\r\n    function setAllowed(address from, address to, uint256 value) external onlyOwner {\r\n        allowed[from][to] = value;\r\n    }\r\n\r\n\r\n\r\n    // ===== frozenTime =====\r\n\r\n    /// @dev When `frozenTime[addr] == 0`, `addr` is not frozen. This is the normal state.\r\n    /// When `frozenTime[addr] == t` and `t > 0`, `addr` was last frozen at timestamp `t`.\r\n    /// So, to unfreeze an address `addr`, set `frozenTime[addr] = 0`.\r\n    mapping(address => uint256) public frozenTime;\r\n\r\n    /// Set `frozenTime[who]` to `time`.\r\n    function setFrozenTime(address who, uint256 time) external onlyOwner {\r\n        frozenTime[who] = time;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title The standard ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address, uint256) external returns (bool);\r\n    function approve(address, uint256) external returns (bool);\r\n    function transferFrom(address, address, uint256) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address) external view returns (uint256);\r\n    function allowance(address, address) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed holder, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title The Reserve Token\r\n * @dev An ERC-20 token with minting, burning, pausing, and user freezing.\r\n * Based on OpenZeppelin's [implementation](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/41aa39afbc13f0585634061701c883fe512a5469/contracts/token/ERC20/ERC20.sol).\r\n *\r\n * Non-constant-sized data is held in ReserveEternalStorage,\r\n * to facilitate potential future upgrades.\r\n */\r\ncontract Reserve is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    // Non-constant-sized data\r\n    ReserveEternalStorage internal data;\r\n\r\n    // Basic token data\r\n    string public name = \"Reserve\";\r\n    string public symbol = \"RSV\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    // Paused data\r\n    bool public paused;\r\n\r\n    // Auth roles\r\n    address public owner;\r\n    address public minter;\r\n    address public pauser;\r\n    address public freezer;\r\n    address public nominatedOwner;\r\n\r\n\r\n    // Auth role change events\r\n    event OwnerChanged(address indexed newOwner);\r\n    event MinterChanged(address indexed newMinter);\r\n    event PauserChanged(address indexed newPauser);\r\n    event FreezerChanged(address indexed newFreezer);\r\n\r\n    // Pause events\r\n    event Paused(address indexed account);\r\n    event Unpaused(address indexed account);\r\n\r\n    // Name change event\r\n    event NameChanged(string newName, string newSymbol);\r\n\r\n    // Law enforcement events\r\n    event Frozen(address indexed freezer, address indexed account);\r\n    event Unfrozen(address indexed freezer, address indexed account);\r\n    event Wiped(address indexed freezer, address indexed wiped);\r\n\r\n\r\n    /// Initialize critical fields.\r\n    constructor() public {\r\n        data = new ReserveEternalStorage(msg.sender);\r\n        owner = msg.sender;\r\n        pauser = msg.sender;\r\n        // Other roles deliberately default to the zero address.\r\n    }\r\n\r\n    /// Accessor for eternal storage contract address.\r\n    function getEternalStorageAddress() external view returns(address) {\r\n        return address(data);\r\n    }\r\n\r\n\r\n    // ==== Admin functions ====\r\n\r\n\r\n    /// Modifies a function to only run if sent by `role`.\r\n    modifier only(address role) {\r\n        require(msg.sender == role, \"unauthorized: not role holder\");\r\n        _;\r\n    }\r\n\r\n    /// Modifies a function to only run if sent by `role` or the contract's `owner`.\r\n    modifier onlyOwnerOr(address role) {\r\n        require(msg.sender == owner || msg.sender == role, \"unauthorized: not role holder and not owner\");\r\n        _;\r\n    }\r\n\r\n    /// Change who holds the `minter` role.\r\n    function changeMinter(address newMinter) external onlyOwnerOr(minter) {\r\n        minter = newMinter;\r\n        emit MinterChanged(newMinter);\r\n    }\r\n\r\n    /// Change who holds the `pauser` role.\r\n    function changePauser(address newPauser) external onlyOwnerOr(pauser) {\r\n        pauser = newPauser;\r\n        emit PauserChanged(newPauser);\r\n    }\r\n\r\n    /// Change who holds the `freezer` role.\r\n    function changeFreezer(address newFreezer) external onlyOwnerOr(freezer) {\r\n        freezer = newFreezer;\r\n        emit FreezerChanged(newFreezer);\r\n    }\r\n\r\n    /// Nominate a new `owner`.  We want to ensure that `owner` is always valid, so we don't\r\n    /// actually change `owner` to `nominatedOwner` until `nominatedOwner` calls `acceptOwnership`.\r\n    function nominateNewOwner(address nominee) external only(owner) {\r\n        nominatedOwner = nominee;\r\n    }\r\n\r\n    /// Accept nomination for ownership.\r\n    /// This completes the `nominateNewOwner` handshake.\r\n    function acceptOwnership() external onlyOwnerOr(nominatedOwner) {\r\n        if (msg.sender != owner) {\r\n            emit OwnerChanged(msg.sender);\r\n        }\r\n        owner = msg.sender;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    /// Set `owner` to 0.\r\n    /// Only do this to deliberately lock in the current permissions.\r\n    function renounceOwnership() external only(owner) {\r\n        owner = address(0);\r\n        emit OwnerChanged(owner);\r\n    }\r\n\r\n    /// Make a different address own the EternalStorage contract.\r\n    /// This will break this contract, so only do it if you're\r\n    /// abandoning this contract, e.g., for an upgrade.\r\n    function transferEternalStorage(address newOwner) external only(owner) {\r\n        data.transferOwnership(newOwner);\r\n    }\r\n\r\n    /// Change the name and ticker symbol of this token.\r\n    function changeName(string calldata newName, string calldata newSymbol) external only(owner) {\r\n        name = newName;\r\n        symbol = newSymbol;\r\n        emit NameChanged(newName, newSymbol);\r\n    }\r\n\r\n    /// Pause the contract.\r\n    function pause() external only(pauser) {\r\n        paused = true;\r\n        emit Paused(pauser);\r\n    }\r\n\r\n    /// Unpause the contract.\r\n    function unpause() external only(pauser) {\r\n        paused = false;\r\n        emit Unpaused(pauser);\r\n    }\r\n\r\n    /// Modifies a function to run only when the contract is not paused.\r\n    modifier notPaused() {\r\n        require(!paused, \"contract is paused\");\r\n        _;\r\n    }\r\n\r\n    /// Freeze token transactions for a particular address.\r\n    function freeze(address account) external only(freezer) {\r\n        require(data.frozenTime(account) == 0, \"account already frozen\");\r\n\r\n        // In `wipe` we use block.timestamp (aka `now`) to check that enough time has passed since\r\n        // this freeze happened. That required time delay -- 4 weeks -- is a long time relative to\r\n        // the maximum drift of block.timestamp, so it is fine to trust the miner here.\r\n        // solium-disable-next-line security/no-block-members\r\n        data.setFrozenTime(account, now);\r\n\r\n        emit Frozen(freezer, account);\r\n    }\r\n\r\n    /// Unfreeze token transactions for a particular address.\r\n    function unfreeze(address account) external only(freezer) {\r\n        require(data.frozenTime(account) > 0, \"account not frozen\");\r\n        data.setFrozenTime(account, 0);\r\n        emit Unfrozen(freezer, account);\r\n    }\r\n\r\n    /// Modifies a function to run only when the `account` is not frozen.\r\n    modifier notFrozen(address account) {\r\n        require(data.frozenTime(account) == 0, \"account frozen\");\r\n        _;\r\n    }\r\n\r\n    /// Burn the balance of an account that has been frozen for at least 4 weeks.\r\n    function wipe(address account) external only(freezer) {\r\n        require(data.frozenTime(account) > 0, \"cannot wipe unfrozen account\");\r\n        // See commentary above about using block.timestamp.\r\n        // solium-disable-next-line security/no-block-members\r\n        require(data.frozenTime(account) + 4 weeks < now, \"cannot wipe frozen account before 4 weeks\");\r\n        _burn(account, data.balance(account));\r\n        emit Wiped(freezer, account);\r\n    }\r\n\r\n\r\n    // ==== Token transfers, allowances, minting, and burning ====\r\n\r\n\r\n    /// @return how many attotokens are held by `holder`.\r\n    function balanceOf(address holder) external view returns (uint256) {\r\n        return data.balance(holder);\r\n    }\r\n\r\n    /// @return how many attotokens `holder` has allowed `spender` to control.\r\n    function allowance(address holder, address spender) external view returns (uint256) {\r\n        return data.allowed(holder, spender);\r\n    }\r\n\r\n    /// Transfer `value` attotokens from `msg.sender` to `to`.\r\n    function transfer(address to, uint256 value)\r\n        external\r\n        notPaused\r\n        notFrozen(msg.sender)\r\n        notFrozen(to)\r\n        returns (bool)\r\n    {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Approve `spender` to spend `value` attotokens on behalf of `msg.sender`.\r\n     *\r\n     * Beware that changing a nonzero allowance with this method brings the risk that\r\n     * someone may use both the old and the new allowance by unfortunate transaction ordering. One\r\n     * way to mitigate this risk is to first reduce the spender's allowance\r\n     * to 0, and then set the desired value afterwards, per\r\n     * [this ERC-20 issue](https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729).\r\n     *\r\n     * A simpler workaround is to use `increaseAllowance` or `decreaseAllowance`, below.\r\n     *\r\n     * @param spender address The address which will spend the funds.\r\n     * @param value uint256 How many attotokens to allow `spender` to spend.\r\n     */\r\n    function approve(address spender, uint256 value)\r\n        external\r\n        notPaused\r\n        notFrozen(msg.sender)\r\n        notFrozen(spender)\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /// Transfer approved tokens from one address to another.\r\n    /// @param from address The address to send tokens from.\r\n    /// @param to address The address to send tokens to.\r\n    /// @param value uint256 The number of attotokens to send.\r\n    function transferFrom(address from, address to, uint256 value)\r\n        external\r\n        notPaused\r\n        notFrozen(msg.sender)\r\n        notFrozen(from)\r\n        notFrozen(to)\r\n        returns (bool)\r\n    {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, data.allowed(from, msg.sender).sub(value));\r\n        return true;\r\n    }\r\n\r\n    /// Increase `spender`'s allowance of the sender's tokens.\r\n    /// @dev From MonolithDAO Token.sol\r\n    /// @param spender The address which will spend the funds.\r\n    /// @param addedValue How many attotokens to increase the allowance by.\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        external\r\n        notPaused\r\n        notFrozen(msg.sender)\r\n        notFrozen(spender)\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, data.allowed(msg.sender, spender).add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /// Decrease `spender`'s allowance of the sender's tokens.\r\n    /// @dev From MonolithDAO Token.sol\r\n    /// @param spender The address which will spend the funds.\r\n    /// @param subtractedValue How many attotokens to decrease the allowance by.\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        external\r\n        notPaused\r\n        notFrozen(msg.sender)\r\n        // This is the one case in which changing the allowance of a frozen spender is allowed.\r\n        // notFrozen(spender)\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, data.allowed(msg.sender, spender).sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /// Mint `value` new attotokens to `account`.\r\n    function mint(address account, uint256 value)\r\n        external\r\n        notPaused\r\n        notFrozen(account)\r\n        only(minter)\r\n    {\r\n        require(account != address(0), \"can't mint to address zero\");\r\n\r\n        totalSupply = totalSupply.add(value);\r\n        data.addBalance(account, value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /// Burn `value` attotokens from `account`, if sender has that much allowance from `account`.\r\n    function burnFrom(address account, uint256 value)\r\n        external\r\n        notPaused\r\n        notFrozen(account)\r\n        only(minter)\r\n    {\r\n        _burn(account, value);\r\n        _approve(account, msg.sender, data.allowed(account, msg.sender).sub(value));\r\n    }\r\n\r\n    /// @dev Transfer of `value` attotokens from `from` to `to`.\r\n    /// Internal; doesn't check permissions.\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0), \"can't transfer to address zero\");\r\n\r\n        data.subBalance(from, value);\r\n        data.addBalance(to, value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /// @dev Burn `value` attotokens from `account`.\r\n    /// Internal; doesn't check permissions.\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"can't burn from address zero\");\r\n\r\n        totalSupply = totalSupply.sub(value);\r\n        data.subBalance(account, value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /// @dev Set `spender`'s allowance on `holder`'s tokens to `value` attotokens.\r\n    /// Internal; doesn't check permissions.\r\n    function _approve(address holder, address spender, uint256 value) internal {\r\n        require(spender != address(0), \"spender cannot be address zero\");\r\n        require(holder != address(0), \"holder cannot be address zero\");\r\n\r\n        data.setAllowed(holder, spender, value);\r\n        emit Approval(holder, spender, value);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nominee\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"changeMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"changePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFreezer\",\"type\":\"address\"}],\"name\":\"changeFreezer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newName\",\"type\":\"string\"},{\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"changeName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freezer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferEternalStorage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"wipe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEternalStorageAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"MinterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"PauserChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newFreezer\",\"type\":\"address\"}],\"name\":\"FreezerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"NameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"freezer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Frozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"freezer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unfrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"freezer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"wiped\",\"type\":\"address\"}],\"name\":\"Wiped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Reserve","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","Library":"","LicenseType":"Unlicense","SwarmSource":"bzzr://d6530ad21e43247255ce5c6488a991b7905d2c68bb772d109067b2e0d16ba58b"}]}