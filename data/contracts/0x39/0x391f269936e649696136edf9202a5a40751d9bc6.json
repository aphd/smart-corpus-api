{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * SEED Platform DEX\r\n */\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function okToTransferTokens(address _holder, uint256 _amountToAdd) external view returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface IFactory {\r\n    function changeATFactoryAddress(address) external;\r\n    function changeTDeployerAddress(address) external;\r\n    function changeFPDeployerAddress(address) external;\r\n    function changeDeployFees (uint256) external;\r\n    function changeFeesCollector (address) external;\r\n    function deployPanelContracts(string calldata, string calldata, string calldata, bytes32, uint8, uint8, uint8, uint256) external;\r\n    function getTotalDeployFees() external view returns (uint256);\r\n    function isFactoryDeployer(address) external view returns(bool);\r\n    function isFactoryATGenerated(address) external view returns(bool);\r\n    function isFactoryTGenerated(address) external view returns(bool);\r\n    function isFactoryFPGenerated(address) external view returns(bool);\r\n    function getTotalDeployer() external view returns(uint256);\r\n    function getTotalATContracts() external view returns(uint256);\r\n    function getTotalTContracts() external view returns(uint256);\r\n    function getTotalFPContracts() external view returns(uint256);\r\n    function getContractsByIndex(uint256) external view returns (address, address, address, address);\r\n    function getDeployerAddressByIndex(uint256) external view returns (address);\r\n    function getATAddressByIndex(uint256) external view returns (address);\r\n    function getTAddressByIndex(uint256) external view returns (address);\r\n    function getFPAddressByIndex(uint256) external view returns (address);\r\n    function withdraw(address) external;\r\n}\r\n\r\n\r\n/**\r\n * @title SeedDex\r\n * @dev This is the main contract for the Seed Decentralised Exchange.\r\n */\r\ncontract SeedDex {\r\n\r\n  using SafeMath for uint;\r\n\r\n  /// Variables\r\n  address public seedToken; // the seed token\r\n  address public factoryAddress; // Address of the factory\r\n  address private ethAddress = address(0);\r\n\r\n  // True when Token.transferFrom is being called from depositToken\r\n  bool private depositingTokenFlag;\r\n\r\n  // mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => mapping (address => uint)) private tokens;\r\n\r\n  // mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\r\n  mapping (address => mapping (bytes32 => bool)) private orders;\r\n\r\n  // mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n  mapping (address => mapping (bytes32 => uint)) private orderFills;\r\n\r\n  /// Logging Events\r\n  event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\r\n  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\r\n  event Deposit(address token, address user, uint amount, uint balance);\r\n  event Withdraw(address token, address user, uint amount, uint balance);\r\n\r\n  /// Constructor function. This is only called on contract creation.\r\n  constructor(address _seedToken, address _factoryAddress)  public {\r\n    seedToken = _seedToken;\r\n    factoryAddress = _factoryAddress;\r\n    depositingTokenFlag = false;\r\n  }\r\n\r\n  /// The fallback function. Ether transfered into the contract is not accepted.\r\n  function() external {\r\n    revert(\"ETH not accepted!\");\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // Deposits, Withdrawals, Balances\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n  /**\r\n  * This function handles deposits of Ether into the contract.\r\n  * Emits a Deposit event.\r\n  * Note: With the payable modifier, this function accepts Ether.\r\n  */\r\n  function deposit() public payable {\r\n    tokens[ethAddress][msg.sender] = tokens[ethAddress][msg.sender].add(msg.value);\r\n    emit Deposit(ethAddress, msg.sender, msg.value, tokens[ethAddress][msg.sender]);\r\n  }\r\n\r\n  /**\r\n  * This function handles withdrawals of Ether from the contract.\r\n  * Verifies that the user has enough funds to cover the withdrawal.\r\n  * Emits a Withdraw event.\r\n  * @param amount uint of the amount of Ether the user wishes to withdraw\r\n  */\r\n  function withdraw(uint amount) public {\r\n    require(tokens[ethAddress][msg.sender] >= amount, \"Not enough balance\");\r\n    tokens[ethAddress][msg.sender] = tokens[ethAddress][msg.sender].sub(amount);\r\n    msg.sender.transfer(amount);\r\n    emit Withdraw(ethAddress, msg.sender, amount, tokens[ethAddress][msg.sender]);\r\n  }\r\n  \r\n  /**\r\n  * This function handles deposits of Ethereum based tokens to the contract.\r\n  * Does not allow Ether.\r\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n  * Emits a Deposit event.\r\n  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n  * @param token Ethereum contract address of the token or 0 for Ether\r\n  * @param amount uint of the amount of the token the user wishes to deposit\r\n  */\r\n  function depositToken(address token, uint amount) public {\r\n    require(token != ethAddress, \"Seed: expecting the zero address to be ERC20\");\r\n    require(IFactory(factoryAddress).isFactoryTGenerated(token) || token == seedToken, \"Seed: deposit allowed only for known tokens\");\r\n\r\n    depositingTokenFlag = true;\r\n    IERC20(token).transferFrom(msg.sender, address(this), amount);\r\n    depositingTokenFlag = false;\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\r\n    emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n\r\n  \r\n  /**\r\n  * This function handles withdrawals of Ethereum based tokens from the contract.\r\n  * Does not allow Ether.\r\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n  * Emits a Withdraw event.\r\n  * @param token Ethereum contract address of the token or 0 for Ether\r\n  * @param amount uint of the amount of the token the user wishes to withdraw\r\n  */\r\n  function withdrawToken(address token, uint amount) public {\r\n    require(token != ethAddress, \"Seed: expecting the zero address to be ERC20\");\r\n    require(tokens[token][msg.sender] >= amount, \"Not enough balance\");\r\n\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\r\n    require(IERC20(token).transfer(msg.sender, amount), \"Transfer failed\");\r\n    emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  /**\r\n  * Retrieves the balance of a token based on a user address and token address.\r\n  * @param token Ethereum contract address of the token or 0 for Ether\r\n  * @param user Ethereum address of the user\r\n  * @return the amount of tokens on the exchange for a given user address\r\n  */\r\n  function balanceOf(address token, address user) public view returns (uint) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // Trading\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n  * Stores the active order inside of the contract.\r\n  * Emits an Order event.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  */\r\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) public {\r\n    require(isValidPair(tokenGet, tokenGive), \"Not a valid pair\");\r\n    require(canBeTransferred(tokenGet, msg.sender, amountGet), \"Token quota exceeded\");\r\n    bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\r\n    orders[msg.sender][hash] = true;\r\n    emit Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\r\n  }\r\n\r\n  /**\r\n  * Facilitates a trade from one user to another.\r\n  * Requires that the transaction is signed properly, the trade isn't past its expiration, and all funds are present to fill the trade.\r\n  * Calls tradeBalances().\r\n  * Updates orderFills with the amount traded.\r\n  * Emits a Trade event.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * Note: amount is in amountGet / tokenGet terms.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n  */\r\n  function trade(\r\n        address  tokenGet,\r\n        uint     amountGet,\r\n        address  tokenGive,\r\n        uint     amountGive,\r\n        uint     expires,\r\n        uint     nonce,\r\n        address  user,\r\n        uint8    v,\r\n        bytes32  r,\r\n        bytes32  s,\r\n        uint     amount) public {\r\n    require(isValidPair(tokenGet, tokenGive), \"Not a valid pair\");\r\n    require(canBeTransferred(tokenGet, msg.sender, amountGet), \"Token quota exceeded\");\r\n    bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\r\n    bytes32 m = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    /*require((\r\n      (orders[user][hash] || ecrecover(m, v, r, s) == user) &&\r\n      block.number <= expires &&\r\n      orderFills[user][hash].add(amount) <= amountGet\r\n    ));*/\r\n    require(orders[user][hash] || ecrecover(m, v, r, s) == user, \"Order does not exist\");\r\n    require(block.number <= expires, \"Order Expired\");\r\n    require(orderFills[user][hash].add(amount) <= amountGet, \"Order amount exceeds maximum availability\");\r\n    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\r\n    orderFills[user][hash] = orderFills[user][hash].add(amount);\r\n    uint amt = amountGive.mul(amount) / amountGet;\r\n    emit Trade(tokenGet, amount, tokenGive, amt, user, msg.sender);\r\n  }\r\n\r\n  /**\r\n  * This is a private function and is only being called from trade().\r\n  * Handles the movement of funds when a trade occurs.\r\n  * Takes fees.\r\n  * Updates token balances for both buyer and seller.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * Note: amount is in amountGet / tokenGet terms.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n  */\r\n  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\r\n    tokens[tokenGet][msg.sender] = tokens[tokenGet][msg.sender].sub(amount);\r\n    tokens[tokenGet][user] = tokens[tokenGet][user].add(amount);\r\n    tokens[tokenGive][user] = tokens[tokenGive][user].sub(amountGive.mul(amount).div(amountGet));\r\n    tokens[tokenGive][msg.sender] = tokens[tokenGive][msg.sender].add(amountGive.mul(amount).div(amountGet));\r\n  }\r\n\r\n  /**\r\n  * This function is to test if a trade would go through.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * Note: amount is in amountGet / tokenGet terms.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n  * @param sender Ethereum address of the user taking the order\r\n  * @return bool: true if the trade would be successful, false otherwise\r\n  */\r\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public view returns(bool) {\r\n    if (tokens[tokenGet][sender] < amount) return false;\r\n    if (availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) < amount) return false;\r\n    if (!canBeTransferred(tokenGet, msg.sender, amountGet)) return false;\r\n\r\n    return true;\r\n  }\r\n\r\n  function canBeTransferred(address token, address user, uint newAmt) private view returns(bool) {\r\n    return (token == seedToken || IERC20(token).okToTransferTokens(user, newAmt + tokens[token][user]) ) ;\r\n  }\r\n\r\n  /**\r\n  * This function checks the available volume for a given order.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @return uint: amount of volume available for the given order in terms of amountGet / tokenGet\r\n  */\r\n  function availableVolume(\r\n          address tokenGet,\r\n          uint amountGet,\r\n          address tokenGive,\r\n          uint amountGive,\r\n          uint expires,\r\n          uint nonce,\r\n          address user,\r\n          uint8 v,\r\n          bytes32 r,\r\n          bytes32 s\r\n  ) public view returns(uint) {\r\n\r\n    bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\r\n\r\n    if ( (orders[user][hash] || ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), v, r, s) == user) || block.number <= expires ) {\r\n      return 0;\r\n    }\r\n\r\n    uint[2] memory available;\r\n    available[0] = amountGet.sub(orderFills[user][hash]);\r\n\r\n    available[1] = tokens[tokenGive][user].mul(amountGet) / amountGive;\r\n\r\n    if (available[0] < available[1]) {\r\n      return available[0];\r\n    } else {\r\n      return available[1];\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n  * This function checks the amount of an order that has already been filled.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\r\n  */\r\n  /* @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user */\r\n  function amountFilled(\r\n          address tokenGet,\r\n          uint amountGet,\r\n          address tokenGive,\r\n          uint amountGive,\r\n          uint expires,\r\n          uint nonce,\r\n          address user/*,\r\n          uint8 v,\r\n          bytes32 r,\r\n          bytes32 s*/\r\n  ) public view returns(uint) {\r\n    bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\r\n    return orderFills[user][hash];\r\n  }\r\n\r\n  /**\r\n  * This function cancels a given order by editing its fill data to the full amount.\r\n  * Requires that the transaction is signed properly.\r\n  * Updates orderFills to the full amountGet\r\n  * Emits a Cancel event.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\r\n  */\r\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\r\n    bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));\r\n    bytes32 m = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    require(orders[msg.sender][hash] || ecrecover(m, v, r, s) == msg.sender, \"Order does not exist\");\r\n    orderFills[msg.sender][hash] = amountGet;\r\n    emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\r\n  }\r\n                                                \r\n  /**\r\n  * this function check if the given pair is valid.\r\n  * @param tokenGet ethereum contract address of the token to receive\r\n  * @param tokenGive ethereum contract address of the token to give\r\n  * @return bool: return true if given pair is valid, otherwise false.\r\n  */\r\n  function isValidPair(address tokenGet, address tokenGive) private view returns(bool) {\r\n     if( isEthSeedPair(tokenGet, tokenGive) ) return true;\r\n     return isSeedPair(tokenGet, tokenGive);\r\n  }\r\n\r\n  /**\r\n  * this function check if the given pair is ETH-SEED or SEED-ETH.\r\n  * @param tokenGet ethereum contract address of the token to receive\r\n  * @param tokenGive ethereum contract address of the token to give\r\n  * @return bool: return true if it's either ETH-SEED or SEED-ETH, otherwise false.\r\n  */\r\n  function isEthSeedPair(address tokenGet, address tokenGive) private view returns(bool) {\r\n      if (tokenGet == ethAddress && tokenGive == seedToken) return true;\r\n      if (tokenGet == seedToken && tokenGive == ethAddress) return true;\r\n      return false;\r\n  }\r\n\r\n  /**\r\n  * this function check if the given pair of tokens include the seed native token.\r\n  * @param tokenGet ethereum contract address of the token to receive\r\n  * @param tokenGive ethereum contract address of the token to give\r\n  * @return bool: return true if one of the token is seed, otherwise false.\r\n  */\r\n  function isSeedPair(address tokenGet, address tokenGive) private view returns(bool) {\r\n      if (tokenGet == tokenGive) return false;\r\n      if (tokenGet == seedToken) return true;\r\n      if (tokenGive == seedToken) return true;\r\n      return false;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"order\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"amountFilled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"seedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"testTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factoryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"availableVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_seedToken\",\"type\":\"address\"},{\"name\":\"_factoryAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Order\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"get\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"give\",\"type\":\"address\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"SeedDex","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c969e16e63ff31ad4bcac3095c616644e6912d7900000000000000000000000035c8c5d9bec0dcd50ce4bd929fa3bed9ed1f7c89","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://bb8a579207a2a9ff92d5e8e3579f844186d8b03d5c3aa8682ccea7eb52ef55e0"}]}