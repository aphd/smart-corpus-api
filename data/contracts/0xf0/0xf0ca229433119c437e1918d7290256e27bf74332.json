{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-12-03\r\n*/\r\n\r\npragma solidity ^0.4.26;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract UniswapExchangeInterface {\r\n    // Address of IERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n    // Provide Liquidity\r\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n    // Trade ETH to IERC20\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\r\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\r\n    // Trade IERC20 to ETH\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\r\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\r\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\r\n    // Trade IERC20 to IERC20\r\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\r\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\r\n    // Trade IERC20 to Custom Pool\r\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\r\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // IERC20 comaptibility for liquidity tokens\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public decimals;\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n}\r\n\r\ninterface KyberNetworkProxyInterface {\r\n    function maxGasPrice() public view returns(uint);\r\n    function getUserCapInWei(address user) public view returns(uint);\r\n    function getUserCapInTokenWei(address user, IERC20 token) public view returns(uint);\r\n    function enabled() public view returns(bool);\r\n    function info(bytes32 id) public view returns(uint);\r\n    function getExpectedRate(IERC20 src, IERC20 dest, uint srcQty) public view returns (uint expectedRate, uint slippageRate);\r\n    function tradeWithHint(IERC20 src, uint srcAmount, IERC20 dest, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId, bytes hint) public payable returns(uint);\r\n    function swapEtherToToken(IERC20 token, uint minRate) public payable returns (uint);\r\n    function swapTokenToEther(IERC20 token, uint tokenQty, uint minRate) public returns (uint);\r\n}\r\n\r\ninterface OrFeedInterface {\r\n    function getExchangeRate ( string fromSymbol, string toSymbol, string venue, uint256 amount ) external view returns ( uint256 );\r\n    function getTokenDecimalCount ( address tokenAddress ) external view returns ( uint256 );\r\n    function getTokenAddress ( string symbol ) external view returns ( address );\r\n    function getSynthBytes32 ( string symbol ) external view returns ( bytes32 );\r\n    function getForexAddress ( string symbol ) external view returns ( address );\r\n}\r\n\r\ncontract Ourbitrage {\r\n    uint256 internal constant _DEFAULT_MAX_RATE = 8 * (10 ** 27); // 8 billion\r\n    IERC20 internal constant _ETH_TOKEN_ADDRESS = IERC20(0x00EeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE); // IERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n\r\n    KyberNetworkProxyInterface internal _kyber;\r\n    OrFeedInterface internal _orfeed;\r\n\r\n    // Uniswap: separate interface for each token type; symbol => interface\r\n    mapping(string => UniswapExchangeInterface) internal _uniswap;\r\n\r\n    address internal _owner;\r\n    address internal _feeCollector;\r\n\r\n    // Contract Addresses of Tokens for Funding; symbol => token contract address\r\n    mapping(string => address) internal _fundingToken;\r\n\r\n    // expressed as a milli-percentage from (0 - 100) * 1000\r\n    mapping(string => uint) internal _allowedSlippage;\r\n\r\n    // Tokens currently being used for an arbitration\r\n//    uint internal _tokensInArbitration;\r\n\r\n    event Arbitrage(string arbType, address fundingToken, uint profit, uint loss);\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    //\r\n    // Initialize\r\n    //\r\n\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function () external payable  {}\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    function getVersion() public pure returns (string) {\r\n        return \"0.0.4\";\r\n    }\r\n\r\n    //\r\n    // Public\r\n    //\r\n\r\n    function getPrice(string from, string to, string venue, uint256 amount) public view returns (uint256) {\r\n        return _orfeed.getExchangeRate(from, to, venue, amount);\r\n    }\r\n\r\n    function getEthBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getFundingTokenAddress(string tokenSymbol) public view returns (address) {\r\n        return _fundingToken[tokenSymbol];\r\n    }\r\n\r\n    function hasFundingTokenApproval(string tokenSymbol) public view returns (bool) {\r\n        IERC20 token = IERC20(_fundingToken[tokenSymbol]);\r\n        return token.allowance(_owner, address(this)) > 0;\r\n    }\r\n\r\n    function getFundingTokenBalance(string tokenSymbol) public view returns (uint256) {\r\n        IERC20 token = IERC20(_fundingToken[tokenSymbol]);\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    function getWalletTokenBalance(string tokenSymbol) public view returns (uint256) {\r\n        IERC20 token = IERC20(_fundingToken[tokenSymbol]);\r\n        return token.balanceOf(msg.sender);\r\n    }\r\n\r\n    //\r\n    // Only Owner; Setup\r\n    //\r\n\r\n    function setKyberNetworkProxyInterface(KyberNetworkProxyInterface kyber) public onlyOwner {\r\n        require(address(kyber) != address(0), \"Invalid KyberNetworkProxyInterface address\");\r\n        _kyber = KyberNetworkProxyInterface(kyber);\r\n    }\r\n\r\n    function setOrFeedInterface(OrFeedInterface orfeed) public onlyOwner {\r\n        require(address(orfeed) != address(0), \"Invalid OrFeedInterface address\");\r\n        _orfeed = OrFeedInterface(orfeed);\r\n    }\r\n\r\n    function setFeeCollector(address feeCollector) public onlyOwner {\r\n        require(address(feeCollector) != address(0), \"Invalid Fee Collector address\");\r\n        _feeCollector = feeCollector;\r\n    }\r\n\r\n    function setupFundingToken(string tokenSymbol, address tokenAddress, address uniswapExchangeAddress, uint allowedSlippage) public onlyOwner {\r\n        address ourbitrage = address(this);\r\n        address kyberAddress = address(_kyber);\r\n        IERC20 token = IERC20(tokenAddress);\r\n\r\n        // Check for existing funds in contract\r\n        if (_fundingToken[tokenSymbol] != address(0)) {\r\n            uint256 oldTokenBalance = token.balanceOf(ourbitrage);\r\n            require(oldTokenBalance == 0, \"You have an existing token balance\");\r\n        }\r\n\r\n        // Set New Funding Token + Exchange\r\n        _fundingToken[tokenSymbol] = tokenAddress;\r\n        _uniswap[tokenSymbol] = UniswapExchangeInterface(uniswapExchangeAddress);\r\n        _allowedSlippage[tokenSymbol] = allowedSlippage;\r\n\r\n        // Pre-Approve Exchanges to Transfer Token on Contracts behalf\r\n        require(token.approve(kyberAddress, 0), \"Failed to approve Kyber for token transfer\");\r\n        token.approve(kyberAddress, uint(-1));\r\n        require(token.approve(uniswapExchangeAddress, 0), \"Failed to approve Uniswap for token transfer\");\r\n        token.approve(uniswapExchangeAddress, uint(-1));\r\n    }\r\n\r\n    //\r\n    // Only Owner; Funding\r\n    //\r\n\r\n    function withdrawETH() public onlyOwner {\r\n        _withdrawETH(msg.sender);\r\n    }\r\n\r\n    function withdrawToken(string tokenSymbol) public onlyOwner {\r\n        _withdrawToken(tokenSymbol, msg.sender);\r\n    }\r\n\r\n    function depositFunds_APPROVE_FIRST(string tokenSymbol, address tokenAddress, uint tokenAmount) public onlyOwner {\r\n        require(_fundingToken[tokenSymbol] != address(0), \"Funding Token has not been setup\");\r\n        require(_fundingToken[tokenSymbol] == tokenAddress, \"Funding Token is not the same as the deposited token type\");\r\n\r\n        IERC20 token = IERC20(_fundingToken[tokenSymbol]);\r\n        uint256 currentTokenBalance = token.balanceOf(msg.sender);\r\n        require(tokenAmount <= currentTokenBalance, \"User does not have enough funds to deposit\");\r\n\r\n        // Check that the token transferFrom has succeeded\r\n        require(token.transferFrom(msg.sender, address(this), tokenAmount), \"Failed to transfer Token Funds into Ourbitrage Contract\");\r\n    }\r\n\r\n    //\r\n    // Only Owner; Arbitration\r\n    //\r\n\r\n    // @dev Buy ETH on Kyber and Sell on Uniswap using Funding Token\r\n    function arbEthFromKyberToUniswap(string tokenSymbol) public onlyOwner returns (uint profit, uint loss) {\r\n//        return _arbEthFromKyberToUniswap(tokenSymbol);\r\n\r\n        // Get Amount of Funds in Contract\r\n        address ourbitrage = address(this);\r\n        IERC20 token = IERC20(_fundingToken[tokenSymbol]);\r\n        uint256 tokenBalance = token.balanceOf(ourbitrage);\r\n\r\n        if (tokenBalance > 0) {\r\n            // Perform Swap\r\n            // Send Tokens to Kyber, and receive ETH in contract\r\n            uint ethAmount = _kyber.tradeWithHint(token, tokenBalance, _ETH_TOKEN_ADDRESS, ourbitrage, _DEFAULT_MAX_RATE, 0, _feeCollector, \"PERM\");\r\n            // Send ETH to Uniswap, and receive Tokens in contract\r\n            _uniswap[tokenSymbol].ethToTokenSwapInput.value(ethAmount)(1, block.timestamp);\r\n\r\n            // Determine Profit/Loss\r\n            (profit, loss) = _getProfitLoss(token, tokenBalance);\r\n        }\r\n    }\r\n\r\n    // @dev Buy ETH on Uniswap and Sell on Kyber using Funding Token\r\n    function arbEthFromUniswapToKyber(string tokenSymbol) public onlyOwner returns (uint profit, uint loss) {\r\n//        return _arbEthFromUniswapToKyber(tokenSymbol);\r\n\r\n        // Get Amount of Funds in Contract\r\n        address ourbitrage = address(this);\r\n        IERC20 token = IERC20(_fundingToken[tokenSymbol]);\r\n        uint256 ethBalance = ourbitrage.balance;\r\n        uint256 tokenBalance = token.balanceOf(ourbitrage);\r\n\r\n        if (tokenBalance > 0) {\r\n            // Perform Swap\r\n            // Send Tokens to Uniswap, and receive ETH in contract\r\n            _uniswap[tokenSymbol].tokenToEthSwapInput(tokenBalance, 1, block.timestamp);\r\n            // Send ETH to Kyber, and receive Tokens in contract\r\n            _kyber.swapEtherToToken.value(ourbitrage.balance - ethBalance)(token, 1);\r\n//            uint ethAmount = ourbitrage.balance - ethBalance;\r\n//            uint tokenAmount = _kyber.tradeWithHint(_ETH_TOKEN_ADDRESS, ethAmount, token, ourbitrage, _DEFAULT_MAX_RATE, 0, _feeCollector, \"PERM\");\r\n\r\n            // Determine Profit/Loss\r\n            (profit, loss) = _getProfitLoss(token, tokenBalance);\r\n        }\r\n    }\r\n\r\n    //\r\n    // Only Owner; Management\r\n    //\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    //\r\n    // Private; Funding\r\n    //\r\n\r\n    function _withdrawETH(address receiver) internal {\r\n        require(receiver != address(0), \"Invalid receiver for withdraw\");\r\n        address ourbitrage = address(this);\r\n        receiver.transfer(ourbitrage.balance);\r\n    }\r\n\r\n    function _withdrawToken(string tokenSymbol, address receiver) internal {\r\n        require(_fundingToken[tokenSymbol] != address(0), \"Funding Token has not been setup\");\r\n        require(receiver != address(0), \"Invalid receiver for withdraw\");\r\n        address ourbitrage = address(this);\r\n        IERC20 token = IERC20(_fundingToken[tokenSymbol]);\r\n        uint256 currentTokenBalance = token.balanceOf(ourbitrage);\r\n        token.transfer(receiver, currentTokenBalance);\r\n    }\r\n\r\n    //\r\n    // Private; Arbitration\r\n    //\r\n\r\n    // @dev Buy ETH on Kyber and Sell on Uniswap using a Funding-Token specified by \"tokenSymbol\"\r\n    // @param tokenSymbol The symbol of the Funding-Token to use\r\n//    function _arbEthFromKyberToUniswap(string tokenSymbol) internal returns (uint profit, uint loss) {\r\n//        require(_fundingToken[tokenSymbol] != address(0), \"Funding Token has not been set\");\r\n//        require(address(_kyber) != address(0), \"Kyber Network Exchange Interface has not been set\");\r\n//\r\n//        // Get Amount of Funds in Contract\r\n//        address ourbitrage = address(this);\r\n//        IERC20 token = IERC20(_fundingToken[tokenSymbol]);\r\n//        uint256 tokenBalance = token.balanceOf(ourbitrage);\r\n////        require(tokenBalance > 0, \"Insufficient funds to process arbitration\");\r\n//\r\n//        if (tokenBalance > 0) {\r\n//            // Perform Swap\r\n//            uint ethReceived = _buyEthOnKyber(token, tokenBalance);  // Buy ETH on Kyber\r\n//            _sellEthOnUniswap(tokenSymbol, ethReceived);             // Sell ETH on Uniswap\r\n//\r\n//            // Determine Profit/Loss\r\n//            (profit, loss) = _getProfitLoss(token, tokenBalance);\r\n//            emit Arbitrage(\"ETH-K2U\", _fundingToken[tokenSymbol], profit, loss);\r\n//        }\r\n//    }\r\n\r\n    // @dev Buy ETH on Uniswap and Sell on Kyber using a Funding-Token specified by \"tokenSymbol\"\r\n    // @param tokenSymbol The symbol of the Funding-Token to use\r\n//    function _arbEthFromUniswapToKyber(string tokenSymbol) internal returns (uint profit, uint loss) {\r\n//        require(_fundingToken[tokenSymbol] != address(0), \"Funding Token has not been set\");\r\n//        require(address(_kyber) != address(0), \"Kyber Network Exchange Interface has not been set\");\r\n//\r\n//        // Get Amount of Funds in Contract\r\n//        address ourbitrage = address(this);\r\n//        IERC20 token = IERC20(_fundingToken[tokenSymbol]);\r\n//        uint256 tokenBalance = token.balanceOf(ourbitrage);\r\n////        require(tokenBalance > 0, \"Insufficient funds to process arbitration\");\r\n//\r\n//        if (tokenBalance > 0) {\r\n//            // Perform Swap\r\n//            uint ethReceived = _buyEthOnUniswap(tokenSymbol, tokenBalance);  // Buy ETH on Uniswap\r\n//            _sellEthOnKyber(token, ethReceived);                             // Sell ETH on Kyber\r\n//\r\n//            // Determine Profit/Loss\r\n//            (profit, loss) = _getProfitLoss(token, tokenBalance);\r\n//            emit Arbitrage(\"ETH-U2K\", _fundingToken[tokenSymbol], profit, loss);\r\n//        }\r\n//    }\r\n\r\n    //\r\n    // Buy/Sell ETH\r\n    //\r\n\r\n    // @dev Buy ETH on Kyber for Funding-Token (SAI/DAI)\r\n//    function _buyEthOnKyber(IERC20 token, uint tokenAmount) internal returns (uint) {\r\n//        address ourbitrage = address(this);\r\n//        uint slippageRate;\r\n//        (, slippageRate) = _kyber.getExpectedRate(token, _ETH_TOKEN_ADDRESS, tokenAmount);\r\n//\r\n//        // Send Tokens to Kyber, and receive ETH in contract\r\n////        _tokensInArbitration = tokenAmount;\r\n//        return _kyber.tradeWithHint(IERC20(token), tokenAmount, _ETH_TOKEN_ADDRESS, ourbitrage, _DEFAULT_MAX_RATE, slippageRate, _feeCollector, \"PERM\");\r\n//    }\r\n//\r\n//    // @dev Sell ETH on Uniswap for Funding-Token (SAI/DAI)\r\n//    function _sellEthOnUniswap(string tokenSymbol, uint ethAmount) internal returns (bool) {\r\n////        uint slippage = _getAllowedSlippage(tokenSymbol, ethAmount);\r\n//        uint minReturn = 1; // _tokensInArbitration - slippage;\r\n//        _uniswap[tokenSymbol].ethToTokenSwapInput.value(ethAmount)(minReturn, block.timestamp);\r\n////        _tokensInArbitration = 0;\r\n//        return true;\r\n//    }\r\n//\r\n//    // @dev Buy ETH on Uniswap for Funding-Token\r\n//    function _buyEthOnUniswap(string tokenSymbol, uint tokenAmount) internal returns (uint) {\r\n////        uint expectedEth = _uniswap[tokenSymbol].getTokenToEthInputPrice(tokenAmount);\r\n////        uint slippage = _getAllowedSlippage(tokenSymbol, expectedEth);\r\n//        uint minEth = 1; // expectedEth - slippage;\r\n//\r\n////        _tokensInArbitration = tokenAmount;\r\n//        return _uniswap[tokenSymbol].tokenToEthSwapInput(tokenAmount, minEth, block.timestamp);\r\n//    }\r\n//\r\n//    // @dev Sell ETH on Kyber for Funding-Token\r\n//    function _sellEthOnKyber(IERC20 token, uint ethAmount) internal returns (uint) {\r\n//        uint slippageRate;\r\n//        (, slippageRate) = _kyber.getExpectedRate(_ETH_TOKEN_ADDRESS, token, ethAmount);\r\n//\r\n//        // Send ETH to Kyber, and receive Funding-Token in contract\r\n//        uint tokensReceived = _kyber.swapEtherToToken.value(ethAmount)(token, slippageRate);\r\n////        _tokensInArbitration = 0;\r\n//        return tokensReceived;\r\n//    }\r\n\r\n    //\r\n    // Buy/Sell Token\r\n    //\r\n\r\n//    // @dev Buy Token on Kyber for Funding-Token\r\n//    function _buyTokenOnKyber(IERC20 token, uint tokenAmount) internal returns (uint) {\r\n//        return 0;\r\n//    }\r\n//\r\n//    // @dev Sell Token on Uniswap for Funding-Token\r\n//    function _sellTokenOnUniswap(string tokenSymbol, uint ethAmount) internal returns (bool) {\r\n//        return true;\r\n//    }\r\n//\r\n//    // @dev Sell Token on Kyber for Funding-Token\r\n//    function _sellTokenOnKyber(IERC20 token, uint tokenAmount) internal returns (uint) {\r\n//        return 0;\r\n//    }\r\n//\r\n//    // @dev Buy Token on Uniswap for Funding-Token\r\n//    function _buyTokenOnUniswap(string tokenSymbol, uint ethAmount) internal returns (bool) {\r\n//        return true;\r\n//    }\r\n\r\n    //\r\n    // Private; Management\r\n    //\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        _owner = newOwner;\r\n    }\r\n\r\n    //\r\n    // Private; Misc\r\n    //\r\n\r\n    function _getProfitLoss(IERC20 token, uint oldBalance) internal view returns (uint profit, uint loss) {\r\n        uint newBalance = token.balanceOf(address(this));\r\n        if (newBalance < oldBalance) {\r\n            profit = 0;\r\n            loss = oldBalance - newBalance;\r\n        } else {\r\n            profit = newBalance - oldBalance;\r\n            loss = 0;\r\n        }\r\n    }\r\n\r\n    // expressed as a milli-percentage from (0 - 100) * 1000\r\n    //   where 1 = 0.001%, 1000 = 1%, 12250 = 12.25%\r\n    //   s = (n * p) / (100 * 1000)\r\n//    function _getAllowedSlippage(string tokenSymbol, uint amount) internal view returns (uint) {\r\n//        return (amount * _allowedSlippage[tokenSymbol]) / 100000;\r\n//    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"uniswapExchangeAddress\",\"type\":\"address\"},{\"name\":\"allowedSlippage\",\"type\":\"uint256\"}],\"name\":\"setupFundingToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"depositFunds_APPROVE_FIRST\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"string\"},{\"name\":\"to\",\"type\":\"string\"},{\"name\":\"venue\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"name\":\"arbEthFromUniswapToKyber\",\"outputs\":[{\"name\":\"profit\",\"type\":\"uint256\"},{\"name\":\"loss\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"name\":\"hasFundingTokenApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orfeed\",\"type\":\"address\"}],\"name\":\"setOrFeedInterface\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"name\":\"getWalletTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEthBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"name\":\"arbEthFromKyberToUniswap\",\"outputs\":[{\"name\":\"profit\",\"type\":\"uint256\"},{\"name\":\"loss\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"name\":\"getFundingTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"kyber\",\"type\":\"address\"}],\"name\":\"setKyberNetworkProxyInterface\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"name\":\"getFundingTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"arbType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fundingToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"loss\",\"type\":\"uint256\"}],\"name\":\"Arbitrage\",\"type\":\"event\"}]","ContractName":"Ourbitrage","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://e351c08b78b19ef35af78513fdd80690da19d4665777e18b2c2cfb0b1500c043"}]}